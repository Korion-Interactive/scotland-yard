//0x8000045 sdk
//yrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 460 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2

# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\BinaryBuffers.cpp" 1
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude\\BinaryBuffers.h" 1


# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SonyCommonIncludes.h" 1
# 18 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SonyCommonIncludes.h"
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sdk_version.h" 1 3
# 19 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SonyCommonIncludes.h" 2

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_common.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 532 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef int _Int32t;
typedef unsigned int _Uint32t;







typedef long _Ptrdifft;







typedef unsigned long _Sizet;
# 1286 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
namespace std {}
# 1411 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
namespace std {
typedef bool _Bool;
}
# 1442 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\stdarg.h" 1 3 4
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;







typedef __builtin_va_list va_list;
# 1443 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 2 3
# 1577 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef long long _Longlong;
typedef unsigned long long _ULonglong;
# 1615 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef wchar_t _Wchart;
typedef int _Wintt;
# 1698 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_null.h" 1 3
# 1699 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 2 3
# 1712 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef va_list _Va_list;
# 1755 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef char _Sysch_t;
# 1779 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
extern "C" {
void _Locksyslock(int);
void _Unlocksyslock(int);
}
# 1812 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
namespace std {
enum _Uninitialized
 {
 _Noinit
 };

extern "C++" {

class _Lockit
 {
public:
# 1837 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
 _Lockit()
  : _Locktype(1)
  {

   _Locksyslock(_Locktype);
  }

 explicit _Lockit(int _Kind)
  : _Locktype(_Kind)
  {

   _Locksyslock(_Locktype);
  }

 ~_Lockit() noexcept
  {

   _Unlocksyslock(_Locktype);
  }



 _Lockit(const _Lockit&);
 _Lockit& operator=(const _Lockit&);

private:
 int _Locktype;
 };
# 1888 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
class _Mutex
 {
public:
 _Mutex(_Uninitialized)
  {
  }

 _Mutex();
 ~_Mutex() noexcept;
 void _Lock();
 void _Unlock();

private:
 _Mutex(const _Mutex&);
 _Mutex& operator=(const _Mutex&);
 void *_Mtx;
 };

}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_weof.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int8_t.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 1 3
# 39 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cdefs.h" 1 3
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_limits.h" 1 3
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 2 3
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 2 3






typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;





typedef long __int64_t;
typedef unsigned long __uint64_t;
# 91 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __int32_t __clock_t;
typedef __int64_t __critical_t;
typedef double __double_t;
typedef float __float_t;
typedef __int64_t __intfptr_t;
typedef __int64_t __intptr_t;
# 105 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __int64_t __intmax_t;
typedef __int32_t __int_fast8_t;
typedef __int32_t __int_fast16_t;
typedef __int32_t __int_fast32_t;
typedef __int64_t __int_fast64_t;
typedef __int8_t __int_least8_t;
typedef __int16_t __int_least16_t;
typedef __int32_t __int_least32_t;
typedef __int64_t __int_least64_t;

typedef __int64_t __ptrdiff_t;
typedef __int64_t __register_t;
typedef __int64_t __segsz_t;
typedef __uint64_t __size_t;
typedef __int64_t __ssize_t;
typedef __int64_t __time_t;
typedef __uint64_t __uintfptr_t;
typedef __uint64_t __uintptr_t;
# 133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __uint64_t __uintmax_t;
typedef __uint32_t __uint_fast8_t;
typedef __uint32_t __uint_fast16_t;
typedef __uint32_t __uint_fast32_t;
typedef __uint64_t __uint_fast64_t;
typedef __uint8_t __uint_least8_t;
typedef __uint16_t __uint_least16_t;
typedef __uint32_t __uint_least32_t;
typedef __uint64_t __uint_least64_t;

typedef __uint64_t __u_register_t;
typedef __uint64_t __vm_offset_t;
typedef __uint64_t __vm_paddr_t;
typedef __uint64_t __vm_size_t;
# 157 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __int64_t __vm_ooffset_t;
typedef __uint64_t __vm_pindex_t;
typedef int ___wchar_t;
# 168 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __builtin_va_list __va_list;
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 2 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 2 3




typedef __int32_t __blksize_t;
typedef __int64_t __blkcnt_t;
typedef __int32_t __clockid_t;
typedef __uint32_t __fflags_t;
typedef __uint64_t __fsblkcnt_t;
typedef __uint64_t __fsfilcnt_t;
typedef __uint32_t __gid_t;
typedef __int64_t __id_t;
typedef __uint32_t __ino_t;
typedef long __key_t;
typedef __int32_t __lwpid_t;
typedef __uint16_t __mode_t;
typedef int __accmode_t;
typedef int __nl_item;
typedef __uint16_t __nlink_t;
typedef __int64_t __off_t;
typedef __int64_t __off64_t;
typedef __int32_t __pid_t;
typedef __int64_t __rlim_t;


typedef __uint8_t __sa_family_t;
typedef __uint32_t __socklen_t;
typedef long __suseconds_t;
typedef struct __timer *__timer_t;
typedef struct __mq *__mqd_t;
typedef __uint32_t __uid_t;
typedef unsigned int __useconds_t;
typedef int __cpuwhich_t;
typedef int __cpulevel_t;
typedef int __cpusetid_t;
# 95 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 3
typedef int __ct_rune_t;
typedef __ct_rune_t __rune_t;







typedef unsigned short __wchar_t;






typedef __ct_rune_t __wint_t;
# 124 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 3
typedef __uint32_t __dev_t;

typedef __uint32_t __fixpt_t;





typedef union {
 char __mbstate8[128];
 __int64_t _mbstateL;
} __mbstate_t;

typedef __uintmax_t __rman_res_t;
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int8_t.h" 2 3



typedef __int8_t int8_t;
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int16_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int16_t.h" 3
typedef short int16_t;
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int32_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int32_t.h" 3
typedef __int32_t int32_t;
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint8_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint8_t.h" 3
typedef __uint8_t uint8_t;
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint16_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint16_t.h" 3
typedef __uint16_t uint16_t;
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint32_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint32_t.h" 3
typedef __uint32_t uint32_t;
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_intptr_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_intptr_t.h" 3
typedef __intptr_t intptr_t;
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uintptr_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uintptr_t.h" 3
typedef __uintptr_t uintptr_t;
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int64_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int64_t.h" 3
typedef __int64_t int64_t;
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint64_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint64_t.h" 3
typedef __uint64_t uint64_t;
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef long _SceInt64t;
typedef unsigned long _SceUint64t;
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef _Int32t int_least32_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef _Uint32t uint_least32_t;
# 88 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef _Int32t int_fast8_t;
typedef _Int32t int_fast16_t;




typedef _Int32t int_fast32_t;


typedef _Uint32t uint_fast8_t;
typedef _Uint32t uint_fast16_t;




typedef _Uint32t uint_fast32_t;
# 155 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef _SceInt64t int_least64_t;
typedef _SceUint64t uint_least64_t;
# 167 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef _SceInt64t int_fast64_t;
typedef _SceUint64t uint_fast64_t;




typedef _SceInt64t intmax_t;
typedef _SceUint64t uintmax_t;
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_common.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdbool.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdbool.h" 2 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_common.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/endian.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/endian.h" 1 3
# 91 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/endian.h" 3
static inline __uint16_t
__bswap16_var(__uint16_t _x)
{

 return ((__uint16_t)((_x) << 8 | (_x) >> 8));
}

static inline __uint32_t
__bswap32_var(__uint32_t _x)
{


 __asm("bswap %0" : "+r" (_x));
 return (_x);



}

static inline __uint64_t
__bswap64_var(__uint64_t _x)
{


 __asm("bswap %0" : "+r" (_x));
 return (_x);







}
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/endian.h" 2 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_pthreadtypes.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_pthreadtypes.h" 3
struct pthread;
struct pthread_attr;
struct pthread_cond;
struct pthread_cond_attr;
struct pthread_mutex;
struct pthread_mutex_attr;
struct pthread_once;
struct pthread_rwlock;
struct pthread_rwlockattr;
struct pthread_barrier;
struct pthread_barrier_attr;
struct pthread_spinlock;
# 69 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_pthreadtypes.h" 3
typedef struct pthread *pthread_t;
typedef struct pthread_attr *pthread_attr_t;
typedef struct pthread_mutex *pthread_mutex_t;
typedef struct pthread_mutex_attr *pthread_mutexattr_t;
typedef struct pthread_cond *pthread_cond_t;
typedef struct pthread_cond_attr *pthread_condattr_t;
typedef int pthread_key_t;
typedef struct pthread_once pthread_once_t;
typedef struct pthread_rwlock *pthread_rwlock_t;
typedef struct pthread_rwlockattr *pthread_rwlockattr_t;
typedef struct pthread_barrier *pthread_barrier_t;
typedef struct pthread_barrierattr *pthread_barrierattr_t;
typedef struct pthread_spinlock *pthread_spinlock_t;







typedef void *pthread_addr_t;
typedef void *(*pthread_startroutine_t)(void *);




struct pthread_once {
 int state;
 pthread_mutex_t mutex;
};
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 2 3


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef unsigned short ushort;
typedef unsigned int uint;






# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_stdint.h" 1 3
# 64 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 2 3

typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;

typedef __uint64_t u_quad_t;
typedef __int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t;
typedef const char * c_caddr_t;


typedef __blksize_t blksize_t;



typedef __cpuwhich_t cpuwhich_t;
typedef __cpulevel_t cpulevel_t;
typedef __cpusetid_t cpusetid_t;


typedef __blkcnt_t blkcnt_t;




typedef __clock_t clock_t;




typedef __clockid_t clockid_t;



typedef __critical_t critical_t;
typedef __int64_t daddr_t;


typedef __dev_t dev_t;




typedef __fflags_t fflags_t;



typedef __fixpt_t fixpt_t;


typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;




typedef __gid_t gid_t;




typedef __uint32_t in_addr_t;




typedef __uint16_t in_port_t;




typedef __id_t id_t;




typedef __ino_t ino_t;




typedef __key_t key_t;




typedef __lwpid_t lwpid_t;




typedef __mode_t mode_t;




typedef __accmode_t accmode_t;




typedef __nlink_t nlink_t;




typedef __off_t off_t;




typedef __off64_t off64_t;




typedef __pid_t pid_t;



typedef __register_t register_t;


typedef __rlim_t rlim_t;



typedef __int64_t sbintime_t;

typedef __segsz_t segsz_t;


typedef __size_t size_t;




typedef __ssize_t ssize_t;




typedef __suseconds_t suseconds_t;




typedef __time_t time_t;




typedef __timer_t timer_t;




typedef __mqd_t mqd_t;



typedef __u_register_t u_register_t;


typedef __uid_t uid_t;




typedef __useconds_t useconds_t;





typedef unsigned long cap_ioctl_t;




struct cap_rights;

typedef struct cap_rights cap_rights_t;


typedef __vm_offset_t vm_offset_t;
typedef __vm_ooffset_t vm_ooffset_t;
typedef __vm_paddr_t vm_paddr_t;
typedef __vm_pindex_t vm_pindex_t;
typedef __vm_size_t vm_size_t;

typedef __rman_res_t rman_res_t;
# 365 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_sigset.h" 1 3
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_sigset.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 1 3
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_sigset.h" 2 3
# 58 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_sigset.h" 3
typedef struct __sigset {
 __uint32_t __bits[4];
} __sigset_t;
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timeval.h" 1 3
# 38 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timeval.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_suseconds_t.h" 1 3
# 39 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timeval.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_time_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_time_t.h" 2 3
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timeval.h" 2 3




struct timeval {
 time_t tv_sec;
 suseconds_t tv_usec;
};
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/timespec.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/timespec.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timespec.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timespec.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_timespec.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_timespec.h" 2 3





struct timespec {
 time_t tv_sec;
 long tv_nsec;
};
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timespec.h" 2 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/timespec.h" 2 3
# 63 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/timespec.h" 3
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_sigset_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_sigset_t.h" 3
typedef __sigset_t sigset_t;
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 2 3

typedef unsigned long __fd_mask;

typedef __fd_mask fd_mask;
# 72 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 3
typedef struct fd_set {
 __fd_mask __fds_bits[(((1024) + (((sizeof(__fd_mask) * 8)) - 1)) / ((sizeof(__fd_mask) * 8)))];
} fd_set;
# 98 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 3
extern "C" {
int pselect(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict,
 const struct timespec *__restrict, const sigset_t *__restrict);




int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);


}
# 366 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 2 3
# 382 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 3
extern "C" {


int ftruncate(int, off_t);



off_t lseek(int, off_t, int);



void * mmap(void *, size_t, int, int, int, off_t);



int truncate(const char *, off_t);

}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 1 3
# 38 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/queue.h" 1 3
# 39 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 2 3
# 83 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 3
struct kevent {
 uintptr_t ident;
 short filter;
 u_short flags;
 u_int fflags;
 intptr_t data;
 void *udata;
};
# 187 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 3
struct knote;
struct klist { struct knote *slh_first; };
struct kqueue;
struct kqlist { struct kqueue *tqh_first; struct kqueue **tqh_last; };
struct knlist {
 struct klist kl_list;
 void (*kl_lock)(void *);
 void (*kl_unlock)(void *);
 void (*kl_assert_locked)(void *);
 void (*kl_assert_unlocked)(void *);
 void *kl_lockarg;
 int kl_autodestroy;
};
# 326 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 3
struct timespec;

extern "C" {
int kqueue(void);
int kevent(int kq, const struct kevent *changelist, int nchanges,
     struct kevent *eventlist, int nevents,
     const struct timespec *timeout);
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_clock.h" 1 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 2 3

struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
struct bintime {
 time_t sec;
 uint64_t frac;
};

static inline void
bintime_addx(struct bintime *_bt, uint64_t _x)
{
 uint64_t _u;

 _u = _bt->frac;
 _bt->frac += _x;
 if (_u > _bt->frac)
  _bt->sec++;
}

static inline void
bintime_add(struct bintime *_bt, const struct bintime *_bt2)
{
 uint64_t _u;

 _u = _bt->frac;
 _bt->frac += _bt2->frac;
 if (_u > _bt->frac)
  _bt->sec++;
 _bt->sec += _bt2->sec;
}

static inline void
bintime_sub(struct bintime *_bt, const struct bintime *_bt2)
{
 uint64_t _u;

 _u = _bt->frac;
 _bt->frac -= _bt2->frac;
 if (_u < _bt->frac)
  _bt->sec--;
 _bt->sec -= _bt2->sec;
}

static inline void
bintime_mul(struct bintime *_bt, u_int _x)
{
 uint64_t _p1, _p2;

 _p1 = (_bt->frac & 0xffffffffull) * _x;
 _p2 = (_bt->frac >> 32) * _x + (_p1 >> 32);
 _bt->sec *= _x;
 _bt->sec += (_p2 >> 32);
 _bt->frac = (_p2 << 32) | (_p1 & 0xffffffffull);
}

static inline void
bintime_shift(struct bintime *_bt, int _exp)
{

 if (_exp > 0) {
  _bt->sec <<= _exp;
  _bt->sec |= _bt->frac >> (64 - _exp);
  _bt->frac <<= _exp;
 } else if (_exp < 0) {
  _bt->frac >>= -_exp;
  _bt->frac |= (uint64_t)_bt->sec << (64 + _exp);
  _bt->sec >>= -_exp;
 }
}
# 140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
static inline int
sbintime_getsec(sbintime_t _sbt)
{

 return (_sbt >> 32);
}

static inline sbintime_t
bttosbt(const struct bintime _bt)
{

 return (((sbintime_t)_bt.sec << 32) + (_bt.frac >> 32));
}

static inline struct bintime
sbttobt(sbintime_t _sbt)
{
 struct bintime _bt;

 _bt.sec = _sbt >> 32;
 _bt.frac = _sbt << 32;
 return (_bt);
}
# 178 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
static inline void
bintime2timespec(const struct bintime *_bt, struct timespec *_ts)
{

 _ts->tv_sec = _bt->sec;
 _ts->tv_nsec = ((uint64_t)1000000000 *
     (uint32_t)(_bt->frac >> 32)) >> 32;
}

static inline void
timespec2bintime(const struct timespec *_ts, struct bintime *_bt)
{

 _bt->sec = _ts->tv_sec;

 _bt->frac = (uint64_t)_ts->tv_nsec * (uint64_t)18446744073LL;
}

static inline void
bintime2timeval(const struct bintime *_bt, struct timeval *_tv)
{

 _tv->tv_sec = _bt->sec;
 _tv->tv_usec = ((uint64_t)1000000 * (uint32_t)(_bt->frac >> 32)) >> 32;
}

static inline void
timeval2bintime(const struct timeval *_tv, struct bintime *_bt)
{

 _bt->sec = _tv->tv_sec;

 _bt->frac = (uint64_t)_tv->tv_usec * (uint64_t)18446744073709LL;
}

static inline struct timespec
sbttots(sbintime_t _sbt)
{
 struct timespec _ts;

 _ts.tv_sec = _sbt >> 32;
 _ts.tv_nsec = ((uint64_t)1000000000 * (uint32_t)_sbt) >> 32;
 return (_ts);
}

static inline sbintime_t
tstosbt(struct timespec _ts)
{

 return (((sbintime_t)_ts.tv_sec << 32) +
     (_ts.tv_nsec * (((uint64_t)1 << 63) / 500000000) >> 32));
}

static inline struct timeval
sbttotv(sbintime_t _sbt)
{
 struct timeval _tv;

 _tv.tv_sec = _sbt >> 32;
 _tv.tv_usec = ((uint64_t)1000000 * (uint32_t)_sbt) >> 32;
 return (_tv);
}

static inline sbintime_t
tvtosbt(struct timeval _tv)
{

 return (((sbintime_t)_tv.tv_sec << 32) +
     (_tv.tv_usec * (((uint64_t)1 << 63) / 500000) >> 32));
}
# 327 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};




struct clockinfo {
 int hz;
 int tick;
 int spare;
 int stathz;
 int profhz;
};
# 469 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_errno_t.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_errno_t.h" 2 3


extern "C" {



typedef int errno_t;


}
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_size_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_size_t.h" 2 3
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_size_t.h" 3
typedef size_t rsize_t;
# 55 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_clock_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_clock_t.h" 2 3
# 56 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_clockid_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_clockid_t.h" 2 3
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 3
struct tm
 {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 };
# 135 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 3
extern "C" {
time_t time(time_t *);
}

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void);
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *);
size_t strftime(char *, size_t,
 const char *, const struct tm *);
int timespec_get(struct timespec *, int);


int clock_getres(clockid_t, struct timespec *);
int clock_gettime(clockid_t, struct timespec *);
int nanosleep(const struct timespec *, struct timespec *);


}


extern "C" {

errno_t asctime_s(char *, rsize_t, const struct tm *);
errno_t ctime_s(char *, rsize_t, const time_t *);
struct tm *gmtime_s(const time_t *,
 struct tm *);
struct tm *localtime_s(const time_t *,
 struct tm *);
}



extern "C++" {

template<rsize_t _Size>
errno_t asctime_s(char (&_Str)[_Size], const struct tm *_Tptr)
 {
 return asctime_s(_Str, _Size, _Tptr);
 }

template<rsize_t _Size>
errno_t ctime_s(char (&_Str)[_Size], const time_t *_Tod)
 {
 return ctime_s(_Str, _Size, _Tod);
 }

}
# 470 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 2 3




extern "C" {
int setitimer(int, const struct itimerval *, struct itimerval *);
int utimes(const char *, const struct timeval *);


int adjtime(const struct timeval *, struct timeval *);
int clock_getcpuclockid2(id_t, int, clockid_t *);
int futimes(int, const struct timeval *);
int futimesat(int, const char *, const struct timeval [2]);
int lutimes(const char *, const struct timeval *);
int settimeofday(const struct timeval *, const struct timezone *);



int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval *, struct timezone *);



}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 3
typedef enum {
  SCE_KERNEL_MTYPE_C = 11,
  SCE_KERNEL_MTYPE_C_SHARED,

  SCE_KERNEL_MEMORY_TYPE_END = 21
} SceKernelMemoryType;






enum {

 __SCE_KERNEL_MAIN_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x0000000000L,
 __SCE_KERNEL_DMEM_END
  __attribute__ ((deprecated)) = 0x5000000000L,
 __SCE_KERNEL_GPU_SHARED_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x1000000000L,
 __SCE_KERNEL_GPU_PRIVATE_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x2000000000L,
 __SCE_KERNEL_GPU_SHARED_DMEM_SIZE
  __attribute__ ((deprecated)) = 0x0d000000L,
 __SCE_KERNEL_GPU_PRIVATE_DMEM_SIZE
  __attribute__ ((deprecated)) = 0x80000000L
};
# 81 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 3
enum {

 __SCE_KERNEL_FIXED_PRT_APERTURE_START_ADDR
  __attribute__ ((deprecated)) = 0x0f00000000UL,
 __SCE_KERNEL_FIXED_PRT_APERTURE_SIZE
  __attribute__ ((deprecated)) = 0x0010000000UL,
 __SCE_KERNEL_FIXED_PRT_APERTURE_END_ADDR
  __attribute__ ((deprecated)) = 0x0f00000000UL + 0x0010000000UL
};
# 106 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 3
extern "C" {

typedef enum {
  SCE_KERNEL_MAP_OP_MAP_DIRECT,
  SCE_KERNEL_MAP_OP_UNMAP,
  SCE_KERNEL_MAP_OP_PROTECT,
  SCE_KERNEL_MAP_OP_MAP_FLEXIBLE,
  SCE_KERNEL_MAP_OP_TYPE_PROTECT,
} SceKernelMapEntryOperation;

typedef struct
{
 void *start;
 off_t offset;
   size_t length;
 char protection;
 char type;
 short pad1;
 int operation;
} SceKernelBatchMapEntry;



typedef struct
{
 void *start;
 void *end;
 off_t offset;
 int protection;
 int memoryType;
 unsigned isFlexibleMemory:1;
 unsigned isDirectMemory:1;
 unsigned isStack:1;
 unsigned isPooledMemory:1;
 unsigned isCommitted:1;
   unsigned isGpuPrt:1;
 unsigned ammUsage:1;
 unsigned __reserved:1;
 char name[32];
 uint8_t gpuMaskId;
 uint8_t __reserved2;
} SceKernelVirtualQueryInfo;



typedef struct
{
 off_t start;
 off_t end;
 int memoryType;
} SceKernelDirectMemoryQueryInfo;
# 166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 3
typedef struct
{
 unsigned op;
 unsigned flags;
 union {
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
   unsigned char type;
  } commit;
  struct {
   void *addr;
   size_t len;
  } decommit;
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
  } protect;
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
   unsigned char type;
  } typeProtect;
  struct {
   void *dst;
   void *src;
   size_t len;
  } move;
  uintptr_t padding[3];
 };
} SceKernelMemoryPoolBatchEntry;

typedef struct
{
 int availableFlushedBlocks;
 int availableCachedBlocks;
 int allocatedFlushedBlocks;
 int allocatedCachedBlocks;
} SceKernelMemoryPoolBlockStats;

size_t sceKernelGetDirectMemorySize();

int32_t sceKernelMapFlexibleMemory(void** addrInOut, size_t len,
       int prot, int flags);
int32_t sceKernelReleaseFlexibleMemory(void* addr, size_t len);
int32_t sceKernelSetPrtAperture(int index, void *addr, size_t len);
int32_t sceKernelGetPrtAperture(int index, void **addr, size_t *len);

int32_t sceKernelAllocateDirectMemory(off_t searchStart, off_t searchEnd,
          size_t len, size_t alignment,
          int memoryType,
          off_t *physAddrOut);
int32_t sceKernelAllocateDirectMemory2(off_t _searchStart, off_t _searchEnd,
     size_t _len, size_t _alignment, int _memoryType, int _flags,
     off_t *_physAddrOut);
int32_t sceKernelAllocateMainDirectMemory(size_t len, size_t alignment,
       int memoryType,
       off_t *physAddrOut);
int32_t sceKernelReleaseDirectMemory(off_t start, size_t len);
int32_t sceKernelCheckedReleaseDirectMemory(off_t start, size_t len);
int32_t sceKernelMapDirectMemory(void **addr, size_t len,
     int prot, int flags, off_t directMemoryStart,
     size_t alignment);
int32_t sceKernelMapDirectMemory2(void **addr, size_t len,
      int type, int prot,
      int flags, off_t directMemoryStart,
     size_t alignment);
int32_t sceKernelGetDirectMemoryType(off_t start,
         int *memoryType,
         off_t *regionStartOut,
         off_t *regionEndOut);

int32_t sceKernelBatchMap(SceKernelBatchMapEntry* entries,
     int numberOfEntries,
     int* numberOfEntriesOut);
int32_t sceKernelBatchMap2(SceKernelBatchMapEntry* entries,
      int numberOfEntries,
      int* numberOfEntriesOut,
      int flags);

int32_t
sceKernelJitCreateSharedMemory(const char *name, size_t len, int maxProt,
          int *fdOut);
int32_t sceKernelJitCreateAliasOfSharedMemory(int fd, int maxProt, int *fdOut);
int32_t sceKernelJitMapSharedMemory(int fd, int prot, void **startOut);
int32_t sceKernelJitGetSharedMemoryInfo(int fd, char* name, int nameBufferSize,
     void **startOut, size_t *lenOut,
     int *maxProtOut);

int32_t sceKernelQueryMemoryProtection(void* addr,
           void** start, void** end, int* prot);
int32_t sceKernelIsStack(void* addr, void** start, void** end);
int32_t sceKernelVirtualQuery(const void *addr, int flags,
         SceKernelVirtualQueryInfo *info,
         size_t infoSize);
int32_t sceKernelSetVirtualRangeName(void* start, size_t len,
    const char *name);
int32_t sceKernelClearVirtualRangeName(void *addr, size_t len);

int32_t sceKernelMapNamedFlexibleMemory(void** addrInOut, size_t len,
     int prot, int flags, const char *name);
int32_t sceKernelMapNamedDirectMemory(void **addr, size_t len,
          int prot, int flags,
          off_t directMemoryStart,
          size_t alignment, const char *name);
int sceKernelReserveVirtualRange(void **addr, size_t len, int flags,
     size_t alignment);

int32_t sceKernelDirectMemoryQuery(off_t offset,
       int flags,
       void *info,
       size_t infoSize);
int32_t sceKernelMtypeprotect(const void *addr, size_t size, int type,
    int prot);

int32_t sceKernelAvailableDirectMemorySize(off_t start,
        off_t end,
        size_t alignment,
        off_t *startOut,
        size_t *sizeOut);
int32_t sceKernelGetPageTableStats(int* cpuTotal, int* cpuAvailable,
       int* gpuTotal, int* gpuAvailable);


int32_t sceKernelMemoryPoolBatch(const SceKernelMemoryPoolBatchEntry *entries,
    int n, int *indexOut, int flags);
int32_t sceKernelMemoryPoolCommit(void *addr, size_t len, int type, int prot,
    int flags);
int32_t sceKernelMemoryPoolDecommit(void *addr, size_t len, int flags);
int32_t sceKernelMemoryPoolExpand(off_t searchStart, off_t searchEnd,
    size_t len, size_t alignment, off_t *physAddrOut);
int32_t sceKernelMemoryPoolGetBlockStats(SceKernelMemoryPoolBlockStats *output,
    size_t outputSize);
int32_t sceKernelMemoryPoolMove(void *dst, void *src, size_t len, int flags);
int32_t sceKernelMemoryPoolReserve(void *addrIn, size_t len, size_t alignment,
    int flags, void **addrOut);

}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sce_errno.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sce_errno.h" 3
extern "C" {
# 768 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sce_errno.h" 3
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sched.h" 1 3
# 68 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sched.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sched.h" 1 3
# 233 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sched.h" 3
struct sched_param {
        int sched_priority;
};
# 244 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sched.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_pid_t.h" 1 3
# 245 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sched.h" 2 3

extern "C" {
int sched_get_priority_max(int);
int sched_get_priority_min(int);
int sched_getparam(pid_t, struct sched_param *);
int sched_getscheduler(pid_t);
int sched_rr_get_interval(pid_t, struct timespec *);
int sched_setparam(pid_t, const struct sched_param *);
int sched_setscheduler(pid_t, int, const struct sched_param *);
int sched_yield(void);
}
# 69 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sched.h" 2 3
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_types.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cpuset.h" 1 3
# 35 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cpuset.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_cpuset.h" 1 3
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_cpuset.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_bitset.h" 1 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_cpuset.h" 2 3
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_cpuset.h" 3
struct _cpuset { long __bits[(((((128)) + (((sizeof(long) * 8)) - 1)) / ((sizeof(long) * 8))))]; };
typedef struct _cpuset cpuset_t;
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cpuset.h" 2 3
# 322 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cpuset.h" 3
extern "C" {
int cpuset(cpusetid_t *);
int cpuset_setid(cpuwhich_t, id_t, cpusetid_t);
int cpuset_getid(cpulevel_t, cpuwhich_t, id_t, cpusetid_t *);
int cpuset_getaffinity(cpulevel_t, cpuwhich_t, id_t, size_t, cpuset_t *);
int cpuset_setaffinity(cpulevel_t, cpuwhich_t, id_t, size_t, const cpuset_t *);
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_types.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 1 3
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/syslimits.h" 1 3
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 2 3
# 133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/signal.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 1 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/trap.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/trap.h" 1 3
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/trap.h" 2 3
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 2 3
# 103 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 3
typedef long sig_atomic_t;
# 116 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 3
struct sigcontext {
 struct __sigset sc_mask;
 long sc_onstack;
 long sc_rdi;
 long sc_rsi;
 long sc_rdx;
 long sc_rcx;
 long sc_r8;
 long sc_r9;
 long sc_rax;
 long sc_rbx;
 long sc_rbp;
 long sc_r10;
 long sc_r11;
 long sc_r12;
 long sc_r13;
 long sc_r14;
 long sc_r15;
 int sc_trapno;
 short sc_fs;
 short sc_gs;
 long sc_addr;
 int sc_flags;
 short sc_es;
 short sc_ds;
 long sc_err;
 long sc_rip;
 long sc_cs;
 long sc_rflags;
 long sc_rsp;
 long sc_ss;
 long sc_len;




 long sc_fpformat;
 long sc_ownedfp;
 long sc_lbrfrom;
 long sc_lbrto;
 long sc_aux1;
 long sc_aux2;
 long sc_fpstate[104] __attribute__((__aligned__(16)));

 long sc_fsbase;
 long sc_gsbase;

 long sc_xfpustate;
 long sc_xfpustate_len;

 long sc_spare[4];
};
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/signal.h" 2 3
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 2 3
# 165 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
typedef void __sighandler_t(int);


union sigval {

 int sival_int;
 void *sival_ptr;

 int sigval_int;
 void *sigval_ptr;
};




struct pthread_attr;

struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 union {
  __lwpid_t _threadid;
  struct {
   void (*_function)(union sigval);
   struct pthread_attr **_attribute;
  } _sigev_thread;
  unsigned short _kevent_flags;
  long __spare__[8];
 } _sigev_un;
};
# 216 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
typedef struct __siginfo {
 int si_signo;
 int si_errno;






 int si_code;
 __pid_t si_pid;
 __uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 union {
  struct {
   int _trapno;
  } _fault;
  struct {
   int _timerid;
   int _overrun;
  } _timer;
  struct {
   int _mqd;
  } _mesgq;
  struct {
   long _band;
  } _poll;
  struct {
   long __spare1__;
   int __spare2__[7];
  } __spare__;
 } _reason;
} siginfo_t;
# 315 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
struct __siginfo;




struct sigaction {
 union {
  void (*__sa_handler)(int);
  void (*__sa_sigaction)(int, struct __siginfo *, void *);
 } __sigaction_u;
 int sa_flags;
 sigset_t sa_mask;
};
# 372 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
typedef __sighandler_t *sig_t;
typedef void __siginfohandler_t(int, struct __siginfo *, void *);






typedef struct sigaltstack stack_t;
# 393 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
struct sigaltstack {
 void *ss_sp;
 __size_t ss_size;
 int ss_flags;
};






struct sigvec {
 __sighandler_t *sv_handler;
 int sv_mask;
 int sv_flags;
};
# 431 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
struct sigstack {
 void *ss_sp;
 int ss_onstack;
};
# 462 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
extern "C" {
__sighandler_t *signal(int, __sighandler_t *);
}
# 134 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/param.h" 1 3
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_align.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_align.h" 1 3
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_align.h" 2 3
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/param.h" 2 3
# 138 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/limits.h" 1 3
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/limits.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/limits.h" 2 3
# 140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 2 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_types.h" 2 3

typedef struct kevent SceKernelKevent;
typedef struct timespec SceKernelTimespec;
typedef struct timeval SceKernelTimeval;
typedef clockid_t SceKernelClockid;
typedef struct sched_param SceKernelSchedParam;
typedef uint64_t SceKernelCpumask;
typedef unsigned int SceKernelUseconds;
typedef int32_t SceKernelModule;
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 3
extern "C" {

typedef struct
{
 size_t size;
} SceKernelLoadModuleOpt;

typedef struct
{
 size_t size;
} SceKernelUnloadModuleOpt;


int sceKernelMlock(const void *addr, size_t len);
int sceKernelMunlock(const void *addr, size_t len);
int sceKernelMprotect(const void *addr, size_t len, int prot);
int sceKernelMsync(void *addr, size_t len, int flags);
int sceKernelMunmap(void *addr, size_t len);
int sceKernelMlockall(int flags);
int sceKernelMunlockall(void);
unsigned int sceKernelSleep(unsigned int seconds);
int sceKernelUsleep(SceKernelUseconds microseconds);
int sceKernelNanosleep(const SceKernelTimespec *rqtp, SceKernelTimespec *rmtp);
int sceKernelClockGetres(SceKernelClockid clockId, SceKernelTimespec *tp);
int sceKernelClockGettime(SceKernelClockid clockId, SceKernelTimespec *tp);
int sceKernelGettimeofday(SceKernelTimeval *tp);

uint64_t sceKernelGetTscFrequency(void);
uint64_t sceKernelReadTsc(void);
uint64_t sceKernelGetProcessTime(void);
uint64_t sceKernelGetProcessTimeCounter(void);
uint64_t sceKernelGetProcessTimeCounterFrequency(void);
int sceKernelGetCurrentCpu(void);

SceKernelModule sceKernelLoadStartModule(const char *moduleFileName,
        size_t args, const void *argp, uint32_t flags,
        const SceKernelLoadModuleOpt *pOpt, int *pRes);
int sceKernelStopUnloadModule(SceKernelModule handle, size_t args,
        const void *argp, uint32_t flags, const SceKernelUnloadModuleOpt *pOpt,
        int *pRes);
int sceKernelDlsym(SceKernelModule handle, const char *symbol, void **addrp) __attribute__((noinline));


int __attribute__((visibility ("hidden"))) module_start(size_t args, const void *argp);
int __attribute__((visibility ("hidden"))) module_stop(size_t args, const void *argp);

void sceKernelSetGPO(uint32_t uiBits);
uint64_t sceKernelGetGPI(void);

}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 1 3
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sched.h" 1 3
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 55 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sched.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 1 3
# 55 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3
# 128 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 3
enum pthread_mutextype {
 PTHREAD_MUTEX_ERRORCHECK = 1,
 PTHREAD_MUTEX_RECURSIVE = 2,
 PTHREAD_MUTEX_NORMAL = 3,
 PTHREAD_MUTEX_ADAPTIVE_NP = 4,
 PTHREAD_MUTEX_TYPE_MAX
};



struct _pthread_cleanup_info {
 __uintptr_t pthread_cleanup_pad[8];
};




extern "C" {
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getstack(const pthread_attr_t * __restrict,
   void ** __restrict, size_t * __restrict);
int pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
int pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
int pthread_attr_getstackaddr(const pthread_attr_t *, void **);
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t);
int pthread_attr_setguardsize(pthread_attr_t *, size_t);
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
int pthread_attr_setstackaddr(pthread_attr_t *, void *);
int pthread_attr_setdetachstate(pthread_attr_t *, int);
int pthread_barrier_destroy(pthread_barrier_t *);
int pthread_barrier_init(pthread_barrier_t *,
   const pthread_barrierattr_t *, unsigned);
int pthread_barrier_wait(pthread_barrier_t *);
int pthread_barrierattr_destroy(pthread_barrierattr_t *);
int pthread_barrierattr_getpshared(const pthread_barrierattr_t *,
   int *);
int pthread_barrierattr_init(pthread_barrierattr_t *);
int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
# 181 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 3
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_getclock(const pthread_condattr_t *,
   clockid_t *);
int pthread_condattr_getpshared(const pthread_condattr_t *, int *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
int pthread_condattr_setpshared(pthread_condattr_t *, int);
int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t *,
   const pthread_condattr_t *);
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t *,
   pthread_mutex_t *, const struct timespec *);
int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
int pthread_create(pthread_t *, const pthread_attr_t *,
   void *(*) (void *), void *);
int pthread_detach(pthread_t);
int pthread_equal(pthread_t, pthread_t);
void pthread_exit(void *) __attribute__((__noreturn__));
void *pthread_getspecific(pthread_key_t);
int pthread_getcpuclockid(pthread_t, clockid_t *);
int pthread_join(pthread_t, void **);
int pthread_key_create(pthread_key_t *,
   void (*) (void *));
int pthread_key_delete(pthread_key_t);
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,
   int *);
int pthread_mutexattr_gettype(pthread_mutexattr_t *, int *);
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_init(pthread_mutex_t *,
   const pthread_mutexattr_t *);
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_timedlock(pthread_mutex_t *,
   const struct timespec *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_once(pthread_once_t *, void (*) (void));
int pthread_rwlock_destroy(pthread_rwlock_t *);
int pthread_rwlock_init(pthread_rwlock_t *,
   const pthread_rwlockattr_t *);
int pthread_rwlock_rdlock(pthread_rwlock_t *);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *,
   const struct timespec *);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *,
   const struct timespec *);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int pthread_rwlock_trywrlock(pthread_rwlock_t *);
int pthread_rwlock_unlock(pthread_rwlock_t *);
int pthread_rwlock_wrlock(pthread_rwlock_t *);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *,
   int *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,
   int *);
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *, int);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
pthread_t pthread_self(void);
int pthread_setspecific(pthread_key_t, const void *);

int pthread_cancel(pthread_t);
int pthread_setcancelstate(int, int *);
int pthread_setcanceltype(int, int *);
void pthread_testcancel(void);


int pthread_getprio(pthread_t);
int pthread_setprio(pthread_t, int);
void pthread_yield(void);


int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *,
   int *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,
   int);
int pthread_mutex_getprioceiling(pthread_mutex_t *, int *);
int pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);

int pthread_mutexattr_getprotocol(pthread_mutexattr_t *, int *);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

int pthread_attr_getinheritsched(const pthread_attr_t *, int *);
int pthread_attr_getschedparam(const pthread_attr_t *,
   struct sched_param *);
int pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
int pthread_attr_getscope(const pthread_attr_t *, int *);
int pthread_attr_setinheritsched(pthread_attr_t *, int);
int pthread_attr_setschedparam(pthread_attr_t *,
   const struct sched_param *);
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_getschedparam(pthread_t pthread, int *,
   struct sched_param *);
int pthread_setschedparam(pthread_t, int,
   const struct sched_param *);

int pthread_getconcurrency(void);
int pthread_setconcurrency(int);


void __pthread_cleanup_push_imp(void (*)(void *), void *,
   struct _pthread_cleanup_info *);
void __pthread_cleanup_pop_imp(int);
}
# 58 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\semaphore.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\semaphore.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_umtx.h" 1 3
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_umtx.h" 3
struct umutex {
 volatile __lwpid_t m_owner;
 __uint32_t m_flags;
 __uint32_t m_ceilings[2];
 __uintptr_t m_rb_lnk;



 __uint32_t m_spare[2];
};

struct ucond {
 volatile __uint32_t c_has_waiters;
 __uint32_t c_flags;
 __uint32_t c_clockid;
 __uint32_t c_spare[1];
};

struct urwlock {
 volatile __int32_t rw_state;
 __uint32_t rw_flags;
 __uint32_t rw_blocked_readers;
 __uint32_t rw_blocked_writers;
 __uint32_t rw_spare[4];
};

struct _usem {
 volatile __uint32_t _has_waiters;
 volatile __uint32_t _count;
 __uint32_t _flags;
};

struct _usem2 {
 volatile __uint32_t _count;
 __uint32_t _flags;
};

struct _umtx_time {
 struct timespec _timeout;
 __uint32_t _flags;
 __uint32_t _clockid;
};
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\semaphore.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_useconds_t.h" 1 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\semaphore.h" 2 3

struct _sem {
 __uint16_t _magic;
 __uint16_t _nameid;
 struct _usem _kern;
};

typedef struct _sem sem_t;




struct timespec;

extern "C" {
int sem_destroy(sem_t *);
int sem_getvalue(sem_t * __restrict, int * __restrict);
int sem_init(sem_t *, int, unsigned int);
int sem_post(sem_t *);
int sem_reltimedwait_np(sem_t *, useconds_t);
int sem_timedwait(sem_t * __restrict, const struct timespec * __restrict);
int sem_trywait(sem_t *);
int sem_unlink(const char *);
int sem_wait(sem_t *);
}
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3
# 140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 3
typedef enum ScePthreadMutextype {
 SCE_PTHREAD_MUTEX_ERRORCHECK = 1,
 SCE_PTHREAD_MUTEX_RECURSIVE = 2,
 SCE_PTHREAD_MUTEX_NORMAL = 3,
 SCE_PTHREAD_MUTEX_ADAPTIVE = 4,
 SCE_PTHREAD_MUTEX_TYPE_MAX
} ScePthreadMutextype;

typedef enum ScePthreadRwlocktype {
 SCE_PTHREAD_RWLOCK_NORMAL = 1,
 SCE_PTHREAD_RWLOCK_PREFER_READER = 2,
 SCE_PTHREAD_RWLOCK_TYPE_MAX
} ScePthreadRwlocktype;
# 166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 3
typedef pthread_attr_t ScePthreadAttr;
typedef pthread_barrier_t ScePthreadBarrier;
typedef pthread_barrierattr_t ScePthreadBarrierattr;
typedef pthread_condattr_t ScePthreadCondattr;
typedef pthread_cond_t ScePthreadCond;
typedef pthread_t ScePthread;
typedef pthread_key_t ScePthreadKey;
typedef pthread_mutex_t ScePthreadMutex;
typedef pthread_mutexattr_t ScePthreadMutexattr;
typedef pthread_once_t ScePthreadOnce;
typedef pthread_rwlock_t ScePthreadRwlock;
typedef pthread_rwlockattr_t ScePthreadRwlockattr;
typedef sem_t ScePthreadSem;





extern "C" {
int scePthreadAttrDestroy(ScePthreadAttr *attr);
int scePthreadAttrGetstack(const ScePthreadAttr * __restrict attr,
   void ** __restrict stackAddr, size_t * __restrict stackSize);
int scePthreadAttrGetstacksize(const ScePthreadAttr *attr, size_t *stackSize);
int scePthreadAttrGetguardsize(const ScePthreadAttr *attr, size_t *guardSize);
int scePthreadAttrGetstackaddr(const ScePthreadAttr *attr, void **stackAddr);
int scePthreadAttrGetdetachstate(const ScePthreadAttr *attr, int *state);
int scePthreadAttrInit(ScePthreadAttr *attr);
int scePthreadAttrSetstacksize(ScePthreadAttr *attr, size_t stackSize);
int scePthreadAttrSetguardsize(ScePthreadAttr *attr, size_t guardSize);
int scePthreadAttrSetstack(ScePthreadAttr *attr, void *addr, size_t size);
int scePthreadAttrSetstackaddr(ScePthreadAttr *attr, void *addr);
int scePthreadAttrSetdetachstate(ScePthreadAttr *attr, int state);
int scePthreadBarrierDestroy(ScePthreadBarrier *barrier);
int scePthreadBarrierInit(ScePthreadBarrier *barrier,
   const ScePthreadBarrierattr *attr, unsigned count, const char *name);
int scePthreadBarrierWait(ScePthreadBarrier *barrier);
int scePthreadBarrierattrDestroy(ScePthreadBarrierattr *barrier);
int scePthreadBarrierattrInit(ScePthreadBarrierattr *barrier);
# 217 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 3
int scePthreadCondattrDestroy(ScePthreadCondattr *attr);
int scePthreadCondattrInit(ScePthreadCondattr *attr);
int scePthreadCondBroadcast(ScePthreadCond *cond);
int scePthreadCondDestroy(ScePthreadCond *cond);
int scePthreadCondInit(ScePthreadCond *cond,
   const ScePthreadCondattr *attr, const char *name);
int scePthreadCondSignal(ScePthreadCond *cond);
int scePthreadCondSignalto(ScePthreadCond *cond, ScePthread thread);
int scePthreadCondTimedwait(ScePthreadCond *cond, ScePthreadMutex *mutex,
                        SceKernelUseconds usec);
int scePthreadCondWait(ScePthreadCond *cond, ScePthreadMutex *mutex);
int scePthreadCreate(ScePthread *thread, const ScePthreadAttr *attr,
                        void *(*entry) (void *), void *arg, const char *name);
int scePthreadDetach(ScePthread thread);
int scePthreadEqual(ScePthread thraed1, ScePthread thread2);
void scePthreadExit(void *value) __attribute__((__noreturn__));
void *scePthreadGetspecific(ScePthreadKey key);
int scePthreadGetcpuclockid(ScePthread thread, clockid_t *clock);
int scePthreadJoin(ScePthread thread, void **value);
int scePthreadKeyCreate(ScePthreadKey *key,
   void (*destructor) (void *));
int scePthreadKeyDelete(ScePthreadKey key);
int scePthreadMutexattrInit(ScePthreadMutexattr *attr);
int scePthreadMutexattrDestroy(ScePthreadMutexattr *attr);
int scePthreadMutexattrGettype(ScePthreadMutexattr *attr, int *type);
int scePthreadMutexattrSettype(ScePthreadMutexattr *attr, int type);
int scePthreadMutexDestroy(ScePthreadMutex *mutex);
int scePthreadMutexInit(ScePthreadMutex *mutex,
   const ScePthreadMutexattr *attr, const char *name);
int scePthreadMutexLock(ScePthreadMutex *mutex);
int scePthreadMutexTrylock(ScePthreadMutex *mutex);
int scePthreadMutexTimedlock(ScePthreadMutex *mutex, SceKernelUseconds usec);
int scePthreadMutexUnlock(ScePthreadMutex *mutex);
int scePthreadOnce(ScePthreadOnce *once, void (*init) (void));
int scePthreadRwlockDestroy(ScePthreadRwlock *rwlock);
int scePthreadRwlockInit(ScePthreadRwlock *rwlock,
   const ScePthreadRwlockattr *attr, const char *name);
int scePthreadRwlockRdlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockTimedrdlock(ScePthreadRwlock *rwlock, SceKernelUseconds usec);
int scePthreadRwlockTimedwrlock(ScePthreadRwlock *rwlock, SceKernelUseconds usec);
int scePthreadRwlockTryrdlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockTrywrlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockUnlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockWrlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockattrDestroy(ScePthreadRwlockattr *attr);
int scePthreadRwlockattrInit(ScePthreadRwlockattr *attr);
int scePthreadRwlockattrGettype(ScePthreadRwlockattr *attr, int *type);
int scePthreadRwlockattrSettype(ScePthreadRwlockattr *attr, int type);
ScePthread scePthreadSelf(void);
int scePthreadSetspecific(ScePthreadKey key, const void *value);

int scePthreadCancel(ScePthread thread);
int scePthreadSetcancelstate(int state, int *oldState);
int scePthreadSetcanceltype(int type, int *oldType);
void scePthreadTestcancel(void);

int scePthreadGetprio(ScePthread thread, int *prio);
int scePthreadSetprio(ScePthread thread, int prio);
void scePthreadYield(void);

int scePthreadMutexattrGetprioceiling(ScePthreadMutexattr *attr,
   int *prio);
int scePthreadMutexattrSetprioceiling(ScePthreadMutexattr *attr,
   int prio);
int scePthreadMutexGetprioceiling(ScePthreadMutex *mutex, int *prio);
int scePthreadMutexSetprioceiling(ScePthreadMutex *mutex, int prio, int *oldPrio);

int scePthreadMutexattrGetprotocol(ScePthreadMutexattr *attr, int *protocol);
int scePthreadMutexattrSetprotocol(ScePthreadMutexattr *attr, int protocol);

int scePthreadAttrGetinheritsched(const ScePthreadAttr *attr, int *inheritSched);
int scePthreadAttrGetschedparam(const ScePthreadAttr *attr,
   SceKernelSchedParam *param);
int scePthreadAttrGetschedpolicy(const ScePthreadAttr *attr, int *policy);
int scePthreadAttrSetinheritsched(ScePthreadAttr *attr, int inheritSched);
int scePthreadAttrSetschedparam(ScePthreadAttr *attr,
   const SceKernelSchedParam *param);
int scePthreadAttrSetschedpolicy(ScePthreadAttr *attr, int policy);
int scePthreadGetschedparam(ScePthread thread, int *policy,
     SceKernelSchedParam *param);
int scePthreadSetschedparam(ScePthread thread, int policy,
     const SceKernelSchedParam *param);

int scePthreadSemInit(ScePthreadSem *sem, int flag, unsigned int value,
    const char *name);
int scePthreadSemDestroy(ScePthreadSem *sem);
int scePthreadSemTimedwait(ScePthreadSem *sem, SceKernelUseconds usec);
int scePthreadSemGetvalue(ScePthreadSem * __restrict sem, int * __restrict sval);
int scePthreadSemPost(ScePthreadSem *sem);
int scePthreadSemTrywait(ScePthreadSem *sem);
int scePthreadSemWait(ScePthreadSem *sem);


int scePthreadAttrGet(ScePthread thread, ScePthreadAttr *attr);
int scePthreadAttrGetaffinity(const ScePthreadAttr *attr, SceKernelCpumask *mask);
int scePthreadAttrSetaffinity(ScePthreadAttr *attr, const SceKernelCpumask mask);
int scePthreadGetaffinity(ScePthread thread, SceKernelCpumask *mask);
int scePthreadSetaffinity(ScePthread thread, const SceKernelCpumask mask);
int scePthreadGetthreadid(void);
int scePthreadRename(ScePthread thread, const char *name);
int scePthreadGetname(ScePthread thread, char *name);
int scePthreadAttrGetsolosched(const ScePthreadAttr *attr, int *solosched);
int scePthreadAttrSetsolosched(ScePthreadAttr *attr, int solosched);

}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_iovec.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_iovec.h" 3
struct iovec {
 void *iov_base;
 size_t iov_len;
};
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_ssize_t.h" 1 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_off_t.h" 1 3
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 2 3


enum uio_rw { UIO_READ, UIO_WRITE };


enum uio_seg {
 UIO_USERSPACE,
 UIO_SYSSPACE,
 UIO_NOCOPY
};
# 112 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 3
extern "C" {
ssize_t readv(int, const struct iovec *, int);
ssize_t writev(int, const struct iovec *, int);

ssize_t preadv(int, const struct iovec *, int, off_t);
ssize_t pwritev(int, const struct iovec *, int, off_t);

}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/stat.h" 1 3
# 122 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/stat.h" 3
struct stat {
 __dev_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 uid_t st_uid;
 gid_t st_gid;
 __dev_t st_rdev;
 struct timespec st_atim;
 struct timespec st_mtim;
 struct timespec st_ctim;
 off_t st_size;
 blkcnt_t st_blocks;
 blksize_t st_blksize;
 fflags_t st_flags;
 __uint32_t st_gen;
 __int32_t st_lspare;
 struct timespec st_birthtim;
# 148 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/stat.h" 3
 unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
 unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
};
# 329 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/stat.h" 3
extern "C" {

int chflags(const char *, unsigned long);
int chflagsat(int, const char *, unsigned long, int);

int chmod(const char *, mode_t);

int fchflags(int, unsigned long);


int fchmod(int, mode_t);


int fchmodat(int, const char *, mode_t, int);
int futimens(int fd, const struct timespec times[2]);
int utimensat(int fd, const char *path, const struct timespec times[2],
  int flag);

int fstat(int, struct stat *);

int lchflags(const char *, unsigned long);
int lchmod(const char *, mode_t);


int lstat(const char * __restrict, struct stat * __restrict);

int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);

int mknod(const char *, mode_t, dev_t);


int stat(const char * __restrict, struct stat * __restrict);
mode_t umask(mode_t);

int fstatat(int, const char *, struct stat *, int);
int mkdirat(int, const char *, mode_t);
int mkfifoat(int, const char *, mode_t);


int mknodat(int, const char *, mode_t, dev_t);

}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dirent.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dirent.h" 3
struct dirent {
 __uint32_t d_fileno;
 __uint16_t d_reclen;
 __uint8_t d_type;
 __uint8_t d_namlen;


 char d_name[255 + 1];



};
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 1 3
# 38 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/fcntl.h" 1 3
# 281 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/fcntl.h" 3
struct flock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
 int l_sysid;
};






struct __oflock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
};
# 325 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/fcntl.h" 3
extern "C" {
int open(const char *, int, ...);
int creat(const char *, mode_t);
int fcntl(int, int, ...);

int flock(int, int);


int openat(int, const char *, int, ...);


int posix_fadvise(int, off_t, off_t, int);
int posix_fallocate(int, off_t, off_t);

}
# 39 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/unistd.h" 1 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/unistd.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_seek.h" 1 3
# 42 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/unistd.h" 2 3
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 2 3
# 224 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 3
struct xfile {
 size_t xf_size;
 pid_t xf_pid;
 uid_t xf_uid;
 int xf_fd;
 void *xf_file;
 short xf_type;
 int xf_count;
 int xf_msgcount;
 off_t xf_offset;
 void *xf_data;
 void *xf_vnode;
 u_int xf_flag;
};
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/mman.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/mman.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/ioccom.h" 1 3
# 71 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/ioccom.h" 3
enum {
    SCE_SYS_DEV_IOCTL_BASE = (127),
    SCE_SYS_DMEM_IOCTL_BASE,
    SCE_SYS_GC_IOCTL_BASE,
    SCE_SYS_DCE_IOCTL_BASE,
    SCE_SYS_UVD_IOCTL_BASE,
    SCE_SYS_VCE_IOCTL_BASE,
    SCE_SYS_DBGGC_IOCTL_BASE,
    SCE_SYS_TWSI_IOCTL_BASE,
    SCE_SYS_MDBG_IOCTL_BASE,
    SCE_SYS_DEVENV_IOCTL_BASE,
    SCE_SYS_AJM_IOCTL_BASE,
    SCE_SYS_TRACE_IOCTL_BASE,
    SCE_SYS_IBS_IOCTL_BASE,
    SCE_SYS_MBUS_IOCTL_BASE,
    SCE_SYS_HDMI_IOCTL_BASE,
    SCE_SYS_CAMERA_IOCTL_BASE,
    SCE_SYS_FAN_IOCTL_BASE,
    SCE_SYS_THERMAL_IOCTL_BASE,
 SCE_SYS_PFS_IOCTL_BASE,
    SCE_SYS_ICC_CONFIG_IOCTL_BASE,
    SCE_SYS_IPC_IOCTL_BASE,
    SCE_SYS_IOSCHED_IOCTL_BASE,
    SCE_SYS_ICC_INDICATOR_IOCTL_BASE,
    SCE_SYS_EXFATFS_IOCTL_BASE,
    SCE_SYS_ICC_NVS_IOCTL_BASE,
    SCE_SYS_DVE_IOCTL_BASE,
    SCE_SYS_ICC_POWER_IOCTL_BASE,
    SCE_SYS_AV_CONTROL_IOCTL_BASE,
    SCE_SYS_ICC_SC_CONFIGURATION_IOCTL_BASE,
    SCE_SYS_ICC_DEVICE_POWER_IOCTL_BASE,
    SCE_SYS_SSHOT_IOCTL_BASE,
    SCE_SYS_DCE_SCANIN_IOCTL_BASE,
    SCE_SYS_FSCTRL_IOCTL_BASE,
    SCE_SYS_HMD_IOCTL_BASE,
    SCE_SYS_SHM_IOCTL_BASE,
    SCE_SYS_PHYSHM_IOCTL_BASE,
    SCE_SYS_HMDDFU_IOCTL_BASE,
    SCE_SYS_BLUETOOTH_HID_IOCTL_BASE,
    SCE_SYS_SBI_IOCTL_BASE,
    SCE_SYS_S3DA_IOCTL_BASE,
    SCE_SYS_SPM_IOCTL_BASE,
    SCE_SYS_BLOCKPOOL_IOCTL_BASE,
    SCE_SYS_SDK_EVENTLOG_IOCTL_BASE,
    SCE_SYS_DRFS_IOCTL_BASE,
    SCE_SYS_ACM_IOCTL_BASE,
    SCE_SYS_A53MM_IOCTL_BASE,
    SCE_SYS_AMM_TRACE_IOCTL_BASE,
    SCE_SYS_MP1_IOCTL_BASE,
    SCE_SYS_CPUKNOB_IOCTL_BASE,
    SCE_SYS_DEVPFS_IOCTL_BASE,
    SCE_SYS_DBGGC_WFDEBUG_IOCTL_BASE,
    SCE_SYS_GBASE_IOCTL_BASE,
    SCE_SYS_IOCONTROLLER_TRACE_IOCTL_BASE,
    SCE_SYS_MP3_IOCTL_BASE,
    SCE_SYS_A53MMSYS_IOCTL_BASE,
    SCE_SYS_SWAPDEV_IOCTL_BASE,
    SCE_SYS_ICC_FLOYD_IOCTL_BASE,
    SCE_SYS_PM_TRACE_IOCTL_BASE,
    SCE_SYS_USBC_IOCTL_BASE,
    SCE_SYS_GVMLOG_IOCTL_BASE,
    SCE_SYS_NAPR_TRACE_IOCTL_BASE,
    SCE_SYS_HMD2_IOCTL_BASE,
    SCE_SYS_APR_IOCTL_BASE,
    SCE_SYS_MP4_MDBG_IOCTL_BASE,
    SCE_SYS_WORKSPACE_IOCTL_BASE,
    SCE_SYS_MP1_BAPMLOG_IOCTL_BASE,
    SCE_SYS_ICC_CRASH_REPORT_IOCTL_BASE,
    SCE_SYS_ICC_CPBOX_IOCTL_BASE,
    SCE_SYS_ICC_HDMI_IOCTL_BASE,
    SCE_SYS_ICC_BDDRIVE_IOCTL_BASE,
    SCE_SYS_DFSPM_IOCTL_BASE,
 SCE_SYS_CORESPM_IOCTL_BASE,

};
# 158 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/ioccom.h" 3
extern "C" {
int ioctl(int, unsigned long, ...);
}
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/mman.h" 2 3
# 386 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/mman.h" 3
extern "C" {





int getpagesizes(size_t *, int);
int madvise(void *, size_t, int);
int mincore(const void *, size_t, char *);
int minherit(void *, size_t, int);

int mlock(const void *, size_t);




int mprotect(const void *, size_t, int);
int msync(void *, size_t, int);
int munlock(const void *, size_t);
int munmap(void *, size_t);

int posix_madvise(void *, size_t, int);


int mlockall(int);
int munlockall(void);
int shm_open(const char *, int, mode_t);
int shm_unlink(const char *);

int physhm_open(const char *, int, mode_t, int);
int physhm_unlink(const char *);
void *mmap_dmem(void *, size_t, int, int, int, off_t);
void *mmap2(void *, size_t, int, int, long, int, off_t);

}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\fcntl.h" 1 3
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 3
typedef struct iovec SceKernelIovec;
typedef struct stat SceKernelStat;
typedef struct dirent SceKernelDirent;
typedef mode_t SceKernelMode;

extern "C" {

ssize_t sceKernelRead(int d, void *buf, size_t nbytes);
ssize_t sceKernelWrite(int d, const void *buf, size_t nbytes);
int sceKernelOpen(const char *path, int flags, SceKernelMode mode);
int sceKernelClose(int d);
int sceKernelUnlink(const char *path);
int sceKernelChmod(const char *path, SceKernelMode mode);
int sceKernelCheckReachability(const char *path);
void sceKernelSync(void);
int sceKernelFsync(int fd);
int sceKernelFdatasync(int fd);
int sceKernelFcntl(int fd, int cmd, ...);
ssize_t sceKernelReadv(int d, const SceKernelIovec *iov, int iovcnt);
ssize_t sceKernelWritev(int d, const SceKernelIovec *iov, int iovcnt);
int sceKernelFchmod(int fd, SceKernelMode mode);
int sceKernelRename(const char *from, const char *to);
int sceKernelMkdir(const char *path, SceKernelMode mode);
int sceKernelRmdir(const char *path);
int sceKernelUtimes(const char *path, const SceKernelTimeval *times);
int sceKernelStat(const char *path, SceKernelStat *sb);
int sceKernelFstat(int fd, SceKernelStat *sb);
int sceKernelFutimes(int fd, const SceKernelTimeval *times);
int sceKernelGetdirentries(int fd, char *buf, int nbytes, long *basep);
int sceKernelGetdents(int fd, char *buf, int nbytes);
ssize_t sceKernelPreadv(int d, const SceKernelIovec *iov, int iovcnt, off_t offset);
ssize_t sceKernelPwritev(int d, const SceKernelIovec *iov, int iovcnt, off_t offset);
ssize_t sceKernelPread(int d, void *buf, size_t nbytes, off_t offset);
ssize_t sceKernelPwrite(int d, const void *buf, size_t nbytes, off_t offset);
int sceKernelMmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset,
        void **res);
off_t sceKernelLseek(int fildes, off_t offset, int whence);
int sceKernelTruncate(const char *path, off_t length);
int sceKernelFtruncate(int fd, off_t length);
int sceKernelSetCompressionAttribute(int fd, int flag);
int sceKernelLwfsSetAttribute(int fd, int flags);
int sceKernelLwfsAllocateBlock(int fd, off_t size);
int sceKernelLwfsTrimBlock(int fd, off_t size);
off_t sceKernelLwfsLseek(int fd, off_t offset, int whence);
ssize_t sceKernelLwfsWrite(int fd, const void *buf, size_t nbytes);
# 160 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 3
typedef struct SceKernelAioResult {
 int64_t returnValue;
 uint32_t state;
} SceKernelAioResult;
# 189 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 3
typedef struct SceKernelAioSchedulingParam {
 int schedulingWindowSize;
 int delayedCountLimit;
 uint32_t enableSplit;
 uint32_t splitSize;
 uint32_t splitChunkSize;
} SceKernelAioSchedulingParam;

typedef struct SceKernelAioParam {
 SceKernelAioSchedulingParam low;
 SceKernelAioSchedulingParam mid;
 SceKernelAioSchedulingParam high;
} SceKernelAioParam;

typedef int SceKernelAioSubmitId;

int sceKernelAioDeleteRequests(SceKernelAioSubmitId id[], int num, int ret[]);

int sceKernelAioDeleteRequest(SceKernelAioSubmitId id, int *ret);

int sceKernelAioWaitRequests(SceKernelAioSubmitId id[],
        int num,
        int state[],
        uint32_t mode,
        SceKernelUseconds *usec);

int sceKernelAioWaitRequest(SceKernelAioSubmitId id,
       int *state,
       SceKernelUseconds *usec);

int sceKernelAioInitialize(SceKernelAioParam* param);

int sceKernelAioInitializeImpl(void* p, int size);


int sceKernelAioCancelRequests(SceKernelAioSubmitId id[], int num, int state[]);

int sceKernelAioCancelRequest(SceKernelAioSubmitId id, int *state);

int sceKernelAioPollRequest(SceKernelAioSubmitId id,
       int *state);

int sceKernelAioPollRequests(SceKernelAioSubmitId id[],
        int num,
        int state[]);



typedef struct SceKernelAioRWRequest {
 off_t offset;
 size_t nbyte;
 void* buf;
 struct SceKernelAioResult *result;
 int fd;
} SceKernelAioRWRequest;

int sceKernelAioSubmitReadCommands(SceKernelAioRWRequest req[],
           int size,
           int prio,
           SceKernelAioSubmitId *id);

int sceKernelAioSubmitReadCommandsMultiple(SceKernelAioRWRequest req[],
             int size,
             int prio,
             SceKernelAioSubmitId id[]);

int sceKernelAioSubmitWriteCommands(SceKernelAioRWRequest req[],
         int size,
         int prio,
         SceKernelAioSubmitId *id);

int sceKernelAioSubmitWriteCommandsMultiple(SceKernelAioRWRequest req[],
           int size,
           int prio,
           SceKernelAioSubmitId id[]);


void sceKernelAioInitializeParam(SceKernelAioParam* param);

int sceKernelAioSetParam(SceKernelAioSchedulingParam* param,
       int schedulingWindowSize,
       int delayedCountLimit,
       uint32_t enableSplit,
       uint32_t splitSize,
       uint32_t splitChunkSize);


int apr_submit(void* buf,
      size_t nelem, int prio, int type,
      void *res,
      uint32_t *sidp);
int apr_resolve(void *pre, void *path,
  size_t len, void *ids, void *size, uint32_t *erridx,
  int *results, int *nresolved);
int apr_stat(void *id, size_t idlen, void *st);
int apr_wait(void *ids, size_t idlen);
int apr_ctrl(int cmd, void* arg, size_t size, void* rsv1, int rsv2);
int sceKernelAprCtrl(int cmd, void* arg, size_t size, void* rsv1, int rsv2);

int ampr_ctrl_debug(int cmd, void* arg, size_t size, void* rsv1, int rsv2);

int sceKernelStreamWriteCreate(size_t size, int *stream_id);
int sceKernelStreamWriteDelete(int stream_id);
typedef struct SceKernelStreamWriteStatus {
 int64_t size;
 int64_t reserved0;
 int64_t tail_offset;
 int64_t stored_size;
 int64_t reserved1[4];
} SceKernelStreamWriteStatus;
int sceKernelStreamWriteStat(int stream_id, SceKernelStreamWriteStatus *status);
int sceKernelStreamWriteActivate(int stream_id, int flags);
int sceKernelStreamWriteWrite(int stream_id,
         const void *buf, size_t size, int flags,
         off_t *written_offset, size_t *stored_size);
int sceKernelStreamWriteRead(int stream_id,
        void *buf, size_t size, off_t offset, int flags);
int sceKernelStreamWriteDeactivate(int stream_id, int flags);

int workspace_ctrl(int cmd, void* arg, size_t size, void* rsv1, int rsv2);

typedef struct SceKernelAioRequestInfo {
 int fd;
 size_t size;
 off_t offset;
} SceKernelAioRequestInfo;

typedef struct SceKernelAioSubmitInfo {
 SceKernelAioSubmitId id;
 int status;
 int priority;
 int cmd;
} SceKernelAioSubmitInfo;

int sceKernelGetAioDebugRequestInfo(
 pid_t pid,
 SceKernelAioSubmitId id,
 SceKernelAioRequestInfo *info,
 int num,
 int *stored_num
);

int sceKernelGetAioDebugSubmitInfo(
 pid_t pid,
 SceKernelAioSubmitInfo *info,
 int num,
 int *stored_num
);

int get_aio_debug_submit_info(int pid, SceKernelAioSubmitInfo* info, int num, int *stored_num);
int get_aio_debug_request_info(int pid, int id, SceKernelAioRequestInfo* info, int num, int *stored_num);

}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/eventflag.h" 1 3
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/eventflag.h" 3
typedef struct _SceKernelEventFlagOptParam {
 size_t size;
} SceKernelEventFlagOptParam;

typedef struct _SceKernelEventFlag* SceKernelEventFlag;




extern "C" {

int sceKernelCreateEventFlag(SceKernelEventFlag *ef, const char *pName,
        uint32_t attr, uint64_t initPattern,
        const SceKernelEventFlagOptParam *pOptParam);
int sceKernelDeleteEventFlag(SceKernelEventFlag ef);
int sceKernelWaitEventFlag(SceKernelEventFlag ef, uint64_t bitPattern,
      uint32_t waitMode, uint64_t *pResultPat,
      SceKernelUseconds *pTimeout);
int sceKernelPollEventFlag(SceKernelEventFlag ef, uint64_t bitPattern,
      uint32_t waitMode, uint64_t *pResultPat);
int sceKernelSetEventFlag(SceKernelEventFlag ef, uint64_t bitPattern);
int sceKernelClearEventFlag(SceKernelEventFlag ef, uint64_t bitPattern);
int sceKernelCancelEventFlag(SceKernelEventFlag ef, uint64_t setPattern,
        int *pNumWaitThreads);

}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/semaphore.h" 1 3
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/semaphore.h" 3
typedef struct _SceKernelSemaOptParam {
 size_t size;
} SceKernelSemaOptParam;

typedef struct _SceKernelSema* SceKernelSema;




extern "C" {

int sceKernelCreateSema(SceKernelSema *sem, const char *name, uint32_t attr,
   int init, int max, const SceKernelSemaOptParam *opt);
int sceKernelDeleteSema(SceKernelSema sem);
int sceKernelWaitSema(SceKernelSema sem, int need, SceKernelUseconds *timo);
int sceKernelPollSema(SceKernelSema sem, int need);
int sceKernelSignalSema(SceKernelSema sem, int count);
int sceKernelCancelSema(SceKernelSema sem, int count, int *threads);

}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/equeue.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/equeue.h" 3
extern "C" {

typedef struct _SceKernelEqueue* SceKernelEqueue;
typedef struct kevent SceKernelEvent;
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/equeue.h" 3
int sceKernelGetEventFilter(const SceKernelEvent *ev);
uintptr_t sceKernelGetEventId(const SceKernelEvent *ev);
intptr_t sceKernelGetEventData(const SceKernelEvent *ev);
unsigned int sceKernelGetEventFflags(const SceKernelEvent *ev);
int sceKernelGetEventError(const SceKernelEvent *ev);
void * sceKernelGetEventUserData(const SceKernelEvent *ev);

int sceKernelCreateEqueue(SceKernelEqueue *eq, const char *name);
int sceKernelDeleteEqueue(SceKernelEqueue eq);
int sceKernelWaitEqueue(SceKernelEqueue eq, SceKernelEvent *ev, int num,
   int *out, SceKernelUseconds *timo);

int sceKernelAddTimerEvent(SceKernelEqueue eq, int id, SceKernelUseconds usec, void *udata);
int sceKernelDeleteTimerEvent(SceKernelEqueue eq, int id);
int sceKernelAddReadEvent(SceKernelEqueue eq, int fd, size_t size, void *udata);
int sceKernelDeleteReadEvent(SceKernelEqueue eq, int fd);
int sceKernelAddWriteEvent(SceKernelEqueue eq, int fd, size_t size, void *udata);
int sceKernelDeleteWriteEvent(SceKernelEqueue eq, int fd);
int sceKernelAddFileEvent(SceKernelEqueue eq, int fd, int watch, void *udata);
int sceKernelDeleteFileEvent(SceKernelEqueue eq, int fd);
int sceKernelAddUserEvent(SceKernelEqueue eq, int id);
int sceKernelAddUserEventEdge(SceKernelEqueue eq, int id);
int sceKernelDeleteUserEvent(SceKernelEqueue eq, int id);
int sceKernelTriggerUserEvent(SceKernelEqueue eq, int id, void *udata);
int sceKernelAddHRTimerEvent(SceKernelEqueue eq, int id, SceKernelTimespec *ts, void *udata);
int sceKernelDeleteHRTimerEvent(SceKernelEqueue eq, int id);
int sceKernelAddAmprEvent(SceKernelEqueue eq, int id, void *udata);
int sceKernelDeleteAmprEvent(SceKernelEqueue eq, int id);
int sceKernelAddAmprSystemEvent(SceKernelEqueue eq, int id, int watch, void *udata);
int sceKernelDeleteAmprSystemEvent(SceKernelEqueue eq, int id);

}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/uuid.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/uuid.h" 3
extern "C" {

typedef struct {
    uint32_t timeLow;
    uint16_t timeMid;
    uint16_t timeHiAndVersion;
    uint8_t clockSeqHiAndReserved;
    uint8_t clockSeqLow;
    uint8_t node[6];
} SceKernelUuid;

int sceKernelUuidCreate(SceKernelUuid* outUuid);

}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/memory.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/memory.h" 3
extern "C" {

int32_t sceKernelAvailableFlexibleMemorySize(size_t *sizeOut);
int32_t sceKernelConfiguredFlexibleMemorySize(size_t *sizeOut);

}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_common.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_defs.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_lldiv.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_lldiv.h" 2 3



typedef struct
{
 _Longlong quot;
 _Longlong rem;
} _Lldiv_t;
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int.h" 3
extern "C" {



typedef struct
{
 long quot;
 long rem;
} ldiv_t;

typedef _Lldiv_t lldiv_t;


extern long labs(long);
extern _Longlong llabs(_Longlong);
extern ldiv_t ldiv(long, long);
extern lldiv_t lldiv(_Longlong, _Longlong);


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int_cpp.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int_cpp.h" 3
extern "C" {

extern "C++" {





  inline long abs(long _Left)
  {
    return (labs(_Left));
  }

  inline ldiv_t div(long _Left, long _Right)
  {
    return (ldiv(_Left, _Right));
  }




  inline _Longlong abs(_Longlong _Left)
  {
    return (llabs(_Left));
  }

  inline _Lldiv_t div(_Longlong _Left, _Longlong _Right)
  {
    return (lldiv(_Left, _Right));
  }


}

}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 2 3
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 3
extern "C" {




typedef struct
 {
 intmax_t quot;
 intmax_t rem;
 } imaxdiv_t;





intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);

intmax_t strtoimax(const char *,
 char **, int);
uintmax_t strtoumax(const char *,
 char **, int);
intmax_t wcstoimax(const _Wchart *,
 _Wchart **, int);
uintmax_t wcstoumax(const _Wchart *,
 _Wchart **, int);
}
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_defs.h" 2 3



typedef int32_t SceUserServiceUserId;
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 2 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 3
typedef _Ptrdifft ptrdiff_t;
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 3
typedef decltype(nullptr) nullptr_t;





typedef float max_align_t __attribute__((__vector_size__ (32) ));
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 2 3






# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\strings.h" 1 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\strings.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 42 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\strings.h" 2 3
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\strings.h" 3
extern "C" {

int bcmp(const void *, const void *, size_t) __attribute__((__pure__));
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);

}
# 56 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 2 3
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
extern "C" {
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
int strcmp(const char *, const char *);
char *strcpy(char *, const char *);
size_t strlen(const char *);

void *memmove(void *, const void *, size_t);
int strcoll(const char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int);
int strerror_r(int, char *, size_t);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
size_t strspn(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);


char *strdup(const char *);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
char *strtok_r(char *, const char *, char **);


}





extern "C" {
const char *strchr(const char *, int);
const char *strpbrk(const char *, const char *);
const char *strrchr(const char *, int);
const char *strstr(const char *, const char *);
}

extern "C++" {
inline char *strchr(char *_Str, int _Ch)
 {
 return ((char *):: strchr((const char *)_Str, _Ch));
 }

inline char *strpbrk(char *_Str1, const char *_Str2)
 {
 return ((char *):: strpbrk((const char *)_Str1, _Str2));
 }

inline char *strrchr(char *_Str, int _Ch)
 {
 return ((char *):: strrchr((const char *)_Str, _Ch));
 }

inline char *strstr(char *_Str1, const char *_Str2)
 {
 return ((char *):: strstr((const char *)_Str1, _Str2));
 }
}
# 143 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
extern "C" {
const void *memchr(const void *, int, size_t);
}

extern "C++" {
inline void *memchr(void *_Str, int _Ch, size_t _Num)
 {
 return ((void *):: memchr((const void *)_Str, _Ch, _Num));
 }
}
# 163 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
extern "C" {

errno_t memcpy_s(void *, rsize_t,
 const void *, rsize_t);
errno_t memmove_s(void *, rsize_t,
 const void *, rsize_t);
errno_t memset_s(void *, rsize_t, int, rsize_t);

errno_t strcpy_s(char *, rsize_t,
 const char *);
errno_t strncpy_s(char *, rsize_t,
 const char *, rsize_t);
errno_t strcat_s(char *, rsize_t,
 const char *);
errno_t strncat_s(char *, rsize_t,
 const char *, rsize_t);
char *strtok_s(char *, rsize_t *,
 const char *, char **);

errno_t strerror_s(char *, rsize_t, errno_t);
size_t strerrorlen_s(errno_t);

size_t strnlen_s(const char *, size_t);
}



extern "C++" {

template<rsize_t _Size>
errno_t strcat_s(char (&_Str1)[_Size], const char *_Str2)
 {
 return strcat_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t strcpy_s(char (&_Str1)[_Size], const char *_Str2)
 {
 return strcpy_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t strerror_s(char (&_Str)[_Size], errno_t _Errcode)
 {
 return strerror_s(_Str, _Size, _Errcode);
 }

template<rsize_t _Size>
errno_t strncat_s(char (&_Str1)[_Size], const char *_Str2, rsize_t _Num)
 {
 return strncat_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t strncpy_s(char (&_Str1)[_Size], const char *_Str2, rsize_t _Num)
 {
 return strncpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t memcpy_s(char (&_Dst)[_Size], const char *_Src, rsize_t _Num)
 {
 return memcpy_s(_Dst, _Size, _Src, _Num);
 }

template<rsize_t _Size>
errno_t memmove_s(char (&_Dst)[_Size], const char *_Src, rsize_t _Num)
 {
 return memmove_s(_Dst, _Size, _Src, _Num);
 }

template<size_t _Size>
size_t strnlen_s(const char (&_Str)[_Size])
 {
 return strnlen_s(_Str, _Size);
 }

}
# 292 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
extern "C" {

size_t strlcat(char * __restrict, const char * __restrict, size_t);
size_t strlcpy(char * __restrict, const char * __restrict, size_t);


char *strndup(const char *, size_t) __attribute__((__malloc__));
size_t strnlen(const char *, size_t) __attribute__((__pure__));


char *strnstr(const char *, const char *, size_t) __attribute__((__pure__));

}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 2 3




typedef struct SceUserServiceInitializeParams {
 int32_t priority;
} SceUserServiceInitializeParams;



typedef enum SceUserServiceEventType {
 SCE_USER_SERVICE_EVENT_TYPE_LOGIN = 0,
 SCE_USER_SERVICE_EVENT_TYPE_LOGOUT
} SceUserServiceEventType;



typedef struct SceUserServiceEvent {
 SceUserServiceEventType eventType;
 SceUserServiceUserId userId;
} SceUserServiceEvent;



typedef struct SceUserServiceLoginUserIdList {
    SceUserServiceUserId userId[(4)];
} SceUserServiceLoginUserIdList;



typedef struct SceUserServiceGamePresets {
 size_t thisSize;
 uint32_t difficulty;
 uint32_t priority;
 uint32_t invertVerticalViewFor1stPersonView;
 uint32_t invertHorizontalViewFor1stPersonView;
 uint32_t invertVerticalViewFor3rdPersonView;
 uint32_t invertHorizontalViewFor3rdPersonView;
 uint32_t displaySubTitles;
 uint32_t audioLanguage;
 uint32_t joinableUserType;
 uint32_t invitableUserType;
} SceUserServiceGamePresets;



extern "C" {




int32_t sceUserServiceInitialize(const SceUserServiceInitializeParams *initParams);



int32_t sceUserServiceInitialize2(int threadPriority, SceKernelCpumask cpuAffinityMask);



int32_t sceUserServiceTerminate();



int32_t sceUserServiceGetLoginUserIdList(SceUserServiceLoginUserIdList *userIdList);



int32_t sceUserServiceGetEvent(SceUserServiceEvent *event);



int32_t sceUserServiceGetInitialUser(SceUserServiceUserId *userId);



int32_t sceUserServiceGetUserName(const SceUserServiceUserId userId, char *userName, const size_t size);



int32_t sceUserServiceGetUserNumber(const SceUserServiceUserId userId, int32_t *number);



static inline
void sceUserServiceGamePresetsInitialize(SceUserServiceGamePresets *presets)
{
 memset(presets, 0x0, sizeof(SceUserServiceGamePresets));
 presets->thisSize = sizeof(SceUserServiceGamePresets);
}



int32_t sceUserServiceGetGamePresets(SceUserServiceUserId userId, SceUserServiceGamePresets *presets);



int32_t sceUserServiceGetAgeLevel(SceUserServiceUserId userId, uint32_t *ageLevel);



int32_t sceUserServiceGetAccessibilityChatTranscription(SceUserServiceUserId userId, int32_t *chatTranscription);



int32_t sceUserServiceGetAccessibilityPressAndHoldDelay(SceUserServiceUserId userId, int32_t *pressAndHoldDelay);



int32_t sceUserServiceGetAccessibilityTriggerEffect(SceUserServiceUserId userId, int32_t *triggerEffect);



int32_t sceUserServiceGetAccessibilityVibration(SceUserServiceUserId userId, int32_t *vibration);



int32_t sceUserServiceGetAccessibilityZoomEnabled(SceUserServiceUserId userId, int32_t *zoomEnabled);



int32_t sceUserServiceGetAccessibilityZoomFollowFocus(SceUserServiceUserId userId, int32_t *zoomFollowFocus);


}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_error.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service.h" 2 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_common.h" 2 3




typedef struct SceNpOnlineId {
 char data[(16)];
 char term;
 char dummy[3];
} SceNpOnlineId;



typedef struct SceNpTitleId {
 char id[(12) + 1];
 uint8_t padding[3];
} SceNpTitleId;



typedef struct SceNpTitleSecret {
 uint8_t data[(128)];
} SceNpTitleSecret;



typedef struct SceNpClientId {
 char id[(128) + 1];
 uint8_t padding[7];
} SceNpClientId;



typedef struct SceNpClientSecret {
 char secret[(256) + 1];
 uint8_t padding[7];
} SceNpClientSecret;


typedef uint32_t SceNpServiceLabel;





typedef struct SceNpAuthorizationCode {
 char code[(128) + 1];
 uint8_t padding[7];
} SceNpAuthorizationCode;



typedef struct SceNpIdToken {
 char token[(4096) + 1];
 uint8_t padding[7];
} SceNpIdToken;





typedef enum SceNpState {
 SCE_NP_STATE_UNKNOWN = 0,
 SCE_NP_STATE_SIGNED_OUT,
 SCE_NP_STATE_SIGNED_IN
} SceNpState;


typedef int32_t SceNpPlatformType;
# 95 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_common.h" 3
typedef struct SceNpUnifiedEntitlementLabel {
 char data[(17)];
 char padding[3];
} SceNpUnifiedEntitlementLabel;



typedef struct SceNpServiceEntitlementLabel {
 char data[(7)];
 char padding[13];
} SceNpServiceEntitlementLabel;




typedef uint64_t SceNpAccountId;



typedef struct SceNpPeerAddressA {
 SceNpAccountId accountId;
 SceNpPlatformType platform;
 char padding[4];
} SceNpPeerAddressA;



typedef struct SceNpLanguageCode2 {
 char code[(35) + 1];
 char padding[12];
} SceNpLanguageCode2;



typedef struct SceNpCountryCode {
 char data[(2)];
 char term;
 char padding[1];
} SceNpCountryCode;


typedef enum SceNpReachabilityState {
 SCE_NP_REACHABILITY_STATE_UNAVAILABLE = 0,
 SCE_NP_REACHABILITY_STATE_AVAILABLE,
 SCE_NP_REACHABILITY_STATE_REACHABLE
} SceNpReachabilityState;




typedef struct SceNpCheckPremiumParameter {
 size_t size;
 SceUserServiceUserId userId;
 char padding[4];
 uint64_t features;
 uint8_t reserved[32];
} SceNpCheckPremiumParameter;

typedef struct SceNpCheckPremiumResult {
 bool authorized;
 uint8_t reserved[32];
} SceNpCheckPremiumResult;

typedef int32_t SceNpPremiumEventType;






typedef struct SceNpNotifyPremiumFeatureParameter {
 size_t size;
 SceUserServiceUserId userId;
 char padding[4];
 uint64_t features;
 uint64_t properties;
 uint8_t reserved[24];
} SceNpNotifyPremiumFeatureParameter;
# 181 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_common.h" 3
typedef struct SceNpCreateAsyncRequestParameter {
 size_t size;
 SceKernelCpumask cpuAffinityMask;
 int threadPriority;

 uint8_t padding[4];
} SceNpCreateAsyncRequestParameter;


extern "C" {


int sceNpSetNpTitleId(
  const SceNpTitleId *titleId,
  const SceNpTitleSecret *titleSecret);


int sceNpSetAdditionalScope(
 const char *scope);

int sceNpCheckCallback(void);

int sceNpGetState(
  SceUserServiceUserId userId,
  SceNpState *state);

typedef void (*SceNpStateCallbackA) (
  SceUserServiceUserId userId,
  SceNpState state,
  void *userdata);



int sceNpRegisterStateCallbackA(
  SceNpStateCallbackA callback,
  void *userdata);

int sceNpUnregisterStateCallbackA(
  int callbackId);

int sceNpGetNpReachabilityState(
  SceUserServiceUserId userId,
  SceNpReachabilityState *state);

typedef void (*SceNpReachabilityStateCallback) (
  SceUserServiceUserId userId,
  SceNpReachabilityState state,
  void *userdata);

int sceNpRegisterNpReachabilityStateCallback(
  SceNpReachabilityStateCallback callback,
  void *userdata);

int sceNpUnregisterNpReachabilityStateCallback(void);

int sceNpHasSignedUp(
  SceUserServiceUserId userId,
  bool *hasSignedUp);

int sceNpGetAccountIdA(
  SceUserServiceUserId userId,
  SceNpAccountId *accountId);

int sceNpGetUserIdByAccountId(
  SceNpAccountId accountId,
  SceUserServiceUserId* userId);

int sceNpGetOnlineId(
  SceUserServiceUserId userId,
  SceNpOnlineId *onlineId);

int sceNpGetAccountCountryA(
  SceUserServiceUserId userId,
  SceNpCountryCode *countryCode);


int sceNpNotifyPremiumFeature(
  const SceNpNotifyPremiumFeatureParameter *param);

typedef void(*SceNpPremiumEventCallback)(
  SceUserServiceUserId userId,
  SceNpPremiumEventType event,
  void *userdata);

int sceNpRegisterPremiumEventCallback(
  SceNpPremiumEventCallback callback,
  void *userdata);

int sceNpUnregisterPremiumEventCallback(void);


int sceNpCreateRequest(void);

int sceNpCreateAsyncRequest(
  const SceNpCreateAsyncRequestParameter *param);

int sceNpDeleteRequest(
  int reqId);

int sceNpAbortRequest(
  int reqId);

int sceNpSetTimeout(
  int reqId,
  int32_t resolveRetry,
  uint32_t resolveTimeout,
  uint32_t connTimeout,
  uint32_t sendTimeout,
  uint32_t recvTimeout);

int sceNpWaitAsync(
  int reqId,
  int *result);

int sceNpPollAsync(
  int reqId,
  int *result);


int sceNpGetAccountLanguage2(
  int reqId,
  SceUserServiceUserId userId,
  SceNpLanguageCode2 *languageCode2);

int sceNpGetAccountAge(
  int reqId,
  SceUserServiceUserId userId,
  uint8_t* age);


int sceNpCheckNpReachability(
  int reqId,
  SceUserServiceUserId userId);


int sceNpCheckPremium(
  int reqId,
  const SceNpCheckPremiumParameter *param,
  SceNpCheckPremiumResult *result);


}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_error.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_auth.h" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_auth.h" 3
typedef struct SceNpAuthCreateAsyncRequestParameter {
 size_t size;
 SceKernelCpumask cpuAffinityMask;
 int threadPriority;

 uint8_t padding[4];
} SceNpAuthCreateAsyncRequestParameter;

typedef struct SceNpAuthGetAuthorizationCodeParameterV3 {
 size_t size;
 SceUserServiceUserId userId;
 uint8_t padding[4];
 const SceNpClientId *clientId;
 const char *scope;
} SceNpAuthGetAuthorizationCodeParameterV3;

typedef struct SceNpAuthGetIdTokenParameterV3 {
 size_t size;
 SceUserServiceUserId userId;
 uint8_t padding[4];
 const SceNpClientId *clientId;
 const SceNpClientSecret *clientSecret;
 const char *scope;
} SceNpAuthGetIdTokenParameterV3;


extern "C" {


int sceNpAuthCreateRequest(void);

int sceNpAuthCreateAsyncRequest(
  const SceNpAuthCreateAsyncRequestParameter *param);

int sceNpAuthDeleteRequest(
  int reqId);

int sceNpAuthAbortRequest(
  int reqId);

int sceNpAuthSetTimeout(
  int reqId,
  int32_t resolveRetry,
  uint32_t resolveTimeout,
  uint32_t connTimeout,
  uint32_t sendTimeout,
  uint32_t recvTimeout);

int sceNpAuthWaitAsync(
  int reqId,
  int *result);

int sceNpAuthPollAsync(
  int reqId,
  int *result);

int sceNpAuthGetAuthorizationCodeV3(
  int reqId,
  const SceNpAuthGetAuthorizationCodeParameterV3 *param,
  SceNpAuthorizationCode *authCode,
  int *issuerId);

int sceNpAuthGetIdTokenV3(
  int reqId,
  const SceNpAuthGetIdTokenParameterV3 *param,
  SceNpIdToken *idToken);


}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_commerce.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_commerce.h" 3
extern "C" {




typedef enum {
 SCE_NP_COMMERCE_PS_STORE_ICON_CENTER = 0,
 SCE_NP_COMMERCE_PS_STORE_ICON_LEFT,
 SCE_NP_COMMERCE_PS_STORE_ICON_RIGHT,
} SceNpCommercePsStoreIconPos;



typedef enum {
 SCE_NP_COMMERCE_PS_STORE_ICON_LAYOUT_DEFAULT = 0,
 SCE_NP_COMMERCE_PS_STORE_ICON_LAYOUT_FOLLOW_DISPLAY_SAFE_AREA_INFO,
 SCE_NP_COMMERCE_PS_STORE_ICON_LAYOUT_FIXED_SCALE_90PERCENT,
} SceNpCommercePsStoreIconLayout;



int32_t sceNpCommerceShowPsStoreIcon(SceNpCommercePsStoreIconPos pos);



int32_t sceNpCommerceHidePsStoreIcon(void);



int32_t sceNpCommerceSetPsStoreIconLayout(SceNpCommercePsStoreIconLayout layout);


}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_trophy2.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_trophy2.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 2 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_malloc.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_malloc.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_malloc.h" 2 3

extern "C" {



typedef struct SceLibcMallocManagedSize {
  unsigned short size;
  unsigned short version;
  unsigned int reserved1;
  size_t maxSystemSize;
  size_t currentSystemSize;
  size_t maxInuseSize;
  size_t currentInuseSize;
} SceLibcMallocManagedSize;


}
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 2 3
# 79 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
typedef struct
 {
 int quot;
 int rem;
 } div_t;


extern "C" {
void exit(int) __attribute__((__noreturn__));

void _Exit(int) noexcept __attribute__((__noreturn__));
}

extern "C" {
int abs(int);
long labs(long);





void abort(void) noexcept __attribute__((__noreturn__));
void *calloc(size_t, size_t);
void *malloc(size_t);

void *(memalign)(size_t boundary, size_t size_arg);

void free(void *);
void *realloc(void *, size_t);

void *aligned_alloc(size_t, size_t);


div_t div(int, int);
ldiv_t ldiv(long, long);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t *,
 const char *, size_t);
int mbtowc(wchar_t *, const char *, size_t);
int rand(void);
void srand(unsigned int);
long strtol(const char *, char **, int);
size_t wcstombs(char *,
 const wchar_t *, size_t);
int wctomb(char *, wchar_t);


void *reallocalign(void *ptr, size_t size, size_t boundary);
size_t malloc_usable_size(void *ptr);
int malloc_stats(SceLibcMallocManagedSize *);
int malloc_stats_fast(SceLibcMallocManagedSize *);



void lcong48(unsigned short [7]);
unsigned short *seed48(unsigned short [3]);
void srand48(long);

double drand48(void);
long lrand48(void);
long mrand48(void);

double erand48(unsigned short [3]);
long nrand48(unsigned short [3]);
long jrand48(unsigned short [3]);

int getopt(int, char *const *, const char *);
void *memalign(size_t, size_t);
int rand_r(unsigned *);

extern char *optarg;
extern int optind, opterr, optopt;



extern "C" {
extern float _Stofx(const char *, char **,
 long, int *);
extern double _Stodx(const char *, char **,
 long, int *);
extern long double _Stoldx(const char *, char **,
 long, int *);
extern long _Stolx(const char *, char **,
 int, int *);
extern unsigned long _Stoulx(const char *, char **,
 int, int *);
extern long long _Stollx(const char *, char **,
 int, int *);
extern unsigned long long _Stoullx(const char *, char **,
 int, int *);
}


unsigned long _Stoul(const char *, char **, int);
float _Stof(const char *, char **, long);
double _Stod(const char *, char **, long);
long double _Stold(const char *, char **, long);
_Longlong _Stoll(const char *, char **, int);
_ULonglong _Stoull(const char *, char **, int);

float _Stofx(const char *, char **, long, int *);
double _Stodx(const char *, char **, long, int *);
long double _Stoldx(const char *, char **, long, int *);
long _Stolx(const char *, char **, int, int *);
unsigned long _Stoulx(const char *, char **, int, int *);
_Longlong _Stollx(const char *, char **, int, int *);
_ULonglong _Stoullx(const char *, char **, int, int *);

size_t _Getmbcurmax(void);


_Longlong llabs(_Longlong);
lldiv_t lldiv(_Longlong, _Longlong);
_Longlong strtoll(const char *,
 char **, int);
_ULonglong strtoull(const char *,
 char **, int);


int at_quick_exit(void (*)(void)) noexcept;
void quick_exit(int) noexcept __attribute__((__noreturn__));


int getargc(void);
char **getargv(void);


}


extern "C" {
typedef void _Atexfun(void);
typedef int _Cmpfun(const void *, const void *);

int atexit(void (*)(void)) noexcept;
void *bsearch(const void *, const void *,
 size_t, size_t, _Cmpfun *);
void qsort(void *, size_t, size_t, _Cmpfun *);

}

extern "C++" {
# 248 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {

double atof(const char *_Str);

inline int atoi(const char *_Str)
 {
 return ((int):: _Stoul(_Str, 0, 10));
 }

inline long atol(const char *_Str)
 {
 return ((long):: _Stoul(_Str, 0, 10));
 }
# 269 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
double strtod(const char * _Str,
 char ** _Endptr);

inline unsigned long strtoul(const char * _Str,
 char ** _Endptr, int _Base)
 {
 return (:: _Stoul(_Str, _Endptr, _Base));
 }



inline _Longlong atoll(const char *_Str)
 {
 return ((_Longlong):: _Stoull(_Str, 0, 10));
 }

float strtof(const char * _Str,
 char ** _Endptr);

inline long double strtold(const char * _Str,
 char ** _Endptr)
 {
 return (:: _Stold(_Str, _Endptr, 0));
 }


}

}
# 338 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {


int (_Fail_s)(const char *, size_t);

typedef void (*constraint_handler_t)(const char *,
 void *, errno_t);

constraint_handler_t set_constraint_handler_s(
 constraint_handler_t);
void abort_handler_s(const char *,
 void *, errno_t);
void ignore_handler_s(const char *,
 void *, errno_t);

}


extern "C" {
typedef int _Cmpfun_s(const void *, const void *, void *);

void *bsearch_s(const void *, const void *,
 rsize_t, rsize_t, _Cmpfun_s *, void *);
errno_t qsort_s(void *,
 rsize_t, rsize_t, _Cmpfun_s *, void *);
}

extern "C++" {
# 382 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
}
# 395 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {
errno_t wctomb_s(int *,
 char *, rsize_t,
 wchar_t);
errno_t mbstowcs_s(size_t *,
 wchar_t *, rsize_t,
 const char *, rsize_t);
errno_t wcstombs_s(size_t *,
 char *, rsize_t,
 const wchar_t *, rsize_t);
}



extern "C++" {

template<rsize_t _Size>
errno_t mbstowcs_s(size_t *_Psize, wchar_t (&_Wcs)[_Size], const char *_Str, rsize_t _Num)
 {
 return mbstowcs_s(_Psize, _Wcs, _Size, _Str, _Num);
 }

template<rsize_t _Size>
errno_t wcstombs_s(size_t *_Psize, char (&_Str)[_Size], const wchar_t *_Wcs, rsize_t _Num)
 {
 return wcstombs_s(_Psize, _Str, _Size, _Wcs, _Num);
 }

template<rsize_t _Size>
errno_t wctomb_s(int *_Pstat, char (&_Str)[_Size], wchar_t _Wc)
 {
 return wctomb_s(_Pstat, _Str, _Size, _Wc);
 }

}
# 440 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {

extern size_t sceLibcHeapSize;
extern unsigned int sceLibcHeapDelayedAlloc;
extern unsigned int sceLibcHeapExtendedAlloc;
extern size_t sceLibcHeapInitialSize;
extern size_t sceLibcHeapHighAddressAlloc;
extern unsigned int sceLibcHeapMemoryLock;
extern unsigned int sceLibcHeapDebugFlags;

}
# 543 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {






int posix_memalign(void **, size_t, size_t);
# 572 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_rtc.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_rtc.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_rtc.h" 2 3

typedef struct SceRtcTick {
 uint64_t tick;
} SceRtcTick;
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 2 3


extern "C" {
# 110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
typedef struct SceRtcDateTime {
 unsigned short year;
 unsigned short month;
 unsigned short day;
 unsigned short hour;
 unsigned short minute;
 unsigned short second;
 unsigned int microsecond;
} SceRtcDateTime;
# 127 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
int sceRtcGetCurrentTick(SceRtcTick *pTick);




int sceRtcGetCurrentClock(SceRtcDateTime *pTime, int iTimeZone);



int sceRtcGetCurrentClockLocalTime(SceRtcDateTime *pTime);




int sceRtcGetCurrentNetworkTick(SceRtcTick *pTick);



int sceRtcConvertUtcToLocalTime(const SceRtcTick *pUtc, SceRtcTick *pLocalTime);



int sceRtcConvertLocalTimeToUtc(const SceRtcTick *pLocalTime, SceRtcTick *pUtc);



int sceRtcIsLeapYear(int year);



int sceRtcGetDaysInMonth(int year, int month);
# 168 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
int sceRtcGetDayOfWeek(int year, int month, int day);



int sceRtcCheckValid(const SceRtcDateTime *pTime);
# 182 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
int sceRtcSetTime_t(SceRtcDateTime *pTime, time_t llTime);




int sceRtcGetTime_t(const SceRtcDateTime *pTime, time_t *pllTime);







int sceRtcSetDosTime(SceRtcDateTime *pTime, unsigned int uiDosTime);




int sceRtcGetDosTime(const SceRtcDateTime *pTime, unsigned int *puiDosTime);




int sceRtcSetWin32FileTime(SceRtcDateTime *pTime, uint64_t ulWin32Time);




int sceRtcGetWin32FileTime(const SceRtcDateTime *pTime, uint64_t *ulWin32Time);







int sceRtcSetTick(SceRtcDateTime *pTime, const SceRtcTick *pTick);




int sceRtcGetTick(const SceRtcDateTime *pTime, SceRtcTick *pTick);



unsigned int sceRtcGetTickResolution(void);







int sceRtcTickAddTicks(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddMicroseconds(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddSeconds(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddMinutes(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddHours(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddDays(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddWeeks(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddMonths(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddYears(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);
# 268 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
int sceRtcFormatRFC2822(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes);



int sceRtcFormatRFC2822LocalTime(char *pszDateTime, const SceRtcTick *pUtc);



int sceRtcFormatRFC3339(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes);



int sceRtcFormatRFC3339LocalTime(char *pszDateTime, const SceRtcTick *pUtc);



int sceRtcFormatRFC3339Precise(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes, unsigned int secfrac);



int sceRtcFormatRFC3339PreciseLocalTime(char *pszDateTime, const SceRtcTick *pUtc, unsigned int secfrac);



int sceRtcParseDateTime(SceRtcTick *pUtc, const char *pszDateTime);



int sceRtcParseRFC3339(SceRtcTick *pUtc, const char *pszDateTime);





static __inline__ int sceRtcSetYear(SceRtcDateTime *pTime, int year);
static __inline__ int sceRtcSetMonth(SceRtcDateTime *pTime, int month);
static __inline__ int sceRtcSetDay(SceRtcDateTime *pTime, int day);
static __inline__ int sceRtcSetHour(SceRtcDateTime *pTime, int hour);
static __inline__ int sceRtcSetMinute(SceRtcDateTime *pTime, int minute);
static __inline__ int sceRtcSetSecond(SceRtcDateTime *pTime, int second);
static __inline__ int sceRtcSetMicrosecond(SceRtcDateTime *pTime, int microsecond);

static __inline__ int sceRtcGetYear(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMonth(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetDay(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetHour(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMinute(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetSecond(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMicrosecond(const SceRtcDateTime *pTime);



static __inline__ int sceRtcSetYear(SceRtcDateTime *pTime, int year)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (year<1 || year>9999) {
  return (-2135621624);
 }

 pTime->year = static_cast<unsigned short>(year);



 return (0);
}



static __inline__ int sceRtcSetMonth(SceRtcDateTime *pTime, int month)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (month<1 || month>12) {
  return (-2135621623);
 }

 pTime->month = static_cast<unsigned short>(month);



 return (0);
}



static __inline__ int sceRtcSetDay(SceRtcDateTime *pTime, int day)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (day<1 || day>31) {
  return (-2135621622);
 }

 pTime->day = static_cast<unsigned short>(day);



 return (0);
}



static __inline__ int sceRtcSetHour(SceRtcDateTime *pTime, int hour)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (hour<0 || hour>23) {
  return (-2135621621);
 }

 pTime->hour = static_cast<unsigned short>(hour);



 return (0);
}



static __inline__ int sceRtcSetMinute(SceRtcDateTime *pTime, int minute)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (minute<0 || minute>59) {
  return (-2135621620);
 }

 pTime->minute = static_cast<unsigned short>(minute);



 return (0);
}



static __inline__ int sceRtcSetSecond(SceRtcDateTime *pTime, int second)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (second<0 || second>59) {
  return (-2135621619);
 }

 pTime->second = static_cast<unsigned short>(second);



 return (0);
}



static __inline__ int sceRtcSetMicrosecond(SceRtcDateTime *pTime, int microsecond)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (microsecond<0 || microsecond>999999) {
  return (-2135621618);
 }

 pTime->microsecond = static_cast<unsigned int>(microsecond);



 return (0);
}



static __inline__ int sceRtcGetYear(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->year);
}



static __inline__ int sceRtcGetMonth(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->month);
}



static __inline__ int sceRtcGetDay(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->day);
}



static __inline__ int sceRtcGetHour(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->hour);
}



static __inline__ int sceRtcGetMinute(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->minute);
}



static __inline__ int sceRtcGetSecond(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->second);
}



static __inline__ int sceRtcGetMicrosecond(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }

 return static_cast<int>(pTime->microsecond);



}



}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_trophy2.h" 2 3


extern "C" {
# 42 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_trophy2.h" 3
typedef int32_t SceNpTrophy2Handle;
typedef int32_t SceNpTrophy2Context;
typedef int32_t SceNpTrophy2Id;
typedef int32_t SceNpTrophy2GroupId;
typedef int32_t SceNpTrophy2Grade;
typedef int32_t SceNpTrophy2ProgressType;

typedef void (*SceNpTrophy2UnlockCallback)(
 SceNpTrophy2Context context,
 SceNpTrophy2Id trophyId,
 void *userdata
);







typedef struct SceNpTrophy2Progress {
 SceNpTrophy2ProgressType type;
 uint8_t reserved[4];
 union {
  uint64_t valueUInt64;
 } value;
} SceNpTrophy2Progress;

typedef struct SceNpTrophy2GameDetails {
 uint32_t numGroups;
 uint32_t numTrophies;
 uint32_t numPlatinum;
 uint32_t numGold;
 uint32_t numSilver;
 uint32_t numBronze;
 char title[(128)];
} SceNpTrophy2GameDetails;

typedef struct SceNpTrophy2GameData {
 uint32_t unlockedTrophies;
 uint32_t unlockedPlatinum;
 uint32_t unlockedGold;
 uint32_t unlockedSilver;
 uint32_t unlockedBronze;
 uint32_t progressPercentage;
} SceNpTrophy2GameData;

typedef struct SceNpTrophy2GroupDetails {
 SceNpTrophy2GroupId groupId;
 uint32_t numTrophies;
 uint32_t numPlatinum;
 uint32_t numGold;
 uint32_t numSilver;
 uint32_t numBronze;
 char title[(128)];
} SceNpTrophy2GroupDetails;

typedef struct SceNpTrophy2GroupData {
 SceNpTrophy2GroupId groupId;
 uint32_t unlockedTrophies;
 uint32_t unlockedPlatinum;
 uint32_t unlockedGold;
 uint32_t unlockedSilver;
 uint32_t unlockedBronze;
 uint32_t progressPercentage;
 uint8_t reserved[4];
} SceNpTrophy2GroupData;

typedef struct SceNpTrophy2Details {
 SceNpTrophy2Id trophyId;
 SceNpTrophy2Grade trophyGrade;
 SceNpTrophy2GroupId groupId;
 bool hidden;
 bool hasReward;
 uint8_t reserved2[2];
 SceNpTrophy2Progress target;
 char name[(128)];
 char description[(1024)];
 char reward[(128)];
} SceNpTrophy2Details;

typedef struct SceNpTrophy2Data {
 SceNpTrophy2Id trophyId;
 bool unlocked;
 uint8_t reserved[3];
 SceNpTrophy2Progress progress;
 SceRtcTick timestamp;
} SceNpTrophy2Data;


int sceNpTrophy2CreateHandle(
 SceNpTrophy2Handle *handle
 );

int sceNpTrophy2DestroyHandle(
 SceNpTrophy2Handle handle
 );

int sceNpTrophy2AbortHandle(
 SceNpTrophy2Handle handle
 );

int sceNpTrophy2CreateContext(
 SceNpTrophy2Context *context,
 SceUserServiceUserId userId,
 SceNpServiceLabel serviceLabel,
 uint64_t options
 );

int sceNpTrophy2DestroyContext(
 SceNpTrophy2Context context
 );

int sceNpTrophy2RegisterContext(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 uint64_t options
 );

int sceNpTrophy2RegisterUnlockCallback(
 SceNpTrophy2UnlockCallback callback,
 void *userdata
 );

int sceNpTrophy2UnregisterUnlockCallback(
 void
 );

int sceNpTrophy2GetGameInfo(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 SceNpTrophy2GameDetails *details,
 SceNpTrophy2GameData *data
 );

int sceNpTrophy2GetGroupInfo(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 SceNpTrophy2GroupId groupId,
 SceNpTrophy2GroupDetails *details,
 SceNpTrophy2GroupData *data
 );

int sceNpTrophy2GetGroupInfoArray(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 uint32_t offset,
 uint32_t limit,
 SceNpTrophy2GroupDetails *detailsArray,
 SceNpTrophy2GroupData *dataArray,
 uint32_t *count
 );

int sceNpTrophy2GetTrophyInfo(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 SceNpTrophy2Id trophyId,
 SceNpTrophy2Details *details,
 SceNpTrophy2Data *data
 );

int sceNpTrophy2GetTrophyInfoArray(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 uint32_t offset,
 uint32_t limit,
 SceNpTrophy2Details *detailsArray,
 SceNpTrophy2Data *dataArray,
 uint32_t *count
 );

int sceNpTrophy2GetGameIcon(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 void *buffer,
 size_t *size
 );

int sceNpTrophy2GetGroupIcon(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 SceNpTrophy2GroupId groupId,
 void *buffer,
 size_t *size
 );

int sceNpTrophy2GetTrophyIcon(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 SceNpTrophy2Id trophyId,
 void *buffer,
 size_t *size
 );

int sceNpTrophy2GetRewardIcon(
 SceNpTrophy2Context context,
 SceNpTrophy2Handle handle,
 SceNpTrophy2Id trophyId,
 void *buffer,
 size_t *size
 );

int sceNpTrophy2ShowTrophyList(
 SceNpTrophy2Context context
 );


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_session_signaling.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_session_signaling.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 1 3
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/__Mbstatet.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/__Mbstatet.h" 2 3





typedef struct _Mbstatet
 {
 unsigned long _Wchar;
 unsigned short _Byte, _State;
 int :32;


 _Mbstatet()
  : _Wchar(0), _Byte(0), _State(0)
  {
  }

 _Mbstatet(const _Mbstatet& _Right)
  : _Wchar(_Right._Wchar), _Byte(_Right._Byte),
   _State(_Right._State)
  {
  }

 _Mbstatet& operator=(const _Mbstatet& _Right)
  {
  _Wchar = _Right._Wchar;
  _Byte = _Right._Byte;
  _State = _Right._State;
  return (*this);
  }

 } _Mbstatet;
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_filet.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_filet.h" 2 3





typedef struct __sFILE _Filet;
# 58 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_eof.h" 1 3
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3





typedef struct fpos_t
 {
 long _Off;
 _Mbstatet _Wstate;
 } fpos_t;
# 82 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 146 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
typedef struct __sFILE {



 unsigned short _Mode;
 unsigned char _Idx;
 signed int _Handle;

 unsigned char *_Buf, *_Bend, *_Next;
 unsigned char *_Rend, *_Wend, *_Rback;

 _Wchart *_WRback, _WBack[2];
 unsigned char *_Rsave, *_WRend, *_WWend;

 _Mbstatet _Wstate;
 char *_Tmpnam;
 unsigned char _Back[6], _Cbuf;
 void *_Mutex;


 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read)(void *, char *, int);
 fpos_t (*_seek)(void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 unsigned char *_up;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;

 struct pthread_mutex *_fl_mutex;
 struct pthread *_fl_owner;
 int _fl_count;
 int _orientation;
 __mbstate_t _mbstate;
} FILE;
# 248 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
extern "C" {
extern FILE _Stdin, _Stdout, _Stderr;

void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);
FILE *fopen(const char *, const char *);





int fprintf(FILE *, const char *, ...);
int fputc(int, FILE *);
int fputs(const char *, FILE *);
size_t fread(void *, size_t, size_t, FILE *);
FILE *freopen(const char *, const char *,
 FILE *);





int fscanf(FILE * , const char *, ...);
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void *, size_t, size_t,
 FILE *);
char *gets(char *);
void perror(const char *);





int printf(const char *, ...);
int puts(const char *);






int remove(const char *);
int rename(const char *, const char *);


void rewind(FILE *);





int scanf(const char *, ...);
void setbuf(FILE * , char *);
int setvbuf(FILE * , char *, int, size_t);





int sprintf(char *, const char *, ...);





int sscanf(const char *, const char *, ...);
int ungetc(int, FILE *);
int vfprintf(FILE *, const char *, _Va_list);
int vprintf(const char *, _Va_list);
int vsprintf(char *, const char *, _Va_list);


FILE *fdopen(signed int, const char *);
int fileno(FILE *);

int getw(FILE *);
int putw(int, FILE *);


long _Fgpos(FILE *, fpos_t *);
int _Flocale(FILE *, const char *, int);
void _Fsetlocale(FILE *, int);
int _Fspos(FILE *, const fpos_t *, long, int);


void _Lockfilelock(_Filet *);
void _Unlockfilelock(_Filet *);


extern FILE *_Files[256];







int snprintf(char *, size_t,
 const char *, ...);
int vsnprintf(char *, size_t,
 const char *, _Va_list);
int vfscanf(FILE *,
 const char *, _Va_list);
int vscanf(const char *, _Va_list);
int vsscanf(const char *,
 const char *, _Va_list);
# 378 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
}



extern "C" {
int getc(FILE *);
int getchar(void);
int putc(int, FILE *);
int putchar(int);
}
# 452 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
extern "C" {

errno_t fopen_s(FILE * *,
 const char *, const char *);
errno_t freopen_s(FILE * *,
 const char *, const char *, FILE *);

int fprintf_s(FILE *, const char *, ...) __attribute__((format(printf, 2, 3)));
int fscanf_s(FILE *, const char *, ...);
int printf_s(const char *, ...) __attribute__((format(printf, 1, 2)));
int scanf_s(const char *, ...);
int snprintf_s(char *, rsize_t,
 const char *, ...) __attribute__((format(printf, 3, 4)));
int sscanf_s(const char *,
 const char *, ...);
int sprintf_s(char *, rsize_t,
 const char *, ...) __attribute__((format(printf, 3, 4)));
int vfprintf_s(FILE *,
 const char *,
 _Va_list);
int vfscanf_s(FILE *,
 const char *,
 _Va_list);
int vprintf_s(const char *,
 _Va_list);
int vscanf_s(const char *,
 _Va_list);
int vsnprintf_s(char *, rsize_t,
 const char *,
 _Va_list);
int vsprintf_s(char *, rsize_t,
 const char *,
 _Va_list);
int vsscanf_s(const char *,
 const char *,
 _Va_list);

char *gets_s(char *, rsize_t);
}



extern "C++" {

template<rsize_t _Size>
char *gets_s(char (&_Buf)[_Size])
 {
 return gets_s(_Buf, _Size);
 }

template<rsize_t _Size>
__attribute__((format(printf, 2, 3))) int sprintf_s(char (&_Buf)[_Size], const char *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vsnprintf_s(char (&_Buf)[_Size], const char *_Fmt, va_list _Ap)
 {
 return vsnprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
int vsprintf_s(char (&_Buf)[_Size], const char *_Fmt, va_list _Ap)
 {
 return vsprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
__attribute__((format(printf, 2, 3))) int snprintf_s(char (&_Buf)[_Size], const char *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

}
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 2 3
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef char SceChar8;
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef unsigned char SceUChar8;
# 57 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int8_t SceInt8;
# 67 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint8_t SceUInt8;
# 77 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int16_t SceShort16;
# 87 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint16_t SceUShort16;
# 97 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int16_t SceInt16;
# 107 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint16_t SceUInt16;
# 117 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int32_t SceInt32;
# 127 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint32_t SceUInt32;
# 137 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int SceInt;
# 147 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef unsigned int SceUInt;
# 203 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int64_t SceInt64;
typedef uint64_t SceUInt64;
typedef long SceLong;
typedef unsigned long SceULong;
typedef int64_t SceLong64;
typedef uint64_t SceULong64;
# 218 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef float SceFloat;
# 227 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef float SceFloat32;
# 236 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef double SceDouble;
# 245 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef double SceDouble64;
# 255 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef signed char SceSByte;
# 265 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef signed char SceSByte8;
# 275 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef unsigned char SceByte;
# 285 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef unsigned char SceByte8;
# 295 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint16_t SceWChar16;
# 305 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint32_t SceWChar32;
# 328 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int SceBool;
# 341 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef intptr_t SceIntPtr;
# 351 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uintptr_t SceUIntPtr;
# 361 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef void SceVoid;
# 371 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef void* ScePVoid;






typedef struct SceIVector2 {
 int x, y;
} SceIVector2;





typedef struct SceFVector2 {
 float x, y;
} SceFVector2;





typedef union SceUVector2 {
 SceIVector2 iv;
 SceFVector2 fv;
} SceUVector2;





typedef struct SceIVector3 {
 int x, y, z;
} SceIVector3;





typedef struct SceFVector3 {
 float x, y, z;
} SceFVector3;





typedef union SceUVector3 {
 SceIVector3 iv;
 SceFVector3 fv;
} SceUVector3;





typedef struct SceIVector4 {
 int x, y, z, w;
} SceIVector4;





typedef struct SceFVector4 {
 float x, y, z, w;
} SceFVector4;





typedef union SceUVector4 {
 SceIVector4 iv;
 SceFVector4 fv;
} SceUVector4;





typedef struct SceIMatrix2{
 SceIVector2 x, y;
} SceIMatrix2;





typedef struct SceFMatrix2{
 SceFVector2 x, y;
} SceFMatrix2;

typedef union SceUMatrix2 {
 SceFMatrix2 fm;
 SceIMatrix2 im;
 SceFVector2 fv[2];
 SceIVector2 iv[2];
 SceUVector2 uv[2];
 float f[2][2];
 int i[2][2];
# 483 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
} SceUMatrix2;






typedef struct SceIMatrix3 {
 SceIVector3 x, y, z;
} SceIMatrix3;





typedef struct SceFMatrix3 {
 SceFVector3 x, y, z;
} SceFMatrix3;





typedef union SceUMatrix3 {
 SceFMatrix3 fm;
 SceIMatrix3 im;
 SceFVector3 fv[3];
 SceIVector3 iv[3];
 SceUVector3 uv[3];
 float f[3][3];
 int i[3][3];
# 526 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
} SceUMatrix3;





typedef struct SceIMatrix4 {
 SceIVector4 x, y, z, w;
} SceIMatrix4;





typedef struct SceFMatrix4 {
 SceFVector4 x, y, z, w;
} SceFMatrix4;





typedef union SceUMatrix4 {
 SceFMatrix4 fm;
 SceIMatrix4 im;
 SceFVector4 fv[4];
 SceIVector4 iv[4];
 SceUVector4 uv[4];
 float f[4][4];
 int i[4][4];
# 570 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
} SceUMatrix4;






typedef struct SceFQuaternion {
 float x, y, z, w;
} SceFQuaternion;





typedef struct SceFColor {
 float r, g, b, a;
} SceFColor;
# 597 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef union SceUnion32 {
 unsigned int ui;
 int i;
 unsigned short us[2];
 short s[2];
 unsigned char uc[4];
 char c[4];
 float f;
} SceUnion32;
# 616 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef union SceUnion64 {
 SceULong64 ull;
 SceLong64 ll;
 unsigned int ui[2];
 int i[2];
 unsigned short us[4];
 short s[4];
 unsigned char uc[8];
 char c[8];
 float f[2];

 SceFVector2 fv;
 SceIVector2 iv;
 void *p;
} SceUnion64;
# 641 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef union SceUnion128 {

 SceULong64 ull[2];
 SceLong64 ll[2];
 unsigned int ui[4];
 int i[4];
 unsigned short us[8];
 short s[8];
 unsigned char uc[16];
 char c[16];
 float f[4];

 SceFVector4 fv;
 SceFQuaternion fq;
 SceFColor fc;
 SceIVector4 iv;
} SceUnion128;
# 668 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef union SceUnion512 {
 SceUnion32 un32[16];
 SceUnion64 un64[8];

 SceULong64 ull[8];
 SceLong64 ll[8];
 unsigned int ui[16];
 int i[16];
 unsigned short us[32];
 short s[32];
 unsigned char uc[64];
 char c[64];
 float f[16];

 SceFMatrix4 fm;
 SceIMatrix4 im;
 SceUMatrix4 um;

} SceUnion512;
# 697 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef struct SceDateTime {
 unsigned short year;
 unsigned short month;
 unsigned short day;
 unsigned short hour;
 unsigned short minute;
 unsigned short second;
 unsigned int microsecond;
} SceDateTime;
# 716 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef size_t SceSize;
# 726 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef SceSize ScePSize;
# 736 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef SceSize SceVSize;
# 746 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef ssize_t SceSSize;
# 756 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef SceSSize ScePSSize;
# 766 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef SceSSize SceVSSize;
# 777 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uintptr_t SceUIntVAddr;
# 794 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int SceUID;
# 816 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef char* SceName;
# 828 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef off_t SceOff;




typedef SceUID ScePID;
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sceerror.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_sce_ok.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sceerror.h" 2 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/nettypes.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/nettypes.h" 3
extern "C" {


typedef uint32_t SceNetInAddr_t;
typedef uint16_t SceNetInPort_t;
typedef uint8_t SceNetSaFamily_t;
typedef uint32_t SceNetSocklen_t;

typedef int SceNetId;




}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/epoll.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/epoll.h" 3
extern "C" {


typedef union SceNetEpollData {
 void *ptr;
 uint32_t u32;




} SceNetEpollData;

typedef struct SceNetEpollEvent {
 uint32_t events;





 uint32_t reserved;
 uint64_t ident;
 SceNetEpollData data;
} SceNetEpollEvent;
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/epoll.h" 3
SceNetId sceNetEpollCreate(const char *name, int flags);
int sceNetEpollControl(SceNetId eid, int op, SceNetId id,
 SceNetEpollEvent *event);
int sceNetEpollWait(SceNetId eid, SceNetEpollEvent *events,
 int maxevents, int timeout);
int sceNetEpollDestroy(SceNetId eid);
int sceNetEpollAbort(SceNetId eid, int flags);


}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/errno.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/errno.h" 3
extern "C" {
# 875 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/errno.h" 3
int *sceNetErrnoLoc(void);



}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/ether.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/ether.h" 3
extern "C" {





typedef struct SceNetEtherAddr {
 uint8_t data[6];
} SceNetEtherAddr;

int sceNetEtherStrton(const char *str, SceNetEtherAddr *n);
int sceNetEtherNtostr(const SceNetEtherAddr *n, char *str, size_t len);
int sceNetGetMacAddress(SceNetEtherAddr *addr, int flags);


}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/in.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/in.h" 3
extern "C" {


typedef struct SceNetInAddr {
 SceNetInAddr_t s_addr;
} SceNetInAddr;

typedef struct SceNetSockaddrIn {
 uint8_t sin_len;
 SceNetSaFamily_t sin_family;
 SceNetInPort_t sin_port;
 SceNetInAddr sin_addr;
 SceNetInPort_t sin_vport;
 char sin_zero[6];
} SceNetSockaddrIn;

typedef struct SceNetIpMreq {
 SceNetInAddr imr_multiaddr;
 SceNetInAddr imr_interface;
} SceNetIpMreq;
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/in.h" 3
}
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/dns.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/dns.h" 3
extern "C" {




typedef struct SceNetDnsInfo {
 SceNetInAddr dns_addr[2];
} SceNetDnsInfo;

int sceNetSetDnsInfo(SceNetDnsInfo *info, int flags);
int sceNetClearDnsCache(int flags);


}
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/netmain.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/netmain.h" 3
extern "C" {


typedef struct SceNetMemoryPoolStats{
  size_t poolSize;
  size_t maxInuseSize;
  size_t currentInuseSize;
  int32_t reserved;
} SceNetMemoryPoolStats;

int sceNetPoolCreate(const char *name, int size, int flags);
int sceNetPoolDestroy(int memid);
int sceNetGetMemoryPoolStats(int memid, SceNetMemoryPoolStats *stat);

int sceNetShowIfconfig(void);
int sceNetShowIfconfigWithMemory(int memid);
int sceNetShowRoute(void);
int sceNetShowRouteWithMemory(int memid);

int sceNetShowNetstat(void);
int sceNetShowNetstatWithMemory(int memid);
int sceNetShowPolicy(void);
int sceNetShowPolicyWithMemory(int memid);


}
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/inet.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/inet.h" 3
extern "C" {


const char *sceNetInetNtop(int af, const void *src, char *dst,
 SceNetSocklen_t size);
int sceNetInetPton(int af, const char *src, void *dst);

uint64_t sceNetHtonll(uint64_t host64);
uint32_t sceNetHtonl(uint32_t host32);
uint16_t sceNetHtons(uint16_t host16);
uint64_t sceNetNtohll(uint64_t net64);
uint32_t sceNetNtohl(uint32_t net32);
uint16_t sceNetNtohs(uint16_t net16);


}
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/netemu.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/netemu.h" 3
extern "C" {


typedef struct SceNetEmulationData {
 uint16_t drop_rate;
 uint16_t drop_duration;
 uint16_t pass_duration;
 uint16_t delay_time;
 uint16_t delay_jitter;
 uint16_t order_rate;
 uint16_t order_delay_time;
 uint16_t duplication_rate;
 uint32_t upper_bps_limit;
 uint32_t lower_bps_limit;
 uint16_t upper_bps_rate;
 uint16_t lower_bps_rate;
 uint16_t lower_size_limit;
 uint16_t upper_size_limit;
 uint8_t reserved[32];
} SceNetEmulationData;

typedef struct SceNetEmulationParam {
 uint16_t option_number;
 uint16_t result;
 uint32_t flags;

 uint32_t policy;
 uint32_t oflags;

 SceNetEmulationData send;
 SceNetEmulationData recv;
 uint32_t pid;
 uint8_t reserved[12];
} SceNetEmulationParam;

int sceNetEmulationSet(SceNetEmulationParam *param,
 int flags);
int sceNetEmulationGet(SceNetEmulationParam *param,
 int flags);


}
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/resolver.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/resolver.h" 3
extern "C" {






typedef union SceNetResolverAddrUn {
 SceNetInAddr addr;
 char reserved[16];
} SceNetResolverAddrUn;

typedef struct SceNetResolverAddr {
 SceNetResolverAddrUn un;
 int af;
 int reserved[3];
} SceNetResolverAddr;

typedef struct SceNetResolverInfo {
 SceNetResolverAddr addrs[10];
 int records;
 int dns4records;
 int reserved1;
 int reserved[13];
} SceNetResolverInfo;
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/resolver.h" 3
SceNetId sceNetResolverCreate(const char *name, int memid, int flags);
int sceNetResolverStartNtoa(SceNetId rid, const char *hostname,
 SceNetInAddr *addr, int timeout, int retry, int flags);
int sceNetResolverStartAton(SceNetId rid, const SceNetInAddr *addr,
 char *hostname, int len, int timeout, int retry, int flags);
int sceNetResolverStartNtoaMultipleRecords(SceNetId rid, const char *hostname,
 SceNetResolverInfo *info, int timeout, int retry, int flags);
int sceNetResolverGetError(SceNetId rid, int *result);
int sceNetResolverDestroy(SceNetId rid);
int sceNetResolverAbort(SceNetId rid, int flags);


}
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/sockaddr_storage.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/sockaddr_storage.h" 3
extern "C" {
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/sockaddr_storage.h" 3
typedef struct SceNetSockaddrStorage {
 SceUInt8 ss_len;
 SceNetSaFamily_t ss_family;
 SceChar8 __ss_pad1[((sizeof(SceInt64)) - sizeof(SceUInt8) - sizeof(SceNetSaFamily_t))];
 SceInt64 __ss_align;
 SceChar8 __ss_pad2[(128U - sizeof(SceUInt8) - sizeof(SceNetSaFamily_t) - ((sizeof(SceInt64)) - sizeof(SceUInt8) - sizeof(SceNetSaFamily_t)) - (sizeof(SceInt64)))];
} SceNetSockaddrStorage;


}
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/socket.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/socket.h" 3
extern "C" {
# 94 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/socket.h" 3
typedef struct SceNetLinger {
 int l_onoff;
 int l_linger;
} SceNetLinger;

typedef struct SceNetSockaddr {
 uint8_t sa_len;
 SceNetSaFamily_t sa_family;
 char sa_data[14];
} SceNetSockaddr;

typedef struct SceNetIovec {
 void *iov_base;
 size_t iov_len;
} SceNetIovec;

typedef struct SceNetMsghdr {
 void *msg_name;
 SceNetSocklen_t msg_namelen;
 SceNetIovec *msg_iov;
 int msg_iovlen;
 void *msg_control;
 SceNetSocklen_t msg_controllen;
 int msg_flags;
} SceNetMsghdr;

typedef struct SceNetUdpSndOnSuspend {
 int onoff;
 SceNetSockaddr *addr;
 SceNetSocklen_t addrlen;

 void *data;
 SceNetSocklen_t datalen;
} SceNetUdpSndOnSuspend;
# 147 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/socket.h" 3
SceNetId sceNetSocket(const char *name, int domain, int type, int protocol);
SceNetId sceNetAccept(SceNetId s, SceNetSockaddr *addr,
 SceNetSocklen_t *addrlen);
int sceNetBind(SceNetId s, const SceNetSockaddr *addr,
 SceNetSocklen_t addrlen);
int sceNetConnect(SceNetId s, const SceNetSockaddr *name,
 SceNetSocklen_t namelen);
int sceNetGetpeername(SceNetId s, SceNetSockaddr *name,
 SceNetSocklen_t *namelen);
int sceNetGetsockname(SceNetId s, SceNetSockaddr *name,
 SceNetSocklen_t *namelen);
int sceNetGetsockopt(SceNetId s, int level, int optname, void *optval,
 SceNetSocklen_t *optlen);
int sceNetListen(SceNetId s, int backlog);
int sceNetRecv(SceNetId s, void *buf, size_t len, int flags);
int sceNetRecvfrom(SceNetId s, void *buf, size_t len, int flags,
 SceNetSockaddr *from, SceNetSocklen_t *fromlen);
int sceNetRecvmsg(SceNetId s, SceNetMsghdr *msg, int flags);
int sceNetSend(SceNetId s, const void *msg, size_t len, int flags);
int sceNetSendto(SceNetId s, const void *msg, size_t len, int flags,
 const SceNetSockaddr *to, SceNetSocklen_t tolen);
int sceNetSendmsg(SceNetId s, const SceNetMsghdr *msg, int flags);
int sceNetSetsockopt(SceNetId s, int level, int optname, const void *optval,
 SceNetSocklen_t optlen);
int sceNetShutdown(SceNetId s, int how);
int sceNetSocketClose(SceNetId s);
int sceNetSocketAbort(SceNetId s, int flags);


}
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/sockinfo.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/sockinfo.h" 3
extern "C" {


typedef struct SceNetSockInfo {
 char name[31 + 1];
 SceUID pid;
 SceNetId s;
 int8_t socket_type;
 int8_t policy;
 int8_t priority;
 int8_t reserved8;
 int recv_queue_length;
 int send_queue_length;
 SceNetInAddr local_adr;
 SceNetInAddr remote_adr;
 SceNetInPort_t local_port;
 SceNetInPort_t remote_port;
 SceNetInPort_t local_vport;
 SceNetInPort_t remote_vport;
 int state;
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/sockinfo.h" 3
 int flags;
# 61 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/sockinfo.h" 3
 int tx_bps;
 int rx_bps;
 int max_tx_bps;
 int max_rx_bps;
 int tx_vbps;
 int rx_vbps;
 int recv_buffer_size;
 int send_buffer_size;
 int reserved6[8];
 int tx_drops;
 int rx_drops;
 int tx_wait;
 int reserved[2];
} SceNetSockInfo;




int sceNetGetSockInfo(SceNetId s, SceNetSockInfo *info, int n, int flags);


}
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/statistics.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/statistics.h" 3
extern "C" {


typedef struct SceNetStatisticsInfo {

 int kernel_mem_free_size;
 int kernel_mem_free_min;
 int packet_count;
 int packet_qos_count;

 int libnet_mem_free_size;
 int libnet_mem_free_min;
} SceNetStatisticsInfo;

typedef struct SceNetInterfaceStats {
 uint64_t tx_bytes;
 uint64_t rx_bytes;
 uint32_t reserved[12];
} SceNetInterfaceStats;

int sceNetGetStatisticsInfo(SceNetStatisticsInfo *info, int flags);
int sceNetGetInterfaceStats(SceNetInterfaceStats *stats, int flags);


}
# 29 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/header/icmp.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/header/icmp.h" 3
extern "C" {


typedef struct SceNetIcmpHeaderEcho {
 uint16_t id;
 uint16_t sequence;
} SceNetIcmpHeaderEcho;

typedef struct SceNetIcmpHeaderFrag {
 uint16_t unused;
 uint16_t mtu;
} SceNetIcmpHeaderFrag;

typedef union SceNetIcmpHeaderUnion {
 SceNetIcmpHeaderEcho echo;
 unsigned int gateway;
 SceNetIcmpHeaderFrag frag;
} SceNetIcmpHeaderUnion;

typedef struct SceNetIcmpHeader {
 uint8_t type;
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/header/icmp.h" 3
 uint8_t code;
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/header/icmp.h" 3
 uint16_t checksum;
 SceNetIcmpHeaderUnion un;
} SceNetIcmpHeader;


}
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/header/ip.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnet/header/ip.h" 3
extern "C" {


typedef struct SceNetIpHeaderIpVerHl {




 uint8_t hl:4;
 uint8_t ver:4;

} SceNetIpHeaderIpVerHl;

typedef union SceNetIpHeaderUnion {
 SceNetIpHeaderIpVerHl ip_ver_hl;
 uint8_t ver_hl;
} SceNetIpHeaderUnion;

typedef struct SceNetIpHeader {
 SceNetIpHeaderUnion un;

 uint8_t ip_tos;
 uint16_t ip_len;
 uint16_t ip_id;
 uint16_t ip_off;




 uint8_t ip_ttl;
 uint8_t ip_p;
 uint16_t ip_sum;
 SceNetInAddr ip_src;
 SceNetInAddr ip_dst;
} SceNetIpHeader;


}
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\net.h" 2 3


extern "C" {



}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_session_signaling.h" 2 3


extern "C" {
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_session_signaling.h" 3
typedef uint32_t SceNpSessionSignalingContextId;
typedef uint32_t SceNpSessionSignalingRequestId;
typedef uint32_t SceNpSessionSignalingGroupId;
typedef uint32_t SceNpSessionSignalingConnectionId;

typedef struct SceNpSessionSignalingInitParam {
 int libhttp2CtxId;
 size_t poolSize;
 SceKernelCpumask cpuAffinityMask;
 int32_t threadPriority;
 size_t threadStackSize;
} SceNpSessionSignalingInitParam;

typedef enum SceNpSessionSignalingRequestEvent {
 SCE_NP_SESSION_SIGNALING_REQUEST_EVENT_PREPARE
} SceNpSessionSignalingRequestEvent;

typedef void(*SceNpSessionSignalingRequestCallback)(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingRequestId reqId,
 SceNpSessionSignalingRequestEvent event,
 const void *eventData,
 int errorCode,
 void *arg
 );

typedef enum SceNpSessionSignalingGroupEvent {
 SCE_NP_SESSION_SIGNALING_GROUP_EVENT_ACTIVATED,
 SCE_NP_SESSION_SIGNALING_GROUP_EVENT_ACTIVATE_ERROR,
 SCE_NP_SESSION_SIGNALING_GROUP_EVENT_PEER_ACTIVATED
} SceNpSessionSignalingGroupEvent;

typedef void(*SceNpSessionSignalingGroupCallback)(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingGroupId grpId,
 SceNpSessionSignalingGroupEvent event,
 const void *eventData,
 int errorCode,
 void *arg
 );

typedef enum SceNpSessionSignalingConnectionEvent {
 SCE_NP_SESSION_SIGNALING_CONNECTION_EVENT_DEAD,
 SCE_NP_SESSION_SIGNALING_CONNECTION_EVENT_ESTABLISHED,
 SCE_NP_SESSION_SIGNALING_CONNECTION_EVENT_ACTIVATED,
} SceNpSessionSignalingConnectionEvent;

typedef void(*SceNpSessionSignalingConnectionCallback2)(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingGroupId grpId,
 SceNpSessionSignalingConnectionId connId,
 SceNpSessionSignalingConnectionEvent event,
 int errorCode,
 void *arg
 );

typedef struct SceNpSessionSignalingCreateContext2Param {
 SceUserServiceUserId userId;
 SceNpServiceLabel serviceLabel;
 SceNpSessionSignalingRequestCallback reqCbFunc;
 void *reqCbArg;
 SceNpSessionSignalingGroupCallback grpCbFunc;
 void *grpCbArg;
 SceNpSessionSignalingConnectionCallback2 connCbFunc;
 void *connCbArg;
} SceNpSessionSignalingCreateContext2Param;

typedef enum SceNpSessionSignalingSessionType {
 SCE_NP_SESSION_SIGNALING_SESSION_TYPE_PLAYER_SESSION,
 SCE_NP_SESSION_SIGNALING_SESSION_TYPE_GAME_SESSION
} SceNpSessionSignalingSessionType;

typedef enum SceNpSessionSignalingTopologyType {
 SCE_NP_SESSION_SIGNALING_TOPOLOGY_TYPE_MESH = 1,
 SCE_NP_SESSION_SIGNALING_TOPOLOGY_TYPE_STAR = 2
} SceNpSessionSignalingTopologyType;

typedef enum SceNpSessionSignalingHostType {
 SCE_NP_SESSION_SIGNALING_HOST_TYPE_NONE = 0,
 SCE_NP_SESSION_SIGNALING_HOST_TYPE_AUTO = 1,
 SCE_NP_SESSION_SIGNALING_HOST_TYPE_ME = 2
} SceNpSessionSignalingHostType;

typedef struct SceNpSessionSignalingSessionOptParam {
 SceNpSessionSignalingTopologyType topologyType;
 SceNpSessionSignalingHostType hostType;
} SceNpSessionSignalingSessionOptParam;

typedef enum SceNpSessionSignalingConnectionInfoCode {
 SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_RTT = 1,
 SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_NET_ADDRESS = 4,
 SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_MAPPED_ADDRESS = 5,
 SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_PACKET_LOSS = 6,
 SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_PEER_ADDRESS = 7,
 SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_PEER_NAT_STATUS = 8
} SceNpSessionSignalingConnectionInfoCode;

typedef struct SceNpSessionSignalingConnectionList {
 SceNpSessionSignalingConnectionId connId[(64)];
 size_t connIdNum;
} SceNpSessionSignalingConnectionList;

typedef union SceNpSessionSignalingConnectionInfo {
 uint32_t rtt;
 SceNpPeerAddressA peerAddrA;
 struct {
  SceNetInAddr addr;
  SceNetInPort_t port;
  uint8_t padding[2];
 } address;
 uint32_t packetLoss;
 int peerNatStatus;
} SceNpSessionSignalingConnectionInfo;

typedef enum SceNpSessionSignalingConnectionStatus {
 SCE_NP_SESSION_SIGNALING_CONNECTION_STATUS_INACTIVE,
 SCE_NP_SESSION_SIGNALING_CONNECTION_STATUS_PENDING,
 SCE_NP_SESSION_SIGNALING_CONNECTION_STATUS_ACTIVE
} SceNpSessionSignalingConnectionStatus;
# 153 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_session_signaling.h" 3
typedef struct SceNpSessionSignalingNetInfo {
 SceNetInAddr localAddr;
 SceNetInAddr mappedAddr;
 int natStatus;
 int stunStatus;
} SceNpSessionSignalingNetInfo;

typedef struct SceNpSessionSignalingConnectionStatistics {
 uint32_t maxConnection;
 uint32_t totalConnection;
 uint32_t connecting;
 uint32_t connected;
} SceNpSessionSignalingConnectionStatistics;

typedef struct SceNpSessionSignalingMemoryInfo {
 size_t totalMemSize;
 size_t curMemUsage;
 size_t maxMemUsage;
 uint8_t reserved[12];
} SceNpSessionSignalingMemoryInfo;


int sceNpSessionSignalingInitialize(
 const SceNpSessionSignalingInitParam *param
);

int sceNpSessionSignalingTerminate(
 void
);

int sceNpSessionSignalingCreateContext2(
 const SceNpSessionSignalingCreateContext2Param *param,
 SceNpSessionSignalingContextId *ctxId
);

int sceNpSessionSignalingRequestPrepare(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingRequestId *reqId
);

int sceNpSessionSignalingDestroyContext(
 SceNpSessionSignalingContextId ctxId
);

int sceNpSessionSignalingActivateUser(
 SceNpSessionSignalingContextId ctxId,
 const SceNpPeerAddressA *peerAddrA,
 SceNpSessionSignalingGroupId *grpId
);

int sceNpSessionSignalingActivateSession(
 SceNpSessionSignalingContextId ctxId,
 const char *sessionId,
 SceNpSessionSignalingSessionType sessionType,
 const SceNpSessionSignalingSessionOptParam *optParam,
 SceNpSessionSignalingGroupId *grpId
);

int sceNpSessionSignalingDeactivate(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingGroupId grpId
);

int sceNpSessionSignalingGetGroupInfo(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingGroupId grpId,
 SceNpSessionSignalingConnectionList *connList
);

int sceNpSessionSignalingGetConnectionInfo(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingConnectionId connId,
 SceNpSessionSignalingConnectionInfoCode code,
 SceNpSessionSignalingConnectionInfo *info
);

int sceNpSessionSignalingGetConnectionStatus(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingConnectionId connId,
 SceNpSessionSignalingConnectionStatus *connectionStatus,
 SceNetInAddr *peerAddr,
 SceNetInPort_t *peerPort
);

int sceNpSessionSignalingGetConnectionFromPeerAddress2(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingGroupId grpId,
 const SceNpPeerAddressA *peerAddrA,
 SceNpSessionSignalingConnectionId *connId
);

int sceNpSessionSignalingGetConnectionFromNetAddress2(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingGroupId grpId,
 SceNetInAddr peerAddr,
 SceNetInPort_t peerPort,
 SceNpSessionSignalingConnectionList *connList
);

int sceNpSessionSignalingGetGroupFromPeerAddress(
 SceNpSessionSignalingContextId ctxId,
 const SceNpPeerAddressA *peerAddrA,
 SceNpSessionSignalingGroupId* grpId
);

int sceNpSessionSignalingGetGroupFromSessionId(
 SceNpSessionSignalingContextId ctxId,
 const char* sessionId,
 SceNpSessionSignalingGroupId* grpId
);

int sceNpSessionSignalingGetLocalNetInfo(
 SceNpSessionSignalingContextId ctxId,
 SceNpSessionSignalingNetInfo *info
);

int sceNpSessionSignalingGetConnectionStatistics(
 SceNpSessionSignalingConnectionStatistics *stats
);

int sceNpSessionSignalingGetMemoryInfo(
 SceNpSessionSignalingMemoryInfo *memInfo
);


}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_bandwidth_test.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_bandwidth_test.h" 3
typedef struct SceNpBandwidthTestInitParam {
 size_t size;
 int threadPriority;
 char padding[4];
 SceKernelCpumask cpuAffinityMask;

 uint32_t reserved[8];
} SceNpBandwidthTestInitParam;

typedef struct SceNpBandwidthTestResult {
 double uploadBps;
 double downloadBps;
 int result;
 uint8_t padding[4];
} SceNpBandwidthTestResult;






extern "C" {


int sceNpBandwidthTestInitStartUpload(const SceNpBandwidthTestInitParam* param, uint32_t timeOutInUsec);
int sceNpBandwidthTestInitStartDownload(const SceNpBandwidthTestInitParam* param, uint32_t timeOutInUsec);
int sceNpBandwidthTestGetStatus(int contextId, int *status);
int sceNpBandwidthTestShutdown(int contextId, SceNpBandwidthTestResult *result);
int sceNpBandwidthTestAbort(int contextId);


}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2_error.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2_push_event.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2_push_event.h" 3
extern "C" {
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2_push_event.h" 3
typedef struct SceNpWebApi2PushEventDataType {
 char val[64 + 1];
} SceNpWebApi2PushEventDataType;


typedef struct SceNpWebApi2PushEventExtdDataKey {
 char val[32 + 1];
} SceNpWebApi2PushEventExtdDataKey;

typedef struct SceNpWebApi2PushEventFilterParameter {
 SceNpWebApi2PushEventDataType dataType;
 SceNpWebApi2PushEventExtdDataKey *pExtdDataKey;
 size_t extdDataKeyNum;
} SceNpWebApi2PushEventFilterParameter;

typedef struct SceNpWebApi2PushEventExtdData {
 SceNpWebApi2PushEventExtdDataKey extdDataKey;
 char *pData;
 size_t dataLen;
} SceNpWebApi2PushEventExtdData;



typedef void(*SceNpWebApi2PushEventCallback)(
 int32_t userCtxId,
 int32_t callbackId,
 const char *pNpServiceName,
 SceNpServiceLabel npServiceLabel,
 const SceNpPeerAddressA *pTo,
 const SceNpOnlineId *pToOnlineId,
 const SceNpPeerAddressA *pFrom,
 const SceNpOnlineId *pFromOnlineId,
 const SceNpWebApi2PushEventDataType *pDataType,
 const char *pData,
 size_t dataLen,
 const SceNpWebApi2PushEventExtdData *pExtdData,
 size_t extdDataNum,
 void *pUserArg
 );

typedef enum SceNpWebApi2PushEventPushContextCallbackType {
 SCE_NP_WEBAPI2_PUSH_EVENT_PUSH_CONTEXT_CALLBACK_TYPE_UNKNOWN = -1,
 SCE_NP_WEBAPI2_PUSH_EVENT_PUSH_CONTEXT_CALLBACK_TYPE_RECEIVED = 0,
 SCE_NP_WEBAPI2_PUSH_EVENT_PUSH_CONTEXT_CALLBACK_TYPE_DROPPED,
} SceNpWebApi2PushEventPushContextCallbackType;


typedef struct SceNpWebApi2PushEventPushContextId {
 char uuid[36 + 1];
} SceNpWebApi2PushEventPushContextId;

typedef void(*SceNpWebApi2PushEventPushContextCallback)(
 int32_t userCtxId,
 int32_t callbackId,
 const SceNpWebApi2PushEventPushContextId *pPushCtxId,
 SceNpWebApi2PushEventPushContextCallbackType cbType,
 const char *pNpServiceName,
 SceNpServiceLabel npServiceLabel,
 const SceNpPeerAddressA *pTo,
 const SceNpOnlineId *pToOnlineId,
 const SceNpPeerAddressA *pFrom,
 const SceNpOnlineId *pFromOnlineId,
 const SceNpWebApi2PushEventDataType *pDataType,
 const char *pData,
 size_t dataLen,
 const SceNpWebApi2PushEventExtdData *pExtdData,
 size_t extdDataNum,
 void *pUserArg
 );
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2_push_event.h" 3
int32_t sceNpWebApi2PushEventCreateHandle(int32_t libCtxId);
int32_t sceNpWebApi2PushEventDeleteHandle(int32_t libCtxId, int32_t handleId);
int32_t sceNpWebApi2PushEventAbortHandle(int32_t libCtxId, int32_t handleId);
int32_t sceNpWebApi2PushEventSetHandleTimeout(int32_t libCtxId, int32_t handleId,
 uint32_t timeout);
int32_t sceNpWebApi2PushEventCreateFilter(int32_t libCtxId,
 int32_t handleId, const char *pNpServiceName,
 SceNpServiceLabel npServiceLabel,
 const SceNpWebApi2PushEventFilterParameter *pFilterParam,
 size_t filterParamNum);
int32_t sceNpWebApi2PushEventDeleteFilter(int32_t libCtxId, int32_t filterId);
int32_t sceNpWebApi2PushEventRegisterCallback(int32_t userCtxId,
 int32_t filterId, SceNpWebApi2PushEventCallback cbFunc, void *pUserArg);
int32_t sceNpWebApi2PushEventUnregisterCallback(int32_t userCtxId,
 int32_t callbackId);


int32_t sceNpWebApi2PushEventRegisterPushContextCallback(int32_t userCtxId,
 int32_t filterId, SceNpWebApi2PushEventPushContextCallback cbFunc,
 void *pUserArg);
int32_t sceNpWebApi2PushEventUnregisterPushContextCallback(int32_t userCtxId,
 int32_t callbackId);
int32_t sceNpWebApi2PushEventCreatePushContext(int32_t userCtxId,
 SceNpWebApi2PushEventPushContextId *pPushCtxId);
int32_t sceNpWebApi2PushEventDeletePushContext(int32_t userCtxId,
 const SceNpWebApi2PushEventPushContextId *pPushCtxId);
int32_t sceNpWebApi2PushEventStartPushContextCallback(int32_t userCtxId,
 const SceNpWebApi2PushEventPushContextId *pPushCtxId);


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2.h" 2 3


extern "C" {
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2.h" 3
typedef const char* SceNpWebApi2HttpMethod;

typedef struct SceNpWebApi2ContentParameter {
 size_t contentLength;
 const char *pContentType;
 uint8_t reserved[16];
} SceNpWebApi2ContentParameter;

typedef struct SceNpWebApi2HttpHeader {
 char *pName;
 char *pValue;
} SceNpWebApi2HttpHeader;

typedef struct SceNpWebApi2MemoryPoolStats {
 size_t poolSize;
 size_t maxInuseSize;
 size_t currentInuseSize;
 int32_t reserved;
} SceNpWebApi2MemoryPoolStats;

typedef struct SceNpWebApi2ResponseInformationOption {
 int32_t httpStatus;
 char *pErrorObject;
 size_t errorObjectSize;
 size_t responseDataSize;
} SceNpWebApi2ResponseInformationOption;
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_webapi2.h" 3
int32_t sceNpWebApi2Initialize(int libHttp2CtxId, size_t poolSize);
int32_t sceNpWebApi2Terminate(int32_t libCtxId);


int32_t sceNpWebApi2CreateUserContext(int32_t libCtxId, SceUserServiceUserId userId);
int32_t sceNpWebApi2DeleteUserContext(int32_t userCtxId);


int32_t sceNpWebApi2CreateRequest(int32_t userCtxId, const char *pApiGroup,
 const char *pPath, SceNpWebApi2HttpMethod method,
 const SceNpWebApi2ContentParameter *pContentParameter, int64_t *pRequestId);
int32_t sceNpWebApi2DeleteRequest(int64_t requestId);
int32_t sceNpWebApi2AbortRequest(int64_t requestId);
int32_t sceNpWebApi2SendRequest(int64_t requestId, const void *pData,
 size_t dataSize, SceNpWebApi2ResponseInformationOption *pRespInfoOption);
int32_t sceNpWebApi2ReadData(int64_t requestId, void *pData, size_t size);


int32_t sceNpWebApi2AddHttpRequestHeader(int64_t requestId,
 const char *pFieldName, const char *pValue);
int32_t sceNpWebApi2GetHttpResponseHeaderValueLength(int64_t requestId,
 const char *pFieldName, size_t *pValueLength);
int32_t sceNpWebApi2GetHttpResponseHeaderValue(int64_t requestId,
 const char *pFieldName, char *pValue, size_t valueSize);


int32_t sceNpWebApi2GetMemoryPoolStats(int32_t libCtxId,
 SceNpWebApi2MemoryPoolStats *pCurrentStat);


int32_t sceNpWebApi2SetRequestTimeout(int64_t requestId, uint32_t timeout);
void sceNpWebApi2CheckTimeout(void);


int32_t sceNpWebApi2AddWebTraceTag(int64_t requestId, const char *pValue);


}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_universal_data_system.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_universal_data_system.h" 3
extern "C" {



typedef int32_t SceNpUniversalDataSystemContext;
typedef int32_t SceNpUniversalDataSystemHandle;






typedef struct SceNpUniversalDataSystemInitParam {
 size_t size;
 size_t poolSize;
} SceNpUniversalDataSystemInitParam;

typedef struct SceNpUniversalDataSystemMemoryStat {
 size_t poolSize;
 size_t maxInuseSize;
 size_t currentInuseSize;
} SceNpUniversalDataSystemMemoryStat;

typedef struct SceNpUniversalDataSystemEvent SceNpUniversalDataSystemEvent;
typedef struct SceNpUniversalDataSystemEventPropertyObject SceNpUniversalDataSystemEventPropertyObject;
typedef struct SceNpUniversalDataSystemEventPropertyArray SceNpUniversalDataSystemEventPropertyArray;

typedef struct SceNpUniversalDataSystemStorageStat {
 size_t inEvents;
 size_t outEvents;
 size_t lostEvents;
 size_t maxInuseSize;
 size_t currentEvents;
 size_t currentInuseSize;
 size_t currentFreeSize;
} SceNpUniversalDataSystemStorageStat;


int sceNpUniversalDataSystemCreateContext(
 SceNpUniversalDataSystemContext *context,
 SceUserServiceUserId userId,
 SceNpServiceLabel serviceLabel,
 uint64_t options
 );

int sceNpUniversalDataSystemDestroyContext(
 SceNpUniversalDataSystemContext context
 );

int sceNpUniversalDataSystemRegisterContext(
 SceNpUniversalDataSystemContext context,
 SceNpUniversalDataSystemHandle handle,
 uint64_t options
 );

int sceNpUniversalDataSystemCreateHandle(
 SceNpUniversalDataSystemHandle *handle
 );

int sceNpUniversalDataSystemDestroyHandle(
 SceNpUniversalDataSystemHandle handle
 );

int sceNpUniversalDataSystemAbortHandle(
 SceNpUniversalDataSystemHandle handle
 );

int sceNpUniversalDataSystemInitialize(
 const SceNpUniversalDataSystemInitParam *param
 );

int sceNpUniversalDataSystemTerminate();

int sceNpUniversalDataSystemGetMemoryStat(
 SceNpUniversalDataSystemMemoryStat *stat
 );

int sceNpUniversalDataSystemPostEvent(
 SceNpUniversalDataSystemContext context,
 SceNpUniversalDataSystemHandle handle,
 const SceNpUniversalDataSystemEvent *event,
 uint64_t options
 );

int sceNpUniversalDataSystemCreateEvent(
 const char *eventName,
 const SceNpUniversalDataSystemEventPropertyObject *prop,
 SceNpUniversalDataSystemEvent **newEvent,
 SceNpUniversalDataSystemEventPropertyObject **propPtr
 );

int sceNpUniversalDataSystemDestroyEvent(
 SceNpUniversalDataSystemEvent *event
 );

int sceNpUniversalDataSystemEventEstimateSize(
 const SceNpUniversalDataSystemEvent *event,
 size_t *size
 );

int sceNpUniversalDataSystemEventToString(
 const SceNpUniversalDataSystemEvent *event,
 char *buf,
 size_t bufSize,
 size_t *stringSize
 );

int sceNpUniversalDataSystemCreateEventPropertyObject(
 SceNpUniversalDataSystemEventPropertyObject **newObject
 );

int sceNpUniversalDataSystemDestroyEventPropertyObject(
 SceNpUniversalDataSystemEventPropertyObject *object
 );

int sceNpUniversalDataSystemEventPropertyObjectSetString(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 const char *value
 );

int sceNpUniversalDataSystemEventPropertyObjectSetInt32(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 int32_t value
 );

int sceNpUniversalDataSystemEventPropertyObjectSetUInt32(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 uint32_t value
 );

int sceNpUniversalDataSystemEventPropertyObjectSetInt64(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 int64_t value
 );

int sceNpUniversalDataSystemEventPropertyObjectSetUInt64(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 uint64_t value
 );

int sceNpUniversalDataSystemEventPropertyObjectSetFloat32(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 float value
 );

int sceNpUniversalDataSystemEventPropertyObjectSetFloat64(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 double value
 );

int sceNpUniversalDataSystemEventPropertyObjectSetBool(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 bool value
 );

int sceNpUniversalDataSystemEventPropertyObjectSetBinary(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 const void *value,
 size_t valueSize
 );

int sceNpUniversalDataSystemEventPropertyObjectSetObject(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 const SceNpUniversalDataSystemEventPropertyObject *value,
 SceNpUniversalDataSystemEventPropertyObject **valuePtr
 );

int sceNpUniversalDataSystemEventPropertyObjectSetArray(
 SceNpUniversalDataSystemEventPropertyObject *object,
 const char *key,
 const SceNpUniversalDataSystemEventPropertyArray *value,
 SceNpUniversalDataSystemEventPropertyArray **valuePtr
 );

int sceNpUniversalDataSystemCreateEventPropertyArray(
 SceNpUniversalDataSystemEventPropertyArray **newArray
 );

int sceNpUniversalDataSystemDestroyEventPropertyArray(
 SceNpUniversalDataSystemEventPropertyArray *array
 );

int sceNpUniversalDataSystemEventPropertyArraySetString(
 SceNpUniversalDataSystemEventPropertyArray *array,
 const char *value
 );

int sceNpUniversalDataSystemEventPropertyArraySetInt32(
 SceNpUniversalDataSystemEventPropertyArray *array,
 int32_t value
 );

int sceNpUniversalDataSystemEventPropertyArraySetUInt32(
 SceNpUniversalDataSystemEventPropertyArray *array,
 uint32_t value
 );

int sceNpUniversalDataSystemEventPropertyArraySetInt64(
 SceNpUniversalDataSystemEventPropertyArray *array,
 int64_t value
 );

int sceNpUniversalDataSystemEventPropertyArraySetUInt64(
 SceNpUniversalDataSystemEventPropertyArray *array,
 uint64_t value
 );

int sceNpUniversalDataSystemEventPropertyArraySetFloat32(
 SceNpUniversalDataSystemEventPropertyArray *array,
 float value
 );

int sceNpUniversalDataSystemEventPropertyArraySetFloat64(
 SceNpUniversalDataSystemEventPropertyArray *array,
 double value
 );

int sceNpUniversalDataSystemEventPropertyArraySetBool(
 SceNpUniversalDataSystemEventPropertyArray *array,
 bool value
 );

int sceNpUniversalDataSystemEventPropertyArraySetBinary(
 SceNpUniversalDataSystemEventPropertyArray *array,
 const void *value,
 size_t valueSize
 );

int sceNpUniversalDataSystemEventPropertyArraySetObject(
 SceNpUniversalDataSystemEventPropertyArray *array,
 const SceNpUniversalDataSystemEventPropertyObject *value,
 SceNpUniversalDataSystemEventPropertyObject **valuePtr
 );

int sceNpUniversalDataSystemEventPropertyArraySetArray(
 SceNpUniversalDataSystemEventPropertyArray *array,
 const SceNpUniversalDataSystemEventPropertyArray *value,
 SceNpUniversalDataSystemEventPropertyArray **valuePtr
 );

int sceNpUniversalDataSystemGetStorageStat(
 SceNpUniversalDataSystemContext context,
 SceNpUniversalDataSystemStorageStat *stat
 );



}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_game_intent.h" 1 3
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_game_intent.h" 3
extern "C" {






typedef struct SceNpGameIntentInitParam{
 size_t size;
 uint8_t reserved[32];
} SceNpGameIntentInitParam;

static inline
void sceNpGameIntentInitParamInit(SceNpGameIntentInitParam *p)
{
 memset(p, 0, sizeof(SceNpGameIntentInitParam));
 p->size = sizeof(SceNpGameIntentInitParam);
}

typedef struct SceNpGameIntentData {
 uint8_t data[(16 * 1024 + 1)];
 uint8_t padding[7];
} SceNpGameIntentData;

typedef struct SceNpGameIntentInfo {
 size_t size;
 SceUserServiceUserId userId;
 char intentType[(32 + 1)];
 uint8_t padding[7];
 uint8_t reserved[256];
 SceNpGameIntentData intentData;
} SceNpGameIntentInfo;

static inline
void sceNpGameIntentInfoInit(SceNpGameIntentInfo *p)
{
 memset(p, 0, sizeof(SceNpGameIntentInfo));
 p->size = sizeof(SceNpGameIntentInfo);
 p->userId = (-1);
}

int32_t
sceNpGameIntentInitialize(
 const SceNpGameIntentInitParam *initParam
 );

int32_t
sceNpGameIntentTerminate(
 void
 );

int32_t
sceNpGameIntentReceiveIntent(
 SceNpGameIntentInfo *intentInfo
 );

int32_t
sceNpGameIntentGetPropertyValueString(
 const SceNpGameIntentData *intentData,
 const char *key,
 char *valueBuf,
 size_t bufSize
 );


}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np.h" 2 3
# 21 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SonyCommonIncludes.h" 2
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service/error.h" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service/tournament.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service/tournament.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service/tournament.h" 2 3



extern "C" {


typedef struct SceSystemServiceTournamentOccurrenceParam {
 size_t size;
 const char* tournamentId;
 SceUserServiceUserId userId;
 const char* occurrenceId;
} SceSystemServiceTournamentOccurrenceParam;

static inline
 void sceSystemServiceInitializeTournamentOccurrenceParam(
  SceSystemServiceTournamentOccurrenceParam *param
 )
{
 memset(param, 0, sizeof(SceSystemServiceTournamentOccurrenceParam));
 param->size = sizeof(SceSystemServiceTournamentOccurrenceParam);
 return;
}

int32_t sceSystemServiceOpenTournamentOccurrence(
 const SceSystemServiceTournamentOccurrenceParam *param
);


}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_param.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_param.h" 3
typedef int32_t SceSystemParamLang;
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service.h" 2 3


extern "C" {




typedef int32_t SceSystemServiceParamId;
# 93 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_service.h" 3
int32_t sceSystemServiceParamGetInt(

  SceSystemServiceParamId paramId,

  int32_t *value

);



int32_t sceSystemServiceParamGetString(

  SceSystemServiceParamId paramId,

  char *buf,

  size_t bufSize

);

typedef enum _SceSystemServiceEventType {
 SCE_SYSTEM_SERVICE_EVENT_INVALID = -1,
 SCE_SYSTEM_SERVICE_EVENT_ON_RESUME = 0x10000000,
 SCE_SYSTEM_SERVICE_EVENT_GAME_LIVE_STREAMING_STATUS_UPDATE = 0x10000001,
 SCE_SYSTEM_SERVICE_EVENT_SESSION_INVITATION = 0x10000002,
 SCE_SYSTEM_SERVICE_EVENT_ENTITLEMENT_UPDATE = 0x10000003,
 SCE_SYSTEM_SERVICE_EVENT_GAME_CUSTOM_DATA = 0x10000004,
 SCE_SYSTEM_SERVICE_EVENT_DISPLAY_SAFE_AREA_UPDATE = 0x10000005,
 SCE_SYSTEM_SERVICE_EVENT_URL_OPEN = 0x10000006,
 SCE_SYSTEM_SERVICE_EVENT_LAUNCH_APP = 0x10000007,
 SCE_SYSTEM_SERVICE_EVENT_APP_LAUNCH_LINK = 0x10000008,
 SCE_SYSTEM_SERVICE_EVENT_ADDCONTENT_INSTALL = 0x10000009,
 SCE_SYSTEM_SERVICE_EVENT_RESET_VR_POSITION = 0x1000000a,
 SCE_SYSTEM_SERVICE_EVENT_JOIN_EVENT = 0x1000000b,
 SCE_SYSTEM_SERVICE_EVENT_PLAYGO_LOCUS_UPDATE = 0x1000000c,
 SCE_SYSTEM_SERVICE_EVENT_PLAY_TOGETHER_HOST = 0x1000000d,
 SCE_SYSTEM_SERVICE_EVENT_SERVICE_ENTITLEMENT_UPDATE = 0x1000000e,
 SCE_SYSTEM_SERVICE_EVENT_EYE_TO_EYE_DISTANCE_UPDATE = 0x1000000f,
 SCE_SYSTEM_SERVICE_EVENT_JOIN_MATCH_EVENT = 0x10000010,
 SCE_SYSTEM_SERVICE_EVENT_PLAY_TOGETHER_HOST_A = 0x10000011,
 SCE_SYSTEM_SERVICE_EVENT_WEBBROWSER_CLOSED = 0x10000012,
 SCE_SYSTEM_SERVICE_EVENT_CONTROLLER_SETTINGS_CLOSED = 0x10000013,
 SCE_SYSTEM_SERVICE_EVENT_JOIN_TEAM_ON_TEAM_MATCH_EVENT = 0x10000014,
 SCE_SYSTEM_SERVICE_EVENT_JOIN_FFA_MATCH_EVENT = 0x10000015,
 SCE_SYSTEM_SERVICE_EVENT_JOIN_FFA_TEAM_MATCH_EVENT = 0x10000016,
 SCE_SYSTEM_SERVICE_EVENT_GAME_INTENT = 0x10000017,
 SCE_SYSTEM_SERVICE_EVENT_OPEN_SHARE_MENU = 0x30000000,
 SCE_SYSTEM_SERVICE_EVENT_UNIFIED_ENTITLEMENT_UPDATE = 0x10000018,
 SCE_SYSTEM_SERVICE_EVENT_PLAYGO_CHUNK_ADDED = 0x10000019,
 SCE_SYSTEM_SERVICE_EVENT_FLEXCONTENT_DOWNLOAD_COMPLETED = 0x1000001a,
 SCE_SYSTEM_SERVICE_EVENT_FLEXCONTENT_UPDATED = 0x1000001b,
 SCE_SYSTEM_SERVICE_EVENT_FLEXCONTENT_RESERVED = 0x1000001c,
 SCE_SYSTEM_SERVICE_EVENT_AVCONTENT_CREATED = 0x1000001d,
} SceSystemServiceEventType;




typedef struct _SceSystemServiceEvent {
 SceSystemServiceEventType eventType;
 union {
  char param[8192];
  struct {
   char source[1024];
   union {
    char arg[4096];
    char url[4096];
   };
  } urlOpen;
  struct {
   uint32_t size;
   uint8_t arg[8188];
  } launchApp;
  struct {
   uint32_t size;
   uint8_t arg[2020];
  } appLaunchLink;
  struct {
   SceUserServiceUserId userId;
   char eventId[37];
   char bootArgument[7169];
  } joinEvent;
  struct {
   SceUserServiceUserId userId;
   uint32_t npServiceLabel;
   uint8_t reserved[8184];
  } serviceEntitlementUpdate;
  struct {
   SceUserServiceUserId userId;
   uint32_t npServiceLabel;
   uint8_t reserved[8184];
  } unifiedEntitlementUpdate;
  struct {
   uint8_t data[8];
   uint8_t reserved[8184];
  } avContentCreated;
  uint8_t reserved[8192];
 } data;
} SceSystemServiceEvent;

int32_t sceSystemServiceReceiveEvent(SceSystemServiceEvent* event);


typedef struct _SceSystemServiceStatus {
 int32_t eventNum;
 bool isSystemUiOverlaid;
 bool isInBackgroundExecution;
 bool isVrPlayAreaBoundaryOverlaid;
 uint8_t reserved[127];
} SceSystemServiceStatus;

int32_t sceSystemServiceGetStatus(SceSystemServiceStatus* status);



int32_t sceSystemServiceLoadExec(const char* path, char* const argv[]);

int32_t sceSystemServiceHideSplashScreen();

int32_t sceSystemServiceDisableMusicPlayer();
int32_t sceSystemServiceReenableMusicPlayer();

int32_t sceSystemServiceDisableMediaPlay();
int32_t sceSystemServiceReenableMediaPlay();

typedef enum {
    SCE_SYSTEM_SERVICE_GPU_LOAD_EMULATION_MODE_OFF,
    SCE_SYSTEM_SERVICE_GPU_LOAD_EMULATION_MODE_NORMAL,
} SceSystemServiceGpuLoadEmulationMode;

int32_t sceSystemServiceSetGpuLoadEmulationMode(
        SceSystemServiceGpuLoadEmulationMode mode
    );

SceSystemServiceGpuLoadEmulationMode sceSystemServiceGetGpuLoadEmulationMode();

typedef struct SceSystemServiceDisplaySafeAreaInfo {
 float ratio;
 uint8_t reserved[128];
} SceSystemServiceDisplaySafeAreaInfo;

int32_t sceSystemServiceGetDisplaySafeAreaInfo(SceSystemServiceDisplaySafeAreaInfo* info);
int32_t sceSystemServiceShowDisplaySafeAreaSettings() __attribute__((__deprecated__));

int32_t sceSystemServicePowerTick();

typedef struct SceSystemServiceAbnormalTerminationInfo SceSystemServiceAbnormalTerminationInfo;
int32_t sceSystemServiceReportAbnormalTermination(const SceSystemServiceAbnormalTerminationInfo* info);

int32_t sceSystemServiceShowControllerSettings();


typedef enum {
 SCE_SYSTEM_SERVICE_SEND_FRIEND_REQUEST = 0,
 SCE_SYSTEM_SERVICE_BLOCK_USER,
 SCE_SYSTEM_SERVICE_LAUNCH_PROFILE
} SceSystemServicePlayerDialogMode;

typedef struct SceSystemServicePlayerDialogParam {
 size_t size;
 SceSystemServicePlayerDialogMode mode;
 SceUserServiceUserId userId;
 uint64_t targetAccountId;
 uint8_t reserved[40];
} SceSystemServicePlayerDialogParam;

void sceSystemServiceInitializePlayerDialogParam(SceSystemServicePlayerDialogParam *param);

int32_t sceSystemServiceLaunchPlayerDialog(const SceSystemServicePlayerDialogParam *param);

typedef struct SceSystemServiceHdrToneMapLuminance {
 float maxFullFrameToneMapLuminance;
 float maxToneMapLuminance;
 float minToneMapLuminance;
} SceSystemServiceHdrToneMapLuminance;

int32_t sceSystemServiceGetHdrToneMapLuminance(SceSystemServiceHdrToneMapLuminance *hdrToneMapLuminance);

int32_t sceSystemServiceGetNoticeScreenSkipFlag(bool* value);

int32_t sceSystemServiceDisableNoticeScreenSkipFlagAutoSet();

int32_t sceSystemServiceSetNoticeScreenSkipFlag();


typedef enum {
 SCE_SYSTEM_SERVICE_CHALLENGE_ACTIVITY_SCREEN_DEFAULT = 0,
 SCE_SYSTEM_SERVICE_CHALLENGE_ACTIVITY_SCREEN_LEADERBOARD = 1
} SceSystemServiceChallengeActivityScreen;

typedef enum {
 SCE_SYSTEM_SERVICE_CHALLENGE_ACTIVITY_COHORT_DEFAULT = 0,
 SCE_SYSTEM_SERVICE_CHALLENGE_ACTIVITY_COHORT_FRIENDS = 1,
 SCE_SYSTEM_SERVICE_CHALLENGE_ACTIVITY_COHORT_GLOBAL = 2
} SceSystemServiceChallengeActivityCohort;

typedef struct SceSystemServiceChallengeActivityParam {
 size_t size;
 const char* activityId;
 SceUserServiceUserId userId;
 SceSystemServiceChallengeActivityScreen screen;
 SceSystemServiceChallengeActivityCohort cohort;
} SceSystemServiceChallengeActivityParam;

static inline
void sceSystemServiceInitializeChallengeActivityParam(
 SceSystemServiceChallengeActivityParam* param
)
{
 memset(param, 0, sizeof(SceSystemServiceChallengeActivityParam));
 param->size = sizeof(SceSystemServiceChallengeActivityParam);
 return;
}

int32_t sceSystemServiceOpenChallengeActivity(
 const SceSystemServiceChallengeActivityParam *param
);



}
# 22 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SonyCommonIncludes.h" 2





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 1 3
# 90 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 3
extern "C" {
void _Assert(const char *, const char *) __attribute__((__noreturn__));
}
# 28 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SonyCommonIncludes.h" 2
# 4 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude\\BinaryBuffers.h" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/CommonTypes.h" 1




typedef unsigned char UInt8;
typedef unsigned short UInt16;
typedef unsigned int UInt32;
typedef uint64_t UInt64;
typedef char Int8;
typedef short Int16;
typedef int Int32;
typedef int64_t Int64;
# 5 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude\\BinaryBuffers.h" 2

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 1 3
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 2 3



namespace std {
using :: ptrdiff_t;
using :: size_t;
using :: max_align_t;
}




namespace std {

template<class _Ty,
 _Ty _Val>
 struct integral_constant
 {
 static constexpr _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant<_Ty, _Val> type;

 constexpr operator value_type() const noexcept
  {
  return (value);
  }


 constexpr value_type operator()() const noexcept
  {
  return (value);
  }

 };


template<class _Ty,
 _Ty _Val>
 constexpr _Ty integral_constant<_Ty, _Val>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;


template<bool _Val>
        struct _Cat_base
  : integral_constant<bool, _Val>
 {
 };


template<class _Ty>
 struct remove_const
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty[]>
 {
 typedef _Ty type[];
 };

template<class _Ty, size_t _Nx>
 struct remove_const<const _Ty[_Nx]>
 {
 typedef _Ty type[_Nx];
 };


template<class _Ty>
 struct remove_volatile
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty[]>
 {
 typedef _Ty type[];
 };

template<class _Ty, size_t _Nx>
 struct remove_volatile<volatile _Ty[_Nx]>
 {
 typedef _Ty type[_Nx];
 };


template<class _Ty>
 struct remove_cv
 {
 typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
  type;
 };



template<class _Ty>
 struct is_integral
  : _Cat_base<__is_integral(_Ty)>
 {
 };
# 261 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 3
template<bool _Test,
 class _Ty = void>
 struct enable_if
 {
 };

template<class _Ty>
 struct enable_if<true, _Ty>
 {
 typedef _Ty type;
 };

template<bool _Test,
 class _Ty = void>
 using enable_if_t = typename enable_if<_Test, _Ty>::type;

using nullptr_t = decltype(nullptr);
# 363 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 2 3



namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;

using :: abort; using :: abs;
using :: at_quick_exit; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: quick_exit;
using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;
# 68 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\initializer_list" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\initializer_list" 3
namespace std {

template<class _Elem>
 class initializer_list
 {
public:
 typedef _Elem value_type;
 typedef const _Elem& reference;
 typedef const _Elem& const_reference;
 typedef size_t size_type;

 typedef const _Elem *iterator;
 typedef const _Elem *const_iterator;

 constexpr initializer_list() noexcept
  : _First(0), _Last(0)
  {
  }

 constexpr initializer_list(const _Elem *_First_arg,
  const _Elem *_Last_arg) noexcept
  : _First(_First_arg), _Last(_Last_arg)
  {
  }

 constexpr initializer_list(const _Elem *_First_arg, size_t _Size_arg)
  : _First(_First_arg), _Last(_First_arg + _Size_arg)
  {
  }

 constexpr const _Elem *begin() const noexcept
  {
  return (_First);
  }

 constexpr const _Elem *end() const noexcept
  {
  return (_Last);
  }

 constexpr size_t size() const noexcept
  {
  return ((size_t)(_Last - _First));
  }

private:
 const _Elem *_First;
 const _Elem *_Last;
 };
}
namespace std {

template<class _Elem> inline
 constexpr const _Elem *begin(
  ::std:: initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.begin());
 }


template<class _Elem> inline
 constexpr const _Elem *end(
  ::std:: initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.end());
 }
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 3
namespace std {

struct _Nil
 {
 };
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 3
template<bool _Test,
 class _Ty1,
 class _Ty2>
 struct conditional
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct conditional<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };


template<class _Ty1,
 class _Ty2>
 struct is_same
  : false_type
 {
 };

template<class _Ty1>
 struct is_same<_Ty1, _Ty1>
  : true_type
 {
 };



template<class _Ty>
 struct is_floating_point
  : _Cat_base<__is_floating_point(_Ty)>
 {
 };
# 96 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 3
template<class _Ty>
 struct is_arithmetic
  : _Cat_base<is_integral<_Ty>::value
   || is_floating_point<_Ty>::value>
 {
 };


template<class _Ty>
 struct remove_reference
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 using remove_reference_t = typename remove_reference<_Ty>::type;


struct _Wrap_int
 {
 _Wrap_int(int)
  {
  }
 };

template<class _Ty>
 struct _Identity
 {
 typedef _Ty type;
 };
# 152 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 3
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 2 3
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
namespace std {
# 117 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<bool,
 class _Ty1,
 class _Ty2>
 struct _If
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct _If<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };

template<class _Ty>
 struct _Always_false
  : false_type
 {
 };
# 156 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<class _Arg,
 class _Result>
 struct unary_function
 {
 typedef _Arg argument_type;
 typedef _Result result_type;
 };


template<class _Arg1,
 class _Arg2,
 class _Result>
 struct binary_function
 {
 typedef _Arg1 first_argument_type;
 typedef _Arg2 second_argument_type;
 typedef _Result result_type;
 };


template<class _Ty = void>
 struct plus
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left + _Right);
  }
 };


template<class _Ty = void>
 struct minus
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left - _Right);
  }
 };


template<class _Ty = void>
 struct multiplies
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left * _Right);
  }
 };


template<class _Ty = void>
 struct equal_to
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef bool result_type ;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left == _Right);
  }
 };


template<class _Ty = void>
 struct less
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef bool result_type ;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left < _Right);
  }
 };



typedef int _Is_trans;


template<>
 struct plus<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct minus<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct multiplies<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct equal_to<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct less<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right));
  }
 };





}



namespace std {

__attribute__((no_sanitize("unsigned-integer-overflow")))
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
 {

 static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
 const size_t _FNV_offset_basis = 14695981039346656037ULL;
 const size_t _FNV_prime = 1099511628211ULL;







 size_t _Val = _FNV_offset_basis;
 for (size_t _Next = 0; _Next < _Count; ++_Next)
  {
  _Val ^= (size_t)_First[_Next];
  _Val *= _FNV_prime;
  }
 return (_Val);
 }


template<class _Kty>
 struct _Bitwise_hash
 {
 typedef _Kty argument_type ;
 typedef size_t result_type ;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
  }
 };

template<class _Kty, bool = __is_enum(_Kty)>
 struct _Enum_hash : _Bitwise_hash<_Kty>
 {
 };

template<class _Kty>
 struct _Enum_hash<_Kty, false>
 {
 _Enum_hash() = delete;
 _Enum_hash(const _Enum_hash&) = delete;
 _Enum_hash& operator=(const _Enum_hash&) = delete;
 };



template<class _Kty>
 struct hash
  : public _Enum_hash<_Kty>
 {
 };





template<>
 struct hash<bool>
  : public _Bitwise_hash<bool>
 {
 };

template<>
 struct hash<char>
  : public _Bitwise_hash<char>
 {
 };

template<>
 struct hash<signed char>
  : public _Bitwise_hash<signed char>
 {
 };

template<>
 struct hash<unsigned char>
  : public _Bitwise_hash<unsigned char>
 {
 };

template<>
 struct hash<char16_t>
  : public _Bitwise_hash<char16_t>
 {
 };

template<>
 struct hash<char32_t>
  : public _Bitwise_hash<char32_t>
 {
 };

template<>
 struct hash<wchar_t>
  : public _Bitwise_hash<wchar_t>
 {
 };

template<>
 struct hash<short>
  : public _Bitwise_hash<short>
 {
 };

template<>
 struct hash<unsigned short>
  : public _Bitwise_hash<unsigned short>
 {
 };

template<>
 struct hash<int>
  : public _Bitwise_hash<int>
 {
 };

template<>
 struct hash<unsigned int>
  : public _Bitwise_hash<unsigned int>
 {
 };

template<>
 struct hash<long>
  : public _Bitwise_hash<long>
 {
 };

template<>
 struct hash<unsigned long>
  : public _Bitwise_hash<unsigned long>
 {
 };

template<>
 struct hash<long long>
  : public _Bitwise_hash<long long>
 {
 };

template<>
 struct hash<unsigned long long>
  : public _Bitwise_hash<unsigned long long>
 {
 };

template<>
 struct hash<float>
  : public _Bitwise_hash<float>
 {
 typedef float _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<double>
  : public _Bitwise_hash<double>
 {
 typedef double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<long double>
  : public _Bitwise_hash<long double>
 {
 typedef long double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  _Kty _Temp = _Keyval == 0 ? 0 : _Keyval;


  unsigned char *_Pyt = (unsigned char *)&_Temp;
  for (size_t _Idx = 10; _Idx < sizeof (long double); ++_Idx)
   _Pyt[_Idx] = 0;


  return (_Mybase::operator()(_Temp));
  }
 };

template<class _Ty>
 struct hash<_Ty *>
  : public _Bitwise_hash<_Ty *>
 {
 };

template<>
 struct hash<nullptr_t>
 {
 using result_type = size_t;
 using argument_type = nullptr_t;

 size_t operator()(nullptr_t) const
  {
  return size_t(0);
  }
 };

}
# 781 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
namespace std {

template<class... _Types>
 struct _Arg_types
 {
 };

template<class _Ty1>
 struct _Arg_types<_Ty1>
 {
 typedef _Ty1 argument_type ;
 };

template<class _Ty1,
 class _Ty2>
 struct _Arg_types<_Ty1, _Ty2>
 {
 typedef _Ty1 first_argument_type ;
 typedef _Ty2 second_argument_type ;
 };


template<class _Ty>
 struct _Is_function
 {
 typedef false_type _Bool_type;
 };
# 820 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };
# 832 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };
# 858 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<class _Ty>
 struct is_function
  : _Is_function<_Ty>::_Bool_type
 {
 };


template<class _Ty> inline
 _Ty *_Addressof(_Ty& _Val, true_type) noexcept
 {
 return (_Val);
 }


template<class _Ty> inline
 _Ty *_Addressof(_Ty& _Val, false_type) noexcept
 {
 return __builtin_addressof(_Val);
 }

template<class _Ty> inline
 _Ty *addressof(_Ty& _Val) noexcept
 {
 return (_Addressof(_Val, is_function<_Ty>()));
 }
# 899 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 2 3

namespace std {

class exception;
typedef void (*_Prhand)(const exception&);
extern _Prhand _Raise_handler;
         void _Throw(const exception&);
# 84 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
class exception
 {
public:
 static _Prhand _Set_raise_handler(_Prhand _Pnew);

 exception() noexcept
  {
  }

 explicit exception(const char *) noexcept
  {
  }

 virtual ~exception() noexcept;


 virtual const char *what() const;
# 110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
 void _Raise() const;

protected:
 virtual void _Doraise() const;

 };


class bad_exception
 : public exception
 {
public:
 bad_exception() noexcept
  {
  }


 virtual ~bad_exception() noexcept;
# 138 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
protected:
 virtual void _Doraise() const;

 };



typedef void (*terminate_handler)();
typedef void (*unexpected_handler )();


         terminate_handler get_terminate() noexcept;
         terminate_handler set_terminate(terminate_handler) noexcept;
                                   unexpected_handler get_unexpected() noexcept;
                                   unexpected_handler set_unexpected(unexpected_handler) noexcept;
                        bool uncaught_exception() noexcept;
# 162 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
         void terminate() noexcept __attribute__((__noreturn__));
                                   void unexpected() __attribute__((__noreturn__));
# 180 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
}

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xxexception" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xxexception" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 2 3
# 234 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
namespace std {

template<class _Ty>
 struct _Ptr_traits
 {
 };

template<class _Ty>
 struct _Ptr_traits<_Ty *>
 {
 static const bool _Is_const = false;
 static const bool _Is_volatile = false;
 };

template<class _Ty>
 struct _Ptr_traits<const _Ty *>
 {
 static const bool _Is_const = true;
 static const bool _Is_volatile = false;
 };

template<class _Ty>
 struct _Ptr_traits<volatile _Ty *>
 {
 static const bool _Is_const = false;
 static const bool _Is_volatile = true;
 };

template<class _Ty>
 struct _Ptr_traits<const volatile _Ty *>
 {
 static const bool _Is_const = true;
 static const bool _Is_volatile = true;
 };

template<class _Ty>
 struct _Is_memfunptr
 {
 typedef false_type _Bool_type;
 };
# 287 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) & > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) && > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };
# 301 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };



template<class _Ty>
 struct _Has_cv_ref_qual
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) &>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) &&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const&&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile&&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile&&>
  : true_type
 {
 };


template<class _Ty>
 struct add_const
 {
 typedef const _Ty type;
 };


template<class _Ty>
 struct add_volatile
 {
 typedef volatile _Ty type;
 };


template<class _Ty>
 struct add_cv
 {
 typedef const volatile _Ty type;
 };


template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_lvalue_reference
 {
 typedef _Ty& type;
 };

template<class _Ty>
 struct _Do_add_lvalue_reference<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_lvalue_reference
  : _Do_add_lvalue_reference<_Ty,
   _Has_cv_ref_qual<_Ty>::value>
 {
 };
# 437 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<> struct add_lvalue_reference< void> { typedef void type; }; template<> struct add_lvalue_reference<const void> { typedef const void type; }; template<> struct add_lvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_lvalue_reference<const volatile void> { typedef const volatile void type; };



template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_rvalue_reference
 {
 typedef typename remove_reference<_Ty>::type&& type;
 };

template<class _Ty>
 struct _Do_add_rvalue_reference<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_rvalue_reference
  : _Do_add_rvalue_reference<_Ty,
   _Has_cv_ref_qual<_Ty>::value>
 {
 };

template<class _Ty>
 struct add_rvalue_reference<_Ty&>
 {
 typedef _Ty& type;
 };
# 474 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<> struct add_rvalue_reference< void> { typedef void type; }; template<> struct add_rvalue_reference<const void> { typedef const void type; }; template<> struct add_rvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_rvalue_reference<const volatile void> { typedef const volatile void type; };



template<class _Ty>
 typename add_rvalue_reference<_Ty>::type
  declval() noexcept;


template<class _Ty>
 struct remove_extent
 {
 typedef _Ty type;
 };

template<class _Ty,
 size_t _Ix>
 struct remove_extent<_Ty[_Ix]>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_extent<_Ty[]>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_all_extents
 {
 typedef _Ty type;
 };

template<class _Ty,
 size_t _Ix>
 struct remove_all_extents<_Ty[_Ix]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };

template<class _Ty>
 struct remove_all_extents<_Ty[]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };


template<class _Ty>
 struct remove_pointer
 {
 typedef _Ty type;
 };
# 536 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };



template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_pointer
 {
 typedef typename remove_reference<_Ty>::type *type;
 };

template<class _Ty>
 struct _Do_add_pointer<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_pointer
  : _Do_add_pointer<_Ty, _Has_cv_ref_qual<_Ty>::value>
 {
 };



template<class _Ty>
 struct _Is_void
  : false_type
 {
 };

template<>
 struct _Is_void<void>
  : true_type
 {
 };

template<class _Ty>
 struct is_void
  : _Is_void<typename remove_cv<_Ty>::type>
 {
 };


template<class _Ty>
 struct is_array
  : false_type
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_array<_Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_array<_Ty[]>
  : true_type
 {
 };


template<class _Ty>
 struct is_lvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_lvalue_reference<_Ty&>
  : true_type
 {
 };


template<class _Ty>
 struct is_rvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_rvalue_reference<_Ty&&>
  : true_type
 {
 };


template<class _Ty>
 struct is_reference
  : _Cat_base<is_lvalue_reference<_Ty>::value
  || is_rvalue_reference<_Ty>::value>
 {
 };


template<class _Ty,
 bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
 struct _Is_member_object_pointer
  : false_type
 {
 };

template<class _Ty1,
 class _Ty2>
 struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
  : true_type
 {
 typedef _Ty2 _Class_type;
 };

template<class _Ty>
 struct is_member_object_pointer
  : _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
 {
 };


template<class _Ty>
 struct is_member_function_pointer
  : _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
 {
 };


template<class _Ty>
 struct _Is_pointer
  : false_type
 {
 };

template<class _Ty>
 struct _Is_pointer<_Ty *>
  : _Cat_base<!is_member_object_pointer<_Ty *>::value
  && !is_member_function_pointer<_Ty *>::value>
 {
 };

template<class _Ty>
 struct is_pointer
  : _Is_pointer<typename remove_cv<_Ty>::type>
 {
 };



template<class _Ty>
 struct _Is_nullptr_t
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };
# 700 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_null_pointer
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };
# 716 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_union
  : _Cat_base<__is_union(_Ty)>
 {
 };


template<class _Ty>
 struct is_class
  : _Cat_base<__is_class(_Ty)>
 {
 };


template<class _Ty>
 struct is_fundamental
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_void<_Ty>::value
  || _Is_nullptr_t<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_object
  : _Cat_base<!is_function<_Ty>::value
  && !is_reference<_Ty>::value
  && !is_void<_Ty>::value>
 {
 };


template<class _Ty,
 bool = is_object<_Ty>::value || is_reference<_Ty>::value>
 struct _Is_referenceable
  : true_type
 {
 };

template<class _Ty>
 struct _Is_referenceable<_Ty, false>
  : false_type
 {
 };
# 769 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ret, class... _Types> struct _Is_referenceable<_Ret (_Types...) , false> : true_type { };
# 780 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ret, class... _Types> struct _Is_referenceable<_Ret (_Types..., ...) , false> : true_type { };
# 819 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _From,
 class _To>
 struct is_convertible


  : _Cat_base<is_void<typename remove_volatile<_From>::type>::value && is_void<typename remove_volatile<_To>::type>::value || __is_convertible_to(typename remove_volatile<_From>::type, typename remove_volatile<_To>::type)>






 {
 };
# 871 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_enum
  : _Cat_base<__is_enum(_Ty)>
 {
 };


template<class _Ty>
 struct is_compound
  : _Cat_base<!is_fundamental<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_member_pointer
  : _Cat_base<is_member_object_pointer<_Ty>::value
  || is_member_function_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_scalar
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_enum<_Ty>::value
  || is_pointer<_Ty>::value
  || is_member_pointer<_Ty>::value
  || _Is_nullptr_t<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_const
  : _Cat_base<_Ptr_traits<_Ty *>::_Is_const
  && !is_function<_Ty>::value>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_const<_Ty[_Nx]>
  : false_type
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_const<const _Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_const<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_const<_Ty&&>
  : false_type
 {
 };


template<class _Ty>
 struct is_volatile
  : _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
  && !is_function<_Ty>::value>
 {
 };

template<class _Ty>
 struct is_volatile<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_volatile<_Ty&&>
  : false_type
 {
 };


template<class _Ty1,
 class _Ty2>
 struct _Copy_cv
 {
 typedef conditional<is_const<_Ty1>::value,
  typename add_const<_Ty2>::type,
  _Ty2> _Tx;
 typedef conditional<is_volatile<_Ty1>::value,
  typename add_volatile<_Tx>::type,
  _Tx> type;
 };

template<class _Ty1,
 class _Ty2>
 using _Copy_cv_t = typename _Copy_cv<_Ty1, _Ty2>::type;

template<class _Ty1,
 class _Ty2>
 struct _Composite_ptr
 {
 typedef
  typename conditional<is_same<_Ty1 *, nullptr_t>::value,
   _Ty2 *,
  typename conditional<is_same<_Ty2 *, nullptr_t>::value,
   _Ty1 *,
  typename conditional<is_same<typename remove_cv<_Ty1>::type,
   void>::value,
   _Copy_cv_t<_Ty1, _Ty2> *,
   _Copy_cv_t<_Ty2, _Ty1> *
   >::type >::type >::type type;
 };

template<class _Ty1,
 class _Ty2>
 using _Composite_ptr_t = typename _Composite_ptr<_Ty1, _Ty2>::type;


template<class _Ty>
 struct _Is_pod
  : _Cat_base<is_scalar<_Ty>::value || __is_pod(_Ty)>
 {
 };

template<class _Ty>
 struct is_pod
  : _Is_pod<typename remove_all_extents<_Ty>::type>
 {
 };


template<class _Ty>
 struct is_empty
  : _Cat_base<__is_empty(_Ty)>
 {
 };


template<class _Ty>
 struct is_polymorphic
  : _Cat_base<__is_polymorphic(_Ty)>
 {
 };


template<class _Ty>
 struct is_abstract
  : _Cat_base<__is_abstract(_Ty)>
 {
 };


template<class _Ty>
 struct is_standard_layout : _Cat_base<__is_standard_layout(_Ty)>
 {
 };


template<class _Ty>
 struct is_literal_type
  : _Cat_base<__is_literal_type(_Ty)>
 {
 };


template<class _Ty>
 struct is_trivial
  : _Cat_base<__is_trivial(_Ty)>
 {
 };


template<class _Ty>
 struct has_virtual_destructor
  : _Cat_base<__has_virtual_destructor(_Ty)>
 {
 };



template<bool,
 class _Ty,
 class... _Types>
 struct _Is_constructible
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Is_constructible<true, _Ty, _Types...>
 {
 template<class _Uty>
  static auto _Fn(int)
   -> decltype((void)_Uty(::std:: declval<_Types>()...), true_type());
 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_Ty>(0)) type;
 };


template<class _Ty,
 class... _Types>
 struct is_constructible
  : _Cat_base<__is_constructible(_Ty, _Types...)>
 {
 };
# 1100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<bool,
 class _Ty>
 struct _Is_cc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_cc<true, _Ty>
  : is_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct _Is_cc<true, _Ty&>
  : is_constructible<_Ty&, _Ty&>
 {
 };

template<class _Ty>
 struct is_copy_constructible
  : _Is_cc<!is_void<_Ty>::value && !is_array<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_default_constructible
  : is_constructible<_Ty>::type
 {
 };


template<bool,
 class _Ty>
 struct _Is_mc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_mc<true, _Ty>
  : is_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct _Is_mc<true, _Ty&>
  : is_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_move_constructible
  : _Is_mc<!is_void<_Ty>::value && !is_array<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _To,
 class _From>
 struct _Is_assignable
  : false_type
 {
 };

template<class _To,
 class _From>
 struct _Is_assignable<true, _To, _From>
 {
 template<class _Uty>
  static auto _Fn(int)
   -> decltype((void)(::std:: declval<_Uty>() = ::std:: declval<_From>()),
    true_type());

 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_To>(0)) type;
 };

template<class _To,
 class _From>
 struct is_assignable
  : _Is_assignable<
   is_object<typename remove_reference<_To>::type>::value
   && !is_array<typename remove_reference<_To>::type>::value
   && is_object<typename remove_reference<_From>::type>::value
   && !is_array<typename remove_reference<_From>::type>::value,
   _To, _From>::type

 {
 };


template<bool,
 class _Ty>
 struct _Is_ca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ca<false, _Ty>
  : is_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_copy_assignable
  : _Is_ca<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ma
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ma<false, _Ty>
  : is_assignable<_Ty&, _Ty&&>
 {
 };

template<class _Ty>
 struct is_move_assignable
  : _Is_ma<is_void<_Ty>::value, _Ty>
 {
 };







template<class _Ty, unsigned int _Nx>
 struct extent;

template<class _Ty>
 struct __is_array_unknown_bounds
  : public _Cat_base<__is_array(_Ty) && !extent<_Ty, 0>::value>
 {
 };

struct __is_destructible_concrete_sub
 {
 template<class _Uty>
  struct __w { _Uty __u; };

 template<class _Ty, class = decltype(declval<__w<_Ty>&>().~__w<_Ty>())>
  static true_type __test(int);

 template<class>
  static false_type __test(...);
 };

template<class _Ty>
 struct __is_destructible_concrete
  : public __is_destructible_concrete_sub
 {
 typedef decltype(__test<_Ty>(0)) type;
 };

struct __is_destructible_abstract_sub
 {
 template<class _Ty, class = decltype(declval<_Ty&>().~_Ty())>
  static true_type __test(int);

 template<class>
  static false_type __test(...);
 };

template<class _Ty>
 struct __is_destructible_abstract
  : public __is_destructible_abstract_sub
 {
 typedef decltype(__test<_Ty>(0)) type;
 };


template<class _Ty,
 bool __b1 = is_void<_Ty>::value || __is_array_unknown_bounds<_Ty>::value || is_function<_Ty>::value,
 bool __b2 = is_reference<_Ty>::value>
 struct __is_destructible_sub;







template<class _Ty>
 struct __is_destructible_sub<_Ty, false, false>
  : public _If<is_abstract<_Ty>::value,
   __is_destructible_abstract<_Ty>,
   __is_destructible_concrete<_Ty>>::type::type
 {
 };

template<class _Ty>
 struct __is_destructible_sub<_Ty, true, false>
  : public false_type
 {
 };

template<class _Ty>
 struct __is_destructible_sub<_Ty, false, true>
  : public true_type
 {
 };

template<class _Ty>
 struct is_destructible
  : _Cat_base<__is_destructible_sub<_Ty>::value>
 {
 };





template<class _Ty,
 class... _Types>
 struct is_trivially_constructible
  : _Cat_base<__is_trivially_constructible(_Ty, _Types...)>
 {
 };
# 1358 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<bool,
 class _Ty>
 struct _Is_tcc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tcc<false, _Ty>
  : is_trivially_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct is_trivially_copy_constructible
  : _Is_tcc<is_void<_Ty>::value || is_array<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_trivially_default_constructible
  : is_trivially_constructible<_Ty>::type
 {
 };


template<bool,
 class _Ty>
 struct _Is_tmc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tmc<false, _Ty>
  : is_trivially_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_trivially_move_constructible
  : _Is_tmc<is_void<_Ty>::value || is_array<_Ty>::value, _Ty>
 {
 };


template<class _To,
 class _From>
 struct is_trivially_assignable
  : _Cat_base<__is_trivially_assignable(_To, _From)>
 {
 };


template<bool,
 class _Ty>
 struct _Is_tca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tca<false, _Ty>
  : is_trivially_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_trivially_copy_assignable
  : _Is_tca<is_void<_Ty>::value
   || has_virtual_destructor<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_trivially_copyable
  : _Cat_base<__is_trivially_copyable(_Ty)>
 {
 };
# 1450 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_trivially_move_assignable
  : is_trivially_assignable<typename add_lvalue_reference< typename remove_volatile<_Ty>::type>::type, typename add_rvalue_reference< typename remove_volatile<_Ty>::type>::type>::type
 {
 };


template<class _Ty>
 struct is_trivially_destructible
  : _Cat_base<is_pod<_Ty>::value || __has_trivial_destructor(_Ty)>
 {
 };


template<bool,
 class _Ty,
 class... _Types>
 struct _Is_ntc
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Is_ntc<true, _Ty, _Types...>
  : _Cat_base<noexcept(_Ty(declval<_Types>()...))>
 {
 };

template<class _Ty,
 class _Type>
 struct _Is_ntc<true, _Ty, _Type>
  : _Cat_base<noexcept(static_cast<_Ty>(declval<_Type>()))>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct _Is_ntc<true, _Ty[_Nx]>
  : _Cat_base<noexcept(_Ty())>
 {
 };

template<class _Ty>
 struct _Is_ntc<true, _Ty>
  : _Cat_base<noexcept(_Ty())>
 {
 };
# 1511 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty,
 class... _Types>
 struct is_nothrow_constructible
  : _Is_ntc<is_constructible<_Ty, _Types...>::value,
   _Ty, _Types...>
 {
 };


template<class _Ty,
 size_t _Nx>
 struct is_nothrow_constructible<_Ty[_Nx]>
  : is_nothrow_constructible<_Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntcc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntcc<true, _Ty>
  : is_nothrow_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct _Is_ntcc<true, _Ty&>
  : is_nothrow_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct is_nothrow_copy_constructible
  : _Is_ntcc<!is_void<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_copy_constructible<_Ty[_Nx]>
  : false_type
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntdc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntdc<true, _Ty>
  : _Cat_base<noexcept(_Ty())>
 {
 };

template<class _Ty>
 struct is_nothrow_default_constructible
  : _Is_ntdc<is_default_constructible<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_default_constructible<_Ty[_Nx]>
  : is_nothrow_default_constructible<_Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntmc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntmc<true, _Ty>
  : is_nothrow_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct _Is_ntmc<true, _Ty&>
  : is_nothrow_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_nothrow_move_constructible
  : _Is_ntmc<!is_void<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_move_constructible<_Ty[_Nx]>
  : false_type
 {
 };


template<bool,
 class _To,
 class _From>
 struct _Is_nta
  : false_type
 {
 };

template<class _To,
 class _From>
 struct _Is_nta<true, _To, _From>
  : _Cat_base<





  noexcept(::std:: declval<_To>() = ::std:: declval<_From>())>
 {
 };

template<class _To,
 class _From>
 struct is_nothrow_assignable
  : _Is_nta<is_assignable<_To, _From>::value, _To, _From>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntca<false, _Ty>
  : is_nothrow_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_nothrow_copy_assignable
  : _Is_ntca<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntma
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntma<false, _Ty>
  : is_nothrow_assignable<_Ty&, _Ty&&>
 {
 };

template<class _Ty>
 struct is_nothrow_move_assignable
  : _Is_ntma<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntd
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntd<true, _Ty>
  : _Cat_base<noexcept(::std:: declval<_Ty>().~_Ty())>
 {
 };

template<class _Ty>
 struct is_nothrow_destructible
  : _Is_ntd<is_destructible<_Ty>::value, _Ty>
 {
 };

template<class _Ty, size_t _Nx>
 struct is_nothrow_destructible<_Ty[_Nx]>
  : is_nothrow_destructible<_Ty>
 {
 };

template<class _Ty>
 struct is_nothrow_destructible<_Ty&>
  : true_type
 {
 };



template<class _Ty>
 struct add_reference
 {
 typedef typename remove_reference<_Ty>::type& type;
 };
# 1736 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<> struct add_reference< void> { typedef void type; }; template<> struct add_reference<const void> { typedef const void type; }; template<> struct add_reference<volatile void> { typedef volatile void type; }; template<> struct add_reference<const volatile void> { typedef const volatile void type; };





template<class _Ty>
 struct has_copy_constructor
  : is_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_default_constructor
  : is_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_move_constructor
  : is_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_copy_assign
  : is_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_move_assign
  : is_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_copy_constructor
  : is_trivially_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_default_constructor
  : is_trivially_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_move_constructor
  : is_trivially_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_copy_assign
  : is_trivially_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_move_assign
  : is_trivially_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_copy_constructor
  : is_nothrow_copy_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_default_constructor
  : is_nothrow_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_move_constructor
  : is_nothrow_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_copy_assign
  : is_nothrow_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_move_assign
  : is_nothrow_move_assignable<_Ty>::type
 {
 };



template<class _Ty>
 struct has_trivial_constructor
  : _Cat_base<is_pod<_Ty>::value || !is_array<_Ty>::value && __has_trivial_constructor(_Ty)>
 {
 };


template<class _Ty>
 struct has_trivial_copy
  : _Cat_base<!is_array<_Ty>::value && __has_trivial_copy(_Ty)>
 {
 };


template<class _Ty>
 struct has_trivial_assign
  : _Cat_base<!is_array<_Ty>::value && (is_pod<typename remove_reference<_Ty>::type>::value || __has_trivial_assign(typename remove_reference<_Ty>::type))>
 {
 };


template<class _Ty>
 struct has_trivial_destructor
  : _Cat_base<is_pod<_Ty>::value || __has_trivial_destructor(_Ty)>
 {
 };


template<class _Ty>
 struct has_nothrow_constructor
  : is_nothrow_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_copy
  : is_nothrow_copy_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_assign
  : is_nothrow_copy_assignable<_Ty>::type
 {
 };




template<class _Ty,
 bool = is_integral<_Ty>::value>
 struct _Sign_base
 {
 typedef typename remove_cv<_Ty>::type _Uty;
 typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
 typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
 };

template<class _Ty>
 struct _Sign_base<_Ty, false>
 {

 typedef is_floating_point<_Ty> _Signed;
 typedef false_type _Unsigned;
 };

template<class _Ty>
 struct is_signed
  : _Sign_base<_Ty>::_Signed
 {
 };


template<class _Ty>
 struct is_unsigned
  : _Sign_base<_Ty>::_Unsigned
 {
 };


template<class _Ty>
 struct _Change_sign
 {
 _Change_sign()
  {
 static_assert(((is_integral<_Ty>::value || is_enum<_Ty>::value) && !is_same<_Ty, bool>::value), "make_signed<T>/make_unsigned<T> require that T shall be a (possibly " "cv-qualified) integral type or enumeration but not a bool type.");




  }

 typedef
  typename _If<is_same<_Ty, signed char>::value
   || is_same<_Ty, unsigned char >::value, signed char,
  typename _If<is_same<_Ty, short >::value
   || is_same<_Ty, unsigned short >::value, short,
  typename _If<is_same<_Ty, int >::value
   || is_same<_Ty, unsigned int >::value, int,
  typename _If<is_same<_Ty, long >::value
   || is_same<_Ty, unsigned long >::value, long,
  typename _If<is_same<_Ty, long long >::value
   || is_same<_Ty, unsigned long long>::value, long long,
  typename _If<is_same<_Ty, __int128_t >::value
   || is_same<_Ty, __uint128_t >::value, __int128_t,
  typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
  typename _If<sizeof (_Ty) == sizeof (short ), short,
  typename _If<sizeof (_Ty) == sizeof (int ), int,
  typename _If<sizeof (_Ty) == sizeof (long ), long,
  typename _If<sizeof (_Ty) == sizeof (long long ), long long,
   __int128_t
  >::type>::type>::type>::type>::type>::type>::type>::type>::type>::type>::type
   _Signed;

 typedef
  typename _If<is_same<_Signed, signed char>::value, unsigned char,
  typename _If<is_same<_Signed, short >::value, unsigned short,
  typename _If<is_same<_Signed, int >::value, unsigned int,
  typename _If<is_same<_Signed, long >::value, unsigned long,
  typename _If<is_same<_Signed, long long >::value, unsigned long long,
   __uint128_t
  >::type>::type>::type>::type>::type
   _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const _Ty>
 {
 typedef const typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<volatile _Ty>
 {
 typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const volatile _Ty>
 {
 typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };


template<class _Ty>
 struct make_signed
 {
 typedef typename _Change_sign<_Ty>::_Signed type;
 };


template<class _Ty>
 struct make_unsigned
 {
 typedef typename _Change_sign<_Ty>::_Unsigned type;
 };
# 2026 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct alignment_of
  : integral_constant<size_t, __alignof__(_Ty)>
 {
 };






template<size_t _Len,
 class _Ty,
 bool _Ok>
 struct _Aligned;

template<size_t _Len,
 class _Ty>
 struct _Aligned<_Len, _Ty, true>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = __alignof__(_Ty);
 };

template<size_t _Len>
 struct _Aligned<_Len, short, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, char, __alignof__(char) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, int, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, short, __alignof__(short) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, long, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, int, __alignof__(int) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, long double, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, long, __alignof__(long) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, max_align_t, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, long double, __alignof__(long double) <= _Len>::value;
 };

template<size_t _Len,
 size_t _Align = _Aligned<_Len, max_align_t, __alignof__(max_align_t) <= _Len>::value>
 struct aligned_storage
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 typedef struct {
  alignas(_Align) unsigned char __data[_Len];
 } type;
 };


template<size_t _Len,
 class... _Types>
 struct aligned_union;

template<size_t _Len>
 struct aligned_union<_Len>
 {
 typedef typename aligned_storage<(_Len > sizeof(char)) ? _Len : sizeof(char), __alignof__(char)>::type type;
 };

template<size_t _Len,
 class _Ty,
 class... _Rest>
 struct aligned_union<_Len, _Ty, _Rest...>
 {
 typedef union
  {
  typename aligned_storage<(_Len > sizeof(_Ty)) ? _Len : sizeof(_Ty), __alignof__(_Ty)>::type _Ty1;
  typename aligned_union<_Len, _Rest...>::type _Ty2;
  } type;
 static const size_t alignment_value = alignment_of<type>::value;
 };


template<class _Ty>
 struct underlying_type
 {
 typedef __underlying_type(_Ty) type;
 };


template<class _Ty>
 struct rank
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty,
 size_t _Ix>
 struct rank<_Ty[_Ix]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };

template<class _Ty>
 struct rank<_Ty[]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };


template<class _Ty, unsigned int _Nx>
 struct _Extent
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty,
 size_t _Ix>
 struct _Extent<_Ty[_Ix], 0>
  : integral_constant<size_t, _Ix>
 {
 };

template<class _Ty,
 unsigned int _Nx,
 size_t _Ix>
 struct _Extent<_Ty[_Ix], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx>
 struct _Extent<_Ty[], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx = 0>
 struct extent
  : _Extent<_Ty, _Nx>
 {
 };


template<class _Base,
 class _Der>
 struct is_base_of
  : _Cat_base<__is_base_of(_Base, _Der)>
 {
 };


template<class _Ty>
 struct decay
 {
 template<class _Ty2>
 struct _Remove_extent_ptr
  {
  typedef typename remove_extent<_Ty2>::type *type;
  };

 typedef typename remove_reference<_Ty>::type _Ty1;

 typedef
  typename _If<is_array<_Ty1>::value,
   _Remove_extent_ptr<_Ty1>,
   typename _If<is_function<_Ty1>::value,
    add_pointer<_Ty1>,
    remove_cv<_Ty1>
   >::type
  >::type::type type;
 };


template<class _Ty>
 using decay_t = typename decay<_Ty>::type;





template<class...>
 using __void_t = void;
# 2290 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct _Common_type_success
 {
 using type = _Ty;
 };

struct _Common_type_fail
 {
 };

template<class... _Ty>
 struct common_type;

template<>
 struct common_type<>
 {
 };

template<class _Ty>
 struct common_type<_Ty>



 : decay<_Ty>

 {
 };

template<class _Ty1,
 class _Ty2,
 class _Dty1 = decay_t<_Ty1>,
 class _Dty2 = decay_t<_Ty2>,
 bool _Already_decayed = is_same<_Ty1, _Dty1>::value && is_same<_Ty2, _Dty2>::value>
 struct _Common_type2
 {
 using type = common_type<_Dty1, _Dty2>;
 };

template<class _Ty1,
 class _Ty2,
 class _Dty1,
 class _Dty2>
 struct _Common_type2<_Ty1, _Ty2, _Dty1, _Dty2, true>
 {
 template<class _Uty1, class _Uty2>
 static auto _Fn(int) -> _Common_type_success<
   decay_t<decltype(false ? declval<_Uty1>() : declval<_Uty2>())>
  >;

 template<class _Uty1, class _Uty2>
 static auto _Fn(_Wrap_int) -> _Common_type_fail;

 using type = decltype(_Fn<_Dty1, _Dty2>(0));
 };

template<class _Ty1,
 class _Ty2>
 struct common_type<_Ty1, _Ty2>





 {
 using type = decay_t<decltype(true ? declval<_Ty1>() : declval<_Ty2>())>;
 };


template<class _Ty1,
 class _Ty2,
 class... _Ty>
 struct _Common_type_rec
 {
 template<class _Uty1, class _Uty2, class... _Uty>
 static auto _Fn(int) -> _Common_type_success<
   typename common_type<typename common_type<_Uty1, _Uty2>::type, _Uty...>::type
  >;

 template<class _Uty1, class _Uty2, class... _Uty>
 static auto _Fn(_Wrap_int) -> _Common_type_fail;

 using type = decltype(_Fn<_Ty1, _Ty2, _Ty...>(0));
 };

template<class _Ty1,
 class _Ty2,
 class... _Ty>
 struct common_type<_Ty1, _Ty2, _Ty...>
 : _Common_type_rec<_Ty1, _Ty2, _Ty...>::type
 {
 };




template<class _Ty,
 _Ty... _Vals>
 struct integer_sequence
 {
 static_assert(is_integral<_Ty>::value, "integer_sequence<T, I...> requires T to be an integral type.");


 typedef integer_sequence<_Ty, _Vals...> type;
 typedef _Ty value_type;

 static constexpr size_t size() noexcept
  {
  return (sizeof...(_Vals));
  }
 };


template<bool _Negative,
 bool _Zero,
 class _Int_con,
 class _Int_seq>
 struct _Make_seq
 {
 static_assert(!_Negative, "make_integer_sequence<T, N> requires N to be non-negative.");

 };

template<class _Ty,
 _Ty... _Vals>
 struct _Make_seq<false, true,
  integral_constant<_Ty, 0>,
  integer_sequence<_Ty, _Vals...> >
  : integer_sequence<_Ty, _Vals...>
 {
 };

template<class _Ty,
 _Ty _Ix,
 _Ty... _Vals>
 struct _Make_seq<false, false,
  integral_constant<_Ty, _Ix>,
  integer_sequence<_Ty, _Vals...> >
  : _Make_seq<false, _Ix == 1,
   integral_constant<_Ty, _Ix - 1>,
   integer_sequence<_Ty, _Ix - 1, _Vals...> >
 {
 };


template<class _Ty,
 _Ty _Size>
 using make_integer_sequence = typename _Make_seq<_Size < 0, _Size == 0,
  integral_constant<_Ty, _Size>, integer_sequence<_Ty> >::type;

template<size_t... _Vals>
 using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
 using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
 using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 2480 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct identity
 {
 typedef _Ty type;

 const _Ty& operator()(const _Ty& _Left) const
  {
  return (_Left);
  }
 };


template<class _Ty> inline
 constexpr _Ty&& forward(
  remove_reference_t<_Ty>& _Arg) noexcept
 {
 return (static_cast<_Ty&&>(_Arg));
 }

template<class _Ty> inline
 constexpr _Ty&& forward(
  remove_reference_t<_Ty>&& _Arg) noexcept
 {
 static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
 return (static_cast<_Ty&&>(_Arg));
 }


template<class _Ty> inline
 constexpr remove_reference_t<_Ty>&&
  move(_Ty&& _Arg) noexcept
 {
 return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename remove_reference<_Ty>::type&&
  _Move(_Ty&& _Arg) noexcept
 {
 return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
  && is_copy_constructible<_Ty>::value,
   const _Ty&, _Ty&&>::type
 move_if_noexcept(_Ty& _Arg) noexcept
 {
 return (::std:: move(_Arg));
 }


template<class _Ty> inline
 decay_t<_Ty> _Decay_copy(_Ty&& _Arg)
 {
 return (::std:: forward<_Ty>(_Arg));
 }


template<class...>
 struct _Param_tester
 {
 typedef void type;
 };

template<class _Ty>
 class reference_wrapper;

template<class _Ty>
 struct _Is_reference_wrapper
  : false_type
 {
 };

template<class _Ty>
 struct _Is_reference_wrapper<reference_wrapper<_Ty>>
  : true_type
 {
 };


struct _Invoker_pmf_object
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmf_pointer
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmf_reference_wrapper
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return ((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmd_object
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd))
  -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd)
  {
  return (::std:: forward<_Ty1>(_Arg1).*_Pmd);
  }
 };

struct _Invoker_pmd_pointer
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd))
  -> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)
  {
  return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd);
  }
 };

struct _Invoker_pmd_reference_wrapper
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd))
  -> decltype(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)
  {
  return (::std:: forward<_Ty1>(_Arg1).get().*_Pmd);
  }
 };

struct _Invoker_functor
 {
 template<class _Callable,
  class... _Types>
  static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args)
  noexcept(noexcept(::std:: forward<_Callable>(_Obj)( ::std:: forward<_Types>(_Args)...)))

  -> decltype(::std:: forward<_Callable>(_Obj)(
   ::std:: forward<_Types>(_Args)...))
  {
  return (::std:: forward<_Callable>(_Obj)(
   ::std:: forward<_Types>(_Args)...));
  }
 };

template<class _Callable,
 class _Ty1,
 class _Decayed = decay_t<_Callable>,
 bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
 bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
 struct _Invoker1;

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
  : _If<is_base_of<
   typename _Is_memfunptr<_Decayed>::_Class_type,
   decay_t<_Ty1> >::value,
  _Invoker_pmf_object,
  typename _If<_Is_reference_wrapper<decay_t<_Ty1>>::value,
  _Invoker_pmf_reference_wrapper,
  _Invoker_pmf_pointer>::type>::type
 {
 };

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
  : _If<is_base_of<
   typename _Is_member_object_pointer<_Decayed>::_Class_type,
   decay_t<_Ty1> >::value,
  _Invoker_pmd_object,
  typename _If<_Is_reference_wrapper<decay_t<_Ty1>>::value,
  _Invoker_pmd_reference_wrapper,
  _Invoker_pmd_pointer>::type>::type
 {
 };

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
  : _Invoker_functor
 {
 };

template<class _Callable,
 class... _Types>
 struct _Invoker;

template<class _Callable>
 struct _Invoker<_Callable>
  : _Invoker_functor
 {
 };

template<class _Callable,
 class _Ty1,
 class... _Types2>
 struct _Invoker<_Callable, _Ty1, _Types2...>
  : _Invoker1<_Callable, _Ty1>
 {
 };
# 2740 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Callable,
 class... _Types> inline
 constexpr auto _Invoke1(_Callable&& _Obj, _Types&&... _Args)
 noexcept(noexcept((_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))))

 -> decltype(_Invoker<_Callable, _Types...>::_Call(
  ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))
 {
 return (_Invoker<_Callable, _Types...>::_Call(
  ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));
 }

template<class _Rx,
 bool = is_void<_Rx>::value>
 struct _Forced
 {
 };

struct _Unforced
 {
 };

template<class _Cv_void,
 class... _Valtys> inline
 void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
 {
 ::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...);
 }

template<class _Rx,
 class... _Valtys> inline
 _Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
 {
 return (::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...));
 }

template<class... _Valtys> inline
 auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
 -> decltype(::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...))
 {
 return (::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...));
 }


template<class _Void,
 class _Func,
 class... _Types>
 struct _Invoke_result
 {
 };

template<class _Func,
 class... _Types>
 struct _Invoke_result<decltype(void(_Invoker<_Func, _Types...>::_Call(::std:: declval<_Func>(),
  ::std:: declval<_Types>()...))), _Func, _Types...>
 {
 typedef decltype(_Invoker<_Func, _Types...>::_Call(::std:: declval<_Func>(),
  ::std:: declval<_Types>()...)) type;
 };
# 2810 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty,
 class = void>
 struct _Weak_result_type
 {
 };

template<class _Ty>
 struct _Weak_result_type<_Ty, typename _Param_tester<
  typename _Ty::result_type>::type>
 {
 typedef typename _Ty::result_type result_type ;
 };

template<class _Ty,
 class = void>
 struct _Weak_argument_type
  : _Weak_result_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_argument_type<_Ty, typename _Param_tester<
  typename _Ty::argument_type>::type>
  : _Weak_result_type<_Ty>
 {
 typedef typename _Ty::argument_type argument_type ;
 };

template<class _Ty,
 class = void>
 struct _Weak_binary_args
  : _Weak_argument_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_binary_args<_Ty, typename _Param_tester<
  typename _Ty::first_argument_type,
  typename _Ty::second_argument_type>::type>
  : _Weak_argument_type<_Ty>
 {
 typedef typename _Ty::first_argument_type first_argument_type ;
 typedef typename _Ty::second_argument_type second_argument_type ;
 };

template<class _Ty>
 struct _Weak_types
 {
 typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
 typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
 typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
  typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
  _Weak_binary_args<_Ty> >::type>::type type;
 };


template<class _Ty>
 class reference_wrapper
  : public _Weak_types<_Ty>::type
 {
public:
 static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
  "reference_wrapper<T> requires T to be an object type "
  "or a function type.");

 typedef _Ty type;

 reference_wrapper(_Ty& _Val) noexcept
  : _Ptr(::std:: addressof(_Val))
  {
  }

 operator _Ty&() const noexcept
  {
  return (*_Ptr);
  }

 _Ty& get() const noexcept
  {
  return (*_Ptr);
  }

 template<class... _Types>
  auto operator()(_Types&&... _Args) const
  -> decltype(_Invoke1(this->get(), ::std:: forward<_Types>(_Args)...))
  {
  return (_Invoke1(get(), ::std:: forward<_Types>(_Args)...));
  }

 reference_wrapper(_Ty&&) = delete;

private:
 _Ty *_Ptr;
 };


template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(_Ty& _Val) noexcept
 {
 return (reference_wrapper<_Ty>(_Val));
 }

template<class _Ty>
 void ref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: ref(_Val.get()));
 }

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(const _Ty& _Val) noexcept
 {
 return (reference_wrapper<const _Ty>(_Val));
 }

template<class _Ty>
 void cref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: cref(_Val.get()));
 }


template<class _Ty>
 struct _Unrefwrap_helper
 {
 typedef _Ty type;
 static const bool _Is_refwrap = false;
 };

template<class _Ty>
 struct _Unrefwrap_helper<reference_wrapper<_Ty> >
 {
 typedef _Ty& type;
 static const bool _Is_refwrap = true;
 };

template<class _Ty>
 struct _Unrefwrap
 {
 typedef decay_t<_Ty> _Ty1;
 typedef typename _Unrefwrap_helper<_Ty1>::type type;
 static const bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
 };


template<bool _Is_ref,
 class _Ty>
 struct _Rerefwrap
 {
 static _Ty _Apply(_Ty _Arg)
  {
  return (_Arg);
  }
 };

template<class _Ty>
 struct _Rerefwrap<true, _Ty>
 {
 static auto _Apply(_Ty _Arg) -> decltype(::std:: ref(_Arg))
  {
  return (::std:: ref(_Arg));
  }
 };


template<class _Ty>
 struct _Result_of_success
 {
 typedef _Ty type;
 };

struct _Result_of_fail
 {
 };

template<class _Ty0,
 class _Ty1>
 struct _Is_same_or_base_of;

template<class _Ret,
 class _Ty0,
 class _Ty1>
 struct _Is_same_or_base_of<_Ret _Ty0::*, _Ty1>
  : public integral_constant<bool, is_same<_Ty0, _Ty1>::value || is_base_of<_Ty0, _Ty1>::value>
 {
 };

template<bool,
 bool,
 class _Fty,
 class... _Args>
 struct _Result_of
 {
 typedef _Result_of_fail type;
 };

template<bool,
 class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf;

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf<true, _Fty, _Arg0, _Args...>
 {
 private:
 template<class _Ufty, class _Uarg0, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype((declval<_Uarg0>().*declval<_Ufty>())(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0, _Args...>(0)) type;
 };

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf<false, _Fty, _Arg0, _Args...>
 {
 private:
 template<class _Ufty, class _Uarg0, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype(((*declval<_Uarg0>()).*declval<_Ufty>())(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0, _Args...>(0)) type;
 };

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of<true, false, _Fty, _Arg0, _Args...>
 {
 typedef typename _Result_of_pmf<
  _Is_same_or_base_of<typename decay<_Fty>::type,
   typename remove_cv<typename remove_reference<_Arg0>::type>::type>::value,
  _Fty, _Arg0, _Args...>::type type;
 };

template<bool,
 class _Fty,
 class _Arg0>
 struct _Result_of_pmd;

template<class _Fty,
 class _Arg0>
 struct _Result_of_pmd<true, _Fty, _Arg0>
 {
 private:
 template<class _Ufty, class _Uarg0>
 static auto _Fn(int) -> _Result_of_success<decltype(declval<_Uarg0>().*declval<_Ufty>())>;

 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0>(0)) type;
 };

template<class _Fty,
 class _Arg0>
 struct _Result_of_pmd<false, _Fty, _Arg0>
 {
 private:
 template<class _Ufty, class _Uarg0>
 static auto _Fn(int) -> _Result_of_success<decltype((*declval<_Uarg0>()).*declval<_Ufty>())>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0>(0)) type;
 };

template<class _Fty,
 class _Arg0>
 struct _Result_of<false, true, _Fty, _Arg0>
 {
 typedef typename _Result_of_pmd<
  _Is_same_or_base_of<typename decay<_Fty>::type,
   typename remove_cv<typename remove_reference<_Arg0>::type>::type>::value,
  _Fty, _Arg0>::type type;
 };

template<class _Fty,
 class... _Args>
 struct _Result_of<false, false, _Fty, _Args...>
 {
 private:
 template<class _Ufty, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype(declval<_Ufty>()(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;
 public:
 typedef decltype(_Fn<_Fty, _Args...>(0)) type;
 };

template<class _Fty>
 struct result_of;
# 3131 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Fty,
 class... _Args>
 struct result_of<_Fty(_Args...)>
 : public _Result_of<
  is_member_function_pointer<typename remove_reference<_Fty>::type>::value,
  is_member_object_pointer<typename remove_reference<_Fty>::type>::value,
  _Fty, _Args...>::type
 {
 };

template<class _Fty,
 class... _Args>
 struct result_of<reference_wrapper<_Fty>(_Args...)>
 : public _Result_of<
  is_member_function_pointer<typename remove_reference<_Fty>::type>::value,
  is_member_object_pointer<typename remove_reference<_Fty>::type>::value,
  _Fty, _Args...>::type
 {
 };
# 3487 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_final
  : _Cat_base<__is_final(_Ty)>
 {
 };
# 3538 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
 using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
 using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
 using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
 using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
 using add_cv_t = typename add_cv<_Ty>::type;




template<class _Ty>
 using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
 using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
 using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
 using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
 using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
 using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
 using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
 using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
 size_t _Align = _Aligned<_Len, max_align_t, __alignof__(max_align_t) <= _Len>::value>
 using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
 class... _Types>
 using aligned_union_t = typename aligned_union<_Len, _Types...>::type;





template<bool _Test,
 class _Ty1,
 class _Ty2>
 using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
 using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
 using underlying_type_t = typename underlying_type<_Ty>::type;







template<class _Ty>
 using result_of_t = typename result_of<_Ty>::type;
# 3879 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xxexception" 2 3

namespace std {

extern "C" {
 void *__cxa_current_primary_exception(void) throw();
 void __cxa_rethrow_primary_exception(void *);
 void __cxa_increment_exception_refcount(void *) throw();
 void __cxa_decrement_exception_refcount(void *) throw();
}






class exception_ptr {
 void *_exptr_;

 friend void rethrow_exception(exception_ptr e);
 friend exception_ptr current_exception() noexcept;
public:
 exception_ptr(void *p = nullptr) noexcept
  : _exptr_(p)
 {
 }

 exception_ptr(const exception_ptr& rhs) noexcept
  : _exptr_(rhs._exptr_)
 {
  __cxa_increment_exception_refcount(_exptr_);
 }

 ~exception_ptr()
 {
  __cxa_decrement_exception_refcount(_exptr_);
 }

 exception_ptr& operator=(const exception_ptr& rhs)
 {
  __cxa_increment_exception_refcount(rhs._exptr_);
  __cxa_decrement_exception_refcount(_exptr_);
  _exptr_ = rhs._exptr_;
  return *this;
 }

 friend bool operator==(const exception_ptr& lhs, const exception_ptr& rhs)
 {
  return lhs._exptr_ == rhs._exptr_;
 }

 friend bool operator!=(const exception_ptr& lhs, const exception_ptr& rhs)
 {
  return lhs._exptr_ != rhs._exptr_;
 }

 explicit operator bool() const
 {
  return _exptr_ != nullptr;
 }
};


inline exception_ptr current_exception() noexcept
 {
 exception_ptr e;
 e._exptr_ = __cxa_current_primary_exception();
 return e;
 }

inline void rethrow_exception(exception_ptr e) __attribute__((__noreturn__));
inline void rethrow_exception(exception_ptr e)
 {
 __cxa_rethrow_primary_exception(e._exptr_);
 terminate();
 }
}

namespace std {

template<class _Excep> inline
 exception_ptr make_exception_ptr(_Excep _Ex) noexcept
 {
 {{
 ::std:: _Throw(_Ex);
 } if (0) {
 return (current_exception());
 }}
 return (exception_ptr());
 }


class nested_exception
 {
public:
 nested_exception() noexcept
  : _Myptr(current_exception())
  {
  }

 nested_exception(const nested_exception& _Right) = default;

 nested_exception& operator=(
  const nested_exception& _Right) = default;

 virtual ~nested_exception() noexcept;

 exception_ptr nested_ptr() const noexcept
  {
  return (_Myptr);
  }

 __attribute__((__noreturn__)) void rethrow_nested() const
  {
  rethrow_exception(_Myptr);
  }

private:
 exception_ptr _Myptr;
 };


template<class _Ty>
 struct _Wrapped_with_nested
  : _Ty, nested_exception
 {
 explicit _Wrapped_with_nested(const _Ty& _Val)
  : _Ty((_Val))
  {
  }
 };

template<class _Ty> inline
 void _Throw_with_nested(_Ty&& _Val,
  typename enable_if<is_class<typename remove_reference<_Ty>::type>::value
   && !is_base_of<nested_exception, typename remove_reference<_Ty>::type>::value
   >::type* = 0)
 {
                                                                                        ;
 }

template<class _Ty> inline
 void _Throw_with_nested(_Ty&& _Val,
  typename enable_if<!is_class<typename remove_reference<_Ty>::type>::value
   || is_base_of<nested_exception, typename remove_reference<_Ty>::type>::value
   >::type* = 0)
 {
                            ;
 }

template<class _Ty> inline
 void throw_with_nested(_Ty&& _Val) __attribute__((__noreturn__));
template<class _Ty> inline
 void throw_with_nested(_Ty&& _Val)
 {
 _Throw_with_nested(_Val);
 }


template<class _Ex> inline
 void _Rethrow_if_nested(const _Ex& _Val,
  typename enable_if<is_polymorphic<_Ex>::value>::type* = 0)
 {
 const nested_exception *e = dynamic_cast<const nested_exception *>(&_Val);
 if (e)
  e->rethrow_nested();
 }

template<class _Ex> inline
 void _Rethrow_if_nested(const _Ex& _Val,
  typename enable_if<!is_polymorphic<_Ex>::value>::type* = 0)
 {
 }

template<class _Ex> inline
 void rethrow_if_nested(const _Ex& _Val)
 {
 _Rethrow_if_nested(_Val);
 }
}
# 183 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 2 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 2 3
# 35 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 3
namespace std {
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 3
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t; using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t; using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;


using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
# 112 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 2 3

 extern "C" {
# 132 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 3
void _Feraise(int);

typedef union
 {
 unsigned short _Word[8];
 float _Float;
 double _Double;
 long double _Long_double;
 } _Dconst;


double _Cosh(double, double);
short _Dtest(double *);
double _Sinh(double, double);
double _Divide(double, double);
short _Exp(double *, double, long);
double _Log(double, int);
double _Recip(double);
double _Sinx(double, unsigned int);
double _Sin(double, unsigned int, int);
int __fpclassifyd(double);
int __isfinite(double);
int __isinf(double);
int __isnan(double);
int __isnormal(double);
int __signbit(double);

extern const _Dconst _Denorm, _Hugeval, _Inf,
 _Nan, _Snan;


float _FCosh(float, float);
short _FDtest(float *);
float _FSinh(float, float);
float _FDivide(float, float);
short _FExp(float *, float, long);
float _FLog(float, int);
float _FRecip(float);
float _FSinx(float, unsigned int);
float _FSin(float, unsigned int, int);
int __fpclassifyf(float);
int __isfinitef(float);
int __isinff(float);
int __isnanf(float);
int __isnormalf(float);
int __signbitf(float);

extern const _Dconst _FDenorm, _FInf, _FNan, _FSnan;


long double _LCosh(long double, long double);
short _LDtest(long double *);
long double _LSinh(long double, long double);
long double _LDivide(long double, long double);
short _LExp(long double *, long double, long);
long double _LLog(long double, int);
long double _LRecip(long double);
long double _LSinx(long double, unsigned int);
long double _LSin(long double, unsigned int, int);
int __fpclassifyl(long double);
int __isfinitel(long double);
int __isinfl(long double);
int __isnanl(long double);
int __isnormall(long double);
int __signbitl(long double);

extern const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
# 210 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cfloat" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cfloat" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\float.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\float.h" 3
typedef struct
 {
 int _Ddig, _Dmdig, _Dmax10e, _Dmaxe, _Dmin10e, _Dmine;
 union
  {
  unsigned short _Us[8];
  float _Float;
  double _Double;
  long double _Long_double;
  } _Deps, _Dmax, _Dmin;
 } _Dvals;



extern "C" {
int _Fltrounds(void);
extern const _Dvals _Dbl, _Flt, _Hlf, _Ldbl;
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cfloat" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\climits" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 1 3
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtgmath.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtgmath.h" 3
namespace std {
template<class _Ty>
 struct _Promote_to_float
 {
 typedef typename conditional<is_same<_Ty, long double>::value,
 long double,
 typename conditional<is_same<_Ty, double>::value
  || is_integral<_Ty>::value, double,
  float>::type>::type type;
 };

template<class _Ty1,
 class _Ty2>
 struct _Common_float_type
 {
 typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
 typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
 typedef typename conditional<is_same<_Ty1f, long double>::value
  || is_same<_Ty2f, long double>::value, long double,
  typename conditional<is_same<_Ty1f, double>::value
   || is_same<_Ty2f, double>::value, double,
   float>::type>::type type;
 };
}
# 81 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtgmath.h" 3
extern "C" double pow(double, double);
float pow(float, float);
long double pow(long double, long double);

template<class _Ty1,
 class _Ty2> inline
 typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
  && ::std:: is_arithmetic<_Ty2>::value,
  typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
 pow(const _Ty1 _Left, const _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: pow(type(_Left), type(_Right)));
 }


extern "C" double acos(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C" double asin(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C" double atan(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C" double atan2( double, double); float atan2(float, float); long double atan2(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" double ceil(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C" double cos(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C" double cosh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C" double exp(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }
extern "C" double fabs(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }
extern "C" double floor(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C" double fmod( double, double); float fmod(float, float); long double fmod(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" double frexp(double, int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left, int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" double ldexp(double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left, int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C" double log(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C" double log10(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C" double sin(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C" double sinh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C" double sqrt(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C" double tan(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C" double tanh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }
# 130 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtgmath.h" 3
extern "C" double fma(double, double, double);
float fma(float, float, float);
long double fma(long double, long double, long double);




template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (:: fma((type)_Left, (type)_Middle, (type)_Right));
 }

template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 hypot3(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (:: hypot3((type)_Left, (type)_Middle, (type)_Right));
 }

extern "C" double remquo(double, double, int *);
float remquo(float, float, int *);
long double remquo(long double, long double, int *);



template<class _Ty1,
 class _Ty2> inline
 typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
 remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: remquo((type)_Left, (type)_Right, _Pquo));
 }

extern "C" double acosh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C" double asinh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C" double atanh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C" double cbrt(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C" double copysign( double, double); float copysign(float, float); long double copysign(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C" double erf(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C" double erfc(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C" double expm1(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C" double exp2(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C" double fdim( double, double); float fdim(float, float); long double fdim(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C" double fmax( double, double); float fmax(float, float); long double fmax(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C" double fmin( double, double); float fmin(float, float); long double fmin(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C" double hypot( double, double); float hypot(float, float); long double hypot(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }

extern "C" int ilogb(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C" double lgamma(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C" long long llrint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C" long long llround(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C" double log1p(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C" double log2(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C" double logb(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C" long lrint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C" long lround(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C" double nearbyint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C" double nextafter( double, double); float nextafter(float, float); long double nextafter(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C" double nexttoward(double, long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left, long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C" double remainder( double, double); float remainder(float, float); long double remainder(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C" double rint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C" double round(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C" double scalbln(double, long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left, long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C" double scalbn(double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left, int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C" double tgamma(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C" double trunc(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 2 3
# 62 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
typedef float float_t;
typedef double double_t;
# 110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
extern "C" {
int _FFpcomp(float, float);
int _Fpcomp(double, double);
int _LFpcomp(long double, long double);

int _FDclass(float);
int _Dclass(double);
int _LDclass(long double);

int _FDsign(float);
int _Dsign(double);
int _LDsign(long double);
}



inline int _FPCOMP(float _Left, float _Right)
 {
 return (_FFpcomp(_Left, _Right));
 }

inline int _FPCOMP(double _Left, double _Right)
 {
 return (_Fpcomp(_Left, _Right));
 }

inline int _FPCOMP(long double _Left, long double _Right)
 {
 return (_LFpcomp(_Left, _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 int _FPCOMP(_Ty1 _Left, _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (_FPCOMP((type)_Left, (type)_Right));
 }


inline int fpclassify(float _Left)
 {
 return (__fpclassifyf(_Left));
 }

inline int fpclassify(double _Left)
 {
 return (__fpclassifyd(_Left));
 }

inline int fpclassify(long double _Left)
 {
 return (__fpclassifyl(_Left));
 }

template<class _Ty> inline
 int fpclassify(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: fpclassify((type)_Left));
 }


inline bool signbit(float _Left)
 {
 return (__signbitf(_Left) != 0);
 }

inline bool signbit(double _Left)
 {
 return (__signbit(_Left) != 0);
 }

inline bool signbit(long double _Left)
 {
 return (__signbitl(_Left) != 0);
 }

template<class _Ty> inline
 bool signbit(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: signbit((type)_Left));
 }


inline bool isfinite(float _Left)
 {
 return (__isfinitef(_Left) != 0);
 }

inline bool isfinite(double _Left)
 {
 return (__isfinite(_Left) != 0);
 }

inline bool isfinite(long double _Left)
 {
 return (__isfinitel(_Left) != 0);
 }

template<class _Ty> inline
 bool isfinite(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isfinite((type)_Left));
 }


inline bool isinf(float _Left)
 {
 return (__isinff(_Left) != 0);
 }

inline bool isinf(double _Left)
 {
 return (__isinf(_Left) != 0);
 }

inline bool isinf(long double _Left)
 {
 return (__isinfl(_Left) != 0);
 }

template<class _Ty> inline
 bool isinf(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isinf((type)_Left));
 }


inline bool isnan(float _Left)
 {
 return (__isnanf(_Left) != 0);
 }

inline bool isnan(double _Left)
 {
 return (__isnan(_Left) != 0);
 }

inline bool isnan(long double _Left)
 {
 return (__isnanl(_Left) != 0);
 }

template<class _Ty> inline
 bool isnan(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isnan((type)_Left));
 }


inline bool isnormal(float _Left)
 {
 return (__isnormalf(_Left) != 0);
 }

inline bool isnormal(double _Left)
 {
 return (__isnormal(_Left) != 0);
 }

inline bool isnormal(long double _Left)
 {
 return (__isnormall(_Left) != 0);
 }

template<class _Ty> inline
 bool isnormal(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isnormal((type)_Left));
 }


template<class _Ty1, class _Ty2> inline
 bool isgreater(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & 4) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isgreaterequal(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (2 | 4)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isless(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & 1) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool islessequal(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (1 | 2)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool islessgreater(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (1 | 4)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isunordered(_Ty1 _Left, _Ty2 _Right)
 {
 return (_FPCOMP(_Left, _Right) == 0);
 }
# 528 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
extern "C" {

double acos(double);
double asin(double);
double atan(double);
double atan2(double, double);
double ceil(double);
double cos(double);
double exp(double);
double fabs(double);
double floor(double);
double fmod(double, double);
double frexp(double, int *);
double ldexp(double, int);
double log(double);
double log10(double);
double modf(double, double *);
double pow(double, double);
double sin(double);
void sincos(double, double *, double *);
double sqrt(double);
double tan(double);
double tanh(double);


double acosh(double);
double asinh(double);
double atanh(double);
double cbrt(double);
double copysign(double, double);
double erf(double);
double erfc(double);
double exp2(double);
double expm1(double);
double fdim(double, double);
double fma(double, double, double);
double fmax(double, double);
double fmin(double, double);
double hypot(double, double);
double hypot3(double, double, double);
int ilogb(double);
double lgamma(double);
long long llrint(double);
long long llround(double);
double log1p(double);
double log2(double);
double logb(double);
long lrint(double);
long lround(double);
double nan(const char *);
double nearbyint(double);
double nextafter(double, double);
double nexttoward(double, long double);
double remainder(double, double);
double remquo(double, double, int *);
double rint(double);
double round(double);
double scalbn(double, int);
double scalbln(double, long);
double tgamma(double);
double trunc(double);
# 635 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
double gamma(double x);
double gamma_r(double x, int *signgamp);
double j0(double x);
double y0(double x);
double j1(double x);
double y1(double x);
double jn(int n, double x);
double yn(int n, double x);
double lgamma_r(double x, int *signgamp);
double scalb(double x, int fn);
double drem(double x, double y);




float acosf(float);
float asinf(float);
float atanf(float);
float atan2f(float, float);
float ceilf(float);
float cosf(float);
float expf(float);
float fabsf(float);
float floorf(float);
float fmodf(float, float);
float frexpf(float, int *);
float ldexpf(float, int);
float logf(float);
float log10f(float);
float modff(float, float *);
float powf(float, float);
void sincosf(float, float *, float *);
float sinf(float);
float sqrtf(float);
float tanf(float);
float tanhf(float);


float acoshf(float);
float asinhf(float);
float atanhf(float);
float cbrtf(float);
float copysignf(float, float);
float erff(float);
float erfcf(float);
float expm1f(float);
float exp2f(float);
float fdimf(float, float);
float fmaf(float, float, float);
float fmaxf(float, float);
float fminf(float, float);
float hypotf(float, float);
float hypot3f(float, float, float);
int ilogbf(float);
float lgammaf(float);
long long llrintf(float);
long long llroundf(float);
float log1pf(float);
float log2f(float);
float logbf(float);
long lrintf(float);
long lroundf(float);
float nanf(const char *);
float nearbyintf(float);
float nextafterf(float, float);
float nexttowardf(float, long double);
float remainderf(float, float);
float remquof(float, float, int *);
float rintf(float);
float roundf(float);
float scalbnf(float, int);
float scalblnf(float, long);
float tgammaf(float);
float truncf(float);
# 755 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
float gammaf(float x);
float gammaf_r(float x, int *signgamp);
float j0f(float x);
float y0f(float x);
float j1f(float x);
float y1f(float x);
float jnf(int n, float x);
float ynf(int n, float x);
float lgammaf_r(float x, int *signgamp);
float scalbf(float x, int fn);
float dremf(float x, float y);




long double acosl(long double);
long double asinl(long double);
long double atanl(long double);
long double atan2l(long double, long double);
long double ceill(long double);
long double cosl(long double);
long double expl(long double);
long double fabsl(long double);
long double floorl(long double);
long double fmodl(long double, long double);
long double frexpl(long double, int *);
long double ldexpl(long double, int);
long double logl(long double);
long double log10l(long double);
long double modfl(long double, long double *);
long double powl(long double, long double);
long double sinl(long double);
long double sqrtl(long double);
long double tanl(long double);
long double tanhl(long double);


long double acoshl(long double);
long double asinhl(long double);
long double atanhl(long double);
long double cbrtl(long double);
long double copysignl(long double, long double);
long double erfl(long double);
long double erfcl(long double);
long double exp2l(long double);
long double expm1l(long double);
long double fdiml(long double, long double);
long double fmal(long double, long double, long double);
long double fmaxl(long double, long double);
long double fminl(long double, long double);
long double hypotl(long double, long double);
long double hypot3l(long double, long double, long double);
int ilogbl(long double);
long double lgammal(long double);
long long llrintl(long double);
long long llroundl(long double);
long double log1pl(long double);
long double log2l(long double);
long double logbl(long double);
long lrintl(long double);
long lroundl(long double);
long double nanl(const char *);
long double nearbyintl(long double);
long double nextafterl(long double, long double);
long double nexttowardl(long double, long double);
long double remainderl(long double, long double);
long double remquol(long double, long double, int *);
long double rintl(long double);
long double roundl(long double);
long double scalbnl(long double, int);
long double scalblnl(long double, long);
long double tgammal(long double);
long double truncl(long double);
# 873 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
inline double cosh(double _Left)
 {
 return (:: _Cosh(_Left, 1.0));
 }

inline double sinh(double _Left)
 {
 return (:: _Sinh(_Left, 1.0));
 }


}



inline double abs(double _Left)
 {
 return (fabs(_Left));
 }


extern "C" {

inline float coshf(float _Left)
 {
 return (:: _FCosh(_Left, 1.0F));
 }

inline float sinhf(float _Left)
 {
 return (:: _FSinh(_Left, 1.0F));
 }

}

inline float abs(float _Left)
 {
 return (fabsf(_Left));
 }

inline float acos(float _Left)
 {
 return (acosf(_Left));
 }

inline float asin(float _Left)
 {
 return (asinf(_Left));
 }

inline float atan(float _Left)
 {
 return (atanf(_Left));
 }

inline float atan2(float _Left, float _Right)
 {
 return (atan2f(_Left, _Right));
 }

inline float ceil(float _Left)
 {
 return (ceilf(_Left));
 }

inline float cos(float _Left)
 {
 return (cosf(_Left));
 }

inline float cosh(float _Left)
 {
 return (:: _FCosh(_Left, 1.0F));
 }

inline float exp(float _Left)
 {
 return (expf(_Left));
 }

inline float fabs(float _Left)
 {
 return (fabsf(_Left));
 }

inline float floor(float _Left)
 {
 return (floorf(_Left));
 }

inline float fmod(float _Left, float _Right)
 {
 return (fmodf(_Left, _Right));
 }

inline float frexp(float _Left, int *_Right)
 {
 return (frexpf(_Left, _Right));
 }

inline float ldexp(float _Left, int _Right)
 {
 return (ldexpf(_Left, _Right));
 }

inline float log(float _Left)
 {
 return (logf(_Left));
 }

inline float log10(float _Left)
 {
 return (log10f(_Left));
 }

inline float modf(float _Left, float *_Right)
 {
 return (modff(_Left, _Right));
 }

inline float pow(float _Left, float _Right)
 {
 return (powf(_Left, _Right));
 }

inline float sin(float _Left)
 {
 return (sinf(_Left));
 }

inline float sinh(float _Left)
 {
 return (:: _FSinh(_Left, 1.0F));
 }

inline float sqrt(float _Left)
 {
 return (sqrtf(_Left));
 }

inline float tan(float _Left)
 {
 return (tanf(_Left));
 }

inline float tanh(float _Left)
 {
 return (tanhf(_Left));
 }


inline float acosh(float _Left)
 {
 return (acoshf(_Left));
 }

inline float asinh(float _Left)
 {
 return (asinhf(_Left));
 }

inline float atanh(float _Left)
 {
 return (atanhf(_Left));
 }

inline float cbrt(float _Left)
 {
 return (cbrtf(_Left));
 }

inline float copysign(float _Left, float _Right)
 {
 return (copysignf(_Left, _Right));
 }

inline float erf(float _Left)
 {
 return (erff(_Left));
 }

inline float erfc(float _Left)
 {
 return (erfcf(_Left));
 }

inline float exp2(float _Left)
 {
 return (exp2f(_Left));
 }

inline float expm1(float _Left)
 {
 return (expm1f(_Left));
 }

inline float fdim(float _Left, float _Right)
 {
 return (fdimf(_Left, _Right));
 }

inline float fma(float _Left, float _Right, float _Addend)
 {
 return (fmaf(_Left, _Right, _Addend));
 }

inline float fmax(float _Left, float _Right)
 {
 return (fmaxf(_Left, _Right));
 }

inline float fmin(float _Left, float _Right)
 {
 return (fminf(_Left, _Right));
 }

inline float hypot(float _Left, float _Right)
 {
 return (hypotf(_Left, _Right));
 }

inline float hypot3(float _Left, float _Mid, float _Right)
 {
 return (hypot3f(_Left, _Mid, _Right));
 }

inline int ilogb(float _Left)
 {
 return (ilogbf(_Left));
 }

inline float lgamma(float _Left)
 {
 return (lgammaf(_Left));
 }

inline long long llrint(float _Left)
 {
 return (llrintf(_Left));
 }

inline long long llround(float _Left)
 {
 return (llroundf(_Left));
 }

inline float log1p(float _Left)
 {
 return (log1pf(_Left));
 }

inline float log2(float _Left)
 {
 return (log2f(_Left));
 }

inline float logb(float _Left)
 {
 return (logbf(_Left));
 }

inline long lrint(float _Left)
 {
 return (lrintf(_Left));
 }

inline long lround(float _Left)
 {
 return (lroundf(_Left));
 }

inline float nearbyint(float _Left)
 {
 return (nearbyintf(_Left));
 }

inline float nextafter(float _Left, float _Right)
 {
 return (nextafterf(_Left, _Right));
 }

inline float nexttoward(float _Left, long double _Right)
 {
 return (nexttowardf(_Left, _Right));
 }

inline float remainder(float _Left, float _Right)
 {
 return (remainderf(_Left, _Right));
 }

inline float remquo(float _Left, float _Right, int *_Pval)
 {
 return (remquof(_Left, _Right, _Pval));
 }

inline float rint(float _Left)
 {
 return (rintf(_Left));
 }

inline float round(float _Left)
 {
 return (roundf(_Left));
 }

inline float scalbn(float _Left, int _Right)
 {
 return (scalbnf(_Left, _Right));
 }

inline float scalbln(float _Left, long _Right)
 {
 return (scalblnf(_Left, _Right));
 }

inline float tgamma(float _Left)
 {
 return (tgammaf(_Left));
 }

inline float trunc(float _Left)
 {
 return (truncf(_Left));
 }
# 1353 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
inline float gamma(float x)
{
  return gammaf(x);
}

inline float gamma_r(float x, int *signgamp)
{
  return gammaf_r(x, signgamp);
}

inline float j0(float x)
{
  return j0f(x);
}

inline float y0(float x)
{
  return y0f(x);
}

inline float j1(float x)
{
  return j1f(x);
}

inline float y1(float x)
{
  return y1f(x);
}

inline float jn(int n, float x)
{
  return jnf(n, x);
}

inline float yn(int n, float x)
{
  return ynf(n, x);
}

inline float lgamma_r(float x, int *signgamp)
{
  return lgammaf_r(x, signgamp);
}

inline float scalb(float x, int fn)
{
  return scalbf(x, fn);
}

inline float drem(float x, float y)
{
  return dremf(x, y);
}

inline void sincos(float _Left, float *_Psin, float *_Pcos)
{
  sincosf(_Left, _Psin, _Pcos);
}



extern "C" {

inline long double coshl(long double _Left)
 {
 return (:: _LCosh(_Left, 1.0L));
 }

inline long double sinhl(long double _Left)
 {
 return (:: _LSinh(_Left, 1.0L));
 }

}

inline long double abs(long double _Left)
 {
 return (fabsl(_Left));
 }

inline long double acos(long double _Left)
 {
 return (acosl(_Left));
 }

inline long double asin(long double _Left)
 {
 return (asinl(_Left));
 }

inline long double atan(long double _Left)
 {
 return (atanl(_Left));
 }

inline long double atan2(long double _Left, long double _Right)
 {
 return (atan2l(_Left, _Right));
 }

inline long double ceil(long double _Left)
 {
 return (ceill(_Left));
 }

inline long double cos(long double _Left)
 {
 return (cosl(_Left));
 }

inline long double cosh(long double _Left)
 {
 return (:: _LCosh(_Left, 1.0L));
 }

inline long double exp(long double _Left)
 {
 return (expl(_Left));
 }

inline long double fabs(long double _Left)
 {
 return (fabsl(_Left));
 }

inline long double floor(long double _Left)
 {
 return (floorl(_Left));
 }

inline long double fmod(long double _Left, long double _Right)
 {
 return (fmodl(_Left, _Right));
 }

inline long double frexp(long double _Left, int *_Right)
 {
 return (frexpl(_Left, _Right));
 }

inline long double ldexp(long double _Left, int _Right)
 {
 return (ldexpl(_Left, _Right));
 }

inline long double log(long double _Left)
 {
 return (logl(_Left));
 }

inline long double log10(long double _Left)
 {
 return (log10l(_Left));
 }

inline long double modf(long double _Left, long double *_Right)
 {
 return (modfl(_Left, _Right));
 }

inline long double pow(long double _Left, long double _Right)
 {
 return (powl(_Left, _Right));
 }

inline long double sin(long double _Left)
 {
 return (sinl(_Left));
 }

inline long double sinh(long double _Left)
 {
 return (:: _LSinh(_Left, 1.0L));
 }

inline long double sqrt(long double _Left)
 {
 return (sqrtl(_Left));
 }

inline long double tan(long double _Left)
 {
 return (tanl(_Left));
 }

inline long double tanh(long double _Left)
 {
 return (tanhl(_Left));
 }


inline long double acosh(long double _Left)
 {
 return (acoshl(_Left));
 }

inline long double asinh(long double _Left)
 {
 return (asinhl(_Left));
 }

inline long double atanh(long double _Left)
 {
 return (atanhl(_Left));
 }

inline long double cbrt(long double _Left)
 {
 return (cbrtl(_Left));
 }

inline long double copysign(long double _Left, long double _Right)
 {
 return (copysignl(_Left, _Right));
 }

inline long double erf(long double _Left)
 {
 return (erfl(_Left));
 }

inline long double erfc(long double _Left)
 {
 return (erfcl(_Left));
 }

inline long double exp2(long double _Left)
 {
 return (exp2l(_Left));
 }

inline long double expm1(long double _Left)
 {
 return (expm1l(_Left));
 }

inline long double fdim(long double _Left, long double _Right)
 {
 return (fdiml(_Left, _Right));
 }

inline long double fma(long double _Left, long double _Right,
 long double _Addend)
 {
 return (fmal(_Left, _Right, _Addend));
 }

inline long double fmax(long double _Left, long double _Right)
 {
 return (fmaxl(_Left, _Right));
 }

inline long double fmin(long double _Left, long double _Right)
 {
 return (fminl(_Left, _Right));
 }

inline long double hypot(long double _Left, long double _Right)
 {
 return (hypotl(_Left, _Right));
 }

inline long double hypot3(long double _Left, long double _Mid,
 long double _Right)
 {
 return (hypot3l(_Left, _Mid, _Right));
 }

inline int ilogb(long double _Left)
 {
 return (ilogbl(_Left));
 }

inline long double lgamma(long double _Left)
 {
 return (lgammal(_Left));
 }

inline long long llrint(long double _Left)
 {
 return (llrintl(_Left));
 }

inline long long llround(long double _Left)
 {
 return (llroundl(_Left));
 }

inline long double log1p(long double _Left)
 {
 return (log1pl(_Left));
 }

inline long double log2(long double _Left)
 {
 return (log2l(_Left));
 }

inline long double logb(long double _Left)
 {
 return (logbl(_Left));
 }

inline long lrint(long double _Left)
 {
 return (lrintl(_Left));
 }

inline long lround(long double _Left)
 {
 return (lroundl(_Left));
 }

inline long double nearbyint(long double _Left)
 {
 return (nearbyintl(_Left));
 }

inline long double nextafter(long double _Left, long double _Right)
 {
 return (nextafterl(_Left, _Right));
 }

inline long double nexttoward(long double _Left, long double _Right)
 {
 return (nexttowardl(_Left, _Right));
 }

inline long double remainder(long double _Left, long double _Right)
 {
 return (remainderl(_Left, _Right));
 }

inline long double remquo(long double _Left, long double _Right,
 int *_Pval)
 {
 return (remquol(_Left, _Right, _Pval));
 }

inline long double rint(long double _Left)
 {
 return (rintl(_Left));
 }

inline long double round(long double _Left)
 {
 return (roundl(_Left));
 }

inline long double scalbn(long double _Left, int _Right)
 {
 return (scalbnl(_Left, _Right));
 }

inline long double scalbln(long double _Left, long _Right)
 {
 return (scalblnl(_Left, _Right));
 }

inline long double tgamma(long double _Left)
 {
 return (tgammal(_Left));
 }

inline long double trunc(long double _Left)
 {
 return (truncl(_Left));
 }
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 2 3



namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2; using :: hypot;
using :: hypot3; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f; using :: hypotf;
using :: hypot3f; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l; using :: hypotl;
using :: hypot3l; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
# 191 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 3
using :: gamma;
using :: gamma_r;
using :: j0;
using :: y0;
using :: j1;
using :: y1;
using :: jn;
using :: yn;
using :: lgamma_r;
using :: scalb;
using :: drem;
using :: sincos;

using :: gammaf;
using :: gammaf_r;
using :: j0f;
using :: y0f;
using :: j1f;
using :: y1f;
using :: jnf;
using :: ynf;
using :: lgammaf_r;
using :: scalbf;
using :: dremf;
using :: sincosf;


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 2 3
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_mbstate_t.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_mbstate_t.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_mbstate_t.h" 2 3





typedef _Mbstatet mbstate_t;
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_wc.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_wc.h" 2 3





typedef _Sizet wctype_t;




typedef _Wintt wint_t;
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3
# 33 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 3
struct tm;
struct _Dnk_filet;







extern "C" {

wint_t fgetwc(_Filet *);
wchar_t *fgetws(wchar_t *, int,
 _Filet *);
wint_t fputwc(wchar_t, _Filet *);
int fputws(const wchar_t *,
 _Filet *);
int fwide(_Filet *, int);
int fwprintf(_Filet *,
 const wchar_t *, ...);
int fwscanf(_Filet *,
 const wchar_t *, ...);
wint_t getwc(_Filet *);
wint_t getwchar(void);
wint_t putwc(wchar_t, _Filet *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t *, size_t,
 const wchar_t *, ...);
int swscanf(const wchar_t *,
 const wchar_t *, ...);
wint_t ungetwc(wint_t, _Filet *);
int vfwprintf(_Filet *,
 const wchar_t *, _Va_list);
int vswprintf(wchar_t *, size_t,
 const wchar_t *, _Va_list);
int vwprintf(const wchar_t *, _Va_list);
int wprintf(const wchar_t *, ...);
int wscanf(const wchar_t *, ...);


int vfwscanf(_Filet *,
 const wchar_t *, _Va_list);
int vswscanf(const wchar_t *,
 const wchar_t *, _Va_list);
int vwscanf(const wchar_t *, _Va_list);



size_t mbrlen(const char *,
 size_t, mbstate_t *);
size_t mbrtowc(wchar_t *, const char *,
 size_t, mbstate_t *);
size_t mbsrtowcs(wchar_t *,
 const char **, size_t, mbstate_t *);
int mbsinit(const mbstate_t *);
size_t wcrtomb(char *,
 wchar_t, mbstate_t *);
size_t wcsrtombs(char *,
 const wchar_t **, size_t, mbstate_t *);
long wcstol(const wchar_t *,
 wchar_t **, int);


_Longlong wcstoll(const wchar_t *,
 wchar_t **, int);
_ULonglong wcstoull(const wchar_t *,
 wchar_t **, int);



wchar_t *wcscat(wchar_t *, const wchar_t *);
int wcscmp(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t *, const wchar_t *);
size_t wcslen(const wchar_t *);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t *,
 const wchar_t *, size_t);

int wcscoll(const wchar_t *, const wchar_t *);
size_t wcscspn(const wchar_t *, const wchar_t *);
wchar_t *wcsncat(wchar_t *,
 const wchar_t *, size_t);
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcstok(wchar_t *, const wchar_t *,
 wchar_t **);
size_t wcsxfrm(wchar_t *,
 const wchar_t *, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t *,
 const wchar_t *, size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);


size_t wcsftime(wchar_t *, size_t,
 const wchar_t *, const struct tm *);

wint_t _Btowc(int);
int _Wctob(wint_t);
double _WStod(const wchar_t *, wchar_t **, long);
float _WStof(const wchar_t *, wchar_t **, long);
long double _WStold(const wchar_t *, wchar_t **, long);
unsigned long _WStoul(const wchar_t *, wchar_t **, int);
}







extern "C" {
const wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
}

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_Str, wchar_t _Ch, size_t _Num)
 {
 return ((wchar_t *)wmemchr((const wchar_t *)_Str, _Ch, _Num));
 }
}
# 165 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcstod.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcstod.h" 3
extern "C" {
double wcstod(const wchar_t *, wchar_t **);

inline unsigned long wcstoul(const wchar_t * _Str,
 wchar_t ** _Endptr, int _Base)
 {return (:: _WStoul(_Str, _Endptr, _Base));
 }
}
# 166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwstr.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwstr.h" 3
extern "C" {
const wchar_t *wcschr(const wchar_t *, wchar_t);
const wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
const wchar_t *wcsrchr(const wchar_t *, wchar_t);
const wchar_t *wcsstr(const wchar_t *, const wchar_t *);
}

extern "C++" {
inline wchar_t *wcschr(wchar_t *_Str, wchar_t _Ch)
 {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch));
 }

inline wchar_t *wcspbrk(wchar_t *_Str1, const wchar_t *_Str2)
 {return ((wchar_t *)wcspbrk((const wchar_t *)_Str1, _Str2));
 }

inline wchar_t *wcsrchr(wchar_t *_Str, wchar_t _Ch)
 {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch));
 }

inline wchar_t *wcsstr(wchar_t *_Str1, const wchar_t *_Str2)
 {return ((wchar_t *)wcsstr((const wchar_t *)_Str1, _Str2));
 }
}

extern "C" {
inline wint_t btowc(int _By)
 {
 return (:: _Btowc(_By));
 }

inline int wctob(wint_t _Wc)
 {
 return (:: _Wctob(_Wc));
 }


float wcstof(const wchar_t *,
 wchar_t **);

inline long double wcstold(const wchar_t * _Str,
 wchar_t ** _Endptr)
 {
 return (:: _WStold(_Str, _Endptr, 0));
 }


}
# 167 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3


extern "C" {

int fwprintf_s(_Filet *,
 const wchar_t *, ...);
int fwscanf_s(_Filet *,
 const wchar_t *, ...);
int snwprintf_s(wchar_t *, rsize_t,
 const wchar_t *, ...);
int swprintf_s(wchar_t *, rsize_t,
 const wchar_t *, ...);
int swscanf_s(const wchar_t *,
 const wchar_t *, ...);
int vfwprintf_s(_Filet *,
 const wchar_t *,
 _Va_list);
int vfwscanf_s(_Filet *,
 const wchar_t *,
 _Va_list);
int vsnwprintf_s(wchar_t *, rsize_t,
 const wchar_t *,
 _Va_list);
int vswprintf_s(wchar_t *, rsize_t,
 const wchar_t *,
 _Va_list);
int vswscanf_s(const wchar_t *,
 const wchar_t *,
 _Va_list);
int vwprintf_s(const wchar_t *,
 _Va_list);
int vwscanf_s(const wchar_t *,
 _Va_list);
int wprintf_s(const wchar_t *, ...);
int wscanf_s(const wchar_t *, ...);

errno_t wcscpy_s(wchar_t *, rsize_t,
 const wchar_t *);
errno_t wcsncpy_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wmemcpy_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wmemmove_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wcscat_s(wchar_t *, rsize_t,
 const wchar_t *);
errno_t wcsncat_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
wchar_t *wcstok_s(wchar_t *, rsize_t *,
 const wchar_t *, wchar_t **);

size_t wcsnlen_s(const wchar_t *, size_t);

errno_t wcrtomb_s(size_t *,
 char *, rsize_t,
 wchar_t,
 mbstate_t *);
errno_t mbsrtowcs_s(size_t *,
 wchar_t *, rsize_t,
 const char **, rsize_t,
 mbstate_t *);
errno_t wcsrtombs_s(size_t *,
 char *, rsize_t,
 const wchar_t **, rsize_t,
 mbstate_t *);
}



extern "C++" {

template<rsize_t _Size>
errno_t mbsrtowcs_s(size_t *_Psize, wchar_t (&_Dst)[_Size], const char **_Src, rsize_t _Len, mbstate_t *_Ps)
 {
 return mbsrtowcs_s(_Psize, _Dst, _Size, _Src, _Len, _Ps);
 }

template<rsize_t _Size>
int swprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vswprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, va_list _Ap)
 {
 return vswprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
errno_t wcrtomb_s(size_t *_Psize, char (&_Str)[_Size], wchar_t _Wc, mbstate_t *_Ps)
 {
 return wcrtomb_s(_Psize, _Str, _Size, _Wc, _Ps);
 }

template<rsize_t _Size>
errno_t wcscat_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2)
 {
 return wcscat_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t wcscpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2)
 {
 return wcscpy_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t wcsncat_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wcsncat_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wcsncpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wcsncpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wcsrtombs_s(size_t *_Psize, char (&_Dst)[_Size], const wchar_t **_Src, rsize_t _Len, mbstate_t *_Ps)
 {
 return wcsrtombs_s(_Psize, _Dst, _Size, _Src, _Len, _Ps);
 }

template<rsize_t _Size>
int snwprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vsnwprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, va_list _Ap)
 {
 return vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<size_t _Size>
size_t wcsnlen_s(const wchar_t (&_Str)[_Size])
 {
 return wcsnlen_s(_Str, _Size);
 }

template<rsize_t _Size>
errno_t wmemcpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wmemcpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wmemmove_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wmemmove_s(_Str1, _Size, _Str2, _Num);
 }

}
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 2 3





namespace std {
using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
# 75 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 3
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3


namespace std {
# 78 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 3
typedef enum
 {
 denorm_indeterminate = -1,
 denorm_absent = 0,
 denorm_present = 1}
  float_denorm_style;


typedef enum
 {
 round_indeterminate = -1,
 round_toward_zero = 0,
 round_to_nearest = 1,
 round_toward_infinity = 2,
 round_toward_neg_infinity = 3}
  float_round_style;


struct _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static constexpr bool has_denorm_loss = (bool)(false);
 static constexpr bool has_infinity = (bool)(false);
 static constexpr bool has_quiet_NaN = (bool)(false);
 static constexpr bool has_signaling_NaN = (bool)(false);
 static constexpr bool is_bounded = (bool)(false);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(false);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr bool is_specialized = (bool)(false);
 static constexpr bool tinyness_before = (bool)(false);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
 static constexpr int digits = (int)(0);
 static constexpr int digits10 = (int)(0);
 static constexpr int max_digits10 = (int)(0);

 static constexpr int max_exponent = (int)(0);
 static constexpr int max_exponent10 = (int)(0);
 static constexpr int min_exponent = (int)(0);
 static constexpr int min_exponent10 = (int)(0);
 static constexpr int radix = (int)(0);
 };


template<class _Ty>
 class numeric_limits
  : public _Num_base
 {
public:
 static constexpr _Ty (min)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty (max)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty lowest() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty round_error() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty infinity() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (_Ty());
  }
 };

template<class _Ty>
 class numeric_limits<const _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<const volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };


struct _Num_int_base
 : public _Num_base
 {
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(true);
 static constexpr bool is_integer = (bool)(true);
 static constexpr bool is_modulo = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr int radix = (int)(2);
 };


struct _Num_float_base
 : public _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static constexpr bool has_denorm_loss = (bool)(false);
 static constexpr bool has_infinity = (bool)(true);
 static constexpr bool has_quiet_NaN = (bool)(true);
 static constexpr bool has_signaling_NaN = (bool)(true);
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(true);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr bool tinyness_before = (bool)(true);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
 static constexpr int radix = (int)(2);
 };


struct _Num_ldbl_base
 : public _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
 static constexpr bool has_denorm_loss = (bool)(true);
 static constexpr bool has_infinity = (bool)(true);
 static constexpr bool has_quiet_NaN = (bool)(true);
 static constexpr bool has_signaling_NaN = (bool)(true);
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(true);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr bool tinyness_before = (bool)(true);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
 static constexpr int radix = (int)(2);
 };


template<> class numeric_limits<char>
 : public _Num_int_base
 {
public:
 typedef char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7f - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7f);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)((-0x7f - 1) != 0);
 static constexpr int digits = (int)(8 - ((-0x7f - 1) != 0 ? 1 : 0));
 static constexpr int digits10 = (int)((8 - ((-0x7f - 1) != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<wchar_t>
 : public _Num_int_base
 {
public:
 typedef wchar_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((_Ty)0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return ((_Ty)0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(0 != 0);
 static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0 != 0 ? 1 : 0));

 static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0 != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<bool>
 : public _Num_int_base
 {
public:
 typedef bool _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (false);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (true);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(1);
 static constexpr int digits10 = (int)(0);
 };


template<> class numeric_limits<signed char>
 : public _Num_int_base
 {
public:
 typedef signed char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7f - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7f);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 - 1);
 static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
 };


template<> class numeric_limits<unsigned char>
 : public _Num_int_base
 {
public:
 typedef unsigned char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8);
 static constexpr int digits10 = (int)(8 * 301L / 1000);
 };


template<> class numeric_limits<short>
 : public _Num_int_base
 {
public:
 typedef short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (short) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned short>
 : public _Num_int_base
 {
public:
 typedef unsigned short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned short));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);

 };


template<> class numeric_limits<char16_t>
 : public _Num_int_base
 {
public:
 typedef char16_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char16_t));
 static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);

 };


template<> class numeric_limits<int>
 : public _Num_int_base
 {
public:
 typedef int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fffffff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (int) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned int>
 : public _Num_int_base
 {
public:
 typedef unsigned int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned int));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);

 };


template<> class numeric_limits<long>
 : public _Num_int_base
 {
public:
 typedef long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fffffffffffffff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffffffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long>
 : public _Num_int_base
 {
public:
 typedef unsigned long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);

 };


template<> class numeric_limits<char32_t>
 : public _Num_int_base
 {
public:
 typedef char32_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char32_t));
 static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);

 };



template<> class numeric_limits<long long>
 : public _Num_int_base
 {
public:
 typedef long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (-0x7fffffffffffffffLL - 1);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffffffffffffLL);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long long>
 : public _Num_int_base
 {
public:
 typedef unsigned long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffffffffffULL);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long long) * 301L / 1000);

 };



template<> class numeric_limits<float>
 : public _Num_float_base
 {
public:
 typedef float _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (1.175494351E-38F);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (3.402823466E+38F);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (1.192092896E-07F);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5F);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (1.175494351E-38F);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_valf());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nanf(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nansf(""));
  }

 static constexpr int digits = (int)(24);
 static constexpr int digits10 = (int)(6);
 static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)128);
 static constexpr int max_exponent10 = (int)((int)38);
 static constexpr int min_exponent = (int)((int)-125);
 static constexpr int min_exponent10 = (int)((int)-37);
 };


template<> class numeric_limits<double>
 : public _Num_float_base
 {
public:
 typedef double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (2.2250738585072014E-308);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (1.7976931348623157E+308);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (2.2204460492503131E-016);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (2.2250738585072014E-308);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_val());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nan(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nans(""));
  }

 static constexpr int digits = (int)(53);
 static constexpr int digits10 = (int)(15);
 static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)1024);
 static constexpr int max_exponent10 = (int)((int)308);
 static constexpr int min_exponent = (int)((int)-1021);
 static constexpr int min_exponent10 = (int)((int)-307);
 };


template<> class numeric_limits<long double>
 : public _Num_ldbl_base
 {
public:
 typedef long double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (3.362103143112093506263E-4932L);
  }


 static constexpr _Ty (max)() noexcept
  {
  return (1.189731495357231765021E+4932L);
  }


 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (1.084202172485504434007E-19L);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5L);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (3.645199531882474602528E-4951L);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_vall());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nanl(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nansl(""));
  }

 static constexpr int digits = (int)(64);
 static constexpr int digits10 = (int)(18);
 static constexpr int max_digits10 = (int)(2 + 64 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)16384);
 static constexpr int max_exponent10 = (int)((int)4932);
 static constexpr int min_exponent = (int)((int)-16381);
 static constexpr int min_exponent10 = (int)((int)-4931);
 };
# 1326 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 3
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
namespace std {

class bad_alloc
 : public ::std:: exception
 {
public:
 bad_alloc(const char *_Message = "bad allocation") noexcept
  : exception(_Message)
  {
  }

 virtual const char *what() const noexcept;


 virtual ~bad_alloc() noexcept;
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
protected:
 virtual void _Doraise() const;

 };


class bad_array_new_length
 : public bad_alloc
 {
public:
 bad_array_new_length() noexcept
  : bad_alloc("bad array new length")
  {
  }


 virtual ~bad_array_new_length() noexcept;


 };
# 70 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
struct nothrow_t
 {



 };
extern const nothrow_t nothrow;
typedef void (*new_handler)();

new_handler get_new_handler() noexcept;
new_handler set_new_handler(new_handler) noexcept;
}


void *operator new(::std:: size_t);
inline void *operator new(::std:: size_t, void *_Ptr) noexcept { return (_Ptr); }
void *operator new(::std:: size_t, const ::std:: nothrow_t&) noexcept;
# 95 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
inline void operator delete(void *, void *) noexcept { }


void operator delete(void *) noexcept;
void operator delete(void *, const ::std:: nothrow_t&) noexcept;

void operator delete(void *, ::std:: size_t) noexcept;
void operator delete(void *, :: size_t, const ::std:: nothrow_t&) noexcept;
# 112 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
void *operator new[](::std:: size_t);
inline void *operator new[](::std:: size_t, void *_Ptr) noexcept { return (_Ptr); }
void *operator new[](::std:: size_t, const ::std:: nothrow_t&) noexcept;
# 123 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
inline void operator delete[](void *, void *) noexcept { }


void operator delete[](void *) noexcept;
void operator delete[](void *, const ::std:: nothrow_t&) noexcept;

void operator delete[](void *, ::std:: size_t) noexcept;
void operator delete[](void *, :: size_t, const ::std:: nothrow_t&) noexcept;
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 2 3
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 3
namespace std {
using :: _Filet; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: gets; using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstring" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstring" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstring" 2 3
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstring" 3
namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strerror_r;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 2 3



namespace std {





typedef long streamoff;
typedef int streamsize;
# 33 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
extern fpos_t _Fpz;
extern const streamoff _BADOFF;


template<class _Statetype>
 class fpos
 {
 typedef fpos<_Statetype> _Myt;

public:
 fpos(streamoff _Off = 0)
  : _Myoff(_Off), _Fpos(_Fpz), _Mystate()
  {
  }

 fpos(_Statetype _State, fpos_t _Fileposition)
  : _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
  {
  }

 _Statetype state() const
  {
  return (_Mystate);
  }

 void state(_Statetype _State)
  {
  _Mystate = _State;
  }

 fpos_t seekpos() const
  {
  return (_Fpos);
  }

 operator streamoff() const
  {
  return ((streamoff)(_Myoff + ((_Fpos)._Off)));
  }

 streamoff operator-(const _Myt& _Right) const
  {
  return ((streamoff)*this - (streamoff)_Right);
  }

 _Myt& operator+=(streamoff _Off)
  {
  _Myoff += _Off;
  return (*this);
  }

 _Myt& operator-=(streamoff _Off)
  {
  _Myoff -= _Off;
  return (*this);
  }

 _Myt operator+(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt operator-(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }

private:
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };

template<class _Statetype>
 bool operator==(const fpos<_Statetype>& _Left,
  const fpos<_Statetype>& _Right)
 {
 return ((streamoff)_Left == (streamoff)_Right);
 }

template<class _Statetype>
 bool operator!=(const fpos<_Statetype>& _Left,
  const fpos<_Statetype>& _Right)
 {
 return (!(_Left == _Right));
 }
# 138 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
typedef fpos<_Mbstatet> streampos;


typedef streampos wstreampos;


template<class _Elem,
 class _Int_type>
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

           static int compare(
  const _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  for (; 0 < _Count; --_Count, ++_First1, ++_First2)
   if (!eq(*_First1, *_First2))
    return (lt(*_First1, *_First2) ? -1 : +1);
  return (0);
  }

           static size_t
  length(const _Elem *_First)
  {
  size_t _Count = 0;
  for (; !eq(*_First, _Elem()); ++_First)
   ++_Count;
  return (_Count);
  }

           static _Elem *copy(
  _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  for (; 0 < _Count; --_Count, ++_Next, ++_First2)
   assign(*_Next, *_First2);
  return (_First1);
  }

           static const _Elem *find(
  const _Elem *_First,
  size_t _Count, const _Elem& _Ch)
  {
  for (; 0 < _Count; --_Count, ++_First)
   if (eq(*_First, _Ch))
    return (_First);
  return (0);
  }

           static _Elem *move(
  _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  if (_First2 < _Next && _Next < _First2 + _Count)
   for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
    assign(*--_Next, *--_First2);
  else
   for (; 0 < _Count; --_Count, ++_Next, ++_First2)
    assign(*_Next, *_First2);
  return (_First1);
  }

           static _Elem *assign(
  _Elem *_First,
  size_t _Count, _Elem _Ch)
  {
  _Elem *_Next = _First;
  for (; 0 < _Count; --_Count, ++_Next)
   assign(*_Next, _Ch);
  return (_First);
  }

 static void
  assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return ((int_type)_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
  }
# 297 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return ((int_type)(-1));
  }
 };


template<class _Elem>
 struct char_traits
  : public _Char_traits<_Elem, long>
 {
 };


template<>
 struct char_traits<char16_t>
 : public _Char_traits<char16_t, unsigned short>
 {
 };

typedef streampos u16streampos;


template<>
 struct char_traits<char32_t>
 : public _Char_traits<char32_t, unsigned int>
 {
 };

typedef streampos u32streampos;


template<>
 struct char_traits<wchar_t>
 {
 typedef wchar_t _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;


 static int compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : __builtin_wmemcmp(_First1, _First2, _Count));
  }
# 356 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static size_t length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : __builtin_wcslen(_First));
  }
# 369 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static _Elem *copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemcpy(_First1, _First2, _Count));
  }


 static const _Elem *find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *)__builtin_wmemchr(_First, _Ch, _Count));
  }
# 392 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static _Elem *move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemmove(_First1, _First2, _Count));
  }

 static _Elem *assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: wmemset(_First, _Ch, _Count));
  }

 static void assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return (_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }
# 484 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return (((:: wint_t)(-1)));
  }
 };


template<> struct char_traits<char>
 {
 typedef char _Elem;
 typedef _Elem char_type;
 typedef int int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;


 static int compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : __builtin_memcmp(_First1, _First2, _Count));
  }
# 517 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static size_t length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : __builtin_strlen(_First));
  }
# 530 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static _Elem *copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memcpy(_First1, _First2, _Count));
  }


 static const _Elem *find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *)__builtin_memchr(_First, _Ch, _Count));
  }
# 553 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static _Elem *move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memmove(_First1, _First2, _Count));
  }

 static _Elem *assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: memset(_First, _Ch, _Count));
  }

 static void assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return ((unsigned char)_Left < (unsigned char)_Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return ((unsigned char)_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }
# 645 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return ((-1));
  }
 };


template<class _Ty>
 class allocator;
class ios_base;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ios;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class istreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class ostreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_streambuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_istream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ostream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_iostream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringbuf;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_istringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_ostringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_filebuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ifstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ofstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_fstream;


typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
 allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
 allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
 allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
 allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;


typedef basic_filebuf<char, char_traits<char> > stdiobuf;
typedef basic_fstream<char, char_traits<char> > stdiostream;



typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
 wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
}


using ::std:: ios;
using ::std:: streambuf;
using ::std:: istream;
using ::std:: ostream;
using ::std:: iostream;

using ::std:: filebuf;
using ::std:: ifstream;
using ::std:: ofstream;
using ::std:: fstream;

using ::std:: stdiobuf;
using ::std:: stdiostream;
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 2 3


namespace std {





template<class _Ty> inline

 void swap(_Ty& _Left, _Ty& _Right)
  noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)

 {
 _Ty _Tmp = _Move(_Left);
 _Left = _Move(_Right);
 _Right = _Move(_Tmp);
 }






template<class _Ty,
 size_t _Size> inline

 void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])



  noexcept(noexcept(swap(*_Left, *_Right)))

 {
 if (&_Left != &_Right)
  {
  _Ty *_First1 = _Left;
  _Ty *_Last1 = _First1 + _Size;
  _Ty *_First2 = _Right;
  for (; _First1 != _Last1; ++_First1, ++_First2)
   swap(*_First1, *_First2);
  }
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
 {
 swap(*_Left, *_Right);
 }


template<class _Ty> inline
 bool _Swap_adl(_Ty& _Left, _Ty& _Right)
  noexcept(noexcept((swap(_Left, _Right), true)))
 {
 swap(_Left, _Right);
 return (true);
 }


struct piecewise_construct_t
 {



 };



constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


template<class...>
 class tuple;

template<class _Ty1,
 class _Ty2>
 struct pair
 {
 typedef pair<_Ty1, _Ty2> _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;
# 104 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 constexpr pair()
  : first(), second()
  {
  }

 constexpr pair(const pair&) = default;
 constexpr pair(pair&&) = default;
# 121 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<const _Other1&, _Ty1>::value
   && is_convertible<const _Other2&, _Ty2>::value,
   void> >

  constexpr pair(const pair<_Other1, _Other2>& _Right)
   : first(_Right.first), second(_Right.second)
  {
  }
# 155 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<_Other1, _Ty1>::value
   && is_convertible<_Other2, _Ty2>::value,
   void> >

  constexpr pair(pair<_Other1, _Other2>&& _Right)
   : first(::std:: forward<_Other1>(_Right.first)),
    second(::std:: forward<_Other2>(_Right.second))
  {
  }
# 191 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
  constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
   : first(_Val1), second(_Val2)
  {
  }
# 219 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<_Other1, first_type>::value
   && is_convertible<_Other2, second_type>::value,
   void> >

  constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
   : first(::std:: forward<_Other1>(_Val1)),
    second(::std:: forward<_Other2>(_Val2))
  {
  }
# 247 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   integer_sequence<size_t, _Indexes1...>,
   integer_sequence<size_t, _Indexes2...>);
# 264 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class... _Types1,
  class... _Types2> inline
  pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2);

 struct _Deleted {};





 _Myt& operator=(const _Myt& _Right)

  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }
# 291 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2>

  _Myt& operator=(const pair<_Other1, _Other2>& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }





 _Myt& operator=(_Myt&& _Right)

   noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))

  {
  first = ::std:: forward<_Ty1>(_Right.first);
  second = ::std:: forward<_Ty2>(_Right.second);
  return (*this);
  }
# 322 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2>

  _Myt& operator=(pair<_Other1, _Other2>&& _Right)
  {
  first = ::std:: forward<_Other1>(_Right.first);
  second = ::std:: forward<_Other2>(_Right.second);
  return (*this);
  }

 void swap(_Myt& _Right)




  noexcept(noexcept((_Swap_adl(this->first, _Right.first))) && noexcept((_Swap_adl(this->second, _Right.second))))


  {
  if (this != &_Right)
   {
   _Swap_adl(first, _Right.first);
   _Swap_adl(second, _Right.second);
   }
  }

 _Ty1 first;
 _Ty2 second;
 };
# 365 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<class _Ty1,
 class _Ty2> inline

 void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)




  noexcept(noexcept(_Left.swap(_Right)))

 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first == _Right.first && _Left.second == _Right.second);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first < _Right.first
  || (!(_Right.first < _Left.first) && _Left.second < _Right.second));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type>
  make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
 {
 typedef pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type> _Mypair;
 return (_Mypair(::std:: forward<_Ty1>(_Val1),
  ::std:: forward<_Ty2>(_Val2)));
 }


 namespace rel_ops
  {
template<class _Ty> inline
 bool operator!=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty> inline
 bool operator>(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty> inline
 bool operator<=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty> inline
 bool operator>=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left < _Right));
 }
  }
}

namespace std {
template<class _Ty,
 size_t _Size>
 class array;


template<class _Tuple>
 struct tuple_size;


template<class _Ty,
 size_t _Size>
 struct tuple_size<array<_Ty, _Size> >

  : integral_constant<int, _Size>



 {
 };
# 505 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<class _Ty1,
 class _Ty2>
 struct tuple_size<pair<_Ty1, _Ty2> >

 : integral_constant<int, 2>



 {
 };
# 528 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<class... _Types>
 struct tuple_size<tuple<_Types...> >
 : integral_constant<size_t, sizeof...(_Types)>
 {
 };



template<class _Tuple, size_t>
 using _Tuple_size_sfinae = _Tuple;

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<const _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<volatile _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<const volatile _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };
# 584 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<size_t _Index,
 class _Tuple>
 struct tuple_element;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 struct tuple_element<_Idx, array<_Ty, _Size> >
 {
 tuple_element()
  {
  static_assert(_Idx < _Size, "array index out of bounds");
  }

 typedef _Ty type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<0, pair<_Ty1, _Ty2> >
 {
 typedef _Ty1 type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<1, pair<_Ty1, _Ty2> >
 {
 typedef _Ty2 type;
 };

template<size_t _Index>
 struct tuple_element<_Index, tuple<> >
 {
 static_assert(_Always_false<integral_constant<size_t, _Index> >::value,
  "tuple index out of bounds");
 };

template<class _This,
 class... _Rest>
 struct tuple_element<0, tuple<_This, _Rest...> >
 {
 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<size_t _Index,
 class _This,
 class... _Rest>
 struct tuple_element<_Index, tuple<_This, _Rest...> >
  : public tuple_element<_Index - 1, tuple<_Rest...> >
 {
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };



template<size_t _Index,
 class _Tuple>
 using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;




template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 0>) noexcept
 {
 return (_Pr.first);
 }

template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 1>) noexcept
 {
 return (_Pr.second);
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
 return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }


template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  _Ctype;
 return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }


template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
  get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
 return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<0>(::std:: move(_Pr)));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<1>(::std:: move(_Pr)));
 }
# 796 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<class _Ty,
 class _Other = _Ty> inline
 _Ty exchange(_Ty& _Val, _Other&& _New_val)
 {
 _Ty _Old_val = ::std:: move(_Val);
 _Val = ::std:: forward<_Other>(_New_val);
 return (_Old_val);
 }
# 845 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 1 3
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
 {
 _Container_base0()

  : _Myproxy(0)

  {
  }

 void _Orphan_all()
  {
  }

 void _Swap_all(_Container_base0&)
  {
  }


 _Container_proxy *_Myproxy;

 };

struct _Iterator_base0
 {
                _Iterator_base0()

  : _Myproxy(0), _Mynextiter(0)

  {
  }

 void _Adopt(const void *)
  {
  }

 const _Container_base0 *_Getcont() const
  {
  return (0);
  }


 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;

 };


struct _Container_proxy
 {
 _Container_proxy()
  : _Mycont(0), _Myfirstiter(0)
  {
  }

 const _Container_base12 *_Mycont;
 _Iterator_base12 *_Myfirstiter;
 };

struct _Container_base12
 {
public:
 _Container_base12()
  : _Myproxy(0)
  {
  }

 _Container_base12(const _Container_base12&)
  : _Myproxy(0)
  {
  }

 _Container_base12& operator=(const _Container_base12&)
  {
  return (*this);
  }

 ~_Container_base12() noexcept
  {
  _Orphan_all();
  }

 _Iterator_base12 **_Getpfirst() const
  {
  return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
  }

 void _Orphan_all();
 void _Swap_all(_Container_base12&);

 _Container_proxy *_Myproxy;
 };

struct _Iterator_base12
 {
public:
 _Iterator_base12()
  : _Myproxy(0), _Mynextiter(0)
  {
  }

 _Iterator_base12(const _Iterator_base12& _Right)
  : _Myproxy(0), _Mynextiter(0)
  {
  *this = _Right;
  }

 _Iterator_base12& operator=(const _Iterator_base12& _Right)
  {
  if (_Myproxy == _Right._Myproxy)
   ;
  else if (_Right._Myproxy != 0)
   _Adopt(_Right._Myproxy->_Mycont);
  else
   {




   }
  return (*this);
  }

 ~_Iterator_base12() noexcept
  {




  }

 void _Adopt(const _Container_base12 *_Parent)
  {
  if (_Parent == 0)
   {




   }
  else
   {
   _Container_proxy *_Parent_proxy = _Parent->_Myproxy;
# 258 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
   _Myproxy = _Parent_proxy;

   }
  }

 void _Clrcont()
  {
  _Myproxy = 0;
  }

 const _Container_base12 *_Getcont() const
  {
  return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
  }

 _Iterator_base12 **_Getpnext()
  {
  return (&_Mynextiter);
  }

 void _Orphan_me()
  {
# 293 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
  }

 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;
 };


inline void _Container_base12::_Orphan_all()
 {
# 313 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
 }

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
 {




 _Container_proxy *_Temp = _Myproxy;
 _Myproxy = _Right._Myproxy;
 _Right._Myproxy = _Temp;

 if (_Myproxy != 0)
  _Myproxy->_Mycont = (_Container_base12 *)this;
 if (_Right._Myproxy != 0)
  _Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
 }


typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;







struct _Zero_then_variadic_args_t
 {
 };

struct _One_then_variadic_args_t
 {
 };

template<class _Ty1,
 class _Ty2,
 bool = is_empty<_Ty1>::value>
 class _Compressed_pair
  : private _Ty1
 {
private:
 _Ty2 _Myval2;

public:
 _Compressed_pair()
  {
  }

 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Ty1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 _Compressed_pair(const _Compressed_pair& _Right)
  : _Ty1(_Right),
   _Myval2(_Right._Myval2)
  {
  }

 _Compressed_pair(_Compressed_pair&& _Right)
  : _Ty1(::std:: move(_Right)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Compressed_pair& operator=(_Compressed_pair&& _Right)
  {
  *this = ::std:: move(_Right);
  return (*this);
  }

 _Ty1& _Get_first() noexcept
  {
  return (*this);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (*this);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (*this);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (*this);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };

template<class _Ty1,
 class _Ty2>
 class _Compressed_pair<_Ty1, _Ty2, false>
 {
private:
 _Ty1 _Myval1;
 _Ty2 _Myval2;

public:
 _Compressed_pair()
  {
  }

 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Myval1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 _Compressed_pair& operator=(_Compressed_pair&& _Right)
  {
  _Myval1 = ::std:: forward<_Ty1>(_Right._Myval1);
  _Myval2 = ::std:: forward<_Ty2>(_Right._Myval2);
  return (*this);
  }

 _Compressed_pair(const _Compressed_pair& _Right)
  : _Myval1(::std:: move(_Right._Myval1)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Compressed_pair(_Compressed_pair&& _Right)
  : _Myval1(::std:: move(_Right._Myval1)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Ty1& _Get_first() noexcept
  {
  return (_Myval1);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (_Myval1);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (_Myval1);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (_Myval1);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };






template<class _Ty>
 struct _Get_unchecked_type
  { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::_Unchecked_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Ty>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class = void>
 struct _Is_checked_helper
  : false_type
 {
 };

template<class _Ty>
 struct _Is_checked_helper<_Ty, typename _Param_tester<
  typename _Ty::_Unchecked_type>::type>
  : true_type
 {
 };


template<class _Iter> inline
 typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
 {
 return (typename _Is_checked_helper<_Iter>::type());
 }


template<class _Iter> inline
 _Iter _Unchecked(_Iter _Src)
 {
 return (_Src);
 }


template<class _Iter,
 class _UIter> inline
 _Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
 {
 _Dest = _Src;
 return (_Dest);
 }



struct input_iterator_tag
 {
 };

struct _Mutable_iterator_tag
 {
 };

struct output_iterator_tag
 : _Mutable_iterator_tag
 {
 };

struct forward_iterator_tag
 : input_iterator_tag, _Mutable_iterator_tag
 {
 };

struct bidirectional_iterator_tag
 : forward_iterator_tag
 {
 };

struct random_access_iterator_tag
 : bidirectional_iterator_tag
 {
 };

struct _Int_iterator_tag
 {
 };


struct _Nonscalar_ptr_iterator_tag
 {
 };
struct _Scalar_ptr_iterator_tag
 {
 };


template<class _Category,
 class _Ty,
 class _Diff = ptrdiff_t,
 class _Pointer = _Ty *,
 class _Reference = _Ty&>
 struct iterator
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;
 typedef _Diff distance_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
 };

template<class _Category,
 class _Ty,
 class _Diff,
 class _Pointer,
 class _Reference,
 class _Base>
 struct _Iterator012
  : public _Base
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;
 typedef _Diff distance_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
 };


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;


template<class,
 class = void>
 struct _Is_iterator
  : false_type
 {
 };

template<class _Ty>
 struct _Is_iterator<_Ty, typename _Param_tester<
  typename _Ty::iterator_category,
  typename _Ty::value_type,
  typename _Ty::difference_type,
  typename _Ty::pointer,
  typename _Ty::reference
  >::type>
  : true_type
 {
 };

template<class _Ty>
 struct _Is_iterator<_Ty *>
  : true_type
 {
 };


template<class _Iter,
 bool = _Is_iterator<_Iter>::value>
 struct _Iterator_traits_base
 {
 typedef typename _Iter::iterator_category iterator_category;
 typedef typename _Iter::value_type value_type;
 typedef typename _Iter::difference_type difference_type;
 typedef difference_type distance_type;
 typedef typename _Iter::pointer pointer;
 typedef typename _Iter::reference reference;
 };

template<class _Iter>
 struct _Iterator_traits_base<_Iter, false>
 {
 };

template<class _Iter>
 struct iterator_traits
  : _Iterator_traits_base<_Iter>
 {
 };

template<class _Ty>
 struct iterator_traits<_Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;
 typedef ptrdiff_t distance_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;
 };

template<class _Ty>
 struct iterator_traits<const _Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;
 typedef ptrdiff_t distance_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 };
# 795 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
template<class _Iter> inline
                typename iterator_traits<_Iter>::iterator_category
  _Iter_cat(const _Iter&)
 {
 typename iterator_traits<_Iter>::iterator_category _Cat;
 return (_Cat);
 }



template<class _Ty1, class _Ty2> inline
auto _Ptr_cat(_Ty1&, _Ty2&)
  -> typename std::conditional<(

      (!std::is_pointer<_Ty1>::value) ||

      (!std::is_pointer<_Ty2>::value) ||

      ((std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ) ||
      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
        std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value )) ||

      (std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
      !std::is_same<typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::type>::type,
                    typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::type>::type >::value ) ||

      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
       (!std::is_same<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type,
                     typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ))),
        _Nonscalar_ptr_iterator_tag,
        _Scalar_ptr_iterator_tag>::type {

  typename std::conditional<(

      (!std::is_pointer<_Ty1>::value) ||

      (!std::is_pointer<_Ty2>::value) ||

      ((std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ) ||
      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
        std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value )) ||

      (std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
      !std::is_same<typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::type>::type,
                    typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::type>::type >::value ) ||

      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
       (!std::is_same<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type,
                     typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ))),
        _Nonscalar_ptr_iterator_tag,
        _Scalar_ptr_iterator_tag>::type _Cat;


    return (_Cat);
}
# 901 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
inline _Scalar_ptr_iterator_tag _Ptr_cat(bool *, bool *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const bool *, bool *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(char *, char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const char *, char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(signed char *, signed char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const signed char *, signed char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned char *,
 unsigned char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned char *,
 unsigned char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(short *, short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const short *, short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned short *,
 unsigned short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned short *,
 unsigned short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(int *, int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const int *, int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned int *, unsigned int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned int *, unsigned int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(long *, long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long *, long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned long *,
 unsigned long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long *,
 unsigned long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(float *, float *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const float *, float *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(double *, double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const double *, double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(long double *, long double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long double *, long double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }


inline _Scalar_ptr_iterator_tag _Ptr_cat(long long *, long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long long *, long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned long long *, unsigned long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long long *, unsigned long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }
# 1332 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
template<class _Iter> inline
 typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
 {
 return (0);
 }


template<class _InIt,
 class _Diff> inline
                void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _FwdIt,
 class _Diff> inline
                void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _BidIt,
 class _Diff> inline
                void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
 {
 for (; 0 < _Off; --_Off)
  ++_Where;
 for (; _Off < 0; ++_Off)
  --_Where;
 }

template<class _RanIt,
 class _Diff> inline
                void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
 {
 _Where += _Off;
 }

template<class _InIt,
 class _Diff> inline
                void advance(_InIt& _Where, _Diff _Off)
 {
 _Advance(_Where, _Off, _Iter_cat(_Where));
 }


template<class _Iter> inline
 typename iterator_traits<_Iter>::difference_type
  *_Dist_type(_Iter)
 {
 return (0);
 }


template<class _InIt,
 class _Diff> inline
                 void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
   input_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _FwdIt,
 class _Diff> inline
                 void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
   forward_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _BidIt,
 class _Diff> inline
                 void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
   bidirectional_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _RanIt,
 class _Diff> inline
                 void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
   random_access_iterator_tag)
 {
# 1438 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
 _Off += _Last - _First;
 }

template<class _InIt> inline
                typename iterator_traits<_InIt>::difference_type
  distance(_InIt _First, _InIt _Last)
 {
 typename iterator_traits<_InIt>::difference_type _Off = 0;
 _Distance2(_First, _Last, _Off, _Iter_cat(_First));
 return (_Off);
 }

template<class _InIt,
 class _Diff> inline
  void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
 {
 _Distance2(_First, _Last, _Off, _Iter_cat(_First));
 }
# 1471 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
template<class _FwdIt> inline
 _FwdIt next(_FwdIt _First,
  typename iterator_traits<_FwdIt>::difference_type _Off = 1)
 {
 static_assert((is_base_of<forward_iterator_tag, typename iterator_traits<_FwdIt>::iterator_category>::value), "next requires forward iterator");



 ::std:: advance(_First, _Off);
 return (_First);
 }



template<class _BidIt> inline
                _BidIt prev(_BidIt _First,
  typename iterator_traits<_BidIt>::difference_type _Off = 1)
 {
 static_assert((is_base_of<bidirectional_iterator_tag, typename iterator_traits<_BidIt>::iterator_category>::value), "prev requires bidirectional iterator");



 ::std:: advance(_First, -_Off);
 return (_First);
 }


template<class _Ty>
 struct pointer_traits;

template<class _RanIt,
 class _Base>
 class _Revranit
  : public _Base
 {
public:
 typedef _Revranit<_RanIt, _Base> _Myt;
 typedef typename _Base::difference_type difference_type;
 typedef typename _Base::pointer pointer;
 typedef typename _Base::reference reference;
 typedef _RanIt iterator_type;

                _Revranit()
  : current()
  {
  }

                explicit _Revranit(_RanIt _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2,
  class _Base2>
  _Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
  : current(_Right.base())
  {
  }

                _RanIt base() const
  {
  return (current);
  }

                reference operator*() const
  {
  _RanIt _Tmp = current;
  return (*--_Tmp);
  }

                pointer operator->() const
  {
  return (::std:: addressof(operator*()));
  }

                _Myt& operator++()
  {
  --current;
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  ++current;
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

 template<class _RanIt2,
  class _Base2>
  bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
  {
  return (current == _Right.base());
  }



                _Myt& operator+=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

                _Myt& operator-=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 template<class _RanIt2,
  class _Base2>
  bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
  {
  return (_Right.base() < current);
  }

 difference_type operator-(const _Myt& _Right) const
  {
  return (_Right.base() - current);
  }

protected:
 _RanIt current;
 };


template<class _RanIt>
 class reverse_iterator
  : public _Revranit<_RanIt, iterator<
   typename iterator_traits<_RanIt>::iterator_category,
   typename iterator_traits<_RanIt>::value_type,
   typename iterator_traits<_RanIt>::difference_type,
   typename iterator_traits<_RanIt>::pointer,
   typename iterator_traits<_RanIt>::reference> >
 {
 typedef reverse_iterator<_RanIt> _Myt;
 typedef _Revranit<_RanIt, iterator<
  typename iterator_traits<_RanIt>::iterator_category,
  typename iterator_traits<_RanIt>::value_type,
  typename iterator_traits<_RanIt>::difference_type,
  typename iterator_traits<_RanIt>::pointer,
  typename iterator_traits<_RanIt>::reference> > _Mybase;

public:
 typedef typename iterator_traits<_RanIt>::difference_type difference_type;
 typedef typename iterator_traits<_RanIt>::pointer pointer;
 typedef typename iterator_traits<_RanIt>::reference reference;
 typedef _RanIt iterator_type;

                reverse_iterator()
  {
  }

                explicit reverse_iterator(_RanIt _Right)
  : _Mybase(_Right)
  {
  }

 template<class _Other>
                 reverse_iterator(const reverse_iterator<_Other>& _Right)
  : _Mybase(_Right.base())
  {
  }

 reverse_iterator(_Mybase _Right)
  : _Mybase(_Right)
  {
  }

 template<class _Other>
                 _Myt& operator=(const reverse_iterator<_Other>& _Right)
  {
  this->current = _Right.base();
  return (*this);
  }

                _Myt& operator++()
  {
  ++*((_Mybase *)this);
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  --*((_Mybase *)this);
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myt& operator+=(difference_type _Off)
  {
  *((_Mybase *)this) += _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myt& operator-=(difference_type _Off)
  {
  *((_Mybase *)this) -= _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }
 };

template<class _RanIt>
 struct _Is_checked_helper<reverse_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt> inline
                reverse_iterator<_RanIt> operator+(
  typename reverse_iterator<_RanIt>::difference_type _Off,
  const reverse_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
                auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
   -> decltype(_Right.base() - _Left.base())
 {
 return (_Right.base() - _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator==(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Left.base() == _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator!=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right.base() < _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }



template<class _RanIt> inline
                reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
 {
 return (reverse_iterator<_RanIt>(_Iter));
 }




template<class _Container>
                auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
                auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
                auto inline end(_Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Container>
                auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array);
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array + _Size);
 }



template<class _Ty>
 class valarray;
template<class _Ty>
 _Ty *begin(valarray<_Ty>&);
template<class _Ty>
 const _Ty *begin(const valarray<_Ty>&);
template<class _Ty>
 _Ty *end(valarray<_Ty>&);
template<class _Ty>
 const _Ty *end(const valarray<_Ty>&);

template<class _Container>
 constexpr auto inline cbegin(const _Container& _Cont)
  noexcept(noexcept(::std:: begin(_Cont)))
  -> decltype(::std:: begin(_Cont))
 {
 return (::std:: begin(_Cont));
 }

template<class _Container>
 constexpr auto inline cend(const _Container& _Cont)
  noexcept(noexcept(::std:: end(_Cont)))
  -> decltype(::std:: end(_Cont))
 {
 return (::std:: end(_Cont));
 }


template<class _Container>
                auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
                auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
                auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Container>
                auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Ty,
 size_t _Size> inline
                reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array + _Size));
 }

template<class _Ty,
 size_t _Size> inline
                reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array));
 }

template<class _Elem> inline
                reverse_iterator<const _Elem *>
  rbegin(::std:: initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.end()));
 }

template<class _Elem> inline
                reverse_iterator<const _Elem *>
  rend(::std:: initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.begin()));
 }


template<class _Container>
                auto inline crbegin(const _Container& _Cont)
  -> decltype(::std:: rbegin(_Cont))
 {
 return (::std:: rbegin(_Cont));
 }

template<class _Container>
                auto inline crend(const _Container& _Cont)
  -> decltype(::std:: rend(_Cont))
 {
 return (::std:: rend(_Cont));
 }
# 2015 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
template<class _Container,
 class _Pr> inline
 void _Erase_nodes_if(_Container& _Cont, _Pr _Pred)
 {
 auto _First = _Cont.begin();
 auto _Last = _Cont.end();
                                          ;
 while (_First != _Last)
  if (_Pred(*_First))
   _First = _Cont.erase(_First);
  else
   ++_First;
 }



template<class _Ty,
 size_t _Size>
 class _Array_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty&,
   _Iterator_base>
 {
public:
 typedef _Array_const_iterator<_Ty, _Size> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;


                _Array_const_iterator()
  {
  _Ptr = 0;
  }

                explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
  : _Ptr{_Parg + _Off}
  {

  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

                reference operator*() const
  {
  return (*_Ptr);
  }

                pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

                _Myiter& operator++()
  {
  ++_Ptr;
  return (*this);
  }

                _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myiter& operator--()
  {
  --_Ptr;
  return (*this);
  }

                _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myiter& operator+=(difference_type _Off)
  {
  _Ptr += _Off;
  return (*this);
  }

                _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

                _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

                difference_type operator-(const _Myiter& _Right) const
  {
  return (_Ptr - _Right._Ptr);
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

                bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

                bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

                bool operator<(const _Myiter& _Right) const
  {
  return (_Ptr < _Right._Ptr);
  }

                bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

                bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

                bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }

 pointer _Ptr;
# 2377 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size>&
  _Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
   typename _Array_const_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
                _Array_const_iterator<_Ty, _Size> operator+(
  typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
  _Array_const_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _Ty,
 size_t _Size>
 class _Array_iterator
  : public _Array_const_iterator<_Ty, _Size>
 {
public:
 typedef _Array_iterator<_Ty, _Size> _Myiter;
 typedef _Array_const_iterator<_Ty, _Size> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;

                _Array_iterator()
  {
  }

                explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
  : _Mybase(_Parg, _Off)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  ((_Mybase *)this)->_Rechecked(_Right);
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return ((pointer)((_Mybase *)this)->_Unchecked());
  }

                reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

                pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

                _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

                _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

                _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

                _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

                _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

                difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size>&
  _Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
   typename _Array_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
                _Array_iterator<_Ty, _Size> operator+(
  typename _Array_iterator<_Ty, _Size>::difference_type _Off,
  _Array_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _RanIt>
 class move_iterator
 {
public:
 typedef move_iterator<_RanIt> _Myt;
 typedef typename iterator_traits<_RanIt>::iterator_category
  iterator_category;
 typedef typename iterator_traits<_RanIt>::value_type
  value_type;
 typedef typename iterator_traits<_RanIt>::difference_type
  difference_type;
 typedef _RanIt pointer;






 typedef value_type&& reference;

 typedef _RanIt iterator_type;

                move_iterator()
  : current()
  {
  }

                explicit move_iterator(iterator_type _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2>
                 move_iterator(const move_iterator<_RanIt2>& _Right)
  : current(_Right.base())
  {
  }

 template<class _RanIt2>
                 _Myt& operator=(const move_iterator<_RanIt2>& _Right)
  {
  current = _Right.base();
  return (*this);
  }

                _RanIt base() const
  {
  return (current);
  }

                reference operator*() const
  {
  return (::std:: move(*current));
  }

                pointer operator->() const
  {
  return (current);
  }

                _Myt& operator++()
  {
  ++current;
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  --current;
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 template<class _RanIt2>
                 bool _Equal(const move_iterator<_RanIt2>& _Right) const
  {
  return (current == _Right.base());
  }



                _Myt& operator+=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

                _Myt& operator-=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

                reference operator[](difference_type _Off) const
  {
  return (::std:: move(current[_Off]));
  }

 template<class _RanIt2>
                 bool _Less(const move_iterator<_RanIt2>& _Right) const
  {
  return (current < _Right.base());
  }

                difference_type operator-(const _Myt& _Right) const
  {
  return (current - _Right.base());
  }

protected:
 iterator_type current;
 };

template<class _RanIt>
 struct _Is_checked_helper<move_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt,
 class _Diff> inline
                move_iterator<_RanIt>
  operator+(_Diff _Off,
  const move_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
                auto inline operator-(
  move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
   -> decltype(_Left.base() - _Right.base())
 {
 return (_Left.base() - _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator==(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator!=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt> inline
                move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
 {
 return (move_iterator<_RanIt>(_Iter));
 }
}


#pragma clang diagnostic pop
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 2 3

namespace std {

template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_Dest)
  ::std:: iter_swap(_First1, _Dest);
 return (_Dest);
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 return (_Swap_ranges(_Unchecked(_First1), _Unchecked(_Last1),
  _Dest));
 }
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 3
template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
 return (_Rechecked(_First,
  _Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: lower_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (!_Pred(_Val, *_Mid))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
 return (_Rechecked(_First,
  _Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: upper_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  _Equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else if (_Pred(_Val, *_Mid))
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = ::std:: lower_bound(_First, _Mid, _Val, _Pred);
   ::std:: advance(_First, _Count);
   _FwdIt _Last2 = ::std:: upper_bound(++_Mid, _First, _Val, _Pred);
   return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
   }
  }

 return (pair<_FwdIt, _FwdIt>(_First, _First));
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred)
 {
 pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
  _Equal_range(_Unchecked(_First), _Unchecked(_Last),
   _Val, _Pred, _Dist_type(_First)));
 return (pair<_FwdIt, _FwdIt>(
  _Rechecked(_First, _Ans.first),
  _Rechecked(_Last, _Ans.second)));
 }


template<class _FwdIt,
 class _Ty> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val)
 {
 return (::std:: equal_range(_First, _Last, _Val, less<>()));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = ::std:: move(*_First);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Move(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Move(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 357 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 3
template<class _Ty>
 struct _Match_pred
 {
 _Match_pred(const _Ty& _Val_arg)
  : _Val(_Val_arg)
  {
  }
 bool operator()(const _Ty& _Val_arg) const
  {
  return (_Val_arg == _Val);
  }
private:
 const _Ty& _Val;
 };

template<class _Ty>
 _Match_pred<_Ty> _Make_match_pred(const _Ty& _Val)
 {
 return (_Match_pred<_Ty>(_Val));
 }


template<class _Fn1>
 struct _Negation_pred
 {
 _Negation_pred(const _Fn1& _F1)
  : _Func1(_F1)
  {
  }

 template<class _Ty>
  bool operator()(const _Ty& _Val) const
  {
  return (!_Func1(_Val));
  }
private:
 _Fn1 _Func1;
 };

template<class _Fn1>
 _Negation_pred<_Fn1> _Make_negation(const _Fn1& _F1)
 {
 return (_Negation_pred<_Fn1>(_F1));
 }
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 2 3

 namespace std {

template<class _FwdIt,
 class _Pr> inline
                pair<_FwdIt, _FwdIt>
  _Minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 pair<_FwdIt, _FwdIt> _Found(_First, _First);
 if (_First != _Last)
  for (; ++_First != _Last; )
   {
   _FwdIt _Next = _First;
   if (++_Next == _Last)
    {
    if (_Pred(*_First, *_Found.first))
     _Found.first = _First;
    else if (!_Pred(*_First, *_Found.second))
     _Found.second = _First;
    }
   else
    {
    if (_Pred(*_Next, *_First))
     {
     if (_Pred(*_Next, *_Found.first))
      _Found.first = _Next;
     if (!_Pred(*_First, *_Found.second))
      _Found.second = _First;
     }
    else
     {
     if (_Pred(*_First, *_Found.first))
      _Found.first = _First;
     if (!_Pred(*_Next, *_Found.second))
      _Found.second = _Next;
     }
    _First = _Next;
    }
   }
 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
                pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                                                                        ;
 pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
  _Minmax_element(_Unchecked(_First), _Unchecked(_Last), _Pred));
 return (pair<_FwdIt, _FwdIt>(
  _Rechecked(_First, _Ans.first),
  _Rechecked(_Last, _Ans.second)));
 }


template<class _FwdIt> inline
                pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: minmax_element(_First, _Last, less<>()));
 }


template<class _Ty> inline
 constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
 {
 return (((_Left) < (_Right)) ? _Right : _Left);
 }

template<class _Ty> inline
 constexpr _Ty (max)(::std:: initializer_list<_Ty> _Ilist)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (((*_Found) < (*_Next)))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty,
 class _Pr> inline
 constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right,
  _Pr _Pred)
 {
 return (_Pred(_Left, _Right) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline
 constexpr _Ty (max)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (_Pred(*_Found, *_Next))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty> inline
 constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
 {
 return (((_Right) < (_Left)) ? _Right : _Left);
 }

template<class _Ty> inline
 constexpr _Ty (min)(::std:: initializer_list<_Ty> _Ilist)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (((*_Next) < (*_Found)))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty,
 class _Pr> inline
 constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right,
  _Pr _Pred)
 {
 return (_Pred(_Right, _Left) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline
 constexpr _Ty (min)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (_Pred(*_Next, *_Found))
   _Found = _Next;
 return (*_Found);
 }
# 163 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _Ty> inline
 constexpr pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty> inline
 constexpr pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist)
 {





 const _Ty *_First = _Ilist.begin();
 const _Ty *_Last = _Ilist.end();
 const _Ty *_Largest = _First;

 if (_First != _Last)
  {
  for (const _Ty *_Next = _First; ++_Next != _Last; )
   if (*_Next < *_First)
    _First = _Next;
   else if (!(*_Next < *_Largest))
    _Largest = _Next;
  }
 return (pair<_Ty, _Ty>(*_First, *_Largest));

 }


template<class _Ty,
 class _Pr> inline
 constexpr pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
 {
 return (_Pred(_Right, _Left)
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty,
 class _Pr> inline
 constexpr pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist,
  _Pr _Pred)
 {





 const _Ty *_First = _Ilist.begin();
 const _Ty *_Last = _Ilist.end();
 const _Ty *_Largest = _First;

 if (_First != _Last)
  {
  for (const _Ty *_Next = _First; ++_Next != _Last; )
   if (_Pred(*_Next, *_First))
    _First = _Next;
   else if (!_Pred(*_Next, *_Largest))
    _Largest = _Next;
  }
 return (pair<_Ty, _Ty>(*_First, *_Largest));

 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Copy_impl(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt copy(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Copy_impl(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 337 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag)
 {
 *_Dest = *_First;
 while (0 < --_Count)
  *++_Dest = *++_First;
 return (++_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 return (_Copy_n(_First, _Count,
  _Dest, _Iter_cat(_First)));
 }
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 return (_Copy_n(_First, _Count,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 if (_Count <= 0)
  return (_Dest);
 else
  return (_Rechecked(_Dest,
   _Copy_n(_Unchecked(_First), _Count,
    _Unchecked(_Dest))));
 }
# 525 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = *--_Last;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_backward(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest - _Count, &*_First,
  _Count * sizeof (*_First));
 return (_Dest - _Count);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Copy_backward(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Rechecked(_Dest,
  _Copy_backward(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 597 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = ::std:: move(*--_Last);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_backward(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest - _Count, &*_First,
  _Count * sizeof (*_First));
 return (_Dest - _Count);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Move_backward(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Rechecked(_Dest,
  _Move_backward(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 669 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _FwdIt,
 class _Ty> inline
 void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First)
  *_First = _Val;
 }

inline void _Fill(char *_First, char *_Last, char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

template<class _FwdIt,
 class _Ty> inline
 void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
                            ;
 _Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest)
  *_Dest = _Val;
 return (_Dest);
 }

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
 signed char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
 unsigned char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
 }
# 803 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (true);
 }

inline bool _Equal(const char *_First1, const char *_Last1,
 const char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
 const signed char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
 const unsigned char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Pred));
 }
# 893 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2)
 {
 return (::std:: equal(_First1, _Last1, _First2,
  equal_to<>()));
 }

template<class _InIt1,
 class _InTy,
 size_t _InSize> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InTy (&_First2)[_InSize])
 {
 return (::std:: equal(_First1, _Last1, _First2,
  equal_to<>()));
 }



template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
   input_iterator_tag, input_iterator_tag)
 {

                                                                 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
   random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
                                            ;
 return (_Equal(_First1, _Last1, _First2, _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
 return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Iter_cat(_First1), _Iter_cat(_First2)));
 }


template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: equal(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }



template<class _InIt,
 class _Pr> inline
 _InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   break;
 return (_First);
 }

template<class _InIt,
 class _Pr> inline
 _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _InIt1,
 class _InIt2> inline
 bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (((*_First1) < (*_First2)))
   return (true);
  else if (*_First2 < *_First1)
   return (false);
 return (_First1 == _Last1 && _First2 != _Last2);
 }

inline bool _Lexicographical_compare(
 const unsigned char *_First1, const unsigned char *_Last1,
 const unsigned char *_First2, const unsigned char *_Last2)
 {
 ptrdiff_t _Num1 = _Last1 - _First1;
 ptrdiff_t _Num2 = _Last2 - _First2;
 int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
 return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
 }
# 1023 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
                              ;
                              ;
 return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2)));
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  {
  if (_Pred(*_First1, *_First2))
   return (true);
  else if (_Pred(*_First2, *_First1))
   return (false);
  }
 return (_First1 == _Last1 && _First2 != _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred));
 }


template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
 {
 return ((-0x7f - 1) <= _Val && _Val <= 0x7f);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
 {
 return (_Val <= 0x7f || static_cast<_Ty>((-0x7f - 1)) <= _Val);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
 {
 return (_Val <= 0x7f);
 }

template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
 {
 return (0 <= _Val && _Val <= 0xff);
 }

template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
 {
 return (_Val <= 0xff);
 }

template<class _InIt,
 class _Ty> inline
 bool _Within_limits(_InIt, const _Ty& _Val)
 {
 typedef typename remove_pointer<_InIt>::type _Elem;
 return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
  integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
 }

template<class _InIt> inline
 bool _Within_limits(_InIt, const bool&)
 {
 return (true);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
 {
 if (!_Within_limits(_First, _Val))
  return (_Last);
 _First = static_cast<_InIt>(:: memchr(
  _First, static_cast<unsigned char>(_Val), _Last - _First));
 return (_First ? _First : _Last);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
 {
 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   break;
 return (_First);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {

 typedef integral_constant<bool,
  (is_same<_InIt, char *>::value
  || is_same<_InIt, signed char *>::value
  || is_same<_InIt, unsigned char *>::value
  || is_same<_InIt, const char *>::value
  || is_same<_InIt, const signed char *>::value
  || is_same<_InIt, const unsigned char *>::value)
  && is_integral<_Ty>::value
 > _Memchr_opt;
 return (_Find(_First, _Last, _Val, _Memchr_opt()));
 }

template<class _InIt,
 class _Ty> inline
 _InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Rechecked(_First,
  _Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   break;
 return (_First);
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _FwdIt _Next = _First;
 for (++_First; _First != _Last; ++_First)
 if (!_Pred(*_First))
  *_Next++ = _Move(*_First);
 return (_Next);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _First = ::std:: find_if(_First, _Last, _Pred);
 if (_First == _Last)
  return (_First);
 else
  return (_Rechecked(_First,
   _Remove_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt _Remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _FwdIt _Next = _First;
 for (++_First; _First != _Last; ++_First)
  if (!(*_First == _Val))
   *_Next++ = _Move(*_First);
 return (_Next);
 }

template<class _FwdIt,
 class _Ty> inline
 _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _First = ::std:: find(_First, _Last, _Val);
 if (_First == _Last)
  return (_First);
 else
  return (_Rechecked(_First,
   _Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty> inline
 typename iterator_traits<_InIt>::difference_type
  _Count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   ++_Count;
 return (_Count);
 }

template<class _InIt,
 class _Ty> inline
 typename iterator_traits<_InIt>::difference_type
  count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Count(_Unchecked(_First), _Unchecked(_Last), _Val));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 typename iterator_traits<_InIt>::difference_type
  _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   ++_Count;
 return (_Count);
 }



template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr,
  forward_iterator_tag, forward_iterator_tag)
 {
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred,
  bidirectional_iterator_tag, bidirectional_iterator_tag)
 {

 while (_Pred(*--_Last1, *--_Last2))
  ;
 ++_Last1;
 ++_Last2;
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
 _Trim_matching_suffixes(_Last1, _Last2, _Pred,
  _Iter_cat(_Last1), _Iter_cat(_Last2));
 typedef typename iterator_traits<_FwdIt1>::difference_type _Diff1;
 typedef typename iterator_traits<_FwdIt2>::difference_type _Diff2;
 for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
  if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
   {
   _Diff2 _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
   if (_Count2 == 0)
    return (false);
   _FwdIt1 _Skip1 = ::std:: next(_Next1);
   _Diff1 _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
   if (_Count2 != _Count1)
    return (false);
   }
 return (true);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   _FwdIt2 _Last2 = ::std:: next(_First2,
    ::std:: distance(_First1, _Last1));
   return (_Check_match_counts(_First1, _Last1,
    _First2, _Last2, _Pred));
   }
 return (true);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Pred));
 }
# 1383 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, equal_to<>()));
 }

template<class _FwdIt1,
 class _InTy,
 size_t _InSize> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _InTy (&_First2)[_InSize])
 {
 return (::std:: is_permutation(_First1, _Last1, _First2, equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
  forward_iterator_tag, forward_iterator_tag)
 {

                                                                 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   if (::std:: distance(_First1, _Last1)
    != ::std:: distance(_First2, _Last2))
    return (false);
   else
    return (_Check_match_counts(_First1, _Last1,
     _First2, _Last2, _Pred));
   }
 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
  random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
                                            ;
 return (_Is_permutation(_First1, _Last1, _First2, _Pred));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {

                              ;
                              ;
 return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
  _Iter_cat(_First1), _Iter_cat(_First2)));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, _Last2, equal_to<>()));
 }



template<class _BidIt> inline
 void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
 {
 for (; _First != _Last && _First != --_Last; ++_First)
  ::std:: iter_swap(_First, _Last);
 }

template<class _BidIt> inline
 void reverse(_BidIt _First, _BidIt _Last)
 {
                            ;
 _Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
 }


template<class _FwdIt> inline
 _FwdIt _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag)
 {
 for (_FwdIt _Next = _Mid, _Res = _Last; ; )
  {
  ::std:: iter_swap(_First, _Next);
  if (++_First == _Mid)
   {
   if (++_Next == _Last)
    return (_Res == _Last ? _Mid : _Res);
   else
    _Mid = _Next;
   }
  else if (++_Next == _Last)
   {
   if (_Res == _Last)
    _Res = _First;
   _Next = _Mid;
   }
  }
 }

template<class _BidIt> inline
 pair<_BidIt, _BidIt> _Reverse_until_sentinel(
  _BidIt _First, _BidIt _Sentinel, _BidIt _Last)
 {
 while (_First != _Sentinel && _Last != _Sentinel)
  ::std:: iter_swap(_First++, --_Last);
 return (::std:: make_pair(_First, _Last));
 }

template<class _BidIt> inline
 _BidIt _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag)
 {
 ::std:: reverse(_First, _Mid);
 ::std:: reverse(_Mid, _Last);
 pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel(_First, _Mid, _Last);
 ::std:: reverse(_Tmp.first, _Tmp.second);
 return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
 }

template<class _RanIt> inline
 _RanIt _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag)
 {
 ::std:: reverse(_First, _Mid);
 ::std:: reverse(_Mid, _Last);
 ::std:: reverse(_First, _Last);
 return (_First + (_Last - _Mid));
 }

template<class _FwdIt> inline
 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
 {
                           ;
                          ;
 if (_First == _Mid)
  return (_Last);
 if (_Mid == _Last)
  return (_First);
 _Rechecked(_First, _Rotate(_Unchecked(_First), _Unchecked(_Mid),
  _Unchecked(_Last), _Iter_cat(_First)));
 return (_First);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr> inline
 _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *,
  forward_iterator_tag, forward_iterator_tag)
 {
 for (; ; ++_First1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (_Mid1 == _Last1)
    return (_Last1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr> inline
 _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *,
  random_access_iterator_tag, random_access_iterator_tag)
 {
 _Diff1 _Count1 = _Last1 - _First1;
 _Diff2 _Count2 = _Last2 - _First2;

 for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }
 return (_Last1);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Rechecked(_First1,
  _Search(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Dist_type(_First1), _Dist_type(_First2),
   _Iter_cat(_First1), _Iter_cat(_First2))));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: search(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _Diff,
 class _Urng>
 class _Rng_from_urng
 {
public:
 typedef make_unsigned_t<_Diff> _Ty0;
 typedef typename _Urng::result_type _Ty1;

 typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
  _Ty0, _Ty1>::type _Udiff;

 explicit _Rng_from_urng(_Urng& _Func)
  : _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
  {
  for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
   --_Bits;
  }

 _Diff operator()(_Diff _Index)
  {
  for (; ; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while (_Mask < _Udiff(_Index - 1))
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits();
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if (_Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff(_Index - 1))
    return (_Ret % _Index);
   }
  }

 _Udiff _Get_all_bits()
  {
  _Udiff _Ret = 0;

  for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
   _Num += _Bits)
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits();
   }

  return (_Ret);
  }

 _Rng_from_urng(const _Rng_from_urng&) = delete;
 _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
 _Udiff _Get_bits()
  {
  for (; ; )
   {
   _Udiff _Val = _Ref() - (_Urng::min)();

   if (_Val <= _Bmask)
    return (_Val);
   }
  }

 _Urng& _Ref;
 size_t _Bits;
 _Udiff _Bmask;
 };


template<class _Elem>
 class _Yarn
 {
public:
 typedef _Yarn<_Elem> _Myt;

 _Yarn()
  : _Myptr(0), _Nul(0)
  {
  }

 _Yarn(const _Myt& _Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Yarn(const _Elem *_Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Myt& operator=(const _Myt& _Right)
  {
  return (*this = _Right._Myptr);
  }

 _Myt& operator=(const _Elem *_Right)
  {
  if (_Myptr != _Right)
   {
   _Tidy();

   if (_Right != 0)
    {
    const _Elem *_Ptr = _Right;
    while (*_Ptr != (_Elem)0)
     ++_Ptr;
    size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

    _Myptr = (_Elem *):: malloc(_Count);
    if (_Myptr != 0)
     :: memcpy(_Myptr, _Right, _Count);
    }
   }
  return (*this);
  }

 ~_Yarn() noexcept
  {
  _Tidy();
  }

 bool empty() const
  {
  return (_Myptr == 0);
  }

 const _Elem *c_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

private:
 void _Tidy()
  {
  if (_Myptr != 0)
   :: free(_Myptr);

  _Myptr = 0;
  }

 _Elem *_Myptr;
 _Elem _Nul;
 };


template<class _Ty,
 class _Alloc>
 struct _Has_allocator_type
 {







 template<class _Uty>
  static auto _Fn(int)
   -> is_convertible<_Alloc,
    typename _Uty::allocator_type>;


 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_Ty>(0)) type;
 };


struct allocator_arg_t
 {



 };




constexpr allocator_arg_t allocator_arg = allocator_arg_t();


void _Xbad_alloc() __attribute__((__noreturn__));
void _Xinvalid_argument(const char *) __attribute__((__noreturn__));
void _Xlength_error(const char *) __attribute__((__noreturn__));
void _Xout_of_range(const char *) __attribute__((__noreturn__));
void _Xoverflow_error(const char *) __attribute__((__noreturn__));
void _Xrange_error(const char *) __attribute__((__noreturn__));
void _Xruntime_error(const char *) __attribute__((__noreturn__));
# 1837 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
}

namespace std {

template<class _Ty,
 class _Alloc>
 struct uses_allocator
  : _Has_allocator_type<_Ty, _Alloc>::type
 {
 };
# 1857 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"




namespace std {
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
template<class _Ty> inline
                     _Ty *_Allocate(size_t _Count, _Ty *,
  bool _Try_aligned_allocation = true)
 {
 void *_Ptr = 0;

 if (_Count == 0)
  return (static_cast<_Ty *>(_Ptr));


 if ((size_t)(-1) / sizeof (_Ty) < _Count)
  _Xbad_alloc();
 const size_t _User_size = _Count * sizeof (_Ty);


 if (_Try_aligned_allocation
  && 4096UL <= _User_size)
  {
  static_assert(sizeof (void *) < 32UL, "Big allocations should at least match vector register size");

  const size_t _Block_size = (sizeof(void *) + 32UL - 1) + _User_size;
  if (_Block_size <= _User_size)
   _Xbad_alloc();
  const uintptr_t _Ptr_container =
   reinterpret_cast<uintptr_t>(::operator new(_Block_size));
                                                  ;
  _Ptr = reinterpret_cast<void *>((_Ptr_container + (sizeof(void *) + 32UL - 1))
   & ~(32UL - 1));
  static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;




  }
 else


  {
  _Ptr = ::operator new(_User_size);
                                        ;
  }
 return (static_cast<_Ty *>(_Ptr));
 }


template<class _Ty> inline
 void _Deallocate(_Ty * _Ptr, size_t _Count)
 {

                                                                   ;
 const size_t _User_size = _Count * sizeof (_Ty);
 if (4096UL <= _User_size)
  {
  const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);

                                                      ;
  const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
  const uintptr_t _Ptr_container =
   *reinterpret_cast<uintptr_t *>(_Ptr_ptr);
# 115 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
                                                         ;







                                 ;



                     ;

  _Ptr = reinterpret_cast<_Ty *>(_Ptr_container);
  }


 ::operator delete(_Ptr);
 }


template<class _Ty1,
 class _Ty2> inline
 void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
 {
 void *_Vptr = _Ptr;
 ::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
 }

template<class _Ty1> inline
 void _Construct(_Ty1 *_Ptr)
 {
 void *_Vptr = _Ptr;

 ::new (_Vptr) _Ty1();
 }


template<class _Ty> inline
 void _Destroy(_Ty *_Ptr)
 {
 _Ptr->~_Ty();
 }


template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al,
  _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  _Al.destroy(::std:: addressof(*_First));
 }

template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al,
  _Scalar_ptr_iterator_tag)
 {
 }

template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al)
 {
 _Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
 }


template<class _Alty>
 struct _Is_simple_alloc
  : _Cat_base<is_same<typename _Alty::size_type, size_t>::value
  && is_same<typename _Alty::difference_type, ptrdiff_t>::value
  && is_same<typename _Alty::pointer,
   typename _Alty::value_type *>::value
  && is_same<typename _Alty::const_pointer,
   const typename _Alty::value_type *>::value
  && is_same<typename _Alty::reference,
   typename _Alty::value_type&>::value
  && is_same<typename _Alty::const_reference,
   const typename _Alty::value_type&>::value>
 {
 };


template<class _Value_type>
 struct _Simple_types
 {
 typedef _Value_type value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef value_type& reference;
 typedef const value_type& const_reference;
 };


template<class _Alty,
 class _Pointer>
 struct _Get_voidptr
 {
 typedef typename _Alty::template rebind<void>::other _Alvoid;
 typedef typename _Alvoid::pointer type;
 };

template<class _Alty,
 class _Ty>
 struct _Get_voidptr<_Alty, _Ty *>
 {
 typedef void *type;
 };



template<class _Ty>
 struct _Get_first_parameter;

template<template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Get_first_parameter<_Ty<_First, _Rest...> >
 {
 typedef _First type;
 };


template<class _Newfirst,
 class _Ty>
 struct _Replace_first_parameter;

template<class _Newfirst,
 template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
 {
 typedef _Ty<_Newfirst, _Rest...> type;
 };
# 273 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
template<class _Ty>
 struct _Get_element_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_ptr_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Other>
 struct _Get_rebind_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Other>
 struct _Get_pointer_traits_rebind_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other> >; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct pointer_traits
 {
 typedef typename _Get_element_type<_Ty>::type element_type;
 typedef _Ty pointer;
 typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;


 template<class _Other>
  using rebind =
   typename _Get_pointer_traits_rebind_type<_Ty, _Other>::type;
# 321 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
 typedef typename _If<is_void<element_type>::value,
  char&,
  add_lvalue_reference_t<element_type> >::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (_Ty::pointer_to(_Val));
  }
 };


template<class _Ty>
 struct pointer_traits<_Ty *>
 {
 typedef _Ty element_type;
 typedef _Ty *pointer;
 typedef ptrdiff_t difference_type;


 template<class _Other>
  using rebind = _Other *;
# 353 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
 typedef typename _If<is_void<_Ty>::value,
  char&,
  add_lvalue_reference_t<_Ty> >::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (::std:: addressof(_Val));
  }
 };


template<class _Ty>
 struct _Get_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_const_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_const_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_size_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<make_unsigned_t< typename _Get_difference_type<_Ty>::type> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_propagate_on_container_copy
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_move
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_swap
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_is_always_equal
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::is_always_equal>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename is_empty<_Ty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



struct _Alloc_allocate
 {

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer _Hint)
   -> decltype(_Al.allocate(_Count, _Hint))
  {
  return (_Al.allocate(_Count, _Hint));
  }

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(_Wrap_int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer)
   -> decltype(_Al.allocate(_Count))
  {
  return (_Al.allocate(_Count));
  }
 };


struct _Alloc_construct
 {


 template<class _Ty,
  class _Objty,
  class... _Types>
  static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
   _Types&&... _Args)
   -> __void_t<decltype(
    _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...))>
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty,
  class _Objty,
  class... _Types>
  static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
   _Types&&... _Args)
  {
  ::new (static_cast<void *>(_Ptr))
   _Objty(::std:: forward<_Types>(_Args)...);
  }
 };


struct _Alloc_destroy
 {
 template<class _Ty,
  class _Objty>
  static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
   -> __void_t<decltype(_Al.destroy(_Ptr))>
  {
  _Al.destroy(_Ptr);
  }

 template<class _Ty,
  class _Objty>
  static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
  {
  _Ptr->~_Objty();
  }
 };


struct _Alloc_max_size
 {
 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al) noexcept
   -> decltype(_Al.max_size())
  {
  return (_Al.max_size());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty&) noexcept
   -> typename _Get_size_type<_Ty>::type
  {
  return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
  }
 };


struct _Alloc_select
 {


 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al)
   -> decltype((_Ty)_Al.select_on_container_copy_construction())
  {
  return (_Al.select_on_container_copy_construction());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty& _Al)
   -> _Ty
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct allocator_traits
 {
 typedef _Alloc allocator_type;
 typedef typename _Alloc::value_type value_type;

 typedef typename _Get_pointer_type<_Alloc>::type
  pointer;
 typedef typename _Get_const_pointer_type<_Alloc>::type
  const_pointer;
 typedef typename _Get_void_pointer_type<_Alloc>::type
  void_pointer;
 typedef typename _Get_const_void_pointer_type<_Alloc>::type
  const_void_pointer;

 typedef typename _Get_size_type<_Alloc>::type size_type;
 typedef typename _Get_difference_type<_Alloc>::type difference_type;

 typedef typename _Get_propagate_on_container_copy<_Alloc>::type
  propagate_on_container_copy_assignment;
 typedef typename _Get_propagate_on_container_move<_Alloc>::type
  propagate_on_container_move_assignment;
 typedef typename _Get_propagate_on_container_swap<_Alloc>::type
  propagate_on_container_swap;






 template<class _Other>
  using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

 template<class _Other>
  using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
# 594 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
 static pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  static void construct(_Alloc& _Al, _Ty *_Ptr,
   _Types&&... _Args)
  {
  _Alloc_construct::_Fn(0, _Al, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  static void destroy(_Alloc& _Al, _Ty *_Ptr)
  {
  _Alloc_destroy::_Fn(0, _Al, _Ptr);
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Alloc_max_size::_Fn(0, _Al));
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Alloc_select::_Fn(0, _Al));
  }
 };


template<class _Ty>
 struct _Allocator_base
 {
 typedef _Ty value_type;
 };


template<class _Ty>
 struct _Allocator_base<const _Ty>
 {
 typedef _Ty value_type;
 };


template<class _Ty>
 class allocator
  : public _Allocator_base<_Ty>
 {
public:







 typedef _Allocator_base<_Ty> _Mybase;
 typedef typename _Mybase::value_type value_type;

 typedef value_type *pointer ;
 typedef const value_type *const_pointer ;

 typedef value_type& reference ;
 typedef const value_type& const_reference ;

 typedef size_t size_type ;
 typedef ptrdiff_t difference_type ;

 typedef false_type propagate_on_container_copy_assignment;

 typedef true_type propagate_on_container_move_assignment;



 typedef false_type propagate_on_container_swap;




 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

                pointer address(reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

                const_pointer address(const_reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

 allocator() noexcept
  {
  }

 allocator(const allocator<_Ty>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<_Ty>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Deallocate(_Ptr, _Count);
  }

                     pointer allocate(size_type _Count)
  {
  return (_Allocate(_Count, (pointer)0));
  }

                                    pointer allocate(size_type _Count, const void *)
  {
  return (allocate(_Count));
  }

 template<class _Objty,
  class... _Types>
                 void construct(_Objty *_Ptr, _Types&&... _Args)
  {
  ::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
  }

 template<class _Uty>
                 void destroy(_Uty *_Ptr)
  {
  _Ptr->~_Uty();
  }

                size_t max_size() const noexcept
  {
  return ((size_t)(-1) / sizeof (_Ty));
  }
 };


template<>
 class allocator<void>
 {
public:






 typedef void value_type;

 typedef void *pointer;
 typedef const void *const_pointer;

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 allocator() noexcept
  {
  }

 allocator(const allocator<void>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<void>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const allocator<_Ty>&,
  const allocator<_Other>&) noexcept
 {
 return (true);
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const allocator<_Ty>& _Left,
  const allocator<_Other>& _Right) noexcept
 {
 return (false);
 }


template<class _Ty>
 struct allocator_traits<allocator<_Ty> >
 {
 typedef allocator<_Ty> _Alloc;

 typedef _Alloc allocator_type;

 typedef typename _Alloc::value_type value_type;




 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef void *void_pointer;
 typedef const void *const_void_pointer;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;

 typedef true_type propagate_on_container_move_assignment;



 typedef false_type propagate_on_container_swap;





 template<class _Other>
  using rebind_alloc = allocator<_Other>;

 template<class _Other>
  using rebind_traits = allocator_traits<allocator<_Other> >;
# 871 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
 static pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Al.allocate(_Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Objty,
  class... _Types>
  static void construct(_Alloc& _Al, _Objty *_Ptr,
   _Types&&... _Args)
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Uty>
  static void destroy(_Alloc& _Al, _Uty *_Ptr)
  {
  _Al.destroy(_Ptr);
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Al.max_size());
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct _Wrap_alloc
  : public _Alloc
 {






 typedef _Alloc _Mybase;
 typedef allocator_traits<_Alloc> _Mytraits;

 typedef typename _Mytraits::value_type value_type;

 typedef typename _Mytraits::pointer pointer;
 typedef typename _Mytraits::const_pointer const_pointer;
 typedef typename _Mytraits::void_pointer void_pointer;
 typedef typename _Mytraits::const_void_pointer const_void_pointer;

 typedef typename _If<is_void<value_type>::value,
  int, value_type>::type& reference;
 typedef typename _If<is_void<const value_type>::value,
  const int, const value_type>::type& const_reference;

 typedef typename _Mytraits::size_type size_type;
 typedef typename _Mytraits::difference_type difference_type;

 typedef typename _Mytraits::propagate_on_container_copy_assignment
  propagate_on_container_copy_assignment;
 typedef typename _Mytraits::propagate_on_container_move_assignment
  propagate_on_container_move_assignment;
 typedef typename _Mytraits::propagate_on_container_swap
  propagate_on_container_swap;





 _Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
  {
  return (_Mytraits::select_on_container_copy_construction(*this));
  }

 template<class _Other>
  struct rebind
  {
  typedef typename _Mytraits::template rebind_alloc<_Other>
   _Other_alloc;
  typedef _Wrap_alloc<_Other_alloc> other;
  };

 pointer address(reference _Val) const
  {
  return (::std:: addressof(_Val));
  }

 const_pointer address(const_reference _Val) const
  {
  return (::std:: addressof(_Val));
  }

 _Wrap_alloc() noexcept
  : _Mybase()
  {
  }

 _Wrap_alloc(const _Mybase& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc(const _Wrap_alloc& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Wrap_alloc(const _Other& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Wrap_alloc(_Other& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc& operator=(const _Mybase& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 _Wrap_alloc& operator=(const _Wrap_alloc& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 template<class _Other>
  _Wrap_alloc& operator=(const _Other& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

                     pointer allocate(size_type _Count)
  {
  return (_Mybase::allocate(_Count));
  }

                     pointer allocate(size_type _Count,
  const_void_pointer _Hint, _Nil = _Nil())
  {
  return (_Mytraits::allocate(*this, _Count, _Hint));
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Mybase::deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  void construct(_Ty *_Ptr,
   _Types&&... _Args)
  {
  _Mytraits::construct(*this, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  void destroy(_Ty *_Ptr)
  {
  _Mytraits::destroy(*this, _Ptr);
  }

 size_type max_size(_Nil = _Nil()) const noexcept
  {
  return (_Mytraits::max_size(*this));
  }
 };

template<class _Ty>
 struct _Wrap_alloc<_Ty *>
  : public _Wrap_alloc<allocator<_Ty *> >
 {
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
 {
 _Left = _Right;
 }

template<class _Alty> inline
 void _Pocca(_Alty&, const _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_copy_assignment _Tag;
 _Pocca(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Left = ::std:: move(_Right);
 }

template<class _Alty> inline
 void _Pocma(_Alty&, _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_move_assignment _Tag;
 _Pocma(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Swap_adl(_Left, _Right);
 }

template<class _Alty> inline
 void _Pocs(_Alty&, _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_swap _Tag;
 _Pocs(_Left, _Right, _Tag);
 }
}







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 2 3

namespace std {

typedef enum memory_order {
 memory_order_relaxed,
 memory_order_consume,
 memory_order_acquire,
 memory_order_release,
 memory_order_acq_rel,
 memory_order_seq_cst
 } memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;
# 97 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
typedef unsigned char _Atomic_flag_t;
# 119 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
extern "C" {
_Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order);
int _Atomic_compare_exchange_weak_4(
 volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order);
_Uint4_t _Atomic_fetch_add_4(
 volatile _Uint4_t *, _Uint4_t, memory_order);
_Uint4_t _Atomic_fetch_sub_4(
 volatile _Uint4_t *, _Uint4_t, memory_order);
}

_Uint4_t _Atomic_load_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, memory_order);
int _Atomic_compare_exchange_weak_4_locking(
 volatile _Atomic_flag_t *, _Uint4_t *, _Uint4_t *, _Uint4_t,
  memory_order, memory_order);
_Uint4_t _Atomic_fetch_add_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, _Uint4_t, memory_order);
_Uint4_t _Atomic_fetch_sub_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, _Uint4_t, memory_order);
# 250 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
typedef _Atomic_integral_t _Atomic_counter_t;


inline _Atomic_integral_t
 _Get_atomic_count(const _Atomic_counter_t& _Counter)
 {
 return (_Counter);
 }

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
 _Atomic_integral_t _Value)
 {
 _Counter = _Value;
 }

inline _Atomic_integral_t _Inc_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_fetch_add_4(&_Counter, 1, _Order) + 1);
 }

inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Dec_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_fetch_sub_4(&_Counter, 1, _Order) - 1);
 }

inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Load_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_load_4(&_Counter, _Order));
 }

inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Load_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(
 _Atomic_counter_t& _Counter,
 _Atomic_integral_t _Expected,
 memory_order _Order)
 {
 return ((_Atomic_integral_t)_Atomic_compare_exchange_weak_4(
  &_Counter, &_Expected, _Expected + 1,
  _Order, _Order));
 }

inline _Atomic_integral_t _Compare_increment_atomic_counter(
 _Atomic_counter_t& _Counter, _Atomic_integral_t _Expected)
 {
 return (_Compare_increment_atomic_counter_explicit(
  _Counter, _Expected, memory_order_seq_cst));
 }
# 351 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
extern "C" {
void _Lock_shared_ptr_spin_lock();
void _Unlock_shared_ptr_spin_lock();
}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 2 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 3
namespace std {

typedef unsigned char _Uint1_t;
typedef unsigned short _Uint2_t;

typedef unsigned long long _Uint8_t;
# 68 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 3
extern "C" {
void _Atomic_store_1(volatile _Uint1_t *_Tgt, _Uint1_t _Value,
 memory_order _Order);
_Uint1_t _Atomic_load_1(volatile _Uint1_t *_Tgt,
 memory_order _Order);
_Uint1_t _Atomic_exchange_1(volatile _Uint1_t *_Tgt,
 _Uint1_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_1(
 volatile _Uint1_t *_Tgt, _Uint1_t *_Exp, _Uint1_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_1(
 volatile _Uint1_t *_Tgt, _Uint1_t *_Exp, _Uint1_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint1_t _Atomic_fetch_add_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_sub_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_and_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_or_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_xor_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
void _Atomic_store_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_load_2(
 volatile _Uint2_t *_Tgt, memory_order _Order);
_Uint2_t _Atomic_exchange_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
int _Atomic_compare_exchange_weak_2(
 volatile _Uint2_t *_Tgt, _Uint2_t *_Exp, _Uint2_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_strong_2(
 volatile _Uint2_t *_Tgt, _Uint2_t *_Exp, _Uint2_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint2_t _Atomic_fetch_add_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_sub_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_and_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_or_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_xor_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
void _Atomic_store_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_load_4(
 volatile _Uint4_t *_Tgt, memory_order _Order);
_Uint4_t _Atomic_exchange_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_4(
 volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_4(
 volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint4_t _Atomic_fetch_add_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_sub_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_and_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_or_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_xor_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
void _Atomic_store_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_load_8(
 volatile _Uint8_t *_Tgt, memory_order _Order);
_Uint8_t _Atomic_exchange_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_8(
 volatile _Uint8_t *_Tgt, _Uint8_t *_Exp, _Uint8_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_8(
 volatile _Uint8_t *_Tgt, _Uint8_t *_Exp, _Uint8_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint8_t _Atomic_fetch_add_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_sub_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_and_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_or_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_xor_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
int _Atomic_flag_test_and_set(volatile _Atomic_flag_t *_Flag,
 memory_order _Order);
void _Atomic_flag_clear(volatile _Atomic_flag_t *_Flag,
 memory_order _Order);
void _Atomic_thread_fence(memory_order _Order);
void _Atomic_signal_fence(memory_order _Order);


int _Atomic_is_lock_free_1();
int _Atomic_is_lock_free_2();
int _Atomic_is_lock_free_4();
int _Atomic_is_lock_free_8();
}
# 190 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 3
inline void _Lock_spin_lock_i(
 volatile _Atomic_flag_t *_Flag)
 {
 while (__c11_atomic_exchange ((_Atomic(_Atomic_flag_t)*)_Flag, (_Atomic_flag_t)1, memory_order_acquire))
                  ;
 }

inline void _Unlock_spin_lock_i(
 volatile _Atomic_flag_t *_Flag)
 {
 __c11_atomic_store ((_Atomic(_Atomic_flag_t)*)_Flag, (_Atomic_flag_t)0, memory_order_release);
 }



inline void _Atomic_copy_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile const void *_Src,
   memory_order _Order)
 {
 _Lock_spin_lock_i(_Flag);
 memcpy((void *)_Tgt, (void *)_Src, _Size);
 _Unlock_spin_lock_i(_Flag);
 }

inline void _Atomic_exchange_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile void *_Src,
   memory_order _Order)
 {
 unsigned char *_Left = (unsigned char *)_Tgt;
 unsigned char *_Right = (unsigned char *)_Src;

 _Lock_spin_lock_i(_Flag);
 for (; 0 < _Size; --_Size)
  {
  unsigned char _Tmp = *_Left;
  *_Left++ = *_Right;
  *_Right++ = _Tmp;
  }
 _Unlock_spin_lock_i(_Flag);
 }

inline int _Atomic_compare_exchange_weak_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile void *_Exp, const volatile void *_Src,
   memory_order _Order1, memory_order _Order2)
 {
 int _Result;

 _Lock_spin_lock_i(_Flag);
 _Result = memcmp((const void *)_Tgt, (const void *)_Exp, _Size) == 0;
 if (_Result != 0)
  memcpy((void *)_Tgt, (void *)_Src, _Size);
 else
  memcpy((void *)_Exp, (void *)_Tgt, _Size);
 _Unlock_spin_lock_i(_Flag);
 return (_Result);
 }

inline int _Atomic_compare_exchange_strong_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
 volatile void *_Tgt, volatile void *_Exp, const volatile void *_Src,
 memory_order _Order1, memory_order _Order2)
 {
 return (_Atomic_compare_exchange_weak_i(_Flag, _Size, _Tgt, _Exp, _Src,
  _Order1, _Order2));
 }
}
# 1147 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3
# 1185 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
#pragma clang diagnostic pop
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 2 3
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
namespace std {
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Ax = allocator<_Elem> >
 class basic_string;
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
template<class _Mystr>
 class _String_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Mystr::value_type,
   typename _Mystr::difference_type,
   typename _Mystr::const_pointer,
   typename _Mystr::const_reference,
   _Iterator_base>
 {
public:
 typedef _String_const_iterator<_Mystr> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::const_pointer pointer;
 typedef typename _Mystr::const_reference reference;

 _String_const_iterator()
  {
  this->_Ptr = 0;
  }

 _String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
  {
  this->_Adopt(_Pstring);
  this->_Ptr = _Parg;
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
# 106 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  return (*this->_Ptr);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  ++this->_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 161 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  --this->_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
# 193 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  if (this->_Getcont() != _Right._Getcont())
   _Compat(_Right);
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
# 277 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 void _Compat(const _Myiter&) const
  {
  }


 pointer _Ptr;
 };

template<class _Mystr> inline
 typename _String_const_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_const_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr>
  _Rechecked(_String_const_iterator<_Mystr>& _Iter,
   typename _String_const_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr> operator+(
  typename _String_const_iterator<_Mystr>
   ::difference_type _Off,
  _String_const_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Mystr>
 class _String_iterator
  : public _String_const_iterator<_Mystr>
 {
public:
 typedef _String_iterator<_Mystr> _Myiter;
 typedef _String_const_iterator<_Mystr> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::pointer pointer;
 typedef typename _Mystr::reference reference;

 _String_iterator()
  {
  }

 _String_iterator(pointer _Parg, const _Container_base *_Pstring)
  : _Mybase(_Parg, _Pstring)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Mystr> inline
 typename _String_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_iterator<_Mystr>
  _Rechecked(_String_iterator<_Mystr>& _Iter,
   typename _String_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_iterator<_Mystr> operator+(
  typename _String_iterator<_Mystr>
   ::difference_type _Off,
  _String_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }



template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _String_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _String_base_types
 {
# 474 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 typedef _Alloc0 _Alloc;


 typedef _String_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _String_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _String_val
  : public _Container_base
 {
public:
 typedef _String_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;






 typedef _String_iterator<_Myt> iterator;
 typedef _String_const_iterator<_Myt> const_iterator;


 _String_val()
  : _Bx{}
  {
  _Mysize = 0;
  _Myres = 0;
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
   : 16 / sizeof (value_type)};
 enum
  {
  _ALLOC_MASK = sizeof (value_type) <= 1 ? 15
   : sizeof (value_type) <= 2 ? 7
   : sizeof (value_type) <= 4 ? 3
   : sizeof (value_type) <= 8 ? 1 : 0};

 value_type *_Myptr()
  {
  return (this->_BUF_SIZE <= this->_Myres
   ? ::std:: addressof(*this->_Bx._Ptr)
   : this->_Bx._Buf);
  }

 const value_type *_Myptr() const
  {
  return (this->_BUF_SIZE <= this->_Myres
   ? ::std:: addressof(*this->_Bx._Ptr)
   : this->_Bx._Buf);
  }

 union _Bxty
  {
  value_type _Buf[_BUF_SIZE];
  pointer _Ptr;
  char _Alias[_BUF_SIZE];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _String_alloc
  : public _String_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alty _Alty;


 _String_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alval(_Al)
  {
  }

 _String_alloc(_Alloc0&& _Al)
  : _Alval(::std:: move(_Al))
  {
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Alval, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Alval, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(_Alval, _Right._Alval);
  }
# 657 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Alty& _Getal() noexcept
  {
  return (_Alval);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alval);
  }

 _Alty _Alval;
 };

template<class _Alloc_types>
 class _String_alloc<false, _Alloc_types>
  : public _String_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _String_alloc<false, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alty _Alty;


 _String_alloc(const _Alloc0& = _Alloc0())
  {
  }

 _String_alloc(_Alloc0&&)
  {
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 749 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Elem,
 class _Traits,
 class _Alloc>
 class basic_string
  : public _String_alloc<!is_empty<_Alloc>::value,
   _String_base_types<_Elem, _Alloc> >
 {
public:
 typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
 typedef _String_alloc<!is_empty<_Alloc>::value,
  _String_base_types<_Elem, _Alloc> > _Mybase;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
# 789 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;


 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 basic_string(const _Myt& _Right)
  : _Mybase(_Right._Getal().select_on_container_copy_construction())
  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
  : _Mybase(_Alloc())
  {
  _Tidy();
  }

 explicit basic_string(const _Alloc& _Al) noexcept
  : _Mybase(_Al)
  {
  _Tidy();
  }
# 830 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 basic_string(const _Myt& _Right, size_type _Roff,
  size_type _Count = npos)
  : _Mybase(_Right._Getal())
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }

 basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
  const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }
# 864 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 basic_string(const _Elem *_Ptr, size_type _Count)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(const _Elem *_Ptr, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(size_type _Count, _Elem _Ch)
  : _Mybase()
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
                             ;
  _Tidy();
  _Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, input_iterator_tag)
  {
  {{
  for (; _First != _Last; ++_First)
   append((size_type)1, (_Elem)*_First);
  } if (0) {
  _Tidy(true);
          ;
  }}
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, forward_iterator_tag)
  {
  size_type _Count = 0;
  _Distance(_First, _Last, _Count);
  reserve(_Count);
  _Construct(_First, _Last, input_iterator_tag());
  }

 void _Construct(_Elem *_First,
  _Elem *_Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   assign(_First, _Last - _First);
  }

 void _Construct(const _Elem *_First,
  const _Elem *_Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   assign(_First, _Last - _First);
  }

 basic_string(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Tidy();
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 basic_string(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  if (this->_Getal() != _Right._Getal())
   assign(_Right.begin(), _Right.end());
  else
   _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)




  noexcept

  {
  if (this != &_Right)
   {
   _Tidy(true);
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());
   if (this->_Getal() != _Right._Getal())
    assign(_Right.begin(), _Right.end());
   else
    _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 _Myt& assign(_Myt&& _Right) noexcept
  {
  if (this == &_Right)
   ;
  else if (get_allocator() != _Right.get_allocator()
   && this->_BUF_SIZE <= _Right._Myres)
   *this = _Right;
  else
   {
   _Tidy(true);
   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  if (_Right._Myres < this->_BUF_SIZE)
   _Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
    _Right._Mysize + 1);
  else
   {
   this->_Bx._Ptr = _Right._Bx._Ptr;
   _Right._Bx._Ptr = pointer();
   }
  this->_Mysize = _Right._Mysize;
  this->_Myres = _Right._Myres;
  _Right._Tidy();
  }

 basic_string(::std:: initializer_list<_Elem> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& assign(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& append(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
  }

 ~basic_string() noexcept
  {
  _Tidy(true);
  }

 static const size_type npos = (size_t)(-1);

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    _Tidy(true);
    this->_Copy_alloc(_Right._Getal());
    }
   assign(_Right);
   }
  return (*this);
  }
# 1091 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& operator=(const _Elem *_Ptr)
  {
  return (assign(_Ptr));
  }

 _Myt& operator=(_Elem _Ch)
  {
  return (assign(1, _Ch));
  }

 _Myt& operator+=(const _Myt& _Right)
  {
  return (append(_Right));
  }
# 1113 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& operator+=(const _Elem *_Ptr)
  {
  return (append(_Ptr));
  }

 _Myt& operator+=(_Elem _Ch)
  {
  return (append((size_type)1, _Ch));
  }

 _Myt& append(const _Myt& _Right)
  {
  return (append(_Right, 0, npos));
  }

 _Myt& append(const _Myt& _Right,
  size_type _Roff, size_type _Count = npos)
  {
  if (_Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;

  size_t _Oldsize = this->_Mysize;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::copy(this->_Myptr() + _Oldsize,
    _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& append(const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (append(*this,
    _Ptr - this->_Myptr(), _Count));
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  size_type _Num;
  size_type _Oldsize = this->_Mysize;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::copy(this->_Myptr() + _Oldsize, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& append(const _Elem *_Ptr)
  {
                      ;
  return (append(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& append(size_type _Count, _Elem _Ch)
  {
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Chassign(this->_Mysize, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& append(_Iter _First, _Iter _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }




 _Myt& append(const_pointer _First, const_pointer _Last)
  {
                                            ;
  if (_Last < _First)
   _Xran();
  return (append(_First, _Last - _First));
  }


 _Myt& append(const_iterator _First, const_iterator _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& assign(const _Myt& _Right)
  {
  return (assign(_Right, 0, npos));
  }

 _Myt& assign(const _Myt& _Right,
  size_type _Roff, size_type _Count = npos)
  {
  if (_Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Count < _Num)
   _Num = _Count;

  if (this == &_Right)
   erase((size_type)(_Roff + _Num)), erase(0, _Roff);
  else if (_Grow(_Num))
   {
   _Traits::copy(this->_Myptr(),
    _Right._Myptr() + _Roff, _Num);
   _Eos(_Num);
   }
  return (*this);
  }
# 1284 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& assign(const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (assign(*this,
    (size_type)(_Ptr - this->_Myptr()), _Count));

  if (_Grow(_Count))
   {
   _Traits::copy(this->_Myptr(), _Ptr, _Count);
   _Eos(_Count);
   }
  return (*this);
  }

 _Myt& assign(const _Elem *_Ptr)
  {
                      ;
  return (assign(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& assign(size_type _Count, _Elem _Ch)
  {
  if (_Count == npos)
   _Xlen();

  if (_Grow(_Count))
   {
   _Chassign(0, _Count, _Ch);
   _Eos(_Count);
   }
  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& assign(_Iter _First, _Iter _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }




 _Myt& assign(const_pointer _First, const_pointer _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }


 _Myt& assign(const_iterator _First, const_iterator _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& insert(size_type _Off, const _Myt& _Right)
  {
  return (insert(_Off, _Right, 0, npos));
  }

 _Myt& insert(size_type _Off,
  const _Myt& _Right, size_type _Roff, size_type _Count = npos)
  {
  if (this->_Mysize < _Off || _Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   if (this == &_Right)
    _Traits::move(this->_Myptr() + _Off,
     this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
      _Count);
   else
    _Traits::copy(this->_Myptr() + _Off,
     _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1392 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& insert(size_type _Off,
  const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (insert(_Off, *this,
    _Ptr - this->_Myptr(), _Count));
  if (this->_Mysize < _Off)
   _Xran();
  if (npos - this->_Mysize <= _Count)
   _Xlen();
  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& insert(size_type _Off, const _Elem *_Ptr)
  {
                      ;
  return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& insert(size_type _Off,
  size_type _Count, _Elem _Ch)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (npos - this->_Mysize <= _Count)
   _Xlen();
  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 iterator insert(const_iterator _Where)
  {
  return (insert(_Where, _Elem()));
  }

 iterator insert(const_iterator _Where, _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, 1, _Ch);
  return (begin() + (difference_type)_Off);
  }

 iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, _Count, _Ch);
  return (begin() + _Off);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }




 iterator insert(const_iterator _Where,
  const_pointer _First, const_pointer _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }


 iterator insert(const_iterator _Where,
  const_iterator _First, const_iterator _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 _Myt& erase(size_type _Off = 0)
  {
  if (this->_Mysize < _Off)
   _Xran();
  _Eos(_Off);
  return (*this);
  }

 _Myt& erase(size_type _Off, size_type _Count)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off <= _Count)
   _Eos(_Off);
  else if (0 < _Count)
   {
   value_type *_Ptr = this->_Myptr() + _Off;
   size_type _Newsize = this->_Mysize - _Count;
   _Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
   _Eos(_Newsize);
   }
  return (*this);
  }

 iterator erase(const_iterator _Where)
  {
  size_type _Count = _Where - begin();
  erase(_Count, 1);
  return (begin() + _Count);
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
                             ;
  size_type _Count = _First - begin();
  erase(_Count, _Last - _First);
  return (begin() + _Count);
  }

 void clear() noexcept
  {
  _Eos(0);
  }

 _Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
  {
  return (replace(_Off, _N0, _Right, 0, npos));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Myt& _Right, size_type _Roff,
   size_type _Count = npos)
  {
  if (this->_Mysize < _Off || _Right.size() < _Roff)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();

  size_type _Nm = this->_Mysize - _N0 - _Off;
  size_type _Newsize = this->_Mysize + _Count - _N0;
  if (this->_Mysize < _Newsize)
   _Grow(_Newsize);

  if (this != &_Right)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off,
    _Right._Myptr() + _Roff, _Count);
   }
  else if (_Count <= _N0)
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   }
  else if (_Roff <= _Off)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   }
  else if (_Off + _N0 <= _Roff)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + (_Roff + _Count - _N0),
    _Count);
   }
  else
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _N0);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off + _N0,
    this->_Myptr() + _Roff + _Count,
    _Count - _N0);
   }

  _Eos(_Newsize);
  return (*this);
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (replace(_Off, _N0, *this,
    (size_type)(_Ptr - this->_Myptr()),
    _Count));
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  size_type _Num;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num = this->_Mysize + _Count - _N0))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1660 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
  {
                      ;
  return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  size_type _Num;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num = this->_Mysize + _Count - _N0))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Myt& _Right)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Right));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr, size_type _Count)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Ptr));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Count, _Ch));
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& replace(const_iterator _First, const_iterator _Last,
   _Iter _First2, _Iter _Last2)
  {
  _Myt _Right(_First2, _Last2);
  replace(_First, _Last, _Right);
  return (*this);
  }




 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  pointer _First2, pointer _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }


 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  iterator _First2, iterator _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 iterator begin() noexcept
  {
  return (iterator(this->_Myptr(), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Myptr(), this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Myptr() + this->_Mysize, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Myptr() + this->_Mysize, this));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if ((size() | this->_ALLOC_MASK) < capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 reference at(size_type _Off)
  {
  if (this->_Mysize <= _Off)
   _Xran();
  return (this->_Myptr()[_Off]);
  }

 const_reference at(size_type _Off) const
  {
  if (this->_Mysize <= _Off)
   _Xran();
  return (this->_Myptr()[_Off]);
  }
# 1883 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 reference operator[](size_type _Off)
  {
# 1893 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  return (this->_Myptr()[_Off]);
  }

 const_reference operator[](size_type _Off) const
  {
# 1906 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  return (this->_Myptr()[_Off]);
  }

 void push_back(_Elem _Ch)
  {
  insert(end(), _Ch);
  }

 void pop_back()
  {
  erase(this->_Mysize - 1);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 const _Elem *c_str() const noexcept
  {
  return (this->_Myptr());
  }

 const _Elem *data() const noexcept
  {
  return (c_str());
  }

 _Elem *data() noexcept
  {
  return (this->_Myptr());
  }

 size_type length() const noexcept
  {
  return (this->_Mysize);
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  size_type _Num = this->_Getal().max_size();
  return (_Num <= 1 ? 1 : _Num - 1);
  }

 void resize(size_type _Newsize)
  {
  resize(_Newsize, _Elem());
  }

 void resize(size_type _Newsize, _Elem _Ch)
  {
  if (_Newsize <= this->_Mysize)
   _Eos(_Newsize);
  else
   append(_Newsize - this->_Mysize, _Ch);
  }

 size_type capacity() const noexcept
  {
  return (this->_Myres);
  }

 void reserve(size_type _Newcap = 0)
  {
  if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
   {
   size_type _Size = this->_Mysize;
   if (_Grow(_Newcap, true))
    _Eos(_Size);
   }
  }

 bool empty() const noexcept
  {
  return (this->_Mysize == 0);
  }

 size_type copy(_Elem *_Ptr,
  size_type _Count, size_type _Off = 0) const
  {
                                      ;
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _Count)
   _Count = this->_Mysize - _Off;
  _Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

 void _Swap_bx(_Myt& _Right)
  {
  if (this->_BUF_SIZE <= this->_Myres)
   if (this->_BUF_SIZE <= _Right._Myres)
    _Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
   else
    {
    pointer _Ptr = this->_Bx._Ptr;
    _Traits::copy(this->_Bx._Buf,
     _Right._Bx._Buf, _Right._Mysize + 1);
    _Right._Bx._Ptr = _Ptr;
    }
  else
   if (_Right._Myres < this->_BUF_SIZE)
    ::std:: swap(this->_Bx._Buf, _Right._Bx._Buf);
   else
    {
    pointer _Ptr = _Right._Bx._Ptr;
    _Traits::copy(_Right._Bx._Buf,
     this->_Bx._Buf, this->_Mysize + 1);
    this->_Bx._Ptr = _Ptr;
    }
  }

 void swap(_Myt& _Right)


  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   ::std:: swap(this->_Myres, _Right._Myres);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {

   this->_Swap_alloc(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Bx, _Right._Bx);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   ::std:: swap(this->_Myres, _Right._Myres);
   }
  else
   {
   _Myt _Tmp = *this;

   *this = _Right;
   _Right = _Tmp;
   }
  }

 size_type find(const _Myt& _Right, size_type _Off = 0) const noexcept
  {
  return (find(_Right._Myptr(), _Off, _Right.size()));
  }
# 2082 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Count == 0 && _Off <= this->_Mysize)
   return (_Off);

  size_type _Nm;
  if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
   {
   const _Elem *_Uptr, *_Vptr;
   for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
    (_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
    if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find(const _Elem *_Ptr, size_type _Off = 0) const
  {
                      ;
  return (find(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find(_Elem _Ch, size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type rfind(const _Myt& _Right, size_type _Off = npos) const noexcept
  {
  return (rfind(_Right._Myptr(), _Off, _Right.size()));
  }
# 2126 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type rfind(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Count == 0)
   return (_Off < this->_Mysize ? _Off
    : this->_Mysize);
  if (_Count <= this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr() +
    (_Off < this->_Mysize - _Count ? _Off
     : this->_Mysize - _Count);
   for (; ; --_Uptr)
    if (_Traits::eq(*_Uptr, *_Ptr)
     && _Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
  {
                      ;
  return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type rfind(_Elem _Ch, size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_of(const _Myt& _Right,
  size_type _Off = 0) const noexcept
  {
  return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2173 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < _Count && _Off < this->_Mysize)
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_of(const _Myt& _Right,
  size_type _Off = npos) const noexcept
  {
  return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2216 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < _Count && 0 < this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_not_of(const _Myt& _Right,
  size_type _Off = 0) const noexcept
  {
  return (find_first_not_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2261 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Off < this->_Mysize)
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
   }
  return (npos);
  }

 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_not_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_not_of(const _Myt& _Right,
  size_type _Off = npos) const noexcept
  {
  return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2303 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }
  return (npos);
  }

 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_not_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 _Myt substr(size_type _Off = 0, size_type _Count = npos) const
  {
  return (_Myt(*this, _Off, _Count, get_allocator()));
  }

 int compare(const _Myt& _Right) const noexcept
  {
  return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
  }
# 2350 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 int compare(size_type _Off, size_type _N0, const _Myt& _Right) const
  {
  return (compare(_Off, _N0, _Right, 0, npos));
  }
# 2362 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 int compare(size_type _Off, size_type _N0, const _Myt& _Right,
  size_type _Roff, size_type _Count = npos) const
  {
  if (_Right.size() < _Roff)
   _Xran();
  if (_Right._Mysize - _Roff < _Count)
   _Count = _Right._Mysize - _Roff;
  return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
  }
# 2380 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 int compare(const _Elem *_Ptr) const
  {
                      ;
  return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
  {
                      ;
  return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count) const
  {
                                      ;
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;

  int _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
   _N0 < _Count ? _N0 : _Count);
  return (_Ans != 0 ? _Ans : _N0 < _Count ? -1
   : _N0 == _Count ? 0 : +1);
  }

 allocator_type get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
  {
  if (_Count == 1)
   _Traits::assign(*(this->_Myptr() + _Off), _Ch);
  else
   _Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
  }

 void _Copy(size_type _Newsize, size_type _Oldlen)
  {
  size_type _Newres = _Newsize | this->_ALLOC_MASK;
  if (max_size() < _Newres)
   _Newres = _Newsize;
  else if (this->_Myres / 2 <= _Newres / 3)
   ;
  else if (this->_Myres <= max_size() - this->_Myres / 2)
   _Newres = this->_Myres
    + this->_Myres / 2;
  else
   _Newres = max_size();

  _Elem *_Ptr;
  {{
   _Ptr = this->_Getal().allocate(_Newres + 1);
  } if (0) {
   _Newres = _Newsize;
   {{
    _Ptr = this->_Getal().allocate(_Newres + 1);
   } if (0) {
   _Tidy(true);
           ;
   }}
  }}

  if (0 < _Oldlen)
   _Traits::copy(_Ptr, this->_Myptr(),
    _Oldlen);
  _Tidy(true);
  this->_Bx._Ptr = _Ptr;
  this->_Myres = _Newres;
  _Eos(_Oldlen);
  }

 void _Eos(size_type _Newsize)
  {
  _Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
  }

 bool _Grow(size_type _Newsize,
  bool _Trim = false)
  {
  if (max_size() < _Newsize)
   _Xlen();
  if (this->_Myres < _Newsize)
   _Copy(_Newsize, this->_Mysize);
  else if (_Trim && _Newsize < this->_BUF_SIZE)
   _Tidy(true,
    _Newsize < this->_Mysize ? _Newsize : this->_Mysize);
  else if (_Newsize == 0)
   _Eos(0);
  return (0 < _Newsize);
  }

 bool _Inside(const _Elem *_Ptr)
  {
  if (_Ptr == 0 || _Ptr < this->_Myptr()
   || this->_Myptr() + this->_Mysize <= _Ptr)
   return (false);
  else
   return (true);
  }

 void _Tidy(bool _Built = false,
  size_type _Newsize = 0)
  {
  if (!_Built)
   ;
  else if (this->_BUF_SIZE <= this->_Myres)
   {
   pointer _Ptr = this->_Bx._Ptr;
   if (0 < _Newsize)
    _Traits::copy(this->_Bx._Buf,
     ::std:: addressof(*_Ptr), _Newsize);
   this->_Getal().deallocate(_Ptr, this->_Myres + 1);
   }
  this->_Myres = this->_BUF_SIZE - 1;
  _Eos(_Newsize);
  }

 void _Xlen() const
  {
  _Xlength_error("string too long");
  }

 void _Xran() const
  {
  _Xout_of_range("invalid string position");
  }
 };
# 2523 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
template<class _Elem, class _Tr, class _Alloc>
const typename basic_string<_Elem, _Tr, _Alloc>::size_type basic_string<_Elem, _Tr, _Alloc>::npos;
# 2541 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
template<class _Elem,
 class _Traits,
 class _Alloc> inline
 void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Traits::length(_Left) + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(1 + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Traits::length(_Right));
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + 1);
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 if (_Right.size() <= _Left.capacity() - _Left.size()
  || _Right.capacity() - _Right.size() < _Left.size())
  return (::std:: move(_Left.append(_Right)));
 else
  return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
  size_type;
 return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem *_Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem _Right)
 {
 return (::std:: move(_Left.append(1, _Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) > 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left < _Right));
 }

typedef basic_string<char, char_traits<char>, allocator<char> >
 string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
 wstring;
}
namespace std {

template<class _Elem,
 class _Traits,
 class _Alloc>
 struct hash<basic_string<_Elem, _Traits, _Alloc> >
 {
 typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
   _Keyval.size() * sizeof (_Elem)));
  }
 };
}
namespace std {
typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
 u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
 u32string;
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 2 3
namespace std {
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 3
class logic_error
 : public ::std:: exception
 {
public:
 explicit logic_error(const string& _Message)
  : _Str(_Message)
  {
  }

 explicit logic_error(const char *_Message)
  : _Str(_Message)
  {
  }


 virtual ~logic_error() noexcept;






 virtual const char *what() const noexcept
  {
  return (_Str.c_str());
  }

private:
 string _Str;




protected:
 virtual void _Doraise() const;

 };


class domain_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit domain_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit domain_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~domain_error() noexcept;

 };


class invalid_argument
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit invalid_argument(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit invalid_argument(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~invalid_argument() noexcept;

 };


class length_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit length_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit length_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~length_error() noexcept;

 };


class out_of_range
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit out_of_range(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit out_of_range(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~out_of_range() noexcept;

 };


class runtime_error
 : public ::std:: exception
 {
public:
 explicit runtime_error(const string& _Message)
  : _Str(_Message)
  {
  }

 explicit runtime_error(const char *_Message)
  : _Str(_Message)
  {
  }


 virtual ~runtime_error() noexcept;






 virtual const char *what() const noexcept
  {
  return (_Str.c_str());
  }

private:
 string _Str;
 };


class overflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit overflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit overflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~overflow_error() noexcept;

 };


class underflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit underflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit underflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~underflow_error() noexcept;

 };


class range_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit range_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit range_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~range_error() noexcept;

 };
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {

template<class _Ty> inline
 pair<_Ty *, ptrdiff_t>
  get_temporary_buffer(ptrdiff_t _Count) noexcept
 {
 _Ty *_Pbuf;

 if (_Count < 0)
  _Count = 0;
 else if (((size_t)(-1) / sizeof (_Ty) < _Count))
  _Xbad_alloc();
 for (_Pbuf = 0; 0 < _Count; _Count /= 2)
  if ((_Pbuf = (_Ty *)::operator new(
   (size_t)_Count * sizeof (_Ty), nothrow)) != 0)
   break;

 return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
 }


template<class _Ty> inline
 void return_temporary_buffer(_Ty *_Pbuf)
 {
 ::operator delete(_Pbuf);
 }
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, input_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 _Construct(::std:: addressof(*_Dest),
  *_First);
 while (0 < --_Count)
  _Construct(::std:: addressof(*++_Dest), *++_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (++_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, forward_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  _Construct(::std:: addressof(*_Dest), *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 return (_Uninitialized_copy_n(_First, _Count,
  _Dest, _Iter_cat(_First)));
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag)
 {
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy_n(_First, _Count,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 if (_Count <= 0)
  return (_Dest);
 else
  return (_Rechecked(_Dest,
   _Uninitialized_copy_n(_Unchecked(_First), _Count,
    _Unchecked(_Dest))));
 }
# 259 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Construct(::std:: addressof(*_Dest), *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy0(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 370 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Nonscalar_ptr_iterator_tag)
 {
                                       ;
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Al.construct(_Dest, *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Scalar_ptr_iterator_tag)
 {
 return (_Uninit_copy(_First, _Last, _Dest,
  _Al, _Nonscalar_ptr_iterator_tag()));
 }

template<class _Ty1,
 class _Ty2> inline
 _Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<allocator<_Ty2> >&, _Scalar_ptr_iterator_tag)
 {
                                       ;
 size_t _Count = (size_t)(_Last - _First);
 return ((_Ty2 *):: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First)) + _Count);
 }
# 426 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Uninit_copy(_First, _Last, _Dest, _Al,
  _Ptr_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Rechecked(_Dest,
  _Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; (void)++_First, ++_Dest)
 ::new (static_cast<void *>(::std:: addressof(*_Dest)))
  typename iterator_traits<_FwdIt>::value_type(::std:: move(*_First));
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }


template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 pair<_InIt, _FwdIt> uninitialized_move_n(_InIt _First,
  _Diff _Count, _FwdIt _Dest)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; 0 < _Count; ++_First, (void)++_Dest, --_Count)
  ::new (static_cast<void *>(::std:: addressof(*_Dest)))
   typename iterator_traits<_FwdIt>::value_type(::std:: move(*_First));
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (pair<_InIt, _FwdIt>(_First, _Dest));
 }
# 526 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
 {
                                       ;
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Al.construct(::std:: addressof(*_Dest), (_Valty&&)*_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Al.destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
 {
 return (_Uninit_move(_First, _Last, _Dest,
  _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));
 }

template<class _Ty1,
 class _Ty2,
 class _Valty> inline
 _Ty2 *_Uninit_move(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<allocator<_Ty2> >&, _Valty *, _Scalar_ptr_iterator_tag)
 {
                                       ;
 size_t _Count = (size_t)(_Last - _First);
 return ((_Ty2 *):: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First)) + _Count);
 }
# 586 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Uninit_move(_First, _Last, _Dest, _Al,
  _Val_type(_First), _Ptr_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Rechecked(_Dest,
  _Uninit_move(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _FwdIt,
 class _Tval> inline
 void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
  _Nonscalar_ptr_iterator_tag)
 {
                            ;
 _FwdIt _Next = _First;

 {{
 for (; _First != _Last; ++_First)
  _Construct(::std:: addressof(*_First), _Val);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 }

template<class _Ty,
 class _Tval> inline
 void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
  _Scalar_ptr_iterator_tag)
 {
 ::std:: fill(_First, _Last, _Val);
 }

template<class _FwdIt,
 class _Tval> inline
 void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
 {
 _Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
 }


template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
  _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Construct(::std:: addressof(*_First), _Val);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}

 return (_First);
 }

template<class _Ty,
 class _Diff,
 class _Tval> inline
 _Ty *_Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
  _Scalar_ptr_iterator_tag)
 {
 return (_Fill_n(_First, _Count, _Val));
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval& _Val)
 {
 return (_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First)));
 }


template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty> inline
 void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
   _Valty *, _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Al.construct(_First, *_Pval);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 }

template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty> inline
 void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
   _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Uninit_fill_n(_First, _Count,
  _Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
 }

template<class _Ty,
 class _Diff,
 class _Tval,
 class _Valty> inline
 void _Uninit_fill_n(_Ty *_First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<allocator<_Ty> >&,
   _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Fill_n(_First, _Count, *_Pval);
 }
# 751 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc> inline
 void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Alloc& _Al)
 {
 _Uninit_fill_n(_First, _Count, _Pval, _Al,
  _Val_type(_First), _Ptr_cat(_First, _First));
 }


template<class _FwdIt,
 class _Diff,
 class _Alloc,
 class _Valty> inline
 void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Al.construct(_First);

 } if (0) {
 for (; _Next != _First; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc,
 class _Valty> inline
 void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Uninit_def_fill_n(_First, _Count,
  _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
 }

template<class _Ty,
 class _Diff,
 class _Valty> inline
 void _Uninit_def_fill_n(_Ty *_First, _Diff _Count,
  _Wrap_alloc<allocator<_Ty> >&, _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Fill_n(_First, _Count, (_Valty)0);
 }
# 821 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
  _Alloc& _Al)
 {
 _Uninit_def_fill_n(_First, _Count, _Al,
  _Val_type(_First), _Ptr_cat(_First, _First));
 }
# 898 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _OutIt,
 class _Ty>
 class raw_storage_iterator
  : public _Outit
 {
public:
 explicit raw_storage_iterator(_OutIt _First)
  : _Next(_First)
  {
  }

 raw_storage_iterator<_OutIt, _Ty>& operator*()
  {
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty>& operator=(const _Ty& _Val)
  {
  _Construct(::std:: addressof(*_Next), _Val);
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty>& operator++()
  {
  ++_Next;
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty> operator++(int)
  {
  raw_storage_iterator<_OutIt, _Ty> _Ans = *this;
  ++_Next;
  return (_Ans);
  }

 _OutIt base() const
  {
  return (_Next);
  }

private:
 _OutIt _Next;
 };


template<class _Ty>
 class _Temp_iterator
  : public _Outit
 {
public:
 typedef _Ty *_Pty;

 _Temp_iterator(ptrdiff_t _Count = 0)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = _Count;
  _Pbuf = &_Buf;
  }

 _Temp_iterator(const _Temp_iterator<_Ty>& _Right)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = 0;
  *this = _Right;
  }

 ~_Temp_iterator() noexcept
  {
  if (_Buf._Begin != 0)
   {
   for (_Pty _Next = _Buf._Begin;
    _Next != _Buf._Hiwater; ++_Next)
    _Destroy(_Next);
   ::std:: return_temporary_buffer(_Buf._Begin);
   }
  }

 _Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
  {
  _Pbuf = _Right._Pbuf;
  return (*this);
  }

 _Temp_iterator<_Ty>& operator=(const _Ty& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ = _Val;
  else
   {
   _Pty _Ptr = _Pbuf->_Current;
   _Construct(_Ptr, _Val);
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }
  return (*this);
  }

 _Temp_iterator<_Ty>& operator=(_Ty&& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ =
    ::std:: forward<_Ty>(_Val);
  else
   {
   _Pty _Ptr = _Pbuf->_Current;
   _Construct(_Ptr, ::std:: forward<_Ty>(_Val));
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }
  return (*this);
  }

 _Temp_iterator<_Ty>& operator*()
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& operator++()
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& operator++(int)
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& _Init()
  {
  _Pbuf->_Current = _Pbuf->_Begin;
  return (*this);
  }

 _Pty _First() const
  {
  return (_Pbuf->_Begin);
  }

 _Pty _Last() const
  {
  return (_Pbuf->_Current);
  }

 ptrdiff_t _Maxlen()
  {
  if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
   {
   pair<_Pty, ptrdiff_t> _Pair =
    ::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

   _Pbuf->_Begin = _Pair.first;
   _Pbuf->_Current = _Pair.first;
   _Pbuf->_Hiwater = _Pair.first;
   _Pbuf->_Size = _Pair.second;
   }
  return (_Pbuf->_Size);
  }

private:
 struct _Bufpar
  {
  _Pty _Begin;
  _Pty _Current;
  _Pty _Hiwater;
  ptrdiff_t _Size;
  };
 _Bufpar _Buf;
 _Bufpar *_Pbuf;
 };


template<class _Ty>
 class auto_ptr;

template<class _Ty>
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref(_Ty *_Right)
  : _Ref(_Right)
  {
  }

 _Ty *_Ref;
 };

template<class _Ty>
 class auto_ptr
  {
public:
 typedef auto_ptr<_Ty> _Myt;
 typedef _Ty element_type;

 explicit auto_ptr(_Ty *_Ptr = 0) noexcept
  : _Myptr(_Ptr)
  {
  }

 auto_ptr(_Myt& _Right) noexcept
  : _Myptr(_Right.release())
  {
  }

 auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  _Myptr = _Ptr;
  }

 template<class _Other>
  operator auto_ptr<_Other>() noexcept
  {
  return (auto_ptr<_Other>(*this));
  }

 template<class _Other>
  operator auto_ptr_ref<_Other>() noexcept
  {
  _Other *_Cvtptr = _Myptr;
  auto_ptr_ref<_Other> _Ans(_Cvtptr);
  _Myptr = 0;
  return (_Ans);
  }

 template<class _Other>
  _Myt& operator=(auto_ptr<_Other>& _Right) noexcept
  {
  reset(_Right.release());
  return (*this);
  }

 template<class _Other>
  auto_ptr(auto_ptr<_Other>& _Right) noexcept
  : _Myptr(_Right.release())
  {
  }

 _Myt& operator=(_Myt& _Right) noexcept
  {
  reset(_Right.release());
  return (*this);
  }

 _Myt& operator=(auto_ptr_ref<_Ty> _Right) noexcept
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  reset(_Ptr);
  return (*this);
  }

 ~auto_ptr() noexcept
  {
  delete _Myptr;
  }

 _Ty& operator*() const noexcept
  {





  return (*get());
  }

 _Ty *operator->() const noexcept
  {





  return (get());
  }

 _Ty *get() const noexcept
  {
  return (_Myptr);
  }

 _Ty *release() noexcept
  {
  _Ty *_Tmp = _Myptr;
  _Myptr = 0;
  return (_Tmp);
  }

 void reset(_Ty *_Ptr = 0)
  {
  if (_Ptr != _Myptr)
   delete _Myptr;
  _Myptr = _Ptr;
  }

private:
 _Ty *_Myptr;
 };
}


#pragma clang diagnostic pop
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 2 3




namespace std {

template<class _Mylist,
 class _Base = _Iterator_base0>
 class _List_unchecked_const_iterator
  : public _Iterator012<bidirectional_iterator_tag,
   typename _Mylist::value_type,
   typename _Mylist::difference_type,
   typename _Mylist::const_pointer,
   typename _Mylist::const_reference,
   _Base>
 {
public:
 typedef _List_unchecked_const_iterator<_Mylist, _Base> _Myiter;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::const_pointer pointer;
 typedef typename _Mylist::const_reference reference;

 _List_unchecked_const_iterator()
  : _Ptr(nullptr)
  {
  }

 _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Ptr(_Pnode)
  {
  this->_Adopt(_Plist);
  }

 reference operator*() const
  {
  return (_Mylist::_Myval(_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  _Ptr = _Mylist::_Nextnode(_Ptr);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  _Ptr = _Mylist::_Prevnode(_Ptr);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 _Nodeptr _Mynode() const
  {
  return (_Ptr);
  }

 _Nodeptr _Ptr;
 };


template<class _Mylist>
 class _List_unchecked_iterator
  : public _List_unchecked_const_iterator<_Mylist>
 {
public:
 typedef _List_unchecked_iterator<_Mylist> _Myiter;
 typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::pointer pointer;
 typedef typename _Mylist::reference reference;

 _List_unchecked_iterator()
  {
  }

 _List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };


template<class _Mylist>
 class _List_const_iterator
  : public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
 {
public:
 typedef _List_const_iterator<_Mylist> _Myiter;
 typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::const_pointer pointer;
 typedef typename _Mylist::const_reference reference;

 _List_const_iterator()
  : _Mybase()
  {
  }

 _List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
  }

 reference operator*() const
  {
# 221 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  return (_Mylist::_Myval(this->_Ptr));
  }

 _Myiter& operator++()
  {
# 241 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 271 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  this->_Ptr = _Mylist::_Prevnode(this->_Ptr);


  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
# 297 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }
 };

template<class _Mylist> inline
 typename _List_const_iterator<_Mylist>::_Unchecked_type
  _Unchecked(_List_const_iterator<_Mylist> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mylist> inline
 _List_const_iterator<_Mylist>&
  _Rechecked(_List_const_iterator<_Mylist>& _Iter,
   typename _List_const_iterator<_Mylist>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Mylist>
 class _List_iterator
  : public _List_const_iterator<_Mylist>
 {
public:
 typedef _List_iterator<_Mylist> _Myiter;
 typedef _List_const_iterator<_Mylist> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::pointer pointer;
 typedef typename _Mylist::reference reference;

 _List_iterator()
  {
  }

 _List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };

template<class _Mylist> inline
 typename _List_iterator<_Mylist>::_Unchecked_type
  _Unchecked(_List_iterator<_Mylist> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mylist> inline
 _List_iterator<_Mylist>&
  _Rechecked(_List_iterator<_Mylist>& _Iter,
   typename _List_iterator<_Mylist>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference,
 class _Nodeptr_type>
 struct _List_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 typedef _Nodeptr_type _Nodeptr;
 };

template<class _Value_type,
 class _Voidptr>
 struct _List_node
  {
  _Voidptr _Next;
  _Voidptr _Prev;
  _Value_type _Myval;

 private:
  _List_node& operator=(const _List_node&);
  };

template<class _Value_type>
 struct _List_node<_Value_type, void *>
  {
  typedef _List_node<_Value_type, void *> *_Nodeptr;
  _Nodeptr _Next;
  _Nodeptr _Prev;
  _Value_type _Myval;

 private:
  _List_node& operator=(const _List_node&);
  };

template<class _Ty>
 struct _List_simple_types
  : public _Simple_types<_Ty>
 {
 typedef _List_node<_Ty, void *> _Node;
 typedef _Node *_Nodeptr;
 };

template<class _Ty,
 class _Alloc0>
 struct _List_base_types
 {
# 478 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
 typedef _Alloc0 _Alloc;


 typedef _List_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
  _Voidptr;
 typedef _List_node<typename _Alty::value_type,
  _Voidptr> _Node;

 typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
 typedef typename _Alnod_type::pointer _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _List_simple_types<typename _Alty::value_type>,
  _List_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference,
   _Nodeptr> >::type
  _Val_types;
 };


template<class _Val_types>
 class _List_val
  : public _Container_base
 {
public:
 typedef _List_val<_Val_types> _Myt;

 typedef typename _Val_types::_Nodeptr _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _List_const_iterator<_Myt> const_iterator;
 typedef _List_iterator<_Myt> iterator;

 typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
 typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;

 _List_val()
  {
  this->_Myhead = 0;
  this->_Mysize = 0;
  }

 static _Nodepref _Nextnode(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Next);
  }

 static _Nodepref _Prevnode(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Prev);
  }

 static reference _Myval(_Nodeptr _Pnode)
  {
  return ((reference)_Pnode->_Myval);
  }

 _Nodeptr _Myhead;
 size_type _Mysize;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _List_alloc
  : public _List_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _List_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alnod(_Al)
  {
  this->_Myhead = _Buyheadnode();
  }

 _List_alloc(_Alloc0&& _Al)
  : _Alnod(::std:: move(_Al))
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_List_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Alnod, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Alnod, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(_Alnod, _Right._Alnod);
  }
# 676 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
 _Nodeptr _Buyheadnode()
  {
  return (_Buynode0(_Nodeptr(), _Nodeptr()));
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  _Alnod.destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  _Alnod.destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  _Alnod.deallocate(_Pnode, 1);
  }

 _Nodeptr _Buynode0(_Nodeptr _Next,
  _Nodeptr _Prev, _Nodeptr _Pnode = nullptr)
  {
  if (_Pnode == nullptr)
   _Pnode = _Alnod.allocate(1);

  if (_Next == _Nodeptr())
   {
   _Next = _Pnode;
   _Prev = _Pnode;
   }
  {{
  _Alnod.construct(
   ::std:: addressof(this->_Nextnode(_Pnode)), _Next);
  _Alnod.construct(
   ::std:: addressof(this->_Prevnode(_Pnode)), _Prev);
  } if (0) {
  _Alnod.deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 _Alty& _Getal() noexcept
  {
  return (_Alnod);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alnod);
  }

 _Alty _Alnod;
 };


template<class _Alloc_types>
 class _List_alloc<false, _Alloc_types>
  : public _List_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _List_alloc<false, _Alloc_types> _Myt;
 typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _List_alloc(const _Alloc0& = _Alloc0())
  {
  this->_Myhead = _Buyheadnode();
  }

 _List_alloc(_Alloc0&&)
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_List_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 830 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
 _Nodeptr _Buyheadnode()
  {
  return (_Buynode0(_Nodeptr(), _Nodeptr()));
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 _Nodeptr _Buynode0(_Nodeptr _Next,
  _Nodeptr _Prev, _Nodeptr _Pnode = nullptr)
  {
  if (_Pnode == nullptr)
   _Pnode = this->_Getal().allocate(1);

  if (_Next == _Nodeptr())
   {
   _Next = _Pnode;
   _Prev = _Pnode;
   }
  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Nextnode(_Pnode)), _Next);
  this->_Getal().construct(
   ::std:: addressof(this->_Prevnode(_Pnode)), _Prev);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc>
 class _List_buy
  : public _List_alloc<!is_empty<_Alloc>::value,
   _List_base_types<_Ty, _Alloc> >
 {
public:
 typedef _List_alloc<!is_empty<_Alloc>::value,
  _List_base_types<_Ty, _Alloc> > _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Nodeptr _Nodeptr;

 _List_buy(const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  }

 _List_buy(_Alloc&& _Al)
  : _Mybase(::std:: move(_Al))
  {
  }

 template<class... _Valty>
  _Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
   _Valty&&... _Val)
  {
  _Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Pnode)),
    ::std:: forward<_Valty>(_Val)...);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 void _Freenode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }
 };


template<class _Ty,
 class _Alloc = allocator<_Ty> >
 class list
  : public _List_buy<_Ty, _Alloc>
 {
public:
 typedef list<_Ty, _Alloc> _Myt;
 typedef _List_buy<_Ty, _Alloc> _Mybase;
 typedef typename _Mybase::_Node _Node;
 typedef typename _Mybase::_Nodeptr _Nodeptr;
 typedef typename _Mybase::_Alty _Alty;

 typedef _Alloc allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::value_type value_type;

 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::_Unchecked_const_iterator
  _Unchecked_const_iterator;
 typedef typename _Mybase::_Unchecked_iterator
  _Unchecked_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 list()
  : _Mybase()
  {
  }

 explicit list(const _Alloc& _Al)
  : _Mybase(_Al)
  {
  }

 explicit list(size_type _Count)
  : _Mybase()
  {
  resize(_Count);
  }


 list(size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  resize(_Count);
  }


 list(size_type _Count, const _Ty& _Val)
  : _Mybase()
  {
  _Construct_n(_Count, _Val);
  }

 list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct_n(_Count, _Val);
  }

 list(const _Myt& _Right)
  : _Mybase(_Right._Getal().select_on_container_copy_construction())
  {
  {{
  insert(begin(), _Right.begin(), _Right.end());
  } if (0) {
  _Tidy();
          ;
  }}
  }

 list(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  {{
  insert(begin(), _Right.begin(), _Right.end());
  } if (0) {
  _Tidy();
          ;
  }}
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  list(_Iter _First, _Iter _Last)
  : _Mybase()
  {
  _Construct(_First, _Last);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  list(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct(_First, _Last);
  }

 template<class _Iter>
            void _Construct(_Iter _First, _Iter _Last)
  {
  {{
  insert(begin(), _First, _Last);
  } if (0) {
  _Tidy();
          ;
  }}
  }

           void _Construct_n(size_type _Count,
  const _Ty& _Val)
  {
  {{
  _Insert_n(_Unchecked_begin(), _Count, _Val);
  } if (0) {
  _Tidy();
          ;
  }}
  }

 list(_Myt&& _Right)
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 list(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

           _Myt& operator=(_Myt&& _Right)

  {
  if (this != &_Right)
   {
   clear();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());
   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

           void _Assign_rv(_Myt&& _Right)
  {
  this->_Swap_all(_Right);
  _Swap_adl(this->_Myhead, _Right._Myhead);
  ::std:: swap(this->_Mysize, _Right._Mysize);
  }

 void push_front(_Ty&& _Val)
  {
  _Insert(_Unchecked_begin(), ::std:: forward<_Ty>(_Val));
  }

 void push_back(_Ty&& _Val)
  {
  _Insert(_Unchecked_end(), ::std:: forward<_Ty>(_Val));
  }

 iterator insert(const_iterator _Where, _Ty&& _Val)
  {
  return (emplace(_Where, ::std:: forward<_Ty>(_Val)));
  }

 template<class... _Valty>
  reference
  emplace_front(_Valty&&... _Val)
  {
  _Insert(_Unchecked_begin(), ::std:: forward<_Valty>(_Val)...);
  return (front());
  }

 template<class... _Valty>
  reference
  emplace_back(_Valty&&... _Val)
  {
  _Insert(_Unchecked_end(), ::std:: forward<_Valty>(_Val)...);
  return (back());
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {





  _Insert(_Where._Unchecked(), ::std:: forward<_Valty>(_Val)...);
  return (_Make_iter(--_Where));
  }

 template<class... _Valty>
            void _Insert(_Unchecked_const_iterator _Where,
  _Valty&&... _Val)
  {
  _Nodeptr _Pnode = _Where._Mynode();
  _Nodeptr _Newnode =
   this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
    ::std:: forward<_Valty>(_Val)...);
  _Incsize(1);
  this->_Prevnode(_Pnode) = _Newnode;
  this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
  }

 void _Insert(_Nodeptr _Ptr)
  {
  _Nodeptr _Pnode = _Unchecked_begin()._Mynode();
  _Nodeptr _Newnode = this->_Buynode0(_Pnode, this->_Prevnode(_Pnode),
     _Ptr);
  _Incsize(1);
  this->_Prevnode(_Pnode) = _Newnode;
  this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
  }

 list(::std:: initializer_list<_Ty> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  insert(begin(), _Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Ty> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<_Ty> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Ty> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~list() noexcept
  {
  _Tidy();
  }

           _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    clear();
    this->_Copy_alloc(_Right._Getal());
    }
   assign(_Right.begin(), _Right.end());
   }
  return (*this);
  }

 iterator begin() noexcept
  {
  return (iterator(this->_Nextnode(this->_Myhead), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Nextnode(this->_Myhead), this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Myhead, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Myhead, this));
  }

 _Unchecked_iterator _Unchecked_begin()
  {
  return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
   this));
  }

 _Unchecked_const_iterator _Unchecked_begin() const
  {
  return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
   this));
  }

 _Unchecked_iterator _Unchecked_end()
  {
  return (_Unchecked_iterator(this->_Myhead, this));
  }

 _Unchecked_const_iterator _Unchecked_end() const
  {
  return (_Unchecked_const_iterator(this->_Myhead, this));
  }

 iterator _Make_iter(const_iterator _Where) const noexcept
  {
  return (iterator(_Where._Ptr, this));
  }

 iterator _Make_iter(_Unchecked_const_iterator _Where) const
  {
  return (iterator(_Where._Ptr, this));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

           void resize(size_type _Newsize)
  {
  if (this->_Mysize < _Newsize)
   {
   size_type _Count = 0;
   {{
   for (; this->_Mysize < _Newsize; ++_Count)
    _Insert(_Unchecked_end());
   } if (0) {
   for (; 0 < _Count; --_Count)
    pop_back();
           ;
   }}
   }
  else
   while (_Newsize < this->_Mysize)
    pop_back();
  }

           void resize(size_type _Newsize, const _Ty& _Val)
  {
  if (this->_Mysize < _Newsize)
   _Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
  else
   while (_Newsize < this->_Mysize)
    pop_back();
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  return (this->_Getal().max_size());
  }

 bool empty() const noexcept
  {
  return (this->_Mysize == 0);
  }

 allocator_type get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(--end()));
  }

 const_reference back() const
  {
  return (*(--end()));
  }

 void push_front(const _Ty& _Val)
  {
  _Insert(_Unchecked_begin(), _Val);
  }

 void pop_front()
  {
  erase(begin());
  }

 void push_back(const _Ty& _Val)
  {
  _Insert(_Unchecked_end(), _Val);
  }

 void pop_back()
  {
  erase(--end());
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
            void assign(_Iter _First, _Iter _Last)
  {
  iterator _Old = begin();
  {{
  for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
   _Reusenode(_Old, *_First);
  for (; _First != _Last; ++_First)
   _Insert(_Unchecked_end(), *_First);
  } if (0) {
  clear();
          ;
  }}
  erase(_Old, end());
  }

 template<class _TArg>
            void _Reusenode(iterator _Where, _TArg&& _Arg)
  {
  {{
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Where._Ptr)));
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Where._Ptr)),
   ::std:: forward<_TArg>(_Arg));
  } if (0) {
  _Unlinknode(_Where);
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Where._Ptr)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Where._Ptr)));
  this->_Getal().deallocate(_Where._Ptr, 1);
          ;
  }}
  }

 void assign(size_type _Count, const _Ty& _Val)
  {
  clear();
  _Insert_n(_Unchecked_begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const _Ty& _Val)
  {





  _Insert(_Where._Unchecked(), _Val);
  return (_Make_iter(--_Where));
  }

           iterator insert(const_iterator _Where,
  size_type _Count, const _Ty& _Val)
  {





  iterator _Prev = _Make_iter(_Where);
  if (_Prev == begin())
   {
   _Insert_n(_Where._Unchecked(), _Count, _Val);
   return (begin());
   }
  else
   {
   --_Prev;
   _Insert_n(_Where._Unchecked(), _Count, _Val);
   return (++_Prev);
   }
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
            iterator insert(const_iterator _Where,
   _Iter _First, _Iter _Last)
  {





  iterator _Prev = _Make_iter(_Where);
  if (_Prev == begin())
   {
   _Insert_range(_Where._Unchecked(), _First, _Last,
    _Iter_cat(_First));
   return (begin());
   }
  else
   {
   --_Prev;
   _Insert_range(_Where._Unchecked(), _First, _Last,
    _Iter_cat(_First));
   return (++_Prev);
   }
  }

 template<class _Iter>
            void _Insert_range(_Unchecked_const_iterator _Where,
   _Iter _First, _Iter _Last, input_iterator_tag)
  {
  size_type _Num = 0;

  {{
  for (; _First != _Last; ++_First, (void)++_Num)
   _Insert(_Where, *_First);
  } if (0) {
  for (; 0 < _Num; --_Num)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

 template<class _Iter>
            void _Insert_range(_Unchecked_const_iterator _Where,
   _Iter _First, _Iter _Last, forward_iterator_tag)
  {
                             ;
  _Iter _Next = _First;

  {{
  for (; _First != _Last; ++_First)
   _Insert(_Where, *_First);
  } if (0) {
  for (; _Next != _First; ++_Next)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

           _Nodeptr _Unlinknode(const_iterator _Where)
  {
# 1533 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  _Nodeptr _Pnode = (_Where)._Mynode();


  if (_Pnode != this->_Myhead)
   {
   this->_Nextnode(this->_Prevnode(_Pnode)) =
    this->_Nextnode(_Pnode);
   this->_Prevnode(this->_Nextnode(_Pnode)) =
    this->_Prevnode(_Pnode);

   --this->_Mysize;
   }
  return (_Pnode);
  }

           iterator erase(const_iterator _Where,
  bool _Keep = false)
  {
  _Nodeptr _Pnode = _Unlinknode(_Where++);
  if (!_Keep)
   if (_Pnode != this->_Myhead)
    this->_Freenode(_Pnode);
  return (_Make_iter(_Where));
  }

           void _Unchecked_erase(_Unchecked_const_iterator _Where)
  {
  _Nodeptr _Pnode = _Where._Mynode();

  if (_Pnode != this->_Myhead)
   {
   this->_Nextnode(this->_Prevnode(_Pnode)) =
    this->_Nextnode(_Pnode);
   this->_Prevnode(this->_Nextnode(_Pnode)) =
    this->_Prevnode(_Pnode);
   this->_Freenode(_Pnode);
   --this->_Mysize;
   }
  }

           iterator erase(const_iterator _First, const_iterator _Last)
  {
  if (_First == begin() && _Last == end())
   {
   clear();
   return (end());
   }
  else
   {
   while (_First != _Last)
    _First = erase(_First);
   return (_Make_iter(_Last));
   }
  }

           void clear() noexcept
  {




  _Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
  this->_Nextnode(this->_Myhead) = this->_Myhead;
  this->_Prevnode(this->_Myhead) = this->_Myhead;
  this->_Mysize = 0;

  for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
   {
   _Pnext = this->_Nextnode(_Pnode);
   this->_Freenode(_Pnode);
   }
  }

           void swap(_Myt& _Right)

  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else





   ::std:: terminate();

  }

 void splice(const_iterator _Where, _Myt& _Right)
  {
  if (this != ::std:: addressof(_Right) && !_Right.empty())
   {
   _Splice(_Where, _Right, _Right.begin(), _Right.end(),
    _Right._Mysize);
   }
  }

 void splice(const_iterator _Where, _Myt&& _Right)
  {
  splice(_Where, (_Myt&)_Right);
  }

           void splice(const_iterator _Where, _Myt& _Right,
  const_iterator _First)
  {






  if (_First != _Right.end())


   {
   const_iterator _Last = _First;
   ++_Last;
   if (this != ::std:: addressof(_Right)
    || (_Where != _First && _Where != _Last))
    _Splice(_Where, _Right, _First, _Last, 1);
   }
  }

 void splice(const_iterator _Where, _Myt&& _Right,
  const_iterator _First)
  {
  splice(_Where, (_Myt&)_Right, _First);
  }

           void splice(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last)
  {
  if (_First != _Last && (this != ::std:: addressof(_Right) || _Where != _Last))
   {
   size_type _Count = 0;

   if (this == ::std:: addressof(_Right))
    ;
   else if (_First == _Right.begin() && _Last == _Right.end())
    _Count = _Right._Mysize;
   else
    {
    const_iterator _Next = _First;

    for (; _Next != _Last; ++_Next, (void)++_Count)
     if (_Next == _Right.end())
      _Xlength_error("list<T> bad splice");
    }
   _Splice(_Where, _Right, _First, _Last, _Count);
   }
  }

 void splice(const_iterator _Where,
  _Myt&& _Right, const_iterator _First, const_iterator _Last)
  {
  splice(_Where, (_Myt&)_Right, _First, _Last);
  }

           void remove(const _Ty& _Val)
  {
  iterator _Val_it = end();

  for (iterator _First = begin(); _First != end(); )
   if (*_First == _Val)
    if (::std:: addressof(*_First) == ::std:: addressof(_Val))
     _Val_it = _First++;
    else
     _First = erase(_First);
   else
    ++_First;

  if (_Val_it != end())
   erase(_Val_it);
  }

 template<class _Pr1>
            void remove_if(_Pr1 _Pred)
  {
  for (iterator _First = begin(); _First != end(); )
   if (_Pred(*_First))
    _First = erase(_First);
   else
    ++_First;
  }

 void unique()
  {
  unique(equal_to<>());
  }

 template<class _Pr2>
            void unique(_Pr2 _Pred)
  {
  const _Nodeptr _Phead = this->_Myhead;
  _Nodeptr _Pprev = this->_Nextnode(_Phead);
  _Nodeptr _Pnode = this->_Nextnode(_Pprev);

  while (_Pnode != _Phead)
   if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
    {
    const _Nodeptr _Perase = _Pnode;
    _Pnode = this->_Nextnode(_Pnode);

    this->_Nextnode(_Pprev) = _Pnode;
    this->_Prevnode(_Pnode) = _Pprev;
    this->_Freenode(_Perase);

    --this->_Mysize;
    }
   else
    {
    _Pprev = _Pnode;
    _Pnode = this->_Nextnode(_Pnode);
    }
  }

 void merge(_Myt& _Right)
  {
  merge(_Right, less<>());
  }

 void merge(_Myt&& _Right)
  {
  merge((_Myt&)_Right);
  }

 template<class _Pr2>
            void merge(_Myt& _Right, _Pr2 _Pred)
  {
  if (::std:: addressof(_Right) != this)
   {
   iterator _First1 = begin(), _Last1 = end();
   iterator _First2 = _Right.begin(), _Last2 = _Right.end();
                                            ;
                                            ;

   while (_First1 != _Last1 && _First2 != _Last2)
    if (_Pred(*_First2, *_First1))
     {
     iterator _Mid2 = _First2;
     _Splice(_First1, _Right, _First2, ++_Mid2, 1);
     _First2 = _Mid2;
     }
    else
     ++_First1;

   if (_First2 != _Last2)
    _Splice(_Last1, _Right, _First2, _Last2,
     _Right._Mysize);
   }
  }

 template<class _Pr2>
  void merge(_Myt&& _Right, _Pr2 _Pred)
  {
  merge((_Myt&)_Right, _Pred);
  }

 void sort()
  {
  sort(less<>());
  }

 template<class _Pr2>
            void sort(_Pr2 _Pred)
  {
  _Sort(begin(), end(), _Pred, this->_Mysize);
  }

 template<class _Pr2>
  iterator _Sort(iterator _First, iterator _Last, _Pr2 _Pred,
   size_type _Size)
  {

  if (_Size < 2)
   return (_First);

  iterator _Mid = ::std:: next(_First, _Size / 2);
  _First = _Sort(_First, _Mid, _Pred, _Size / 2);
  _Mid = _Sort(_Mid, _Last, _Pred, _Size - _Size / 2);
  iterator _Newfirst = _First;

  for (bool _Initial_loop = true; ; _Initial_loop = false)
   {
   if (_Pred(*_Mid, *_First))
    {
    if (_Initial_loop)
     _Newfirst = _Mid;
    splice(_First, *this, _Mid++);
    if (_Mid == _Last)
     return (_Newfirst);
    }
   else
    {
    ++_First;
    if (_First == _Mid)
     return (_Newfirst);
    }
   }
  }

           void reverse() noexcept
  {
  const _Nodeptr _Phead = this->_Myhead;
  _Nodeptr _Pnode = _Phead;

  for (; ; )
   {
   const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
   this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
   this->_Prevnode(_Pnode) = _Pnext;

   if (_Pnext == _Phead)
    break;
   _Pnode = _Pnext;
   }
  }

           void _Splice(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last,
  size_type _Count)
  {
# 1924 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  if (this->_Getal() != _Right._Getal())
   ::std:: terminate();


  _Splice_same(_Where, _Right, _First, _Last, _Count);
  }

           void _Splice_same(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last,
  size_type _Count)
  {
  if (this != ::std:: addressof(_Right))
   {
   _Incsize(_Count);
   _Right._Mysize -= _Count;
   }
  this->_Nextnode(this->_Prevnode(_First._Mynode())) =
   _Last._Mynode();
  this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
   _Where._Mynode();
  this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
   _First._Mynode();

  _Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
  this->_Prevnode(_Where._Mynode()) =
   this->_Prevnode(_Last._Mynode());
  this->_Prevnode(_Last._Mynode()) =
   this->_Prevnode(_First._Mynode());
  this->_Prevnode(_First._Mynode()) = _Pnode;
  }

           void _Unchecked_splice(_Unchecked_const_iterator _Where,
  _Unchecked_const_iterator _First,
  _Unchecked_const_iterator _Last)
  {
  this->_Nextnode(this->_Prevnode(_First._Mynode())) =
   _Last._Mynode();
  this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
   _Where._Mynode();
  this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
   _First._Mynode();

  _Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
  this->_Prevnode(_Where._Mynode()) =
   this->_Prevnode(_Last._Mynode());
  this->_Prevnode(_Last._Mynode()) =
   this->_Prevnode(_First._Mynode());
  this->_Prevnode(_First._Mynode()) = _Pnode;
  }

 void _Tidy()
  {
  clear();
  }

           void _Insert_n(_Unchecked_const_iterator _Where,
  size_type _Count, const _Ty& _Val)
  {
  size_type _Countsave = _Count;

  {{
  for (; 0 < _Count; --_Count)
   _Insert(_Where, _Val);
  } if (0) {
  for (; _Count < _Countsave; ++_Count)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

 void _Incsize(size_type _Count)
  {
  if (max_size() - this->_Mysize - 1 < _Count)
   _Xlength_error("list<T> too long");
  this->_Mysize += _Count;
  }
# 2023 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
 };
# 2038 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
template<class _Ty,
 class _Alloc> inline
 void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator==(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator!=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }
# 2122 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
}
# 7 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude\\BinaryBuffers.h" 2

namespace psn
{
    class BinaryWriter
    {
        void* buffer;
        UInt32 maxBufferSize;
        char* pos;

    public:

        BinaryWriter(void* stream, UInt32 maxSize);

        void Reset();

        UInt32 GetWrittenLength();

        void WriteBool(bool value);

        void WriteInt8(Int8 value);
        void WriteUInt8(UInt8 value);

        void WriteInt16(Int16 value);
        void WriteUInt16(UInt16 value);

        void WriteInt32(Int32 value);
        void WriteUInt32(UInt32 value);

        void WriteInt64(Int64 value);
        void WriteUInt64(UInt64 value);

        void WriteRtcTick(SceRtcTick value);

        void WritePtr(void* ptr);

        void WriteDouble(double value);

        void WriteData(const char* data, UInt32 size);
        void WriteDataBlock(const char* data, UInt32 size);

        void WriteString(const char* str);
        void WriteString(const char* str, UInt32 size);

        UInt32* ReservePlaceholderUInt32();

    private:
        void Check(size_t requiredSize);
    };

    class BinaryReader
    {
        void* buffer;
        UInt32 maxBufferSize;
        char* pos;

    public:

        BinaryReader(void* stream, UInt32 maxSize);

        void Reset();

        bool ReadBool();

        Int8 ReadInt8();
        UInt8 ReadUInt8();

        Int16 ReadInt16();
        UInt16 ReadUInt16();

        Int32 ReadInt32();
        UInt32 ReadUInt32();

        Int64 ReadInt64();
        UInt64 ReadUInt64();

        float ReadFloat();
        double ReadDouble();

        void ReadData(char* data, UInt32 size);

        void ReadString(char* str, int maxLength);
        char* ReadStringPtr();

        void* ReadDataPtr(UInt32 size);

        void* GetPosPtr();

    private:
        void Check(size_t requiredSize);
    };
}
# 2 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\BinaryBuffers.cpp" 2

namespace psn
{
    BinaryWriter::BinaryWriter(void* stream, UInt32 maxSize)
    {
        maxBufferSize = maxSize;
        buffer = stream;

        pos = (char*)buffer;
    }

    void BinaryWriter::Reset()
    {
        pos = (char*)buffer;
    }

    UInt32 BinaryWriter::GetWrittenLength()
    {
        int bytesUsed = pos - (char*)buffer;

        return bytesUsed;
    }


    void BinaryWriter::WriteBool(bool value)
    {
        Check(1);

        if (value == false) *((char*)pos) = 0;
        else *((char*)pos) = 1;

        pos += 1;
    }

    void BinaryWriter::WriteInt8(Int8 value)
    {
        Check(sizeof(Int8));
        *((Int8*)pos) = value;
        pos += sizeof(Int8);
    }

    void BinaryWriter::WriteUInt8(UInt8 value)
    {
        Check(sizeof(UInt8));
        *((UInt8*)pos) = value;
        pos += sizeof(UInt8);
    }

    void BinaryWriter::WriteInt16(Int16 value)
    {
        Check(sizeof(Int16));
        *((Int16*)pos) = value;
        pos += sizeof(Int16);
    }

    void BinaryWriter::WriteUInt16(UInt16 value)
    {
        Check(sizeof(UInt16));
        *((UInt16*)pos) = value;
        pos += sizeof(UInt16);
    }

    void BinaryWriter::WriteInt32(Int32 value)
    {
        Check(sizeof(Int32));
        *((Int32*)pos) = value;
        pos += sizeof(Int32);
    }

    void BinaryWriter::WriteUInt32(UInt32 value)
    {
        Check(sizeof(UInt32));
        *((UInt32*)pos) = value;
        pos += sizeof(UInt32);
    }

    void BinaryWriter::WriteInt64(Int64 value)
    {
        Check(sizeof(UInt64));
        *((Int64*)pos) = value;
        pos += sizeof(Int64);
    }

    UInt32* BinaryWriter::ReservePlaceholderUInt32()
    {
        Check(sizeof(UInt32));
        UInt32* ptr = (UInt32*)pos;
        pos += sizeof(UInt32);

        return ptr;
    }

    void BinaryWriter::WriteUInt64(UInt64 value)
    {
        Check(sizeof(UInt64));
        *((UInt64*)pos) = value;
        pos += sizeof(UInt64);
    }

    void BinaryWriter::WriteRtcTick(SceRtcTick value)
    {
        Check(sizeof(UInt64));
        *((UInt64*)pos) = value.tick;
        pos += sizeof(UInt64);
    }

    void BinaryWriter::WritePtr(void* ptr)
    {
        Check(sizeof(void*));

        *((UInt64*)pos) = (UInt64)ptr;
        pos += sizeof(void*);
    }

    void BinaryWriter::WriteDouble(double value)
    {
        Check(sizeof(double));
        *((double*)pos) = value;
        pos += sizeof(double);
    }

    void BinaryWriter::WriteString(const char* str)
    {
        if (str == __null)
        {
            WriteData("", strlen(""));
            return;
        }

        UInt32 strLen = strlen(str);

        WriteData(str, strLen);
    }

    void BinaryWriter::WriteString(const char* str, UInt32 size)
    {
        WriteData(str, size);
    }

    void BinaryWriter::WriteData(const char* data, UInt32 size)
    {
        Check(size + sizeof(UInt32));

        *((UInt32*)pos) = size;
        pos += sizeof(UInt32);

        if (size > 0)
        {
            memcpy(pos, data, size);
            pos += size;
        }
    }

    void BinaryWriter::WriteDataBlock(const char* data, UInt32 size)
    {
        if (size > 0)
        {
            memcpy(pos, data, size);
            pos += size;
        }
    }

    void BinaryWriter::Check(size_t requiredSize)
    {
        int sizeUsed = pos - (char*)buffer;
        if (sizeUsed + requiredSize > maxBufferSize)
        {
        }
    }

    BinaryReader::BinaryReader(void* stream, UInt32 maxSize)
    {
        maxBufferSize = maxSize;
        buffer = stream;

        pos = (char*)buffer;
    }

    void BinaryReader::Reset()
    {
        pos = (char*)buffer;
    }


    bool BinaryReader::ReadBool()
    {
        Check(1);

        bool value = false;
        if (*pos == 1) value = true;

        pos += 1;

        return value;
    }

    Int8 BinaryReader::ReadInt8()
    {
        Check(sizeof(Int8));

        Int8 value = *((Int8*)pos);

        pos += sizeof(Int8);

        return value;
    }

    UInt8 BinaryReader::ReadUInt8()
    {
        Check(sizeof(UInt8));
        UInt8 value = *((UInt8*)pos);

        pos += sizeof(UInt8);

        return value;
    }

    Int16 BinaryReader::ReadInt16()
    {
        Check(sizeof(Int16));
        Int16 value = *((Int16*)pos);
        pos += sizeof(Int16);

        return value;
    }

    UInt16 BinaryReader::ReadUInt16()
    {
        Check(sizeof(UInt16));
        UInt16 value = *((UInt16*)pos);
        pos += sizeof(UInt16);

        return value;
    }

    Int32 BinaryReader::ReadInt32()
    {
        Check(sizeof(Int32));
        Int32 value = *((Int32*)pos);
        pos += sizeof(Int32);

        return value;
    }

    UInt32 BinaryReader::ReadUInt32()
    {
        Check(sizeof(UInt32));
        UInt32 value = *((UInt32*)pos);
        pos += sizeof(UInt32);

        return value;
    }

    Int64 BinaryReader::ReadInt64()
    {
        Check(sizeof(UInt64));
        Int64 value = *((Int64*)pos);
        pos += sizeof(Int64);

        return value;
    }

    UInt64 BinaryReader::ReadUInt64()
    {
        Check(sizeof(UInt64));
        UInt64 value = *((UInt64*)pos);
        pos += sizeof(UInt64);

        return value;
    }

    float BinaryReader::ReadFloat()
    {
        Check(sizeof(float));
        double value = *((float*)pos);
        pos += sizeof(float);

        return value;
    }

    double BinaryReader::ReadDouble()
    {
        Check(sizeof(double));
        double value = *((double*)pos);
        pos += sizeof(double);

        return value;
    }

    void BinaryReader::ReadString(char* str, int maxLength)
    {
        UInt32 numBytes = ReadUInt32();

        if (numBytes > maxLength)
        {

            return;
        }

        if (numBytes == 0)
        {
            if (maxLength > 0) str[0] = 0;
            return;
        }

        ReadData(str, numBytes);


    }

    void BinaryReader::ReadData(char* data, UInt32 size)
    {
        Check(size + sizeof(UInt32));

        if (size > 0)
        {
            memcpy(data, pos, size);
            pos += size;
        }
    }

    char* BinaryReader::ReadStringPtr()
    {
        UInt32 numBytes = ReadUInt32();

        if (numBytes == 0)
        {
            return __null;
        }

        char* str = pos;

        pos += numBytes;

        return str;
    }

    void* BinaryReader::ReadDataPtr(UInt32 size)
    {
        char* ptr = pos;

        pos += size;

        return ptr;
    }

    void* BinaryReader::GetPosPtr()
    {
        return pos;
    }

    void BinaryReader::Check(size_t requiredSize)
    {
        int sizeUsed = pos - (char*)buffer;
        if (sizeUsed + requiredSize > maxBufferSize)
        {
        }
    }
}
# 3 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\Errors.cpp" 1
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude\\Errors.h" 1





namespace psn
{
    enum APIResultTypes
    {
        Success = 0,
        Warning = 1,
        Error = 2,
    };

    struct APIResult
    {
    public:
        APIResultTypes apiResult;
        char const * message;
        char const * filename;
        Int32 lineNumber;
        Int32 sceErrorCode;

        static void SetResult(APIResult* result, APIResultTypes type);
        static void SetResult(APIResult* result, APIResultTypes type, char const * message, char const * filename, Int32 lineNumber);
        static void SetSceResult(APIResult* result, APIResultTypes type, Int32 sceErrorCode, char const * filename, Int32 lineNumber);
        static void SetSceResultMessage(APIResult* result, APIResultTypes type, Int32 sceErrorCode, char const* message, char const* filename, Int32 lineNumber);
    };
}
# 2 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\Errors.cpp" 2


namespace psn
{
    void APIResult::SetResult(APIResult* result, APIResultTypes type)
    {
        result->apiResult = type;
        result->message = "";
        result->filename = "";
        result->lineNumber = 0;
        result->sceErrorCode = 0;
    }

    void APIResult::SetResult(APIResult* result, APIResultTypes type, char const * message, char const * filename, int lineNumber)
    {
        result->apiResult = type;
        result->message = message;
        result->filename = filename;
        result->lineNumber = lineNumber;
        result->sceErrorCode = 0;
    }

    void APIResult::SetSceResult(APIResult* result, APIResultTypes type, int sceErrorCode, char const * filename, int lineNumber)
    {
        char const* message = 0;

        result->apiResult = type;

        if (message == 0)
        {
            result->message = "";
        }
        else
        {
            result->message = message;
        }
        result->filename = filename;
        result->lineNumber = lineNumber;
        result->sceErrorCode = sceErrorCode;
    }

    void APIResult::SetSceResultMessage(APIResult* result, APIResultTypes type, int sceErrorCode, char const* message, char const* filename, int lineNumber)
    {
        result->apiResult = type;

        if (message == 0)
        {
            result->message = "";
        }
        else
        {
            result->message = message;
        }
        result->filename = filename;
        result->lineNumber = lineNumber;
        result->sceErrorCode = sceErrorCode;
    }
}
# 4 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\HandleMsg.cpp" 1
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude\\HandleMsg.h" 1



# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SharedCoreIncludes.h" 1






# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 1 3
# 8 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SharedCoreIncludes.h" 2
# 24 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SharedCoreIncludes.h"
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/UserMap.h" 1
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
namespace std {

template<class _Mytree,
 class _Base = _Iterator_base0>
 class _Tree_unchecked_const_iterator
  : public _Iterator012<bidirectional_iterator_tag,
   typename _Mytree::value_type,
   typename _Mytree::difference_type,
   typename _Mytree::const_pointer,
   typename _Mytree::const_reference,
   _Base>
 {
public:
 typedef _Tree_unchecked_const_iterator<_Mytree, _Base> _Myiter;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::const_pointer pointer;
 typedef typename _Mytree::const_reference reference;

 _Tree_unchecked_const_iterator()
  : _Ptr(nullptr)
  {
  }

 _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Ptr(_Pnode)
  {
  this->_Adopt(_Plist);
  }

 reference operator*() const
  {
  return (_Mytree::_Myval(_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  if (_Mytree::_Isnil(_Ptr))
   ;
  else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
   _Ptr = _Mytree::_Min(
    _Mytree::_Right(_Ptr));
  else
   {
   _Nodeptr _Pnode;
   while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
    && _Ptr == _Mytree::_Right(_Pnode))
    _Ptr = _Pnode;
   _Ptr = _Pnode;
   }
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  if (_Mytree::_Isnil(_Ptr))
   _Ptr = _Mytree::_Right(_Ptr);
  else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
   _Ptr = _Mytree::_Max(
    _Mytree::_Left(_Ptr));
  else
   {
   _Nodeptr _Pnode;
   while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
    && _Ptr == _Mytree::_Left(_Pnode))
    _Ptr = _Pnode;
   if (_Mytree::_Isnil(_Ptr))
    ;
   else
    _Ptr = _Pnode;
   }
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 _Nodeptr _Mynode() const
  {
  return (_Ptr);
  }

 _Nodeptr _Ptr;
 };


template<class _Mytree>
 class _Tree_unchecked_iterator
  : public _Tree_unchecked_const_iterator<_Mytree>
 {
public:
 typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
 typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::pointer pointer;
 typedef typename _Mytree::reference reference;

 _Tree_unchecked_iterator()
  {
  }

 _Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };


template<class _Mytree>
 class _Tree_const_iterator
  : public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
 {
public:
 typedef _Tree_const_iterator<_Mytree> _Myiter;
 typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::const_pointer pointer;
 typedef typename _Mytree::const_reference reference;

 _Tree_const_iterator()
  : _Mybase()
  {
  }

 _Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
  }

 reference operator*() const
  {
# 250 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  return (_Mytree::_Myval(this->_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 274 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 311 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  --(*(_Mybase *)this);


  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
# 337 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }
 };

template<class _Mytree> inline
 typename _Tree_const_iterator<_Mytree>::_Unchecked_type
  _Unchecked(_Tree_const_iterator<_Mytree> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mytree> inline
 _Tree_const_iterator<_Mytree>&
  _Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
   typename _Tree_const_iterator<_Mytree>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Mytree>
 class _Tree_iterator
  : public _Tree_const_iterator<_Mytree>
 {
public:
 typedef _Tree_iterator<_Mytree> _Myiter;
 typedef _Tree_const_iterator<_Mytree> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;

 typedef typename _Mytree::pointer pointer;
 typedef typename _Mytree::reference reference;

 _Tree_iterator()
  {
  }

 _Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };

template<class _Mytree> inline
 typename _Tree_iterator<_Mytree>::_Unchecked_type
  _Unchecked(_Tree_iterator<_Mytree> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mytree> inline
 _Tree_iterator<_Mytree>&
  _Rechecked(_Tree_iterator<_Mytree>& _Iter,
   typename _Tree_iterator<_Mytree>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference,
 class _Nodeptr_type>
 struct _Tree_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 typedef _Nodeptr_type _Nodeptr;
 };

template<class _Value_type,
 class _Voidptr>
 struct _Tree_node
  {
  _Voidptr _Left;
  _Voidptr _Parent;
  _Voidptr _Right;
  char _Color;
  char _Isnil;
  _Value_type _Myval;

 private:
  _Tree_node& operator=(const _Tree_node&);
  };

template<class _Value_type>
 struct _Tree_node<_Value_type, void *>
  {
  typedef _Tree_node<_Value_type, void *> *_Nodeptr;
  _Nodeptr _Left;
  _Nodeptr _Parent;
  _Nodeptr _Right;
  char _Color;
  char _Isnil;
  _Value_type _Myval;

 private:
  _Tree_node& operator=(const _Tree_node&);
  };

template<class _Ty>
 struct _Tree_simple_types
  : public _Simple_types<_Ty>
 {
 typedef _Tree_node<_Ty, void *> _Node;
 typedef _Node *_Nodeptr;
 };

template<class _Ty,
 class _Alloc0>
 struct _Tree_base_types
 {
# 525 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 typedef _Alloc0 _Alloc;


 typedef _Tree_base_types<_Ty, _Alloc0> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
  _Voidptr;
 typedef _Tree_node<typename _Alty::value_type,
  _Voidptr> _Node;

 typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
 typedef typename _Alnod_type::pointer _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Tree_simple_types<typename _Alty::value_type>,
  _Tree_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference,
   _Nodeptr> >::type
  _Val_types;
 };


template<class _Val_types>
 class _Tree_val
  : public _Container_base
 {
public:
 typedef _Tree_val<_Val_types> _Myt;

 typedef typename _Val_types::_Nodeptr _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _Tree_const_iterator<_Myt> const_iterator;
 typedef _Tree_iterator<_Myt> iterator;

 _Tree_val()
  {
  this->_Myhead = 0;
  this->_Mysize = 0;
  }

 enum _Redbl
  {
  _Red, _Black};

 static char& _Color(_Nodeptr _Pnode)
  {
  return ((char&)_Pnode->_Color);
  }

 static char& _Isnil(_Nodeptr _Pnode)
  {
  return ((char&)_Pnode->_Isnil);
  }

 static _Nodepref _Left(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Left);
  }

 static _Nodepref _Parent(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Parent);
  }

 static _Nodepref _Right(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Right);
  }

 static reference _Myval(_Nodeptr _Pnode)
  {
  return ((reference)_Pnode->_Myval);
  }

 static _Nodeptr _Max(_Nodeptr _Pnode)
  {
  while (!_Isnil(_Right(_Pnode)))
   _Pnode = _Right(_Pnode);
  return (_Pnode);
  }

 static _Nodeptr _Min(_Nodeptr _Pnode)
  {
  while (!_Isnil(_Left(_Pnode)))
   _Pnode = _Left(_Pnode);
  return (_Pnode);
  }

 _Nodeptr _Myhead;
 size_type _Mysize;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _Tree_alloc
  : public _Tree_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;

 _Tree_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alnod(_Al)
  {
  _Construct();
  }

 _Tree_alloc(_Alloc0&& _Al)
  : _Alnod(::std:: move(_Al))
  {
  _Construct();
  }


 void _Construct()
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_Tree_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Alnod, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Alnod, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(_Alnod, _Right._Alnod);
  }
# 745 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 _Nodeptr _Buyheadnode()
  {
  _Nodeptr _Pnode = _Alnod.allocate(1);

  {{
  _Alnod.construct(
   ::std:: addressof(this->_Left(_Pnode)), _Pnode);
  _Alnod.construct(
   ::std:: addressof(this->_Parent(_Pnode)), _Pnode);
  _Alnod.construct(
   ::std:: addressof(this->_Right(_Pnode)), _Pnode);
  } if (0) {
  _Alnod.deallocate(_Pnode, 1);
          ;
  }}

  this->_Color(_Pnode) = this->_Black;
  this->_Isnil(_Pnode) = true;
  return (_Pnode);
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  _Alnod.destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  _Alnod.destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  _Alnod.destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  _Alnod.deallocate(_Pnode, 1);
  }

 _Alty& _Getal() noexcept
  {
  return (_Alnod);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alnod);
  }

 _Alty _Alnod;
 };


template<class _Alloc_types>
 class _Tree_alloc<false, _Alloc_types>
  : public _Tree_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _Tree_alloc<false, _Alloc_types> _Myt;
 typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;

 _Tree_alloc(const _Alloc0& = _Alloc0())
  {
  _Construct();
  }

 _Tree_alloc(_Alloc0&&)
  {
  _Construct();
  }


 void _Construct()
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_Tree_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 887 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 _Nodeptr _Buyheadnode()
  {
  _Nodeptr _Pnode = this->_Getal().allocate(1);

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Left(_Pnode)), _Pnode);
  this->_Getal().construct(
   ::std:: addressof(this->_Parent(_Pnode)), _Pnode);
  this->_Getal().construct(
   ::std:: addressof(this->_Right(_Pnode)), _Pnode);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  this->_Color(_Pnode) = this->_Black;
  this->_Isnil(_Pnode) = true;
  return (_Pnode);
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc>
 class _Tree_buy
  : public _Tree_alloc<!is_empty<_Alloc>::value,
   _Tree_base_types<_Ty, _Alloc> >
 {
public:
 typedef _Tree_alloc<!is_empty<_Alloc>::value,
  _Tree_base_types<_Ty, _Alloc> > _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Nodeptr _Nodeptr;

 _Tree_buy(const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  }

 _Nodeptr _Buynode0(_Nodeptr _Pnode = nullptr)
  {
  if (_Pnode == nullptr)
   _Pnode = this->_Getal().allocate(1);

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Left(_Pnode)), this->_Myhead);
  this->_Getal().construct(
   ::std:: addressof(this->_Parent(_Pnode)), this->_Myhead);
  this->_Getal().construct(
   ::std:: addressof(this->_Right(_Pnode)), this->_Myhead);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 void _Freenode0(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 template<class... _Valty>
  _Nodeptr _Buynode(_Valty&&... _Val)
  {
  _Nodeptr _Pnode = _Buynode0();

  this->_Color(_Pnode) = this->_Red;
  this->_Isnil(_Pnode) = false;

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Pnode)),
    ::std:: forward<_Valty>(_Val)...);
  } if (0) {
  _Freenode0(_Pnode);
          ;
  }}

  return (_Pnode);
  }
 };


template<bool _Pr_has_storage,
 class _Traits>
 class _Tree_comp
  : public _Tree_buy<typename _Traits::value_type,
   typename _Traits::allocator_type>
 {
public:
 typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
 typedef _Tree_buy<typename _Traits::value_type,
  typename _Traits::allocator_type> _Mybase;

 typedef typename _Traits::allocator_type allocator_type;
 typedef typename _Traits::key_compare key_compare;

 _Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
  : _Mybase(_Al), comp(_Parg)
  {
  }

 key_compare& _Getcomp()
  {
  return (comp);
  }

 const key_compare& _Getcomp() const
  {
  return (comp);
  }

 void _Setcomp(const key_compare& _Right)
  {
  comp = _Right;
  }

 void _Swapcomp(key_compare& _Right)
  {
  _Swap_adl(comp, _Right);
  }

 key_compare comp;
 };

template<class _Traits>
 class _Tree_comp<false, _Traits>
  : public _Tree_buy<typename _Traits::value_type,
   typename _Traits::allocator_type>
 {
public:
 typedef _Tree_comp<false, _Traits> _Myt;
 typedef _Tree_buy<typename _Traits::value_type,
  typename _Traits::allocator_type> _Mybase;

 typedef typename _Traits::allocator_type allocator_type;
 typedef typename _Traits::key_compare key_compare;

 _Tree_comp(const key_compare&, const allocator_type& _Al)
  : _Mybase(_Al)
  {
  }

 key_compare _Getcomp() const
  {
  return (key_compare());
  }

 void _Setcomp(const key_compare&)
  {
  }

 void _Swapcomp(const key_compare&)
  {
  }
 };


template<class _Traits>
 class _Tree
  : public _Tree_comp<
   !is_empty<typename _Traits::key_compare>::value, _Traits>
 {
public:
 typedef _Tree<_Traits> _Myt;
 typedef _Tree_comp<
  !is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;

 typedef typename _Traits::key_type key_type;
 typedef typename _Traits::value_compare value_compare;
 enum
  {
  _Multi = _Traits::_Multi};

 typedef typename _Mybase::_Node _Node;
 typedef typename _Mybase::_Nodeptr _Nodeptr;
 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::key_compare key_compare;
 typedef typename _Mybase::allocator_type allocator_type;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;

 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _If<is_same<key_type, value_type>::value,
  typename _Mybase::const_iterator,
  typename _Mybase::iterator>::type iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 typedef pair<iterator, bool> _Pairib;
 typedef pair<iterator, iterator> _Pairii;
 typedef pair<const_iterator, const_iterator> _Paircc;

 struct _Copy_tag
  {
  };
 struct _Move_tag
  {
  };

 _Tree(const key_compare& _Parg,
  const allocator_type& _Al)
  : _Mybase(_Parg, _Al)
  {
  }

 _Tree(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right.key_comp(), _Al)
  {
  {{
  _Copy(_Right, _Copy_tag());
  } if (0) {
  _Tidy();
          ;
  }}
  }

 _Tree(_Myt&& _Right)
  : _Mybase(_Right.key_comp(), ::std:: move(_Right._Getal()))
  {
  _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  }

 _Tree(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(_Right.key_comp(), _Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   clear();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());

   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right, true_type)
  {
  this->_Swap_all(_Right);
  this->_Swapcomp(_Right._Getcomp());
  _Swap_adl(this->_Myhead, _Right._Myhead);
  ::std:: swap(this->_Mysize, _Right._Mysize);
  }

 void _Assign_rv(_Myt&& _Right, false_type)
  {
  if (get_allocator() == _Right.get_allocator())
   _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  else
   _Copy(_Right, _Move_tag());
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right),
   typename _Alty::propagate_on_container_move_assignment());
  }

 _Pairib insert(value_type&& _Val)
  {
  return (_Insert_nohint(false,
   ::std:: forward<value_type>(_Val), _Nil()));
  }

 iterator insert(const_iterator _Where, value_type&& _Val)
  {
  return (_Insert_hint(_Where,
   ::std:: forward<value_type>(_Val), _Nil()));
  }

 template<class _Valty,
  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,
   void> >
  _Pairib insert(_Valty&& _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
  return (_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class _Valty,
  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,
   void> >
  iterator insert(const_iterator _Where, _Valty&& _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
  return (_Insert_hint(_Where,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class _Valty>
  typename enable_if<is_convertible<_Valty, key_type>::value
   && !is_same<typename remove_cv<key_type>::type, value_type>::value,
   _Pairib>::type
  emplace(_Valty&& _Val)
  {
  typedef typename value_type::second_type mapped_type;
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val),
   mapped_type());
  return (_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class... _Valty>
  _Pairib emplace(_Valty&&... _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
  return (_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class... _Valty>
  iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
  return (_Insert_hint(_Where,
   this->_Myval(_Newnode), _Newnode));
  }

 ~_Tree() noexcept
  {
  _Tidy();
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   clear();
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    this->_Copy_alloc(_Right._Getal());
   this->_Getcomp() = _Right._Getcomp();
   _Copy(_Right, _Copy_tag());
   }
  return (*this);
  }

 iterator begin() noexcept
  {
  return (iterator(_Lmost(), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(_Lmost(), this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Myhead, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Myhead, this));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  return (this->_Getal().max_size());
  }

 bool empty() const noexcept
  {
  return (size() == 0);
  }

 allocator_type get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 key_compare key_comp() const
  {
  return (this->_Getcomp());
  }

 value_compare value_comp() const
  {
  return (value_compare(key_comp()));
  }
# 1401 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 _Pairib insert(const value_type& _Val)
  {
  return (_Insert_nohint(false,
   _Val, _Nil()));
  }

 iterator insert(const_iterator _Where,
  const value_type& _Val)
  {
  return (_Insert_hint(_Where,
   _Val, _Nil()));
  }

 template<class _Iter>
  void insert(_Iter _First, _Iter _Last)
  {
                             ;
  for (; _First != _Last; ++_First)
   emplace_hint(end(), *_First);
  }

 void insert(::std:: initializer_list<value_type> _Ilist)
  {
  insert(_Ilist.begin(), _Ilist.end());
  }

 iterator erase(const_iterator _Where,
  bool _Keep = false)
  {
# 1440 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  if (this->_Isnil(_Where._Mynode()))
   _Xout_of_range("invalid map/set<T> iterator");
  _Nodeptr _Erasednode = _Where._Mynode();
  ++_Where;


  _Nodeptr _Fixnode;
  _Nodeptr _Fixnodeparent;
  _Nodeptr _Pnode = _Erasednode;

  if (this->_Isnil(this->_Left(_Pnode)))
   _Fixnode = this->_Right(_Pnode);
  else if (this->_Isnil(this->_Right(_Pnode)))
   _Fixnode = this->_Left(_Pnode);
  else
   {
   _Pnode = _Where._Mynode();
   _Fixnode = this->_Right(_Pnode);
   }

  if (_Pnode == _Erasednode)
   {
   _Fixnodeparent = this->_Parent(_Erasednode);
   if (!this->_Isnil(_Fixnode))
    this->_Parent(_Fixnode) = _Fixnodeparent;

   if (_Root() == _Erasednode)
    _Root() = _Fixnode;
   else if (this->_Left(_Fixnodeparent) == _Erasednode)
    this->_Left(_Fixnodeparent) = _Fixnode;
   else
    this->_Right(_Fixnodeparent) =
     _Fixnode;

   if (_Lmost() == _Erasednode)
    _Lmost() = this->_Isnil(_Fixnode)
     ? _Fixnodeparent
     : this->_Min(_Fixnode);

   if (_Rmost() == _Erasednode)
    _Rmost() = this->_Isnil(_Fixnode)
     ? _Fixnodeparent
     : this->_Max(_Fixnode);
   }
  else
   {
   this->_Parent(this->_Left(_Erasednode)) =
    _Pnode;
   this->_Left(_Pnode) =
    this->_Left(_Erasednode);

   if (_Pnode == this->_Right(_Erasednode))
    _Fixnodeparent = _Pnode;
   else
    {
    _Fixnodeparent =
     this->_Parent(_Pnode);
    if (!this->_Isnil(_Fixnode))
     this->_Parent(_Fixnode) = _Fixnodeparent;
    this->_Left(_Fixnodeparent) = _Fixnode;
    this->_Right(_Pnode) =
     this->_Right(_Erasednode);
    this->_Parent(this->_Right(_Erasednode)) =
     _Pnode;
    }

   if (_Root() == _Erasednode)
    _Root() = _Pnode;
   else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
    this->_Left(this->_Parent(_Erasednode)) =
     _Pnode;
   else
    this->_Right(this->_Parent(_Erasednode)) =
     _Pnode;

   this->_Parent(_Pnode) =
    this->_Parent(_Erasednode);
   ::std:: swap(this->_Color(_Pnode),
    this->_Color(_Erasednode));
   }

  if (this->_Color(_Erasednode) == this->_Black)
   {
   for (; _Fixnode != _Root()
    && this->_Color(_Fixnode) == this->_Black;
    _Fixnodeparent = this->_Parent(_Fixnode))
    if (_Fixnode == this->_Left(_Fixnodeparent))
     {
     _Pnode = this->_Right(_Fixnodeparent);
     if (this->_Color(_Pnode) == this->_Red)
      {
      this->_Color(_Pnode) = this->_Black;
      this->_Color(_Fixnodeparent) = this->_Red;
      _Lrotate(_Fixnodeparent);
      _Pnode = this->_Right(_Fixnodeparent);
      }

     if (this->_Isnil(_Pnode))
      _Fixnode = _Fixnodeparent;
     else if (this->_Color(this->_Left(_Pnode)) == this->_Black
      && this->_Color(this->_Right(_Pnode)) == this->_Black)
      {
      this->_Color(_Pnode) = this->_Red;
      _Fixnode = _Fixnodeparent;
      }
     else
      {
      if (this->_Color(this->_Right(_Pnode))
       == this->_Black)
       {
       this->_Color(this->_Left(_Pnode)) = this->_Black;
       this->_Color(_Pnode) = this->_Red;
       _Rrotate(_Pnode);
       _Pnode = this->_Right(_Fixnodeparent);
       }

      this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
      this->_Color(_Fixnodeparent) = this->_Black;
      this->_Color(this->_Right(_Pnode)) = this->_Black;
      _Lrotate(_Fixnodeparent);
      break;
      }
     }
    else
     {
     _Pnode = this->_Left(_Fixnodeparent);
     if (this->_Color(_Pnode) == this->_Red)
      {
      this->_Color(_Pnode) = this->_Black;
      this->_Color(_Fixnodeparent) = this->_Red;
      _Rrotate(_Fixnodeparent);
      _Pnode = this->_Left(_Fixnodeparent);
      }

     if (this->_Isnil(_Pnode))
      _Fixnode = _Fixnodeparent;
     else if (this->_Color(this->_Right(_Pnode)) ==
      this->_Black
      && this->_Color(this->_Left(_Pnode)) == this->_Black)
      {
      this->_Color(_Pnode) = this->_Red;
      _Fixnode = _Fixnodeparent;
      }
     else
      {
      if (this->_Color(this->_Left(_Pnode)) == this->_Black)
       {
       this->_Color(this->_Right(_Pnode)) = this->_Black;
       this->_Color(_Pnode) = this->_Red;
       _Lrotate(_Pnode);
       _Pnode = this->_Left(_Fixnodeparent);
       }

      this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
      this->_Color(_Fixnodeparent) = this->_Black;
      this->_Color(this->_Left(_Pnode)) = this->_Black;
      _Rrotate(_Fixnodeparent);
      break;
      }
     }

   this->_Color(_Fixnode) = this->_Black;
   }

  if (!_Keep)
   {
   this->_Getal().destroy(
    ::std:: addressof(this->_Myval(_Erasednode)));
   this->_Getal().deallocate(_Erasednode, 1);
   }
  if (0 < this->_Mysize)
   --this->_Mysize;

  return (iterator(_Where._Ptr,
   this));
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
  if (_First == begin() && _Last == end())
   {
   clear();
   return (begin());
   }
  else
   {
   while (_First != _Last)
    erase(_First++);
   return (iterator(_First._Ptr, this));
   }
  }

 size_type erase(const key_type& _Keyval)
  {
  _Pairii _Where = equal_range(_Keyval);
  size_type _Num = 0;
  _Distance(_Where.first, _Where.second, _Num);
  erase(_Where.first, _Where.second);
  return (_Num);
  }

 void clear() noexcept
  {




  _Erase(_Root());
  _Root() = this->_Myhead;
  _Lmost() = this->_Myhead;
  _Rmost() = this->_Myhead;
  this->_Mysize = 0;
  }

 iterator find(const key_type& _Keyval)
  {
  iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }

 const_iterator find(const key_type& _Keyval) const
  {
  const_iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  iterator find(const _Other& _Keyval)
  {
  iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }

 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  const_iterator find(const _Other& _Keyval) const
  {
  const_iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }


 size_type count(const key_type& _Keyval) const
  {
  _Paircc _Ans = equal_range(_Keyval);
  size_type _Num = 0;
  _Distance(_Ans.first, _Ans.second, _Num);
  return (_Num);
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  size_type count(const _Other& _Keyval) const
  {
  _Paircc _Ans = equal_range(_Keyval);
  size_type _Num = 0;
  _Distance(_Ans.first, _Ans.second, _Num);
  return (_Num);
  }


 iterator lower_bound(const key_type& _Keyval)
  {
  return (iterator(_Lbound(_Keyval), this));
  }

 const_iterator lower_bound(const key_type& _Keyval) const
  {
  return (const_iterator(_Lbound(_Keyval), this));
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  iterator lower_bound(const _Other& _Keyval)
  {
  return (iterator(_Lbound(_Keyval), this));
  }

 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  const_iterator lower_bound(const _Other& _Keyval) const
  {
  return (const_iterator(_Lbound(_Keyval), this));
  }


 iterator upper_bound(const key_type& _Keyval)
  {
  return (iterator(_Ubound(_Keyval), this));
  }

 const_iterator upper_bound(const key_type& _Keyval) const
  {
  return (const_iterator(_Ubound(_Keyval), this));
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  iterator upper_bound(const _Other& _Keyval)
  {
  return (iterator(_Ubound(_Keyval), this));
  }

 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  const_iterator upper_bound(const _Other& _Keyval) const
  {
  return (const_iterator(_Ubound(_Keyval), this));
  }


 _Pairii equal_range(const key_type& _Keyval)
  {
  return (_Eqrange(_Keyval));
  }

 _Paircc equal_range(const key_type& _Keyval) const
  {
  return (_Eqrange(_Keyval));
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  _Pairii equal_range(const _Other& _Keyval)
  {
  return (_Eqrange(_Keyval));
  }

 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  _Paircc equal_range(const _Other& _Keyval) const
  {
  return (_Eqrange(_Keyval));
  }


 void swap(_Myt& _Right)
  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   this->_Swapcomp(_Right._Getcomp());
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   this->_Swapcomp(_Right._Getcomp());
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else
   {




   ::std:: terminate();

   }
  }

protected:
 template<class _Valty>
  _Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
  {
  return (_Node);
  }

 template<class _Valty>
  _Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
  {
  return (this->_Buynode(::std:: forward<_Valty>(_Val)));
  }

 void _Destroy_if_not_nil(_Nodeptr _Newnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Newnode)));
  this->_Getal().deallocate(_Newnode, 1);
  }

 void _Destroy_if_not_nil(_Nil)
  {
  }

 template<class _Valty,
  class _Nodety>
  iterator _Insert_hint(const_iterator _Where,
   _Valty&& _Val, _Nodety _Newnode)
  {
  const_iterator _Next;
  bool _Leftish = false;

  {{






  if (size() == 0)
   return (_Insert_at(true, this->_Myhead,
    ::std:: forward<_Valty>(_Val), _Newnode));
  else if (this->_Multi)
   {
   if (_Where == begin())
    {
    if (!this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val)))

     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    _Leftish = true;
    }
   else if (_Where == end())
    {
    if (!this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Rmost())))

     return (_Insert_at(false, _Rmost(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (!this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val))

    && !this->_Getcomp()(this->_Kfn(_Val), this->_Key((--(_Next = _Where))._Mynode())))


    {
    if (this->_Isnil(this->_Right(_Next._Mynode())))
     return (_Insert_at(false, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (!this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode()))

    && (++(_Next = _Where) == end()
     || !this->_Getcomp()(this->_Key(_Next._Mynode()), this->_Kfn(_Val))))

    {
    if (this->_Isnil(this->_Right(_Where._Mynode())))
     return (_Insert_at(false, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else
    _Leftish = true;
   }
  else
   {
   if (_Where == begin())
    {
    if (this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode())))

     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (_Where == end())
    {
    if (this->_Getcomp()(this->_Key(_Rmost()), this->_Kfn(_Val)))

     return (_Insert_at(false, _Rmost(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode()))

    && this->_Getcomp()(this->_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))


    {
    if (this->_Isnil(this->_Right(_Next._Mynode())))
     return (_Insert_at(false, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val))

    && (++(_Next = _Where) == end()
     || this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Next._Mynode()))))

    {
    if (this->_Isnil(this->_Right(_Where._Mynode())))
     return (_Insert_at(false, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   }
  } if (0) {
  _Destroy_if_not_nil(_Newnode);
          ;
  }}

  return (_Insert_nohint(_Leftish,
   ::std:: forward<_Valty>(_Val), _Newnode).first);
  }

 template<class _Valty,
  class _Nodety>
  _Pairib _Insert_nohint(bool _Leftish,
   _Valty&& _Val, _Nodety _Newnode, bool _Keep = false)
  {
  {{
  _Nodeptr _Trynode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;
  bool _Addleft = true;

  while (!this->_Isnil(_Trynode))
   {
   _Wherenode = _Trynode;
   if (_Leftish)
    _Addleft = !this->_Getcomp()(this->_Key(_Trynode), this->_Kfn(_Val));


   else
    _Addleft = this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Trynode));


   _Trynode = _Addleft ? this->_Left(_Trynode)
    : this->_Right(_Trynode);
   }

  if (this->_Multi)
   return (_Pairib(_Insert_at(_Addleft, _Wherenode,
    ::std:: forward<_Valty>(_Val), _Newnode), true));
  else
   {
   iterator _Where = iterator(_Wherenode, this);
   if (!_Addleft)
    ;
   else if (_Where == begin())
    return (_Pairib(_Insert_at(true, _Wherenode,
     ::std:: forward<_Valty>(_Val), _Newnode), true));
   else
    --_Where;

   if (this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val)))


    return (_Pairib(_Insert_at(_Addleft, _Wherenode,
     ::std:: forward<_Valty>(_Val), _Newnode), true));
   else
    {
    if (!_Keep)
     _Destroy_if_not_nil(_Newnode);
    return (_Pairib(_Where, false));
    }
   }
  } if (0) {
  _Destroy_if_not_nil(_Newnode);
          ;
  }}
  }

 template<class _Valty,
  class _Nodety>
  iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
  _Valty&& _Val, _Nodety _Node)
  {
  if (max_size() - 1 <= this->_Mysize)
   {
   _Destroy_if_not_nil(_Node);
   _Xlength_error("map/set<T> too long");
   }
  _Nodeptr _Newnode = _Buynode_if_nil(_Node,
   ::std:: forward<_Valty>(_Val));

  ++this->_Mysize;
  _Newnode->_Parent = _Wherenode;

  if (_Wherenode == this->_Myhead)
   {
   _Root() = _Newnode;
   _Lmost() = _Newnode;
   _Rmost() = _Newnode;
   }
  else if (_Addleft)
   {
   this->_Left(_Wherenode) = _Newnode;
   if (_Wherenode == _Lmost())
    _Lmost() = _Newnode;
   }
  else
   {
   this->_Right(_Wherenode) = _Newnode;
   if (_Wherenode == _Rmost())
    _Rmost() = _Newnode;
   }

  for (_Nodeptr _Pnode = _Newnode;
   this->_Color(this->_Parent(_Pnode)) == this->_Red; )
   if (this->_Parent(_Pnode)
    == this->_Left(this->_Parent(this->_Parent(_Pnode))))
    {
    _Wherenode =
     this->_Right(this->_Parent(this->_Parent(_Pnode)));
    if (this->_Color(_Wherenode) == this->_Red)
     {
     this->_Color(this->_Parent(_Pnode)) = this->_Black;
     this->_Color(_Wherenode) = this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode)))
      = this->_Red;
     _Pnode = this->_Parent(this->_Parent(_Pnode));
     }
    else
     {
     if (_Pnode == this->_Right(this->_Parent(_Pnode)))
      {
      _Pnode = this->_Parent(_Pnode);
      _Lrotate(_Pnode);
      }
     this->_Color(this->_Parent(_Pnode)) =
      this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Rrotate(this->_Parent(this->_Parent(_Pnode)));
     }
    }
   else
    {
    _Wherenode =
     this->_Left(this->_Parent(this->_Parent(_Pnode)));
    if (this->_Color(_Wherenode) == this->_Red)
     {
     this->_Color(this->_Parent(_Pnode)) = this->_Black;
     this->_Color(_Wherenode) = this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Pnode = this->_Parent(this->_Parent(_Pnode));
     }
    else
     {
     if (_Pnode == this->_Left(this->_Parent(_Pnode)))
      {
      _Pnode = this->_Parent(_Pnode);
      _Rrotate(_Pnode);
      }
     this->_Color(this->_Parent(_Pnode)) =
      this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Lrotate(this->_Parent(this->_Parent(_Pnode)));
     }
    }

  this->_Color(_Root()) = this->_Black;
  return (iterator(_Newnode, this));
  }

 template<class _Moveit>
  void _Copy(const _Myt& _Right, _Moveit _Movefl)
  {
  _Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
  this->_Mysize = _Right.size();
  this->_Getcomp() = _Right._Getcomp();
  if (!this->_Isnil(_Root()))
   {
   _Lmost() = this->_Min(_Root());
   _Rmost() = this->_Max(_Root());
   }
  else
   {
   _Lmost() = this->_Myhead;
   _Rmost() = this->_Myhead;
   }
  }

 template<class _Ty,
  class _Is_set>
  _Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
  {
  return (this->_Buynode(_Val));
  }

 template<class _Ty>
  _Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
  {
  return (this->_Buynode(::std:: move(_Val)));
  }

 template<class _Ty>
  _Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
  {
  return (this->_Buynode(
   ::std:: move(const_cast<key_type&>(_Val.first)),
   ::std:: move(_Val.second)));
  }

 template<class _Moveit>
  _Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
   _Moveit _Movefl)
  {
  _Nodeptr _Newroot = this->_Myhead;

  if (!this->_Isnil(_Rootnode))
   {
   typename is_same<key_type, value_type>::type _Is_set;
   _Nodeptr _Pnode = _Copy_or_move(
    this->_Myval(_Rootnode), _Movefl, _Is_set);
   _Pnode->_Parent = _Wherenode;
   _Pnode->_Color = this->_Color(_Rootnode);
   if (this->_Isnil(_Newroot))
    _Newroot = _Pnode;

   {{
   this->_Left(_Pnode) =
    _Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
   this->_Right(_Pnode) =
    _Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
   } if (0) {
   _Erase(_Newroot);
           ;
   }}
   }

  return (_Newroot);
  }
# 2214 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 template<class _Other>
  _Paircc _Eqrange(const _Other& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Lonode = this->_Myhead;
  _Nodeptr _Hinode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    if (this->_Isnil(_Hinode)
      && this->_Getcomp()(_Keyval, this->_Key(_Pnode)))

     _Hinode = _Pnode;
    _Lonode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  _Pnode = this->_Isnil(_Hinode) ? _Root()
   : this->_Left(_Hinode);
  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(_Keyval, this->_Key(_Pnode)))
    {
    _Hinode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }
   else
    _Pnode = this->_Right(_Pnode);

  const_iterator _First = const_iterator(_Lonode, this);
  const_iterator _Last = const_iterator(_Hinode, this);
  return (_Paircc(_First, _Last));
  }

 template<class _Other>
  _Pairii _Eqrange(const _Other& _Keyval)
  {
  _Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));
  iterator _First = iterator(_Ans.first._Ptr, this);
  iterator _Last = iterator(_Ans.second._Ptr, this);
  return (_Pairii(_First, _Last));
  }

 void _Erase(_Nodeptr _Rootnode)
  {
  for (_Nodeptr _Pnode = _Rootnode;
   !this->_Isnil(_Pnode); _Rootnode = _Pnode)
   {
   _Erase(this->_Right(_Pnode));
   _Pnode = this->_Left(_Pnode);
   this->_Getal().destroy(
    ::std:: addressof(this->_Myval(_Rootnode)));

   this->_Getal().deallocate(_Rootnode, 1);
   }
  }

 bool _Compare(const key_type& _Left, const key_type& _Right) const
  {
  return (this->_Getcomp()(_Left, _Right));
  }

 template<class _Ty1,
  class _Ty2>
  bool _Compare(const _Ty1& _Left, const _Ty2& _Right) const
  {
  return (this->_Getcomp()(_Left, _Right));
  }

 template<class _Other>
  _Nodeptr _Lbound(const _Other& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (_Compare(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  return (_Wherenode);
  }

 template<class _Other>
  _Nodeptr _Lbound(const _Other& _Keyval)
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  return (_Wherenode);
  }

 _Nodeptr& _Lmost() const
  {
  return (this->_Left(this->_Myhead));
  }

 void _Lrotate(_Nodeptr _Wherenode)
  {
  _Nodeptr _Pnode = this->_Right(_Wherenode);
  this->_Right(_Wherenode) = this->_Left(_Pnode);

  if (!this->_Isnil(this->_Left(_Pnode)))
   this->_Parent(this->_Left(_Pnode)) = _Wherenode;
  this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  if (_Wherenode == _Root())
   _Root() = _Pnode;
  else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
   this->_Left(this->_Parent(_Wherenode)) = _Pnode;
  else
   this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  this->_Left(_Pnode) = _Wherenode;
  this->_Parent(_Wherenode) = _Pnode;
  }

 _Nodeptr& _Rmost() const
  {
  return (this->_Right(this->_Myhead));
  }

 _Nodeptr& _Root() const
  {
  return (this->_Parent(this->_Myhead));
  }

 void _Rrotate(_Nodeptr _Wherenode)
  {
  _Nodeptr _Pnode = this->_Left(_Wherenode);
  this->_Left(_Wherenode) = this->_Right(_Pnode);

  if (!this->_Isnil(this->_Right(_Pnode)))
   this->_Parent(this->_Right(_Pnode)) = _Wherenode;
  this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  if (_Wherenode == _Root())
   _Root() = _Pnode;
  else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
   this->_Right(this->_Parent(_Wherenode)) = _Pnode;
  else
   this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  this->_Right(_Pnode) = _Wherenode;
  this->_Parent(_Wherenode) = _Pnode;
  }

 template<class _Other>
  _Nodeptr _Ubound(const _Other& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (_Compare(_Keyval, this->_Key(_Pnode)))
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }
   else
    _Pnode = this->_Right(_Pnode);

  return (_Wherenode);
  }
# 2412 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 void _Tidy()
  {
  erase(begin(), end());
  }

 const key_type& _Kfn(const value_type& _Val) const
  {
  return (_Traits::_Kfn(_Val));
  }

 const key_type& _Key(_Nodeptr _Pnode) const
  {
  return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
  }
 };


template<class _Traits> inline
 bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Traits> inline
 bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Traits> inline
 bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Traits> inline
 bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Traits> inline
 bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Traits> inline
 bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Left < _Right));
 }
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 1 3
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
namespace std {

template<class _Src,
 class _Dest>
 struct _Tuple_enable
 {
 };

template<>
 struct _Tuple_enable<tuple<>, tuple<> >
 {
 typedef void ** type;
 };

template<class _Src0,
 class... _Types1,
 class _Dest0,
 class... _Types2>
 struct _Tuple_enable<tuple<_Src0, _Types1...>,
  tuple<_Dest0, _Types2...> >





  : _If<is_convertible<_Src0, _Dest0>::value,


  _Tuple_enable<tuple<_Types1...>, tuple<_Types2...> >,
  _Tuple_enable<int, int>
 >::type
 {
 };


template<class _Src,
 class _Dest>
 struct _Is_tuple_constructible
 : public false_type
 {
 };

template<>
 struct _Is_tuple_constructible<tuple<>, tuple<>>
 : public true_type
 {
 };

template<class _Dest0,
 class... _Types1,
 class _Src0,
 class... _Types2>
 struct _Is_tuple_constructible<tuple<_Dest0, _Types1...>,
  tuple<_Src0, _Types2...> >
 : public integral_constant<bool,
  is_constructible<_Dest0, _Src0>::value
   && _Is_tuple_constructible<tuple<_Types1...>,
    tuple<_Types2...> >::value>
 {
 };


template<class _Src,
 class _Dest>
 struct _Is_tuple_convertible
 : public false_type
 {
 };

template<>
 struct _Is_tuple_convertible<tuple<>, tuple<>>
 : public true_type
 {
 };

template<class _Src0,
 class... _Types1,
 class _Dest0,
 class... _Types2>
 struct _Is_tuple_convertible<tuple<_Src0, _Types1...>,
  tuple<_Dest0, _Types2...> >
 : public integral_constant<bool,
  is_convertible<_Src0, _Dest0>::value
   && _Is_tuple_convertible<tuple<_Types1...>,
    tuple<_Types2...> >::value>
 {
 };


struct _Ignore
 {
 template<class _Ty>
  constexpr void operator=(const _Ty&) const
  {
  }
 };




const _Ignore ignore = _Ignore();



struct _Tuple_alloc_t
 {
 };


constexpr _Tuple_alloc_t _Tuple_alloc{};





template<class _Ty>
 struct _Tuple_val
 {
 constexpr _Tuple_val()
  : _Val()
  {
  }

 template<class _Other>
  constexpr _Tuple_val(_Other&& _Arg)
  : _Val(::std:: forward<_Other>(_Arg))
  {
  }

 template<class _Other>
  _Tuple_val& operator=(_Other&& _Right)
  {
  _Val = ::std:: forward<_Other>(_Right);
  return (*this);
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc&,
   enable_if_t<!uses_allocator<_Ty, _Alloc>::value,
    _Tuple_alloc_t>, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   enable_if_t<uses_allocator<_Ty, _Alloc>::value
    && is_constructible<_Ty,
     allocator_arg_t, _Alloc, _Other...>::value,
    _Tuple_alloc_t>, _Other&&... _Arg)
  : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   enable_if_t<uses_allocator<_Ty, _Alloc>::value
    && !is_constructible<_Ty,
     allocator_arg_t, _Alloc, _Other...>::value,
    _Tuple_alloc_t>, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)..., _Al)
  {
  }

 _Ty _Val;
 };


template<class... _Types>
 class tuple;

template<>
 class tuple<>
 {
public:
 typedef tuple<> _Myt;
 typedef _Myt _This_type;

 constexpr tuple() noexcept
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&) noexcept
  {
  }

 constexpr tuple(const tuple&) noexcept
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&, const _Myt&) noexcept
  {
  }

 void swap(_Myt&) noexcept
  {
  }

 constexpr bool _Equals(const _Myt&) const noexcept
  {
  return (true);
  }

 constexpr bool _Less(const _Myt&) const noexcept
  {
  return (false);
  }
 };

struct _One_arg_t
 {
 };

template<class _This,
 class... _Rest>
 class tuple<_This, _Rest...>
  : public tuple<_Rest...>
 {
public:
 typedef _This _This_type;
 typedef tuple<_This, _Rest...> _Myt;
 typedef tuple<_Rest...> _Mybase;
 static const size_t _Mysize = 1 + sizeof...(_Rest);

 template<class...>
  struct _Is_default_constructible
   : true_type
  {
  };

 template<class _Myty,
  class... _Myrest>
  struct _Is_default_constructible<_Myty, _Myrest...>
   : integral_constant<bool, is_default_constructible<_Myty>::value
    && _Is_default_constructible<_Myrest...>::value>
  {
  };







  constexpr tuple()
   : _Mybase(),
    _Myfirst()
  {
  }

 template<class... _Rest2>
  explicit constexpr tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
   : _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
    _Myfirst(allocator_arg)
  {
  }

 template<bool _SizeIs1, bool _SameAsThisTuple, class _Dummy = void>
  struct _CheckTupleLikeConstructor
  {
  template<class...>
   static constexpr bool _EnableCopyConstructor() { return true; }
  template<class...>
   static constexpr bool _EnableMoveConstructor() { return true; }
  };

 template<class _Dummy>
  struct _CheckTupleLikeConstructor<true, false, _Dummy>
  {
  template<class... _Other>
  static constexpr bool _EnableCopyConstructor()
   {
   return !is_convertible<const tuple<_Other...>&, _This>::value
    && !is_constructible<_This, const tuple<_Other...>&>::value;
   }

  template<class... _Other>
  static constexpr bool _EnableMoveConstructor()
   {
   return !is_convertible<tuple<_Other...>, _This>::value
    && !is_constructible<_This, tuple<_Other...>>::value;
   }
  };

 template<class _Dummy>
  struct _CheckTupleLikeConstructor<true, true, _Dummy>
  {
  template<class...>
   static constexpr bool _EnableCopyConstructor() { return false; }
  template<class...>
   static constexpr bool _EnableMoveConstructor() { return false; }
  };

 template<class... _Other,
# 333 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<const _Other&...>, _Myt>::type>

  constexpr tuple(const tuple<_Other...>& _Right)
  : _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
  {
  }
# 357 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Alloc,
  class... _Other,
# 369 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<const _Other&...>, _Myt>::type>

  tuple(allocator_arg_t, const _Alloc& _Al,
   const tuple<_Other...>& _Right)
  : _Mybase(allocator_arg, _Al, _Right._Get_rest()),
   _Myfirst(_Al, _Tuple_alloc,
    _Right._Myfirst._Val)
  {
  }
# 400 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class...>
  struct _Is_copy_constructible
   : true_type
  {
  };

 template<class _Myty,
  class... _Myrest>
  struct _Is_copy_constructible<_Myty, _Myrest...>
   : integral_constant<bool, is_copy_constructible<_Myty>::value
    && _Is_copy_constructible<_Myrest...>::value>
  {
  };







  constexpr explicit tuple(const _This& _This_arg,
   const _Rest&... _Rest_arg)
   : _Mybase(_Rest_arg...),
    _Myfirst(_This_arg)
  {
  }
# 448 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Alloc>

  tuple(allocator_arg_t, const _Alloc& _Al,
   const _This& _This_arg, const _Rest&... _Rest_arg)
  : _Mybase(allocator_arg, _Al, _Rest_arg...),
   _Myfirst(_Al, _Tuple_alloc, _This_arg)
  {
  }
# 472 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class...>
  struct _PackExpandsToThisTuple : false_type {};

 template<class _Ty>
  struct _PackExpandsToThisTuple<_Ty>
   : is_same<typename remove_cv<typename remove_reference<_Ty>::type>::type, _Myt>
  {
  };

 template<bool _MaybeEnable, class _Dummy = void>
  struct _CheckArgsConstructor
  {
  template<class...>
   static constexpr bool _EnableImplicit() { return false; }
  template<class...>
   static constexpr bool _EnableExplicit() { return false; }
  };

 template<class _Dummy>
 struct _CheckArgsConstructor<true, _Dummy>
  {
  template<class... _Types>
   static constexpr bool _EnableImplicit()
   {
   return _Is_tuple_constructible<_Myt, tuple<_Types&&...>>::value
     && _Is_tuple_convertible<tuple<_Types&&...>, _Myt>::value;
   };

  template<class... _Types>
   static constexpr bool _EnableExplicit()
   {
   return _Is_tuple_constructible<_Myt, tuple<_Types&&...>>::value
     && !_Is_tuple_convertible<tuple<_Types&&...>, _Myt>::value;
   };
  };

 template<class _This2,
  class... _Rest2,
# 520 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<_This2, _Rest2...>, _Myt>::type>

  constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }
# 543 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Alloc,
  class _This2,
  class... _Rest2,





  class = typename _Tuple_enable<
   tuple<_This2, _Rest2...>, _Myt>::type>

  tuple(allocator_arg_t, const _Alloc& _Al,
   _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_This2>(_This_arg))
  {
  }
# 580 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class... _Other,
# 591 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<_Other...>, _Myt>::type>

  constexpr tuple(tuple<_Other...>&& _Right)
  : _Mybase((typename tuple<_Other...>::_Mybase&&)_Right),
   _Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>
    (_Right._Myfirst._Val))
  {
  }
# 619 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Alloc,
  class... _Other,
# 631 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<_Other...>, _Myt>::type>

  tuple(allocator_arg_t, const _Alloc& _Al,
   tuple<_Other...>&& _Right)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<typename tuple<_Other...>::_Mybase>
     (_Right._Get_rest())),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<typename tuple<_Other...>::_This_type>
     (_Right._Myfirst._Val))
  {
  }
# 668 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<template<class, class> class _Is_fn,
  class _Tuple1,
  class _Tuple2>
  struct _Is_tuple_assignable;

 template<template<class, class> class _Is_fn,
  class _First0,
  class _First1>
  struct _Is_tuple_assignable<_Is_fn, tuple<_First0>, tuple<_First1> >
  {
  static const bool value = _Is_fn<_First0, _First1>::value;
  };

 template<template<class, class> class _Is_fn,
  class _First0,
  class... _Rest0,
  class _First1,
  class... _Rest1>
  struct _Is_tuple_assignable<_Is_fn, tuple<_First0, _Rest0...>,
   tuple<_First1, _Rest1...> >
  {
  static const bool value =
   _Is_fn<_First0, _First1>::value
    && _Is_tuple_assignable<_Is_fn,
     tuple<_Rest0...>,
     tuple<_Rest1...> >::value;
  };

 template<class _Ty1,
  class _Ty2>
  struct _Is_copy_assignable
   : public is_assignable<_Ty1&, const _Ty2&>
  {
  };
# 712 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Other0,
  class... _Other>
  _Myt& operator=(const tuple<_Other0, _Other...>& _Right)

  {
  _Myfirst._Val = _Right._Myfirst._Val;
  _Get_rest() = _Right._Get_rest();
  return (*this);
  }

 template<class _Ty1,
  class _Ty2>
  struct _Is_move_assignable
   : public is_assignable<_Ty1&, _Ty2&&>
  {
  };
# 738 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Other0,
  class... _Other>
  _Myt& operator=(tuple<_Other0, _Other...>&& _Right)

  {
  _Myfirst._Val = ::std:: forward<typename tuple<_Other0, _Other...>
   ::_This_type>(_Right._Myfirst._Val);
  _Get_rest() = ::std:: forward<typename tuple<_Other0, _Other...>
   ::_Mybase>(_Right._Get_rest());
  return (*this);
  }

 template<class... _Other>
  constexpr bool _Equals(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other), "comparing tuple to object with different size");

  return (_Myfirst._Val == _Right._Myfirst._Val
   && _Mybase::_Equals(_Right._Get_rest()));
  }

 template<class... _Other>
  constexpr bool _Less(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other), "comparing tuple to object with different size");

  return (_Myfirst._Val < _Right._Myfirst._Val
   || (!(_Right._Myfirst._Val < _Myfirst._Val)
    && _Mybase::_Less(_Right._Get_rest())));
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al)
  : _Mybase(allocator_arg, _Al),
   _Myfirst(_Al, _Tuple_alloc)
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const _Myt& _Right)
  : _Mybase(allocator_arg, _Al, _Right._Get_rest()),
   _Myfirst(_Al, _Tuple_alloc,
    _Right._Myfirst._Val)
  {
  }
# 795 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 tuple(const _Myt&) = default;
 tuple(_Myt&&) = default;


 template<class _Tag,
  class _This2,
  class = enable_if_t<is_same<_Tag, _One_arg_t>::value,
   void> >
  constexpr tuple(_Tag, _This2&& _This_arg)
  : _Mybase(),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }

 template<class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<const _First&, const _Second&>, _Myt>::type>
  constexpr tuple(const pair<_First, _Second>& _Right)

  : _Mybase(_One_arg_t(), _Right.second),
   _Myfirst(_Right.first)
  {

  }

 template<class _Alloc,
  class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<const _First&, const _Second&>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const pair<_First, _Second>& _Right)

  : _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
   _Myfirst(_Al, _Tuple_alloc,
    _Right.first)
  {

  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Myfirst._Val = _Right._Myfirst._Val;
  _Get_rest() = _Right._Get_rest();
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(const pair<_First, _Second>& _Right)
  {
  static_assert(_Mysize == 2, "assigning to tuple from object with different size");

  _Myfirst._Val = _Right.first;
  _Get_rest()._Myfirst._Val = _Right.second;
  return (*this);
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   _Myt&& _Right)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<_Mybase>(_Right._Get_rest())),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_This>(_Right._Myfirst._Val))
  {
  }

 template<class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<_First, _Second>, _Myt>::type>
  constexpr tuple(pair<_First, _Second>&& _Right)

  : _Mybase(_One_arg_t(), ::std:: forward<_Second>(_Right.second)),
   _Myfirst(::std:: forward<_First>(_Right.first))
  {

  }

 template<class _Alloc,
  class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<_First, _Second>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   pair<_First, _Second>&& _Right)

  : _Mybase(allocator_arg, _Al,
    tuple<_Second>(::std:: forward<_Second>(_Right.second))),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_First>(_Right.first))
  {

  }

 _Myt& operator=(_Myt&& _Right)
  noexcept(is_nothrow_move_assignable<_This>::value && is_nothrow_move_assignable<_Mybase>::value)

  {
  _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
  _Get_rest() = ::std:: forward<_Mybase>(_Right._Get_rest());
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(pair<_First, _Second>&& _Right)
  {
  static_assert(_Mysize == 2, "assigning to tuple from object with different size");

  _Myfirst._Val = ::std:: forward<_First>(_Right.first);
  _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
  return (*this);
  }

 constexpr _Mybase& _Get_rest() noexcept
  {
  return (*this);
  }

 constexpr const _Mybase& _Get_rest() const noexcept
  {
  return (*this);
  }

 void swap(tuple& _Right)
  noexcept(noexcept(_Swap_adl(this->_Myfirst._Val, _Right._Myfirst._Val)) && noexcept(_Swap_adl(_Right._Get_rest(), _Right._Get_rest())))


  {
  _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
  _Mybase::swap(_Right._Get_rest());
  }

 _Tuple_val<_This> _Myfirst;
 };
# 948 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator==(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Equals(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator!=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator<(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator>=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator>(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Right < _Left);
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator<=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Right < _Left));
 }
# 1016 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class... _Types> inline


 void swap(tuple<_Types...>& _Left,
  tuple<_Types...>& _Right)
   noexcept(noexcept(_Left.swap(_Right)))
 {
 return (_Left.swap(_Right));
 }


template<class _Ty,
 class _Tuple>
 struct _Tuple_element;

template<class _This,
 class... _Rest>
 struct _Tuple_element<_This, tuple<_This, _Rest...> >
 {
 typedef int _Check_type;
 static_assert((is_void<typename _Tuple_element<_This, tuple<_Rest...> >::_Check_type>::value), "duplicate type T in get<T>(tuple)");



 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<class _Ty,
 class _This,
 class... _Rest>
 struct _Tuple_element<_Ty, tuple<_This, _Rest...> >
  : public _Tuple_element<_Ty, tuple<_Rest...> >
 {
 };

template<class _Ty>
 struct _Tuple_element<_Ty, tuple<> >
 {
 typedef void _Check_type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, const _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, volatile _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, const volatile _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };


template<size_t _Index,
 class... _Types> inline
 constexpr typename tuple_element<_Index, tuple<_Types...> >::type&
  get(tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 constexpr const typename tuple_element<_Index, tuple<_Types...> >::type&
  get(const tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 constexpr typename tuple_element<_Index, tuple<_Types...> >::type&&
  get(tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
  _RRtype;
 return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
 }
# 1133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class _Ty,
 class... _Types> inline
 constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<class _Ty,
 class... _Types> inline
 constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<class _Ty,
 class... _Types> inline
 constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (::std:: forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
 }
# 1168 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class... _Types> inline
 constexpr tuple<typename _Unrefwrap<_Types>::type...>
  make_tuple(_Types&&... _Args)
 {
 typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
 return (_Ttype(::std:: forward<_Types>(_Args)...));
 }


template<class... _Types> inline
 constexpr tuple<_Types&...>
  tie(_Types&... _Args) noexcept
 {
 typedef tuple<_Types&...> _Ttype;
 return (_Ttype(_Args...));
 }


template<class _Ty,
 size_t _Size>
 class array;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;
# 1252 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class... _Types> inline
 constexpr tuple<_Types&&...>
  forward_as_tuple(_Types&&... _Args) noexcept
 {
 return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
 }


template<class _Seq_type1,
 class _Seq_type2>
 struct _Cat_sequences;

template<size_t... _Indexes1,
 size_t... _Indexes2>
 struct _Cat_sequences<integer_sequence<size_t, _Indexes1...>,
  integer_sequence<size_t, _Indexes2...> >
 {
 typedef integer_sequence<size_t, _Indexes1..., _Indexes2...> type;
 };


template<class _Ty,
 class... _For_array>
 struct _View_as_tuple
 {
 static_assert(_Always_false<_Ty>::value, "Unsupported tuple_cat arguments.");

 };

template<class... _Types>
 struct _View_as_tuple<tuple<_Types...> >
 {
 typedef tuple<_Types...> type;
 };

template<class _Ty1,
 class _Ty2>
 struct _View_as_tuple<pair<_Ty1, _Ty2> >
 {
 typedef tuple<_Ty1, _Ty2> type;
 };

template<class _Ty,
 class... _Types>
 struct _View_as_tuple<array<_Ty, 0>, _Types...>
 {
 typedef tuple<_Types...> type;
 };

template<class _Ty,
 size_t _Size,
 class... _Types>
 struct _View_as_tuple<array<_Ty, _Size>, _Types...>
  : _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
 {
 };


template<size_t _Nx,
 class _Ty>
 struct _Repeat_for
  : integral_constant<size_t, _Nx>
 {
 };


template<class _Ret,
 class _Kx_arg,
 class _Ix_arg,
 size_t _Ix_next,
 class... _Tuples>
 struct _Tuple_cat2
 {
 static_assert(sizeof...(_Tuples) == 0, "Unsupported tuple_cat arguments.");

 typedef _Ret type;
 typedef _Kx_arg _Kx_arg_seq;
 typedef _Ix_arg _Ix_arg_seq;
 };

template<class... _Types1,
 class _Kx_arg,
 size_t... _Ix,
 size_t _Ix_next,
 class... _Types2,
 class... _Rest>
 struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
  integer_sequence<size_t, _Ix...>, _Ix_next,
  tuple<_Types2...>, _Rest...>
  : _Tuple_cat2<
   tuple<_Types1..., _Types2...>,
   typename _Cat_sequences<_Kx_arg,
    typename make_integer_sequence<size_t, sizeof...(_Types2)>
     ::type>::type,
   integer_sequence<size_t, _Ix...,
    _Repeat_for<_Ix_next, _Types2>::value...>,
   _Ix_next + 1,
   _Rest...>
 {
 };

template<class... _Tuples>
 struct _Tuple_cat1
  : _Tuple_cat2<tuple<>, integer_sequence<size_t>,
    integer_sequence<size_t>, 0,
   typename _View_as_tuple<typename decay<_Tuples>::type>::type...>
 {
 };

template<class _Ret,
 size_t... _Kx,
 size_t... _Ix,
 class _Ty> inline
 constexpr _Ret _Tuple_cat(integer_sequence<size_t, _Kx...>,
  integer_sequence<size_t, _Ix...>, _Ty&& _Arg)
 {
 return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
 }

template<class... _Tuples> inline
 constexpr typename _Tuple_cat1<_Tuples...>::type
  tuple_cat(_Tuples&&... _Tpls)
 {
 typedef _Tuple_cat1<_Tuples...> _Cat1;
 return (_Tuple_cat<typename _Cat1::type>(
  typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
  ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
 }



template<class _Ty1,
 class _Ty2>
 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   integer_sequence<size_t, _Indexes1...>,
   integer_sequence<size_t, _Indexes2...>)
  : first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
   second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
  {
  }


template<class _Ty1,
 class _Ty2>
 template<class... _Types1,
  class... _Types2> inline
  pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2)
  : pair(_Val1, _Val2,
   make_integer_sequence<size_t, sizeof...(_Types1)>(),
   make_integer_sequence<size_t, sizeof...(_Types2)>())
  {
  }
# 1444 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
struct _Uses_alloc_none {};
struct _Uses_alloc_arg {};
struct _Uses_alloc_last {};

template<class _Objty, class _Alty, class... _Types,
 class = typename enable_if<
  !uses_allocator<_Objty, _Alty>::value
  && is_constructible<_Objty, _Types...>::value
 >::type>
 _Uses_alloc_none _Uses_alloc_type(int, int);

template<class _Objty, class _Alty, class... _Types,
 class = typename enable_if<
  uses_allocator<_Objty, _Alty>::value
  && is_constructible<_Objty, allocator_arg_t, _Alty, _Types...>::value
 >::type>
 _Uses_alloc_arg _Uses_alloc_type(_Wrap_int, int);

template<class _Objty, class _Alty, class... _Types,
 class = typename enable_if<
  uses_allocator<_Objty, _Alty>::value
  && is_constructible<_Objty, _Types..., _Alty>::value
 >::type>
 _Uses_alloc_last _Uses_alloc_type(_Wrap_int, _Wrap_int);

template<class _Objty, class _Alty, class... _Types, size_t... _Indices> inline
 tuple<_Types&&...>
 _Make_uses_alloc_construct_args_impl(_Uses_alloc_none,
  _Alty& _Al, tuple<_Types...>&& _Tup, index_sequence<_Indices...>)
 {
 return ::std:: forward_as_tuple(::std:: get<_Indices>(::std:: move(_Tup))...);
 }

template<class _Objty, class _Alty, class... _Types, size_t... _Indices> inline
 tuple<const allocator_arg_t&, _Alty&, _Types&&...>
 _Make_uses_alloc_construct_args_impl(_Uses_alloc_arg,
  _Alty& _Al, tuple<_Types...>&& _Tup, index_sequence<_Indices...>)
 {
 return ::std:: forward_as_tuple(allocator_arg, _Al,
  ::std:: get<_Indices>(::std:: move(_Tup))...);
 }

template<class _Objty, class _Alty, class... _Types, size_t... _Indices> inline
 tuple<_Types&&..., _Alty&>
 _Make_uses_alloc_construct_args_impl(_Uses_alloc_last,
  _Alty& _Al, tuple<_Types...>&& _Tup, index_sequence<_Indices...>)
 {
 return ::std:: forward_as_tuple(::std:: get<_Indices>(::std:: move(_Tup))..., _Al);
 }

template<class _Objty, class _Alty, class... _Types> inline
 decltype(auto) _Make_uses_alloc_construct_args(_Alty& _Al, tuple<_Types...>&& _Tup)
 {
 using _UAType = decltype(_Uses_alloc_type<_Objty, _Alty, _Types...>(0, 0));
 return _Make_uses_alloc_construct_args_impl<_Objty>(_UAType(),
  _Al, ::std:: move(_Tup), make_index_sequence<sizeof...(_Types)>());
 }

}

namespace std {

template<class... _Types,
 class _Alloc>
 struct uses_allocator<tuple<_Types...>, _Alloc>
  : true_type
 {
 };
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 2 3

namespace std {

template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc>
 class multimap;


template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc,
 bool _Mfl>
 class _Tmap_traits
 {
public:
 typedef _Kty key_type;
 typedef pair<const _Kty, _Ty> value_type;
 typedef _Pr key_compare;
 typedef _Alloc allocator_type;

 enum
  {
  _Multi = _Mfl};

 class value_compare
  {
  friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

 public:
  typedef value_type first_argument_type ;
  typedef value_type second_argument_type ;
  typedef bool result_type ;

  bool operator()(const value_type& _Left,
   const value_type& _Right) const
   {
   return (comp(_Left.first, _Right.first));
   }

  value_compare(key_compare _Pred)
   : comp(_Pred)
   {
   }

 protected:
  key_compare comp;
  };

 template<class _Ty1,
  class _Ty2>
  static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)
  {
  return (_Val.first);
  }
 };


template<class _Kty,
 class _Ty,
 class _Pr = less<_Kty>,
 class _Alloc = allocator<pair<const _Kty, _Ty> > >
 class map
  : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
 {
public:
 typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
 typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
 typedef _Kty key_type;
 typedef _Ty mapped_type;
 typedef _Pr key_compare;
 typedef typename _Mybase::value_compare value_compare;
 typedef typename _Mybase::allocator_type allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::reverse_iterator reverse_iterator;
 typedef typename _Mybase::const_reverse_iterator
  const_reverse_iterator;
 typedef typename _Mybase::value_type value_type;

 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Pairib _Pairib;






 map()
  : _Mybase(key_compare(), allocator_type())
  {
  }

 explicit map(const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  }

 map(const _Myt& _Right)
  : _Mybase(_Right,
   _Right._Getal().select_on_container_copy_construction())
  {
  }

 map(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 explicit map(const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  }

 map(const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last,
   const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last,
   const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_First, _Last);
  }


 template<class _Iter>
  map(_Iter _First, _Iter _Last, const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  _Mybase::insert(_First, _Last);
  }


 _Myt& operator=(const _Myt& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 map(_Myt&& _Right)
  : _Mybase(::std:: move(_Right))
  {
  }

 map(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(::std:: move(_Right), _Al)
  {
  }

 _Myt& operator=(_Myt&& _Right)


  {
  _Mybase::operator=(::std:: move(_Right));
  return (*this);
  }

 mapped_type& operator[](key_type&& _Keyval)
  {
  iterator _Where = _Mybase::lower_bound(_Keyval);
  if (_Where == _Mybase::end()
   || _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
   _Where = _Mybase::emplace_hint(_Where,
    piecewise_construct,
    ::std:: forward_as_tuple(::std:: move(_Keyval)),
    tuple<>());

  return (_Where->second);
  }

 void swap(_Myt& _Right)



  {
  _Mybase::swap(_Right);
  }
# 228 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 _Pairib insert(const value_type& _Val)
  {
  return (_Mybase::_Insert_nohint(false, _Val, _Nil()));
  }

 iterator insert(const_iterator _Where, const value_type& _Val)
  {
  return (_Mybase::insert(_Where, _Val));
  }


 _Pairib insert(value_type&& _Val)
  {
  return (_Mybase::_Insert_nohint(false,
   ::std:: forward<value_type>(_Val), _Nil()));
  }

 iterator insert(const_iterator _Where, value_type&& _Val)
  {
  return (_Mybase::_Insert_hint(_Where,
   ::std:: forward<value_type>(_Val), _Nil()));
  }


 template<class _Iter>
  void insert(_Iter _First, _Iter _Last)
  {
  _Mybase::insert(_First, _Last);
  }

 void insert(::std:: initializer_list<value_type> _Ilist)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 template<class _Valty,
  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,
   void> >
  _Pairib insert(_Valty&& _Val)
  {
  typename _Mybase::_Nodeptr
   _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
  return (_Mybase::_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class _Valty,
  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,
   void> >
  iterator insert(const_iterator _Where, _Valty&& _Val)
  {
  return (_Mybase::insert(_Where, ::std:: forward<_Valty>(_Val)));
  }
# 389 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 map(::std:: initializer_list<value_type> _Ilist)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 map(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }


 map(::std:: initializer_list<value_type> _Ilist,
  const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }


 map(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  _Mybase::clear();
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 mapped_type& operator[](const key_type& _Keyval)
  {
  iterator _Where = _Mybase::lower_bound(_Keyval);
  if (_Where == _Mybase::end()
   || _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
   _Where = _Mybase::emplace_hint(_Where,
    piecewise_construct,
    ::std:: forward_as_tuple(_Keyval),
    tuple<>());
  return (_Where->second);
  }

 mapped_type& at(const key_type& _Keyval)
  {
  iterator _Where = _Mybase::lower_bound(_Keyval);
  if (_Where == _Mybase::end()
   || _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
   _Xout_of_range("invalid map<K, T> key");
  return (_Where->second);
  }

 const mapped_type& at(const key_type& _Keyval) const
  {
  const_iterator _Where = _Mybase::lower_bound(_Keyval);
  if (_Where == _Mybase::end()
   || _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
   _Xout_of_range("invalid map<K, T> key");
  return (_Where->second);
  }
# 480 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 };
# 503 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc> inline
 void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
  map<_Kty, _Ty, _Pr, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }
# 536 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
template<class _Kty,
 class _Ty,
 class _Pr = less<_Kty>,
 class _Alloc = allocator<pair<const _Kty, _Ty> > >
 class multimap
  : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
 {
public:
 typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
 typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
 typedef _Kty key_type;
 typedef _Ty mapped_type;
 typedef _Pr key_compare;
 typedef typename _Mybase::value_compare value_compare;
 typedef typename _Mybase::allocator_type allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::reverse_iterator reverse_iterator;
 typedef typename _Mybase::const_reverse_iterator
  const_reverse_iterator;
 typedef typename _Mybase::value_type value_type;

 typedef typename _Mybase::_Alty _Alty;





 multimap()
  : _Mybase(key_compare(), allocator_type())
  {
  }

 explicit multimap(const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  }

 multimap(const _Myt& _Right)
  : _Mybase(_Right,
   _Right._Getal().select_on_container_copy_construction())
  {
  }

 multimap(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 explicit multimap(const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  }

 multimap(const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last,
   const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last,
   const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_First, _Last);
  }


 template<class _Iter>
  multimap(_Iter _First, _Iter _Last, const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  _Mybase::insert(_First, _Last);
  }


 _Myt& operator=(const _Myt& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 multimap(_Myt&& _Right)
  : _Mybase(::std:: move(_Right))
  {
  }

 multimap(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(::std:: move(_Right), _Al)
  {
  }

 _Myt& operator=(_Myt&& _Right)


  {
  _Mybase::operator=(::std:: move(_Right));
  return (*this);
  }

 template<class _Valty,

  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,



   void> >
  iterator insert(_Valty&& _Val)
  {
  return (_Mybase::insert(::std:: forward<_Valty>(_Val)).first);
  }

 template<class _Valty,

   class = enable_if_t<is_constructible<value_type, _Valty&&>::value,



   void> >
  iterator insert(const_iterator _Where, _Valty&& _Val)
  {
  return (_Mybase::insert(_Where, ::std:: forward<_Valty>(_Val)));
  }
# 693 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 template<class... _Valty>
  iterator emplace(_Valty&&... _Val)
  {
  return (_Mybase::emplace(::std:: forward<_Valty>(_Val)...).first);
  }

 void swap(_Myt& _Right)



  {
  _Mybase::swap(_Right);
  }

 multimap(::std:: initializer_list<value_type> _Ilist)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 multimap(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }


 multimap(::std:: initializer_list<value_type> _Ilist,
  const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }


 multimap(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  _Mybase::clear();
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void insert(::std:: initializer_list<value_type> _Ilist)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const value_type& _Val)
  {
  return (_Mybase::insert(_Val).first);
  }

 iterator insert(const_iterator _Where, const value_type& _Val)
  {
  return (_Mybase::insert(_Where, _Val));
  }


 iterator insert(value_type&& _Val)
  {
  return (_Mybase::insert(::std:: forward<value_type>(_Val)).first);
  }

 iterator insert(const_iterator _Where, value_type&& _Val)
  {
  return (_Mybase::insert(_Where, ::std:: forward<value_type>(_Val)));
  }


 template<class _Iter>
  void insert(_Iter _First, _Iter _Last)
  {
  _Mybase::insert(_First, _Last);
  }
# 801 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 };
# 824 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc> inline
 void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
  multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }
# 860 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
}
# 2 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/UserMap.h" 2

namespace psn
{
    template<class UserData>
    class UserMap
    {
        std::map<SceUserServiceUserId, UserData*> s_UsersList;

    public:
        UserData* CreateUser(SceUserServiceUserId userId)
        {
            UserData* userData = new UserData(userId);

            s_UsersList.insert(std::pair<SceUserServiceUserId, UserData*>(userId, userData));

            return userData;
        }

        UserData* FindUser(SceUserServiceUserId userId)
        {
            auto it = s_UsersList.find(userId);

            if (it == s_UsersList.end())
            {
                return __null;
            }

            return it->second;
        }

        void DeleteUser(SceUserServiceUserId userId)
        {
            auto it = s_UsersList.find(userId);

            if (it == s_UsersList.end())
            {
                return;
            }

            delete it->second;

            s_UsersList.erase(userId);
        }

        bool DoesUserExist(SceUserServiceUserId userId)
        {
            auto it = s_UsersList.find(userId);

            if (it == s_UsersList.end())
            {
                return false;
            }

            return true;
        }

        typedef void(*CleanUpCallback)(UserData* userData);

        void Clean(CleanUpCallback callback)
        {
            auto it = s_UsersList.begin();
            while (it != s_UsersList.end())
            {
                callback(it->second);

                delete it->second;

                s_UsersList.erase(it->first);

                it = s_UsersList.begin();
            }
        }
    };

    struct InitialiseData
    {
        SceUserServiceUserId userId;
    };

}
# 25 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SharedCoreIncludes.h" 2

# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/PrxPluginInterface.h" 1



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 5 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/PrxPluginInterface.h" 2

# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/IPluginUnity.h" 1
# 12 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/IPluginUnity.h"
class IPluginUnity
{
public:
    virtual ~IPluginUnity() {}


    virtual int UnityIntVersion() const = 0;


    virtual const char* UnityVersion() const = 0;


    virtual bool IsDevelopmentBuild() const = 0;


    virtual bool IsDebugBuild() const = 0;
};
# 7 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/PrxPluginInterface.h" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/IPluginSceNpParams.h" 1
# 12 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/IPluginSceNpParams.h"
class IPluginSceNpParams
{
public:
    virtual ~IPluginSceNpParams() {}


    virtual const void* NpCommunicationsID() const = 0;


    virtual const void* NpCommunicationsSignature() const = 0;


    virtual const void* NpCommunicationsPassphrase() const = 0;


    virtual const char* NpServiceID() const = 0;


    virtual int NpAgeRating() const = 0;


    virtual bool NpHasTrophyPack() const = 0;


    virtual const void* NpTitleSecret() const = 0;


    virtual int NpPushNotifications() const = 0;
};
# 8 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/PrxPluginInterface.h" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/IPluginSceAppParams.h" 1
# 13 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/IPluginSceAppParams.h"
class IPluginSceAppParams
{
public:
    virtual ~IPluginSceAppParams() {}


    virtual bool IsTrialApp() const = 0;


    virtual const char* ServiceID() const = 0;


    virtual const char* TitleID() const = 0;
};
# 9 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/PrxPluginInterface.h" 2

# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/UnityEventQueue.h" 1
# 56 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/UnityEventQueue.h"
namespace UnityEventQueue
{
# 72 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/UnityEventQueue.h"
    struct EventId
    {
    public:
        EventId(unsigned long long high, unsigned long long low)
            : mGUIDHigh(high)
            , mGUIDLow(low)
        {}

        EventId(const EventId & other)
        {
            mGUIDHigh = other.mGUIDHigh;
            mGUIDLow = other.mGUIDLow;
        }

        EventId & operator=(const EventId & other)
        {
            mGUIDHigh = other.mGUIDHigh;
            mGUIDLow = other.mGUIDLow;
            return *this;
        }

        bool Equals(const EventId & other) const { return mGUIDHigh == other.mGUIDHigh && mGUIDLow == other.mGUIDLow; }
        bool LessThan(const EventId & other) const { return mGUIDHigh < other.mGUIDHigh || (mGUIDHigh == other.mGUIDHigh && mGUIDLow < other.mGUIDLow); }

        unsigned long long mGUIDHigh;
        unsigned long long mGUIDLow;
    };
    inline bool operator==(const EventId & left, const EventId & right) { return left.Equals(right); }
    inline bool operator!=(const EventId & left, const EventId & right) { return !left.Equals(right); }
    inline bool operator<(const EventId & left, const EventId & right) { return left.LessThan(right); }
    inline bool operator>(const EventId & left, const EventId & right) { return right.LessThan(left); }
    inline bool operator>=(const EventId & left, const EventId & right) { return !operator<(left, right); }
    inline bool operator<=(const EventId & left, const EventId & right) { return !operator>(left, right); }





    template<typename T> const EventId GetEventId() {}
    class EventQueue;
    class EventHandler;



    template<typename T> EventHandler * GetEventDestructor() { return (EventHandler*)__null; }



    template<typename T> void GenericDestructorMethodForType(const T & ) {}







    class EventHandler
    {
    public:
        EventHandler() : m_Next(0) {}
        virtual ~EventHandler() {}

        virtual void HandleEvent(EventId & id, void * data) = 0;

        virtual EventId HandlerEventId() = 0;

        virtual EventHandler * GetMyEventDestructor() = 0;

        EventHandler * GetNext() { return m_Next; }
    private:


        friend class EventHandlerList;
        EventHandler * m_Next;
    };
# 156 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/UnityEventQueue.h"
    template<typename EVENTTYPE, typename OBJECTTYPE>
    class ClassBasedEventHandler : public EventHandler
    {
    public:
        ClassBasedEventHandler(OBJECTTYPE * handler = __null) : m_Handler(handler) {}


        virtual void HandleEvent(EventId & id, void * data)
        { (void)id; m_Handler->HandleEvent(*static_cast<EVENTTYPE*>(data)); }


        virtual EventId HandlerEventId()
        { return GetEventId<EVENTTYPE>(); }


        virtual EventHandler * GetMyEventDestructor()
        { return GetEventDestructor<EVENTTYPE>(); }

        ClassBasedEventHandler<EVENTTYPE, OBJECTTYPE> *
        SetObject(OBJECTTYPE * handler)
        { m_Handler = handler; return this; }

        OBJECTTYPE * GetHandler()
        { return m_Handler; }
    protected:
        OBJECTTYPE * m_Handler;
    };







    template<typename EVENTTYPE>
    class StaticFunctionEventHandler : public EventHandler
    {
    public:
        typedef void (*HandlerFunction)(const EVENTTYPE & payload);

        StaticFunctionEventHandler(HandlerFunction handlerCallback) : m_Handler(handlerCallback) {}

        virtual void HandleEvent(EventId & id, void * data)
        { (void)id; m_Handler(*static_cast<EVENTTYPE*>(data)); }


        virtual EventId HandlerEventId()
        { return GetEventId<EVENTTYPE>(); }


        virtual EventHandler * GetMyEventDestructor()
        { return GetEventDestructor<EVENTTYPE>(); }

    protected:
        HandlerFunction m_Handler;
    };





    struct AddEventHandler
    {
        AddEventHandler(EventHandler * handler) : m_Handler(handler) {}
        EventHandler * m_Handler;
    };

    struct RemoveEventHandler
    {
        RemoveEventHandler(EventHandler * handler) : m_Handler(handler) {}
        EventHandler * m_Handler;
    };





    struct DebugLogEvent
    {
        char m_Buffer[64];
    };
# 252 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/UnityEventQueue.h"
    class IEventQueue
    {
    public:


        virtual ~IEventQueue() {}







        template<typename T>
        void SendEvent(T & payload)
        {

            ((sizeof(T) < (2048+sizeof(EventId) - sizeof(EventId))) ? (void)0 : :: _Assert("C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/UnityEventQueue.h" "(" "269" ") : Assertion Failed (" "sizeof(T) < (kMaxEventQueueEventSize - sizeof(EventId))" ")", __func__));





            SendEventImpl(UnityEventQueue::GetEventId<T>(), (unsigned char *)(&payload), sizeof(T));
        }
# 293 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/UnityEventQueue.h"
        template<typename T>
        void RegisterCleanup(T & payload)
        {
            EventHandler * eh = UnityEventQueue::GetEventDestructor<T>();
            if (eh != __null)
                SetCleanupImpl(eh);
        }





        virtual void AddHandler(EventHandler * handler) = 0;
        virtual void RemoveHandler(EventHandler * handler) = 0;
    protected:
        virtual void SendEventImpl(EventId id, unsigned char * data, int size) = 0;





        virtual void SetCleanupImpl(EventHandler * handler) = 0;
    };
}

namespace UnityEventQueue { template<> inline const EventId GetEventId< AddEventHandler > () { return EventId(0x19D736400584B24BULL,0x98B9EFBE26D3F3C9ULL) ; } }
namespace UnityEventQueue { template<> inline const EventId GetEventId< RemoveEventHandler > () { return EventId(0x8D4A317C4F577F4AULL,0x851D6E457566A905ULL) ; } }
namespace UnityEventQueue { template<> inline const EventId GetEventId< DebugLogEvent > () { return EventId(0x8F0D898251731644ULL,0x904C3F1D04BAB17CULL) ; } }
# 11 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/PrxPluginInterface.h" 2
# 24 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/PrxPluginInterface.h"
typedef int(*fnPrxPluginQueryInterface)(int, void**);






struct PrxPluginArgsV2
{
    static bool Validate(PrxPluginArgsV2* arg, size_t argSize)
    {
        if ((argSize < sizeof(PrxPluginArgsV2)) || (arg->m_Size != sizeof(PrxPluginArgsV2)) || (arg->m_Version != s_Version))
        {
            return false;
        }

        return true;
    }

    PrxPluginArgsV2() : m_Size(0) , m_Version(0), m_QueryInterface(__null) {}
    static const uint32_t s_Version = 0x0200;
    static const size_t s_LegacySize = 52;
    uint32_t m_Size;
    uint32_t m_Version;
    fnPrxPluginQueryInterface m_QueryInterface;
};
# 62 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/../PlayerInterface/PrxPluginInterface.h"
class PrxPluginInterface
{
public:

    fnPrxPluginQueryInterface m_queryInterface;

    IPluginUnity* m_IUnity;
    IPluginSceAppParams* m_ISceAppParams;
    IPluginSceNpParams* m_ISceNpParams;

    UnityEventQueue::IEventQueue* m_IEventQueue;


    PrxPluginInterface()
    {
        m_queryInterface = __null;
        m_IUnity = __null;
        m_ISceAppParams = __null;
        m_ISceNpParams = __null;
        m_IEventQueue = __null;
    }


    void SetupRuntimeInterfaces()
    {
        if (m_queryInterface)
        {

            m_IEventQueue = GetRuntimeInterface<UnityEventQueue::IEventQueue>(0x00000000, m_queryInterface);

            m_IUnity = GetRuntimeInterface<IPluginUnity>(0x00000001, m_queryInterface);
            m_ISceAppParams = GetRuntimeInterface<IPluginSceAppParams>(0x00000002, m_queryInterface);
            m_ISceNpParams = GetRuntimeInterface<IPluginSceNpParams>(0x00000003, m_queryInterface);
        }
    }

    bool InitialisePrxPluginArgs(unsigned int sz, const void* arg, const char* pluginName)
    {
        if (PrxPluginArgsV2::Validate((PrxPluginArgsV2*)arg, sz))
        {
            m_queryInterface = ((PrxPluginArgsV2*)arg)->m_QueryInterface;
        }
        else
        {
            printf("\nERROR...\n");
            printf(" %s is an old version that cannot be used by the current player runtime.\n", pluginName);
            printf(" Please update the %s native module and any associated managed assemblies to the latest versions\n", pluginName);
            printf("  Plugin args version, found %04x, expected %04x\n", ((PrxPluginArgsV2*)arg)->m_Version, ((PrxPluginArgsV2*)arg)->s_Version);

            return false;
        }

        return true;
    }

    template<typename T> T* GetRuntimeInterface(int interfaceID, fnPrxPluginQueryInterface queryInterface)
    {
        if (queryInterface)
        {
            void* interfacePtr = __null;
            int queryStatus = queryInterface(interfaceID, &interfacePtr);
            if (queryStatus == 0x00000000)
            {
                return (T*)interfacePtr;
            }
        }
        return __null;
    }
};

class PRXHelphers
{
public:
    static int LoadPRX(const char * module_file_name, SceKernelModule& handle)
    {
        int arg = 1;
        int res;
        handle = sceKernelLoadStartModule(module_file_name, 1, &arg, 0, __null, &res);
        if (handle < 0)
            return -1;
        return res;
    }

    static int UnloadPRX(SceKernelModule handle)
    {
        int args[2] = { 10, 20 };
        int res;
        int result = sceKernelStopUnloadModule(handle, 2, args, 0, __null,
            &res);
        if (result < 0)
            return -1;
        return res;
    }
};
# 27 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SharedCoreIncludes.h" 2


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 1 3
# 30 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude/SharedCoreIncludes.h" 2
# 5 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\PSNCommon\\SharedInclude\\HandleMsg.h" 2


namespace UnityEventQueue
{
    class IEventQueue;
}

namespace psn
{
    class MsgHandler
    {
    public:

        typedef void(*MethodCallbackSimple)(APIResult* result);
        typedef void(*MethodCallbackWithData)(UInt8* sourceData, int sourceSize, APIResult* result);
        typedef void(*MethodCallbackFull)(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        struct MsgHeader
        {
            UInt32 version;
            UInt32 methodId;
        };
        static void ProcessMsg(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static bool GetSimpleMethod(UInt32 methodId, MethodCallbackSimple* foundMethod);
        static bool GetWithDataMethod(UInt32 methodId, MethodCallbackWithData* foundMethod);
        static bool GetFullMethod(UInt32 methodId, MethodCallbackFull* foundMethod);

        static void AddMethod(int methodId, MethodCallbackSimple methodCallback);
        static void AddMethod(int methodId, MethodCallbackWithData methodCallback);
        static void AddMethod(int methodId, MethodCallbackFull methodCallback);

        enum UserState
        {
            Added,
            Removed,
        };

        typedef void(*UserStateCallback)(SceUserServiceUserId userId, UserState state, APIResult* result);


        static void NotifyAddUser(SceUserServiceUserId userId, APIResult* result);
        static void NotifyRemoveUser(SceUserServiceUserId userId, APIResult* result);
        static void RegisterUserCallback(UserStateCallback callback);

        typedef void(*SystemEventCallback)(SceSystemServiceEvent& sevent);

        static void NotifySystemEvent(SceSystemServiceEvent& sevent);

        static void RegisterSystemEventCallback(SystemEventCallback callback);
        static bool IsSystemEventQueueInitialized();

        static void InitialiseSystemEventManager(UnityEventQueue::IEventQueue* eventQueue);
        static void ShutdownSystemEventManager();
    };







}
# 2 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\HandleMsg.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source/../SystemEvents/PS5SystemEventManager.h" 1


# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source/../SystemEvents/PS5SystemEvents.h" 1







struct PS5OnResume { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnResume > () { return EventId(0xD725C2DB79674D8CULL,0xA52A1009670D0880ULL) ; } }


struct PS5OnGameLiveStreamingStatusUpdate { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnGameLiveStreamingStatusUpdate > () { return EventId(0x11C8947A2EF44E45ULL,0xA1F77F0AC927272EULL) ; } }


struct PS5OnSessionInvitation { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnSessionInvitation > () { return EventId(0xCF791F68B6884AEFULL,0x8198EC6D98D70F8AULL) ; } }


struct PS5OnEntitlementUpdate { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnEntitlementUpdate > () { return EventId(0xDE76F015C0DE4BE8ULL,0x9046B1153C877E39ULL) ; } }


struct PS5OnGameCustomData { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnGameCustomData > () { return EventId(0x7D073AAAF3004C2BULL,0x810A278660A015D6ULL) ; } }


struct PS5OnDisplaySafeAreaUpdate { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnDisplaySafeAreaUpdate > () { return EventId(0xD69939D64B2544ABULL,0xB5E6A5B6BC273194ULL) ; } }


struct PS5OnUrlOpen { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnUrlOpen > () { return EventId(0xC89E302816C644DBULL,0x832F32CD9410F333ULL) ; } }


struct PS5OnLaunchApp { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnLaunchApp > () { return EventId(0xA1458D5B05264EA2ULL,0xA70506FE4FCD11F3ULL) ; } }


struct PS5OnLaunchLink { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnLaunchLink > () { return EventId(0x477AFB5C1CA045D6ULL,0x95E9C61B8365A66AULL) ; } }


struct PS5OnAddcontentInstall { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnAddcontentInstall > () { return EventId(0x01E30CD6D6764564ULL,0x9F2D243AC685D381ULL) ; } }


struct PS5OnResetVrPosition { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnResetVrPosition > () { return EventId(0x2BD3588AC2A34A03ULL,0x8401C671EAB0964BULL) ; } }


struct PS5OnJoinEvent { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnJoinEvent > () { return EventId(0x8ABE8C89A5AD4C65ULL,0xA818D17C31FD215EULL) ; } }

struct PS5OnPlaygoLocusUpdate { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnPlaygoLocusUpdate > () { return EventId(0x21A78E6026A443FBULL,0xB4E9B96B3B18FDA0ULL) ; } }

struct PS5OnOpenShareMenu { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnOpenShareMenu > () { return EventId(0xB7AD0B23F68B4361ULL,0x802C36342FF448A7ULL) ; } }

struct PS5OnPlayTogetherHost { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnPlayTogetherHost > () { return EventId(0xA136D11F66DB9F7FULL,0x83EC5A5608DDDB55ULL) ; } }

struct PS5OnSystemEvent { SceSystemServiceEvent params; };
namespace UnityEventQueue { template<> inline const EventId GetEventId< PS5OnSystemEvent > () { return EventId(0x926962B0FC4940C5ULL,0x81DCC522B0823744ULL) ; } }
# 4 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source/../SystemEvents/PS5SystemEventManager.h" 2


namespace UnityPlugin
{
    class PS5SystemEventManager
    {
    public:
        PS5SystemEventManager() : m_EventQueue(__null) {}
        ~PS5SystemEventManager() {}

        void Initialize(UnityEventQueue::IEventQueue* eventQueue);
        void Shutdown();

        void HandleEvent(PS5OnResume& data);
        void HandleEvent(PS5OnGameLiveStreamingStatusUpdate& data);
        void HandleEvent(PS5OnSessionInvitation& data);
        void HandleEvent(PS5OnEntitlementUpdate& data);
        void HandleEvent(PS5OnGameCustomData& data);
        void HandleEvent(PS5OnDisplaySafeAreaUpdate& data);
        void HandleEvent(PS5OnUrlOpen& data);
        void HandleEvent(PS5OnLaunchApp& data);
        void HandleEvent(PS5OnLaunchLink& data);
        void HandleEvent(PS5OnAddcontentInstall& data);
        void HandleEvent(PS5OnResetVrPosition& data);
        void HandleEvent(PS5OnJoinEvent& data);
        void HandleEvent(PS5OnPlaygoLocusUpdate& data);
        void HandleEvent(PS5OnOpenShareMenu& data);
        void HandleEvent(PS5OnPlayTogetherHost& data);
        void HandleEvent(PS5OnSystemEvent& data);

        bool IsEventQueueValid() { return (m_EventQueue!=__null); }
    private:
        UnityEventQueue::IEventQueue* m_EventQueue;
    };
}
# 3 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\HandleMsg.cpp" 2

namespace psn
{
    static std::map<int, MsgHandler::MethodCallbackSimple> s_MethodSimpleList;
    static std::map<int, MsgHandler::MethodCallbackWithData> s_MethodWithDataList;
    static std::map<int, MsgHandler::MethodCallbackFull> s_MethodFullList;

    static std::list<MsgHandler::UserStateCallback> s_UserStateCallbackList;
    static std::list<MsgHandler::SystemEventCallback> s_SystemEventCallbackList;

    static UnityPlugin::PS5SystemEventManager* s_SystemEventManager = __null;


    void MsgHandler::ProcessMsg(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        MsgHeader* header = (MsgHeader*)(sourceData);
        sourceData += sizeof(MsgHeader);

        if (header->version != 1)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Unexpected message header version", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\HandleMsg.cpp", 25));
            return;
        }


        MethodCallbackSimple methodSimple;
        MethodCallbackWithData methodWithData;
        MethodCallbackFull methodFull;

        if (GetSimpleMethod(header->methodId, &methodSimple) == true)
        {

            methodSimple(result);
        }
        else if (GetWithDataMethod(header->methodId, &methodWithData) == true)
        {

            methodWithData(sourceData, sourceSize, result);
        }
        else if (GetFullMethod(header->methodId, &methodFull) == true)
        {

            methodFull(sourceData, sourceSize, resultsData, resultsMaxSize, resultsSize, result);
        }
        else
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find registered method from id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\HandleMsg.cpp", 51));
            return;
        }
    }

    bool MsgHandler::GetSimpleMethod(UInt32 methodId, MethodCallbackSimple* foundMethod)
    {
        auto it = s_MethodSimpleList.find(methodId);

        if (it == s_MethodSimpleList.end())
        {
            return false;
        }

        if (it->second == __null)
        {
            return false;
        }

        *foundMethod = it->second;

        return true;
    }

    bool MsgHandler::GetWithDataMethod(UInt32 methodId, MethodCallbackWithData* foundMethod)
    {
        auto it = s_MethodWithDataList.find(methodId);

        if (it == s_MethodWithDataList.end())
        {
            return false;
        }

        *foundMethod = it->second;

        return true;
    }

    bool MsgHandler::GetFullMethod(UInt32 methodId, MethodCallbackFull* foundMethod)
    {
        auto it = s_MethodFullList.find(methodId);

        if (it == s_MethodFullList.end())
        {
            return false;
        }

        *foundMethod = it->second;

        return true;
    }

    void MsgHandler::AddMethod(int methodId, MsgHandler::MethodCallbackSimple methodCallback)
    {
        s_MethodSimpleList.insert(std::pair<int, MethodCallbackSimple>(methodId, methodCallback));
    }

    void MsgHandler::AddMethod(int methodId, MsgHandler::MethodCallbackWithData methodCallback)
    {
        s_MethodWithDataList.insert(std::pair<int, MethodCallbackWithData>(methodId, methodCallback));
    }

    void MsgHandler::AddMethod(int methodId, MsgHandler::MethodCallbackFull methodCallback)
    {
        s_MethodFullList.insert(std::pair<int, MethodCallbackFull>(methodId, methodCallback));
    }

    void MsgHandler::NotifyAddUser(SceUserServiceUserId userId, APIResult* result)
    {
        for (std::list<UserStateCallback>::iterator it = s_UserStateCallbackList.begin(); it != s_UserStateCallbackList.end(); ++it)
        {
            (*it)(userId, UserState::Added, result);
        }
    }

    void MsgHandler::NotifyRemoveUser(SceUserServiceUserId userId, APIResult* result)
    {
        for (std::list<UserStateCallback>::iterator it = s_UserStateCallbackList.begin(); it != s_UserStateCallbackList.end(); ++it)
        {
            (*it)(userId, UserState::Removed, result);
        }
    }

    void MsgHandler::RegisterUserCallback(UserStateCallback callback)
    {
        s_UserStateCallbackList.push_back(callback);
    }

    void MsgHandler::NotifySystemEvent(SceSystemServiceEvent& sevent)
    {
        for (std::list<SystemEventCallback>::iterator it = s_SystemEventCallbackList.begin(); it != s_SystemEventCallbackList.end(); ++it)
        {
            (*it)(sevent);
        }
    }

    void MsgHandler::InitialiseSystemEventManager(UnityEventQueue::IEventQueue* eventQueue)
    {

        if (s_SystemEventManager == __null)
        {
            s_SystemEventManager = new UnityPlugin::PS5SystemEventManager();
            s_SystemEventManager->Initialize(eventQueue);
        }

    }

    void MsgHandler::ShutdownSystemEventManager()
    {

        if (s_SystemEventManager != __null)
        {
            s_SystemEventManager->Shutdown();
            delete s_SystemEventManager;
            s_SystemEventManager = __null;
        }

    }

    void MsgHandler::RegisterSystemEventCallback(SystemEventCallback callback)
    {
        if (s_SystemEventManager != __null)
        {
            s_SystemEventCallbackList.push_back(callback);
        }
    }

    bool MsgHandler::IsSystemEventQueueInitialized()
    {
        if (s_SystemEventManager==__null)
            return false;
        return s_SystemEventManager->IsEventQueueValid();
    }
}
# 5 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\Source\\Module.cpp" 1
# 6 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\SystemEvents\\PS5SystemEventManager.cpp" 1
# 10 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCommon\\SystemEvents\\PS5SystemEventManager.cpp"
namespace UnityPlugin
{


    UnityEventQueue::ClassBasedEventHandler<PS5OnResume, PS5SystemEventManager> g_OnResumeAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnGameLiveStreamingStatusUpdate, PS5SystemEventManager> g_OnGameLiveStreamingStatusUpdate;
    UnityEventQueue::ClassBasedEventHandler<PS5OnSessionInvitation, PS5SystemEventManager> g_OnSessionInvitationAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnEntitlementUpdate, PS5SystemEventManager> g_OnEntitlementUpdateAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnGameCustomData, PS5SystemEventManager> g_OnGameCustomDataAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnDisplaySafeAreaUpdate, PS5SystemEventManager> g_OnDisplaySafeAreaUpdateAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnUrlOpen, PS5SystemEventManager> g_OnUrlOpenAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnLaunchApp, PS5SystemEventManager> g_OnLaunchAppAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnLaunchLink, PS5SystemEventManager> g_OnLaunchLinkAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnAddcontentInstall, PS5SystemEventManager> g_OnAddcontentInstallAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnResetVrPosition, PS5SystemEventManager> g_OnResetVrPositionAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnJoinEvent, PS5SystemEventManager> g_OnJoinEventAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnPlaygoLocusUpdate, PS5SystemEventManager> g_OnPlaygoLocusUpdateAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnOpenShareMenu, PS5SystemEventManager> g_OnOpenShareMenuAdapter;
    UnityEventQueue::ClassBasedEventHandler<PS5OnPlayTogetherHost, PS5SystemEventManager> g_OnPlayTogetherHostAdapter;

    UnityEventQueue::ClassBasedEventHandler<PS5OnSystemEvent, PS5SystemEventManager> g_OnSystemEventAdapter;

    void PS5SystemEventManager::Initialize(UnityEventQueue::IEventQueue* eventQueue)
    {
        m_EventQueue = eventQueue;

        if (m_EventQueue)
        {
            m_EventQueue->AddHandler(g_OnResumeAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnGameLiveStreamingStatusUpdate.SetObject(this));
            m_EventQueue->AddHandler(g_OnSessionInvitationAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnEntitlementUpdateAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnGameCustomDataAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnDisplaySafeAreaUpdateAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnUrlOpenAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnLaunchAppAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnLaunchLinkAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnAddcontentInstallAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnResetVrPositionAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnJoinEventAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnPlaygoLocusUpdateAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnOpenShareMenuAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnPlayTogetherHostAdapter.SetObject(this));
            m_EventQueue->AddHandler(g_OnSystemEventAdapter.SetObject(this));
        }
    }

    void PS5SystemEventManager::Shutdown()
    {
        if (m_EventQueue)
        {
            m_EventQueue->RemoveHandler(&g_OnResumeAdapter);
            m_EventQueue->RemoveHandler(&g_OnGameLiveStreamingStatusUpdate);
            m_EventQueue->RemoveHandler(&g_OnSessionInvitationAdapter);
            m_EventQueue->RemoveHandler(&g_OnEntitlementUpdateAdapter);
            m_EventQueue->RemoveHandler(&g_OnGameCustomDataAdapter);
            m_EventQueue->RemoveHandler(&g_OnDisplaySafeAreaUpdateAdapter);
            m_EventQueue->RemoveHandler(&g_OnUrlOpenAdapter);
            m_EventQueue->RemoveHandler(&g_OnLaunchAppAdapter);
            m_EventQueue->RemoveHandler(&g_OnLaunchLinkAdapter);
            m_EventQueue->RemoveHandler(&g_OnAddcontentInstallAdapter);
            m_EventQueue->RemoveHandler(&g_OnResetVrPositionAdapter);
            m_EventQueue->RemoveHandler(&g_OnJoinEventAdapter);
            m_EventQueue->RemoveHandler(&g_OnPlaygoLocusUpdateAdapter);
            m_EventQueue->RemoveHandler(&g_OnOpenShareMenuAdapter);
            m_EventQueue->RemoveHandler(&g_OnPlayTogetherHostAdapter);
            m_EventQueue->RemoveHandler(&g_OnSystemEventAdapter);
        }
    }


    void PS5SystemEventManager::HandleEvent(PS5OnResume& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnGameLiveStreamingStatusUpdate& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnSessionInvitation& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnEntitlementUpdate& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnGameCustomData& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnDisplaySafeAreaUpdate& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnUrlOpen& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnLaunchApp& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnLaunchLink& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnAddcontentInstall& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnResetVrPosition& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnJoinEvent& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnPlaygoLocusUpdate& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnOpenShareMenu& data)
    {

    }

    void PS5SystemEventManager::HandleEvent(PS5OnPlayTogetherHost& data)
    {
    }

    void PS5SystemEventManager::HandleEvent(PS5OnSystemEvent& data)
    {
        psn::MsgHandler::NotifySystemEvent(data.params);
    }

    extern "C" __declspec (dllexport) void PrxInjectSystemServiceEvent (int type, void *paramdata)
    {
        SceSystemServiceEvent serviceEvent;
        serviceEvent.eventType = (SceSystemServiceEventType)type;
        memcpy(&serviceEvent.data.param, paramdata, 8192);
        psn::MsgHandler::NotifySystemEvent(serviceEvent);
    }

    extern "C" __declspec (dllexport) bool PrxIsSystemEventQueueInitialized ()
    {
        return psn::MsgHandler::IsSystemEventQueueInitialized();
    }



}
# 7 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp" 1
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Authentication.h" 1




namespace psn
{
    class Authentication
    {
    public:

        enum Methods
        {
            GetAuthorizationCode = 0x0900001u,
            GetIdToken = 0x0900002u,
        };

        static void RegisterMethods();
        static void GetAuthorizationCodeImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetIdTokenImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
    };
}
# 2 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp" 2




#pragma comment(lib,"libSceNpAuth_stub_weak.a")

namespace psn
{
    void Authentication::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::GetAuthorizationCode, Authentication::GetAuthorizationCodeImpl);
        MsgHandler::AddMethod(Methods::GetIdToken, Authentication::GetIdTokenImpl);
    }

    void Authentication::GetAuthorizationCodeImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        SceNpAuthCreateAsyncRequestParameter asyncParam;
        SceNpAuthGetAuthorizationCodeParameterV3 authParam;

        SceNpClientId clientId;

        SceNpAuthorizationCode authCode;
        int issuerId = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        char* clientIdStr = reader.ReadStringPtr();
        char* scopeStr = reader.ReadStringPtr();

        memset(&asyncParam, 0, sizeof(asyncParam));
        asyncParam.size = sizeof(asyncParam);

        int ret = sceNpAuthCreateAsyncRequest(&asyncParam);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 40));
            return;
        }

        int requestId = ret;

        memset(&clientId, 0, sizeof(clientId));
        strncpy(clientId.id, clientIdStr, (128));

        memset(&authParam, 0, sizeof(authParam));
        authParam.size = sizeof(authParam);
        authParam.userId = userId;
        authParam.clientId = &clientId;
        authParam.scope = scopeStr;

        ret = sceNpAuthGetAuthorizationCodeV3(requestId, &authParam, &authCode, &issuerId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 58));
            return;
        }

        int asyncResult = 0;

        ret = sceNpAuthWaitAsync(requestId, &asyncResult);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 67));
            return;
        }

        if (asyncResult < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, asyncResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 73));
            return;
        }

        if (0 < requestId)
        {
            ret = sceNpAuthDeleteRequest(requestId);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, asyncResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 82));
                return;
            }
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(issuerId);
        writer.WriteString(authCode.code);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Authentication::GetIdTokenImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        SceNpAuthCreateAsyncRequestParameter asyncParam;
        SceNpAuthGetIdTokenParameterV3 authParam;
        SceNpClientId clientId;
        SceNpClientSecret clientSecret;
        SceNpIdToken idToken;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        char* clientIdStr = reader.ReadStringPtr();
        char* clientSecretStr = reader.ReadStringPtr();
        char* scopeStr = reader.ReadStringPtr();

        memset(&asyncParam, 0, sizeof(asyncParam));
        asyncParam.size = sizeof(asyncParam);

        int ret = sceNpAuthCreateAsyncRequest(&asyncParam);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 121));
            return;
        }

        int requestId = ret;

        memset(&clientId, 0, sizeof(clientId));
        strncpy(clientId.id, clientIdStr, (128));

        memset(&clientSecret, 0, sizeof(clientSecret));
        strncpy(clientSecret.secret, clientSecretStr, (256));

        memset(&authParam, 0, sizeof(authParam));
        authParam.size = sizeof(authParam);
        authParam.userId = userId;
        authParam.clientId = &clientId;
        authParam.clientSecret = &clientSecret;
        authParam.scope = scopeStr;

        ret = sceNpAuthGetIdTokenV3(requestId, &authParam, &idToken);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 143));
            return;
        }

        int asyncResult = 0;

        ret = sceNpAuthWaitAsync(requestId, &asyncResult);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 152));
            return;
        }

        if (asyncResult < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, asyncResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 158));
            return;
        }

        if (0 < requestId)
        {
            ret = sceNpAuthDeleteRequest(requestId);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, asyncResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Authentication.cpp", 167));
                return;
            }
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteString(idToken.token);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 8 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Bandwidth.cpp" 1
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Bandwidth.h" 1




namespace psn
{
    class Bandwidth
    {
    public:

        enum Methods
        {
            StartMeasurement = 0x1700001u,
            PollMeasurement = 0x1700002u,
            AbortMeasurement = 0x1700003u,
        };

        static void RegisterMethods();
        static void StartMeasurementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void PollMeasurementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void AbortMeasurementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static int GetStatus(int ctxId);
    };
}
# 2 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Bandwidth.cpp" 2


#pragma comment(lib,"libSceNpUtility_stub_weak.a")

namespace psn
{
    void Bandwidth::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::StartMeasurement, Bandwidth::StartMeasurementImpl);
        MsgHandler::AddMethod(Methods::PollMeasurement, Bandwidth::PollMeasurementImpl);
        MsgHandler::AddMethod(Methods::AbortMeasurement, Bandwidth::AbortMeasurementImpl);
    }



    void Bandwidth::StartMeasurementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 mode = reader.ReadInt32();
        Int32 timeoutMs = reader.ReadInt32();
        UInt64 cpuAffinityMask = reader.ReadUInt64();

        SceNpBandwidthTestInitParam param;
        memset(&param, 0x00, sizeof(param));
        param.size = sizeof(param);

        param.threadPriority = 700;

        param.cpuAffinityMask = cpuAffinityMask;

        printf("Bandwidth mask = %lx\n", cpuAffinityMask);







        int ret = -1;

        if (mode == 1)
        {
            ret = sceNpBandwidthTestInitStartUpload(&param, timeoutMs * 1000);
        }
        else if (mode == 2)
        {
            ret = sceNpBandwidthTestInitStartDownload(&param, timeoutMs * 1000);
        }
        else
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Unknown bandwidth mode", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Bandwidth.cpp", 55));
            return;
        }

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Bandwidth.cpp", 61));
            return;
        }

        int status = GetStatus(ret);

        if (status < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, status, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Bandwidth.cpp", 69));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(ret);
        writer.WriteInt32(status);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int Bandwidth::GetStatus(int ctxId)
    {
        int status;
        int ret = sceNpBandwidthTestGetStatus(ctxId, &status);
        if (ret < 0)
        {
            return ret;
        }
        return status;
    }

    void Bandwidth::PollMeasurementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 ctxId = reader.ReadInt32();

        int status = GetStatus(ctxId);

        if (status < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, status, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Bandwidth.cpp", 106));
            return;
        }

        SceNpBandwidthTestResult testResult;

        if (status == 2)
        {
            testResult.uploadBps = 0.0;
            testResult.downloadBps = 0.0;
            testResult.result = -1;

            int ret = sceNpBandwidthTestShutdown(ctxId, &testResult);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Bandwidth.cpp", 122));
                return;
            }
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(status);

        if (status == 2)
        {
            writer.WriteDouble(testResult.uploadBps);
            writer.WriteDouble(testResult.downloadBps);
            writer.WriteInt32(testResult.result);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Bandwidth::AbortMeasurementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 9 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp" 1
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Commerce.h" 1


# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApiNotifications.h" 1





# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApi.h" 1





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_xstd2.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\typeinfo" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\typeinfo" 3
namespace std {

class bad_cast
 : public ::std:: exception
 {
public:
 bad_cast() noexcept
  {}

 virtual ~bad_cast() noexcept;





 virtual const char *what() const noexcept
  {
  return ("std::bad_cast");
  }






protected:
 virtual void _Doraise() const;

 };


class bad_typeid
 : public ::std:: exception
 {
public:
 bad_typeid() noexcept
  {}

 virtual ~bad_typeid() noexcept;





 virtual const char *what() const noexcept
  {
  return ("std::bad_typeid");
  }






protected:
 virtual void _Doraise() const;

 };
}




namespace __cxxabiv1
 {
 class __class_type_info;
 }


namespace std {





class type_info
 {
public:
 size_t hash_code() const noexcept
  {
  return (::std:: _Hash_seq((const unsigned char *)name(),
   :: strlen(name())));
  }

 virtual ~type_info() noexcept;
# 143 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\typeinfo" 3
 bool before(const type_info& _Right) const noexcept
  {
  return (strcmp(_Myname, _Right._Myname) < 0);
  }

 bool operator==(const type_info& _Right) const noexcept
  {
  return (_Myname == _Right._Myname
   || strcmp(_Myname, _Right._Myname) == 0);
  }


 bool operator!=(const type_info& _Right) const noexcept
  {
  return (!(*this == _Right));
  }

 const char *name() const
  {
  return (_Myname);
  }
# 173 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\typeinfo" 3
protected:
 explicit type_info(const char *_Name)
  : _Myname(_Name)
  {}
 const char *_Myname;


public:
 type_info(const type_info&) = delete;
 type_info& operator=(const type_info&) = delete;
 };
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_typeid.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 2 3

namespace std {
template<class _Ty>
 struct default_delete;

template<class _Ty,
 class _Dx = default_delete<_Ty> >
 class unique_ptr;


class bad_weak_ptr
 : public ::std:: exception
 {
public:
 explicit bad_weak_ptr(const char * = 0) noexcept
  {
  }


 virtual ~bad_weak_ptr() noexcept;


 virtual const char *what() const noexcept
  {
  return ("bad_weak_ptr");
  }
 };

[[noreturn]] void _Throw_bad_weak_ptr();


class _Ref_count_base
 {
private:
 virtual void _Destroy() noexcept = 0;
 virtual void _Delete_this() noexcept = 0;


private:
 _Atomic_counter_t _Uses;
 _Atomic_counter_t _Weaks;

protected:
 _Ref_count_base()
  {
  _Init_atomic_counter(_Uses, 1);
  _Init_atomic_counter(_Weaks, 1);
  }

public:
 virtual ~_Ref_count_base() noexcept
  {
  }

 bool _Incref_nz()
  {
  for (; ; )
   {
   _Atomic_integral_t _Count =
    _Load_atomic_counter_explicit(_Uses, memory_order_relaxed);

   if (_Count == 0)
    return (false);
   if (_Compare_increment_atomic_counter_explicit(
    _Uses, _Count, memory_order_relaxed))
    return (true);
   }
  }
# 148 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 3
 void _Incref()
  {
  _Inc_atomic_counter_explicit(_Uses, memory_order_relaxed);
  }

 void _Incwref()
  {
  _Inc_atomic_counter_explicit(_Weaks, memory_order_relaxed);
  }

 void _Decref()
  {
  if (_Dec_atomic_counter_explicit(_Uses, memory_order_acq_rel) == 0)
   {
   _Destroy();
   _Decwref();
   }
  }

 void _Decwref()
  {
  if (_Dec_atomic_counter_explicit(_Weaks, memory_order_acq_rel) == 0)
   _Delete_this();
  }

 long _Use_count() const noexcept
  {
  return (_Get_atomic_count(_Uses));
  }

 bool _Expired() const noexcept
  {
  return (_Use_count() == 0);
  }

 virtual void *_Get_deleter(const std:: type_info&) const noexcept
  {
  return (0);
  }
 };


template<class _Ty>
 class _Ref_count
 : public _Ref_count_base
 {
public:
 _Ref_count(_Ty *_Px)
  : _Ref_count_base(), _Ptr(_Px)
  {
  }

private:
 virtual void _Destroy() noexcept
  {
  delete _Ptr;
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 _Ty * _Ptr;
 };


template<class _Ty,
 class _Dx>
 class _Ref_count_del
 : public _Ref_count_base
 {
public:
 _Ref_count_del(_Ty *_Px, _Dx _Dt)
  : _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
  {
  }

 virtual void *_Get_deleter(
  const std:: type_info& _Typeid) const noexcept
  {
  return ((void *)(_Typeid == typeid(_Dx)
   ? ::std:: addressof(_Dtor) : 0));
  }

private:
 virtual void _Destroy() noexcept
  {
  _Dtor(_Ptr);
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 _Ty *_Ptr;
 _Dx _Dtor;
 };


template<class _Ty,
 class _Dx,
 class _Alloc>
 class _Ref_count_del_alloc
 : public _Ref_count_base
 {
public:
 typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myt;
 typedef _Wrap_alloc<_Alloc> _Myalty0;
 typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;

 _Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, const _Alloc& _Ax)
  : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Dt,
   _One_then_variadic_args_t(), _Ax, _Px)
  {
  }

 virtual void *_Get_deleter(
  const std:: type_info& _Typeid) const noexcept
  {
  return ((void *)(_Typeid == typeid(_Dx)
   ? ::std:: addressof(_Mypair._Get_first()) : 0));
  }

private:
 virtual void _Destroy() noexcept
  {
  _Mypair._Get_first()(_Mypair._Get_second()._Get_second());
  }

 virtual void _Delete_this() noexcept
  {
  _Myalty _Al = _Mypair._Get_second()._Get_first();
  _Al.destroy(this);
  _Al.deallocate(typename _Myalty::pointer(this), 1);
  }

 _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Ty *> > _Mypair;
 };


template<class _Ty>
 class weak_ptr;
template<class _Ty>
 class shared_ptr;
template<class _Ty>
 class enable_shared_from_this;

template<class _Ty1,
 class _Ty2>
 void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
  _Ref_count_base *);

template<class _Ty>
 inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
  typename _Ty::_EStype * = 0)
 {
 if (_Ptr)
  _Do_enable(_Ptr,
   (enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
 }

inline void _Enable_shared(const volatile void *, const volatile void *)
 {
 }


template<class _Ty>
 class _Ptr_base
 {
public:
 typedef _Ptr_base<_Ty> _Myt;
 typedef _Ty element_type;

 constexpr _Ptr_base() noexcept
  : _Ptr(0), _Rep(0)
  {
  }

 _Ptr_base(_Myt&& _Right)
  : _Ptr(_Right._Ptr), _Rep(_Right._Rep)
  {
  _Right._Ptr = 0;
  _Right._Rep = 0;
  }

 template<class _Ty2>
  _Ptr_base(_Ptr_base<_Ty2>&& _Right)
  : _Ptr(_Right._Ptr), _Rep(_Right._Rep)
  {
  _Right._Ptr = 0;
  _Right._Rep = 0;
  }

 _Myt& operator=(_Myt&& _Right)
  {
  _Assign_rv(::std:: move(_Right));
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Swap(_Right);
  }

 long use_count() const noexcept
  {
  return (_Rep ? _Rep->_Use_count() : 0);
  }

 void _Swap(_Ptr_base& _Right) noexcept
  {
  ::std:: swap(_Rep, _Right._Rep);
  ::std:: swap(_Ptr, _Right._Ptr);
  }

 template<class _Ty2>
  bool owner_before(const _Ptr_base<_Ty2>& _Right) const
  {
  return (_Rep < _Right._Rep);
  }

 void *_Get_deleter(const std:: type_info& _Typeid) const noexcept
  {
  return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
  }

 _Ty *_Get() const noexcept
  {
  return (_Ptr);
  }

 bool _Expired() const noexcept
  {
  return (!_Rep || _Rep->_Expired());
  }

 void _Decref()
  {
  if (_Rep != 0)
   _Rep->_Decref();
  }

 void _Reset()
  {
  _Reset(0, 0);
  }

 template<class _Ty2>
  void _Reset(const _Ptr_base<_Ty2>& _Other)
  {
  _Reset(_Other._Ptr, _Other._Rep);
  }

 template<class _Ty2>
  void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
  {
  _Reset(_Other._Ptr, _Other._Rep, _Throw);
  }

 template<class _Ty2>
            void _Reset(auto_ptr<_Ty2>&& _Other)
  {
  _Ty2 *_Px = _Other.get();
  _Reset0(_Px, new _Ref_count<_Ty>(_Px));
  _Other.release();
  _Enable_shared(_Px, _Rep);
  }

 template<class _Ty2>
  void _Reset(_Ty *_Other_ptr, const _Ptr_base<_Ty2>& _Other)
  {
  _Reset(_Other_ptr, _Other._Rep);
  }

 void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Other_rep)
   _Other_rep->_Incref();
  _Reset0(_Other_ptr, _Other_rep);
  }

 void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
  {


  if (_Other_rep && _Other_rep->_Incref_nz())
   _Reset0(_Other_ptr, _Other_rep);
  else if (_Throw)
   _Throw_bad_weak_ptr();
  }

 void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Rep != 0)
   _Rep->_Decref();
  _Rep = _Other_rep;
  _Ptr = _Other_ptr;
  }

 void _Decwref()
  {
  if (_Rep != 0)
   _Rep->_Decwref();
  }

 void _Resetw()
  {
  _Resetw((_Ty *)0, 0);
  }

 template<class _Ty2>
  void _Resetw(const _Ptr_base<_Ty2>& _Other)
  {
  _Resetw(_Other._Ptr, _Other._Rep);
  }

 template<class _Ty2>
            void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
  {
  if (_Other_rep)
   _Other_rep->_Incwref();
  if (_Rep != 0)
   _Rep->_Decwref();
  _Rep = _Other_rep;
  _Ptr = const_cast<remove_cv_t<_Ty2> *>(_Other_ptr);
  }

private:
 _Ty *_Ptr;
 _Ref_count_base *_Rep;
 template<class _Ty0>
  friend class _Ptr_base;
 };


template<class _Ty>
 class shared_ptr
  : public _Ptr_base<_Ty>
 {
public:
 typedef shared_ptr<_Ty> _Myt;
 typedef _Ptr_base<_Ty> _Mybase;





 constexpr shared_ptr() noexcept
  {
  }

 template<class _Ux>
  explicit shared_ptr(_Ux *_Px)
  {
  _Resetp(_Px);
  }

 template<class _Ux,
  class _Dx>
  shared_ptr(_Ux *_Px, _Dx _Dt)
  {
  _Resetp(_Px, _Dt);
  }

 constexpr shared_ptr(nullptr_t) noexcept
  : shared_ptr()
  {
  }

 template<class _Dx>
  shared_ptr(nullptr_t, _Dx _Dt)
  {
  _Resetp((_Ty *)0, _Dt);
  }

 template<class _Dx,
  class _Alloc>
  shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
  {
  _Resetp((_Ty *)0, _Dt, _Ax);
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
  shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  _Resetp(_Px, _Dt, _Ax);
  }

 template<class _Ty2>
  shared_ptr(const shared_ptr<_Ty2>& _Right, _Ty *_Px) noexcept
  {
  this->_Reset(_Px, _Right);
  }

 shared_ptr(const _Myt& _Other) noexcept
  {
  this->_Reset(_Other);
  }

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value,
   void> >
  shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept
  {
  this->_Reset(_Other);
  }

 template<class _Ty2>
  explicit shared_ptr(const weak_ptr<_Ty2>& _Other,
   bool _Throw = true)
  {
  this->_Reset(_Other, _Throw);
  }

 template<class _Ty2>
  shared_ptr(auto_ptr<_Ty2>&& _Other)
  {
  this->_Reset(::std:: move(_Other));
  }

 shared_ptr(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right))
  {
  }

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value,
   void> >
  shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept
  : _Mybase(::std:: move(_Right))
  {
  }

 template<class _Ux,
  class _Dx,
  class = enable_if_t<is_convertible<
   typename unique_ptr<_Ux, _Dx>::pointer, _Ty *>::value,
   void> >
  shared_ptr(unique_ptr<_Ux, _Dx>&& _Right)
  {
  _Ux *_Px = _Right.get();
  _Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px,
   _Rerefwrap<is_reference<_Dx>::value, _Dx>::
    _Apply(_Right.get_deleter())));
  _Right.release();
  }

 template<class _Ux,
  class _Dx>
  _Myt& operator=(unique_ptr<_Ux, _Dx>&& _Right)
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(shared_ptr<_Ty2>&& _Right) noexcept
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 ~shared_ptr() noexcept
  {
  this->_Decref();
  }

 _Myt& operator=(const _Myt& _Right) noexcept
  {
  shared_ptr(_Right).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(const shared_ptr<_Ty2>& _Right) noexcept
  {
  shared_ptr(_Right).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(auto_ptr<_Ty2>&& _Right)
  {
  shared_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 void reset() noexcept
  {
  shared_ptr().swap(*this);
  }

 template<class _Ux>
  void reset(_Ux *_Px)
  {
  shared_ptr(_Px).swap(*this);
  }

 template<class _Ux,
  class _Dx>
  void reset(_Ux *_Px, _Dx _Dt)
  {
  shared_ptr(_Px, _Dt).swap(*this);
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
  void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  shared_ptr(_Px, _Dt, _Ax).swap(*this);
  }

 void swap(_Myt& _Other) noexcept
  {
  this->_Swap(_Other);
  }

 _Ty *get() const noexcept
  {
  return (this->_Get());
  }

 typename add_lvalue_reference<_Ty>::type operator*() const noexcept
  {
  return (*this->_Get());
  }

 _Ty *operator->() const noexcept
  {
  return (this->_Get());
  }

                bool unique() const noexcept
  {
  return (this->use_count() == 1);
  }


        int _No_bool_decl;


 explicit operator bool() const noexcept
  {
  return (this->_Get() != 0);
  }

private:
 template<class _Ux>
            void _Resetp(_Ux *_Px)
  {
  {{
  _Resetp0(_Px, new _Ref_count<_Ux>(_Px));
  } if (0) {
  delete _Px;
          ;
  }}
  }

 template<class _Ux,
  class _Dx>
            void _Resetp(_Ux *_Px, _Dx _Dt)
  {
  {{
  _Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
  } if (0) {
  _Dt(_Px);
          ;
  }}
  }

 template<class _Ux,
  class _Dx,
  class _Alloc>
            void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
  {
  typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
  typedef _Wrap_alloc<_Alloc> _Alref0;
  typename _Alref0::template rebind<_Refd>::other _Alref(_Ax);

  {{
  _Refd *_Pref = ::std:: addressof(*_Alref.allocate(1));
  _Alref.construct(_Pref, _Px, _Dt, _Ax);
  _Resetp0(_Px, _Pref);
  } if (0) {
  _Dt(_Px);
          ;
  }}
  }

public:
 template<class _Ux>
  void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
  {
  this->_Reset0(_Px, _Rx);
  _Enable_shared(_Px, _Rx);
  }
 };
# 764 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 3
template<class _Ty1,
 class _Ty2>
 bool operator==(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (_Left.get() == _Right.get());
 }

template<class _Ty1,
 class _Ty2>
 bool operator!=(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2>
 bool operator<(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (less<decltype(_Always_false<_Ty1>::value
  ? _Left.get() : _Right.get())>()(
   _Left.get(), _Right.get()));
 }

template<class _Ty1,
 class _Ty2>
 bool operator>=(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ty1,
 class _Ty2>
 bool operator>(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2>
 bool operator<=(const shared_ptr<_Ty1>& _Left,
  const shared_ptr<_Ty2>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Ty>
 bool operator==(const shared_ptr<_Ty>& _Left,
  nullptr_t) noexcept
 {
 return (_Left.get() == (_Ty *)0);
 }

template<class _Ty>
 bool operator==(nullptr_t,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return ((_Ty *)0 == _Right.get());
 }

template<class _Ty>
 bool operator!=(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty>
 bool operator!=(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty>
 bool operator<(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (less<_Ty *>()(_Left.get(), (_Ty *)0));
 }

template<class _Ty>
 bool operator<(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (less<_Ty *>()((_Ty *)0, _Right.get()));
 }

template<class _Ty>
 bool operator>=(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ty>
 bool operator>=(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Ty>
 bool operator>(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Ty>
 bool operator>(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Ty>
 bool operator<=(const shared_ptr<_Ty>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Ty>
 bool operator<=(nullptr_t _Left,
  const shared_ptr<_Ty>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Ty>
 basic_ostream<_Elem, _Traits>&
 operator<<(basic_ostream<_Elem, _Traits>& _Out,
  const shared_ptr<_Ty>& _Px)
 {
 return (_Out << _Px.get());
 }

template<class _Ty>
 void swap(shared_ptr<_Ty>& _Left,
  shared_ptr<_Ty>& _Right) noexcept
 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = static_cast<_Elem1 *>(_Other.get());
 return (shared_ptr<_Ty1>(_Other, _Ptr));
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = const_cast<_Elem1 *>(_Other.get());
 return (shared_ptr<_Ty1>(_Other, _Ptr));
 }

template<class _Ty1,
 class _Ty2>
 shared_ptr<_Ty1>
  dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
 {
 typedef typename shared_ptr<_Ty1>::element_type _Elem1;
 _Elem1 *_Ptr = dynamic_cast<_Elem1 *>(_Other.get());
 if (_Ptr)
  return (shared_ptr<_Ty1>(_Other, _Ptr));
 else
  return (shared_ptr<_Ty1>());
 }

template<class _Dx,
 class _Ty>
 _Dx *get_deleter(const shared_ptr<_Ty>& _Sx) noexcept
 {
 return ((_Dx *)_Sx._Get_deleter(typeid(_Dx)));
 }


template<class _Ty>
 class _Ref_count_obj
 : public _Ref_count_base
 {
public:
 template<class... _Types>
  _Ref_count_obj(_Types&&... _Args)
  : _Ref_count_base()
  {
  ::new ((void *)&_Storage) _Ty(::std:: forward<_Types>(_Args)...);
  }

 _Ty *_Getptr() const
  {
  return ((_Ty *)&_Storage);
  }

private:
 virtual void _Destroy() noexcept
  {
  _Getptr()->~_Ty();
  }

 virtual void _Delete_this() noexcept
  {
  delete this;
  }

 typename aligned_storage<sizeof (_Ty),
  alignment_of<_Ty>::value>::type _Storage;
 };


template<class _Ty,
 class _Alloc>
 class _Ref_count_obj_alloc
 : public _Ref_count_base
 {
public:
 typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Myt;
 typedef _Wrap_alloc<_Alloc> _Myalty0;
 typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;
 typedef typename aligned_union<1, _Ty>::type _Mystoragety;

 template<class... _Types>
  _Ref_count_obj_alloc(const _Alloc& _Al_arg, _Types&&... _Args)
  : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Al_arg)
  {
  ::new ((void *)_Getptr()) _Ty(::std:: forward<_Types>(_Args)...);
  }

 _Ty *_Getptr() const
  {
  return ((_Ty *)&_Mypair._Get_second());
  }

private:
 virtual void _Destroy() noexcept
  {
  _Getptr()->~_Ty();
  }

 virtual void _Delete_this() noexcept
  {
  _Myalty _Al = _Mypair._Get_first();
  _Al.destroy(this);
  _Al.deallocate(
   ::std:: pointer_traits<typename _Myalty::pointer>::
    pointer_to(*this),
   1);
  }

 _Compressed_pair<_Myalty, _Mystoragety> _Mypair;
 };


template<class _Ty,
 class... _Types> inline
  shared_ptr<_Ty> make_shared(_Types&&... _Args)
 {
 _Ref_count_obj<_Ty> *_Rx =
  new _Ref_count_obj<_Ty>(::std:: forward<_Types>(_Args)...);

 shared_ptr<_Ty> _Ret;
 _Ret._Resetp0(_Rx->_Getptr(), _Rx);
 return (_Ret);
 }


template<class _Ty,
 class _Alloc,
 class... _Types> inline
 shared_ptr<_Ty> allocate_shared(
  const _Alloc& _Al_arg, _Types&&... _Args)
 {
 typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Refoa;
 typedef _Wrap_alloc<_Alloc> _Alref0;
 typename _Alref0::template rebind<_Refoa>::other _Alref(_Al_arg);

 typename decltype(_Alref)::pointer _Rx = _Alref.allocate(1);
 _Refoa *_Rx_raw = ::std:: addressof(*_Rx);

 {{
  ::new (static_cast<void *>(_Rx_raw))
   _Refoa(_Al_arg, ::std:: forward<_Types>(_Args)...);
 } if (0) {
  _Alref.deallocate(_Rx, 1);
         ;
 }}

 shared_ptr<_Ty> _Ret;
 _Ret._Resetp0(_Rx->_Getptr(), _Rx_raw);
 return (_Ret);
 }


template<class _Ty>
 class weak_ptr
  : public _Ptr_base<_Ty>
 {
public:
 typedef weak_ptr<_Ty> _Myt;
 typedef _Ptr_base<_Ty> _Mybase;

 constexpr weak_ptr() noexcept
  {
  }

 weak_ptr(const weak_ptr& _Other) noexcept
  {
  this->_Resetw(_Other);
  }

 weak_ptr(const shared_ptr<_Ty>& _Other)
  {
  this->_Resetw(_Other);
  }

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value,
   void> >
  weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept
  {
  this->_Resetw(_Other);
  }

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value,
   void> >
  weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept
  {
  this->_Resetw(_Other.lock());
  }


 weak_ptr(_Myt&& _Other) noexcept
  : _Mybase(::std:: move(_Other))
  {
  }

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value,
   void> >
  weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept
  {
  this->_Resetw(_Other.lock());
  _Other.reset();
  }


 ~weak_ptr() noexcept
  {
  this->_Decwref();
  }

 weak_ptr& operator=(const weak_ptr& _Right) noexcept
  {
  this->_Resetw(_Right);
  return (*this);
  }

 template<class _Ty2>
  weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept
  {
  this->_Resetw(_Right.lock());
  return (*this);
  }


 _Myt& operator=(_Myt&& _Right) noexcept
  {
  weak_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }

 template<class _Ty2>
  _Myt& operator=(weak_ptr<_Ty2>&& _Right) noexcept
  {
  weak_ptr(::std:: move(_Right)).swap(*this);
  return (*this);
  }


 template<class _Ty2>
  weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept
  {
  this->_Resetw(_Right);
  return (*this);
  }

 void reset() noexcept
  {
  this->_Resetw();
  }

 void swap(weak_ptr& _Other) noexcept
  {
  this->_Swap(_Other);
  }

 bool expired() const noexcept
  {
  return (this->_Expired());
  }

 shared_ptr<_Ty> lock() const noexcept
  {
  return (shared_ptr<_Ty>(*this, false));
  }
 };






template<class _Ty>
 void swap(weak_ptr<_Ty>& _W1, weak_ptr<_Ty>& _W2) noexcept
 {
 _W1.swap(_W2);
 }


template<class _Ty>
 class enable_shared_from_this
 {
public:
 typedef _Ty _EStype;

 shared_ptr<_Ty> shared_from_this()
  {
  return (shared_ptr<_Ty>(_Wptr));
  }

 shared_ptr<const _Ty> shared_from_this() const
  {
  return (shared_ptr<const _Ty>(_Wptr));
  }
# 1227 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 3
protected:
 constexpr enable_shared_from_this() noexcept
  {
  }

 enable_shared_from_this(const enable_shared_from_this&) noexcept
  {
  }

 enable_shared_from_this&
  operator=(const enable_shared_from_this&) noexcept
  {
  return (*this);
  }

 ~enable_shared_from_this() noexcept
  {
  }

private:
 template<class _Ty1,
  class _Ty2>
  friend void _Do_enable(
   _Ty1 *,
   enable_shared_from_this<_Ty2>*,
   _Ref_count_base *);

 weak_ptr<_Ty> _Wptr;
 };

template<class _Ty1,
 class _Ty2>
 inline void _Do_enable(
  _Ty1 *_Ptr,
  enable_shared_from_this<_Ty2> *_Es,
  _Ref_count_base *_Refptr)
 {
 _Es->_Wptr._Resetw(_Ptr, _Refptr);
 }
}

namespace std {



template<class _Ty>
 struct default_delete
 {
 constexpr default_delete() noexcept = default;

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value,
   void> >
  default_delete(const default_delete<_Ty2>&) noexcept
  {
  }

 void operator()(_Ty *_Ptr) const noexcept
  {
  static_assert(0 < sizeof (_Ty), "can't delete an incomplete type");

  delete _Ptr;
  }
 };

template<class _Ty>
 struct default_delete<_Ty[]>
 {
 constexpr default_delete() noexcept = default;
# 1317 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 3
 template<class _Other>
  void operator()(_Other *) const = delete;

 void operator()(_Ty *_Ptr) const noexcept
  {
  static_assert(0 < sizeof (_Ty), "can't delete an incomplete type");

  delete[] _Ptr;
  }

 };


template<class _Val,
 class _Ty>
 struct _Get_deleter_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Val *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Dx,
 bool _Empty_deleter>
 class _Unique_ptr_base
 {
public:
 typedef typename remove_reference<_Dx>::type _Dx_noref;
 typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;

 _Unique_ptr_base(pointer _Ptr, _Dx _Dt)
  : _Myptr(_Ptr), _Mydel(_Dt)
  {
  }

 _Unique_ptr_base(pointer _Ptr)
  : _Myptr(_Ptr)
  {
  }

 template<class _Ptr2,
  class _Dx2>
  _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 _Dt)
  : _Myptr(_Ptr), _Mydel(_Dt)
  {
  }

 template<class _Ptr2>
  _Unique_ptr_base(_Ptr2 _Ptr)
  : _Myptr(_Ptr)
  {
  }

 _Dx_noref& get_deleter() noexcept
  {
  return (_Mydel);
  }

 const _Dx_noref& get_deleter() const noexcept
  {
  return (_Mydel);
  }

 pointer _Myptr;
 _Dx _Mydel;
 };

template<class _Ty,
 class _Dx>
 class _Unique_ptr_base<_Ty, _Dx, true>
  : public _Dx
 {
public:
 typedef _Dx _Mybase;
 typedef typename remove_reference<_Dx>::type _Dx_noref;
 typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;

 _Unique_ptr_base(pointer _Ptr, _Dx _Dt) noexcept
  : _Myptr(_Ptr), _Mybase(_Dt)
  {
  }

 _Unique_ptr_base(pointer _Ptr) noexcept
  : _Myptr(_Ptr)
  {
  }

 template<class _Ptr2,
  class _Dx2>
  _Unique_ptr_base(_Ptr2 _Ptr, _Dx2 _Dt) noexcept
  : _Myptr(_Ptr), _Mybase(_Dt)
  {
  }

 template<class _Ptr2>
  _Unique_ptr_base(_Ptr2 _Ptr) noexcept
  : _Myptr(_Ptr)
  {
  }

 _Dx_noref& get_deleter() noexcept
  {
  return (*this);
  }

 const _Dx_noref& get_deleter() const noexcept
  {
  return (*this);
  }

 pointer _Myptr;
 };


template<class _Ty,
 class _Dx>
 class unique_ptr
  : private _Unique_ptr_base<_Ty, _Dx,
   is_empty<_Dx>::value
    || is_same<default_delete<_Ty>, _Dx>::value>
 {
public:
 typedef unique_ptr<_Ty, _Dx> _Myt;
 typedef _Unique_ptr_base<_Ty, _Dx,
  is_empty<_Dx>::value
   || is_same<default_delete<_Ty>, _Dx>::value> _Mybase;
 typedef typename _Mybase::pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 using _Mybase::get_deleter;

 template<class _Dt0 = deleter_type,
  class = enable_if_t<!is_pointer<_Dt0>::value
   && is_default_constructible<_Dt0>::value,
   void> >
  constexpr unique_ptr() noexcept
   : _Mybase(pointer())
  {
  }

 template<class _Delt0 = deleter_type,
  class = enable_if_t<!is_pointer<_Delt0>::value
   && is_default_constructible<_Delt0>::value,
   void> >
  constexpr unique_ptr(nullptr_t) noexcept
   : _Mybase(pointer())
  {
  }

 template<class _Delt0 = deleter_type,
  class = enable_if_t<!is_pointer<_Delt0>::value
   && is_default_constructible<_Delt0>::value,
   void> >
  explicit unique_ptr(pointer _Ptr) noexcept
   : _Mybase(_Ptr)
  {
  }

 unique_ptr(pointer _Ptr,
  typename _If<is_reference<_Dx>::value, _Dx,
   const typename remove_reference<_Dx>::type&>::type _Dt) noexcept
  : _Mybase(_Ptr, _Dt)
  {
  }

 unique_ptr(pointer _Ptr,
  typename remove_reference<_Dx>::type&& _Dt) noexcept
  : _Mybase(_Ptr, ::std:: move(_Dt))
  {
  static_assert(!is_reference<_Dx>::value,
   "unique_ptr constructed with reference to rvalue deleter");
  }

 unique_ptr(unique_ptr&& _Right) noexcept
  : _Mybase(_Right.release(),
   ::std:: forward<_Dx>(_Right.get_deleter()))
  {
  }

 template<class _Ty2,
  class _Dx2,
  class = enable_if_t<!is_array<_Ty2>::value
   && is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer,
    pointer>::value
   && (is_reference<_Dx>::value
    ? is_same<_Dx2, _Dx>::value
    : is_convertible<_Dx2, _Dx>::value),
   void> >
  unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
   : _Mybase(_Right.release(),
    ::std:: forward<_Dx2>(_Right.get_deleter()))
  {
  }

 template<class _Ty2,
  class = enable_if_t<is_convertible<_Ty2 *, _Ty *>::value
   && is_same<_Dx, default_delete<_Ty> >::value,
   void> >
  unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept
   : _Mybase(_Right.release())
  {
  }

 _Myt& operator=(nullptr_t) noexcept
  {
  reset();
  return (*this);
  }

 template<class _Ty2,
  class _Dx2>
            enable_if_t<!is_array<_Ty2>::value
   && is_assignable<_Dx&, _Dx2&&>::value
   && is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer,
    pointer>::value,
   _Myt&>
  operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
  {
  reset(_Right.release());
  this->get_deleter() = ::std:: forward<_Dx2>(_Right.get_deleter());
  return (*this);
  }

           _Myt& operator=(_Myt&& _Right) noexcept
  {
  if (this != &_Right)
   {
   reset(_Right.release());
   this->get_deleter() = ::std:: forward<_Dx>(_Right.get_deleter());
   }
  return (*this);
  }

 void swap(_Myt& _Right) noexcept
  {
  _Swap_adl(this->_Myptr, _Right._Myptr);
  _Swap_adl(this->get_deleter(),
   _Right.get_deleter());
  }

 ~unique_ptr() noexcept
  {
  if (get() != pointer())
   this->get_deleter()(get());
  }

 typename add_lvalue_reference<_Ty>::type operator*() const
  {
  return (*get());
  }

 pointer operator->() const noexcept
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 pointer get() const noexcept
  {
  return (this->_Myptr);
  }


 int _No_bool_decl;


 explicit operator bool() const noexcept
  {
  return (get() != pointer());
  }

 pointer release() noexcept
  {
  pointer _Ans = get();
  this->_Myptr = pointer();
  return (_Ans);
  }

 void reset(pointer _Ptr = pointer()) noexcept
  {
  pointer _Old = get();
  this->_Myptr = _Ptr;
  if (_Old != pointer())
   this->get_deleter()(_Old);
  }

 unique_ptr(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;
 };


template<class _Ty,
 class _Dx>
 class unique_ptr<_Ty[], _Dx>
  : private _Unique_ptr_base<_Ty, _Dx,
   is_empty<_Dx>::value
    || is_same<default_delete<_Ty[]>, _Dx>::value>
 {
public:
 typedef unique_ptr<_Ty[], _Dx> _Myt;
 typedef _Unique_ptr_base<_Ty, _Dx,
  is_empty<_Dx>::value
   || is_same<default_delete<_Ty[]>, _Dx>::value> _Mybase;
 typedef typename _Mybase::pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 using _Mybase::get_deleter;

 constexpr unique_ptr() noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value, "unique_ptr constructed with null deleter pointer");

  }

 template<class _Uty>
  using _Enable_ctor_reset = enable_if_t<
   is_same<_Uty, pointer>::value
   || (is_same<pointer, element_type *>::value
    && is_pointer<_Uty>::value
    && is_convertible<
     remove_pointer_t<_Uty>(*)[],
     element_type(*)[]>::value)
   >;

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 explicit unique_ptr(_Uty _Ptr) noexcept
  : _Mybase(_Ptr)
  {
  static_assert(!is_pointer<_Dx>::value,
   "unique_ptr constructed with null deleter pointer");
  }

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 unique_ptr(_Uty _Ptr,
  typename _If<is_reference<_Dx>::value, _Dx,
   const typename remove_reference<_Dx>::type&>::type _Dt) noexcept
  : _Mybase(_Ptr, _Dt)
  {
  }

 template<class _Uty,
  class = _Enable_ctor_reset<_Uty> >
 unique_ptr(_Uty _Ptr,
  typename remove_reference<_Dx>::type&& _Dt) noexcept
  : _Mybase(_Ptr, ::std:: move(_Dt))
  {
  static_assert(!is_reference<_Dx>::value,
   "unique_ptr constructed with reference to rvalue deleter");
  }

 unique_ptr(unique_ptr&& _Right) noexcept
  : _Mybase(_Right.release(),
   ::std:: forward<_Dx>(_Right.get_deleter()))
  {
  }

 _Myt& operator=(_Myt&& _Right) noexcept
  {
  if (this != &_Right)
   {
   reset(_Right.release());
   this->get_deleter() = ::std:: move(_Right.get_deleter());
   }
  return (*this);
  }

 template<class _Uty,
  class _Ex,
  bool _More,
  class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
  class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
  using _Enable_conversion = enable_if_t<
   is_array<_Uty>::value
   && is_same<pointer, element_type *>::value
   && is_same<_UP_pointer, _UP_element_type *>::value
   && is_convertible<_UP_element_type(*)[], element_type(*)[]>::value
   && _More>;

 template<class _Uty,
  class _Ex,
  class = _Enable_conversion<_Uty, _Ex,
   is_reference<_Dx>::value
   ? is_same<_Ex, _Dx>::value
   : is_convertible<_Ex, _Dx>::value> >
  unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
   : _Mybase(_Right.release(),
    ::std:: forward<_Ex>(_Right.get_deleter()))
  {
  }
# 1723 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 3
 constexpr unique_ptr(nullptr_t) noexcept
  : _Mybase(pointer())
  {
  static_assert(!is_pointer<_Dx>::value, "unique_ptr constructed with null deleter pointer");

  }

 _Myt& operator=(nullptr_t) noexcept
  {
  reset(pointer());
  return (*this);
  }




 void reset(nullptr_t _Ptr) noexcept

  {
  pointer _Old = this->_Myptr;
  this->_Myptr = _Ptr;
  if (_Old != pointer())
   this->get_deleter()(_Old);
  }

 void swap(_Myt& _Right) noexcept
  {
  _Swap_adl(this->_Myptr, _Right._Myptr);
  _Swap_adl(this->get_deleter(), _Right.get_deleter());
  }

 ~unique_ptr() noexcept
  {
  _Delete();
  }

 _Ty& operator[](size_t _Idx) const
  {
  return (get()[_Idx]);
  }

 pointer get() const noexcept
  {
  return (this->_Myptr);
  }


 int _No_bool_decl;


 explicit operator bool() const noexcept
  {
  return (get() != pointer());
  }

 pointer release() noexcept
  {
  pointer _Ans = get();
  this->_Myptr = pointer();
  return (_Ans);
  }






 template<class _Uty>
 void reset(_Uty) = delete;

 void reset(pointer _Ptr = pointer()) noexcept

  {
  pointer _Old = get();
  this->_Myptr = _Ptr;
  if (_Old != pointer())
   this->get_deleter()(_Old);
  }

 unique_ptr(const _Myt&) = delete;

 _Myt& operator=(const _Myt&) = delete;

private:
 void _Delete()
  {
  if (get() != pointer())
   this->get_deleter()(get());
  }
 };



template<class _Ty,
 class... _Types> inline
 enable_if_t<!is_array<_Ty>::value,
  unique_ptr<_Ty> >
  make_unique(_Types&&... _Args)
 {
 return (unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...)));
 }

template<class _Ty> inline
 enable_if_t<is_array<_Ty>::value && extent<_Ty>::value == 0,
  unique_ptr<_Ty> >
  make_unique(size_t _Size)
 {
 typedef typename remove_extent<_Ty>::type _Elem;
 return (unique_ptr<_Ty>(new _Elem[_Size]()));
 }

template<class _Ty,
 class... _Types,
 class = enable_if_t<extent<_Ty>::value != 0,
  void> >
 void make_unique(_Types&&...) = delete;
# 1848 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 3
template<class _Ty,
 class _Dx>


 void swap(unique_ptr<_Ty, _Dx>& _Left,
  unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (_Left.get() == _Right.get());
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 typedef typename unique_ptr<_Ty1, _Dx1>::pointer _Ptr1;
 typedef typename unique_ptr<_Ty2, _Dx2>::pointer _Ptr2;
 typedef typename common_type<_Ptr1, _Ptr2>::type _Common;
 return (less<_Common>()(_Left.get(), _Right.get()));
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2>
 bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left,
  const unique_ptr<_Ty2, _Dx2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Dx>
 bool operator==(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t) noexcept
 {
 return (!_Left);
 }

template<class _Ty,
 class _Dx>
 bool operator==(nullptr_t,
  const unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 return (!_Right);
 }

template<class _Ty,
 class _Dx>
 bool operator!=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator!=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator<(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
 return (less<_Ptr>()(_Left.get(), _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator<(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
 return (less<_Ptr>()(_Left, _Right.get()));
 }

template<class _Ty,
 class _Dx>
 bool operator>=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator>=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Ty,
 class _Dx>
 bool operator>(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Dx>
 bool operator>(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Dx>
 bool operator<=(const unique_ptr<_Ty, _Dx>& _Left,
  nullptr_t _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Dx>
 bool operator<=(nullptr_t _Left,
  const unique_ptr<_Ty, _Dx>& _Right)
 {
 return (!(_Right < _Left));
 }


enum class pointer_safety {
 relaxed,
 preferred,
 strict
 };

typedef pointer_safety _Pointer_safety;

inline void declare_reachable(void *)
 {
 }

template<class _Ty> inline
 _Ty *undeclare_reachable(_Ty *_Ptr)
 {
 return (_Ptr);
 }

inline void declare_no_pointers(char *, size_t)
 {
 }

inline void undeclare_no_pointers(char *, size_t)
 {
 }

inline _Pointer_safety get_pointer_safety() noexcept
 {
 return (pointer_safety::relaxed);
 }
# 2068 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\memory" 3
template<class _Ty>
 struct owner_less;

template<class _Ty>
 struct owner_less<shared_ptr<_Ty> >
 {
 typedef shared_ptr<_Ty> first_argument_type ;
 typedef shared_ptr<_Ty> second_argument_type ;
 typedef bool result_type ;

 bool operator()(const shared_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const shared_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const weak_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }
 };

template<class _Ty>
 struct owner_less<weak_ptr<_Ty> >
 {
 typedef weak_ptr<_Ty> first_argument_type ;
 typedef weak_ptr<_Ty> second_argument_type ;
 typedef bool result_type ;

 bool operator()(const weak_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const weak_ptr<_Ty>& _Left,
  const shared_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }

 bool operator()(const shared_ptr<_Ty>& _Left,
  const weak_ptr<_Ty>& _Right) const
  {
  return (_Left.owner_before(_Right));
  }
 };
}
namespace std {

template<class _Ty,
 class _Dx>
 struct hash<unique_ptr<_Ty, _Dx> >
 {
 typedef unique_ptr<_Ty, _Dx> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  typedef typename argument_type::pointer _Ptrtype;
  return (hash<_Ptrtype>()(_Keyval.get()));
  }
 };

template<class _Ty>
 struct hash<shared_ptr<_Ty> >
 {
 typedef shared_ptr<_Ty> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (hash<_Ty *>()(_Keyval.get()));
  }
 };
}
namespace std {

inline void *align(size_t _Bound, size_t _Size,
 void *& _Ptr, size_t& _Space) noexcept
 {
 size_t _Off = (size_t)((uintptr_t)_Ptr & (_Bound - 1));
 if (0 < _Off)
  _Off = _Bound - _Off;
 if (_Space < _Off || _Space - _Off < _Size)
  return (0);
 else
  {
  _Ptr = (char *)_Ptr + _Off;
  _Space -= _Off;
  return (_Ptr);
  }
 }



struct _Shared_ptr_spin_lock
 {
 _Shared_ptr_spin_lock()
  {
  _Lock_shared_ptr_spin_lock();
  }

 ~_Shared_ptr_spin_lock() noexcept
  {
  _Unlock_shared_ptr_spin_lock();
  }
 };

template<class _Ty> inline
 bool atomic_is_lock_free(const shared_ptr<_Ty> *)
 {
 return (false);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty> *_Ptr,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 shared_ptr<_Ty> _Result = *_Ptr;
 return (_Result);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty> *_Ptr)
 {
 return (atomic_load_explicit(_Ptr, memory_order_seq_cst));
 }

template<class _Ty> inline
 void atomic_store_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 _Ptr->swap(_Other);
 }

template<class _Ty> inline
 void atomic_store(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)
 {
 atomic_store_explicit(_Ptr, _Other, memory_order_seq_cst);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_exchange_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other,
  memory_order)
 {
 _Shared_ptr_spin_lock _Lock;
 _Ptr->swap(_Other);
 return (_Other);
 }

template<class _Ty> inline
 shared_ptr<_Ty> atomic_exchange(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)
 {
 return (atomic_exchange_explicit(_Ptr, _Other, memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_weak_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value,
  memory_order, memory_order)
 {
 shared_ptr<_Ty> _Old_exp;
 _Shared_ptr_spin_lock _Lock;
 bool _Success = _Ptr->get() == _Exp->get()
  && !_Ptr->owner_before(*_Exp)
  && !_Exp->owner_before(*_Ptr);
 if (_Success)
  _Ptr->swap(_Value);
 else
  {
  _Exp->swap(_Old_exp);
  *_Exp = *_Ptr;
  }
 return (_Success);
 }

template<class _Ty> inline
 bool atomic_compare_exchange_weak(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp,
   shared_ptr<_Ty> _Value)
 {
 return (atomic_compare_exchange_weak_explicit(_Ptr, _Exp, _Value,
  memory_order_seq_cst, memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_strong_explicit(
  shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value,
  memory_order, memory_order)
 {
 return (atomic_compare_exchange_weak_explicit(_Ptr, _Exp, _Value,
  memory_order_seq_cst, memory_order_seq_cst));
 }

template<class _Ty> inline
 bool atomic_compare_exchange_strong(
 shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp,
  shared_ptr<_Ty> _Value)
 {
 return (atomic_compare_exchange_strong_explicit(_Ptr, _Exp, _Value,
  memory_order_seq_cst, memory_order_seq_cst));
 }

}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/error.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/vector.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/vector.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/refobject.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/refobject.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace Common {

class RefObject
{
public:
 RefObject();
 ~RefObject();
 int32_t GetRefCount(void) const;
 int32_t AddRef();
 int32_t Release(void);

private:
 int32_t m_refCount;
};

}
}
}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/vector.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace Common {

class LibContext;

template<typename T>
class Vector;

template<typename T>
class ConstIterator : public RefObject
{
public:
 static void intrusive_ptr_add_ref(ConstIterator<T> * c);
 static void intrusive_ptr_sub_ref(ConstIterator<T> * c);
 using const_pointer = const T*;
 using pointer = T * ;
 using const_reference = const T&;
 using This = ConstIterator<T>;

 ConstIterator();
 ConstIterator(pointer p);
 ConstIterator(const_pointer p);
 ~ConstIterator();

 const_reference operator*() const;
 const_pointer operator->() const;
 This &operator++();
 This &operator++(int);
 This operator+(size_t) const;
 This &operator--();
 This &operator--(int);
 bool operator==(const This& right) const;
 bool operator!=(const This& right) const;

protected:
 T * m_ptr;

private:
 friend class Vector<T>;
};

template<typename T>
class Iterator : public ConstIterator<T> {
public:
 using This = Iterator<T>;
 using Base = ConstIterator<T>;
 using pointer = T * ;
 using reference = T & ;

 Iterator();
 Iterator(pointer p);

 reference operator*() const;
 pointer operator->() const;
 This &operator++();
 This &operator++(int);
 This &operator--();
 This &operator--(int);
 bool operator==(const This& right) const;
 bool operator!=(const This& right) const;
 This &operator=(const This&);

private:
 friend class Vector<T>;
};

template<class V>
class VectorVal
{
public:
 using value_type = V;
 using pointer = V * ;
 using const_pointer = const V*;
 using reference = V & ;
 using const_reference = const V&;
 using iterator = Iterator<V>;
 using const_iterator = ConstIterator<V>;

 VectorVal();

protected:
 V m_origin;
 V * m_first;
 V *m_last;
 V *m_end;
 bool isOrigin(V *ptr) { return ptr == &m_origin; };

private:
 typedef VectorVal<V> This;
};

template <typename T>
class Vector : public VectorVal<T>, public RefObject
{
public:
 static void intrusive_ptr_add_ref(Vector * c);
 static void intrusive_ptr_sub_ref(Vector * c);
 using Base = VectorVal<T>;
 using iterator = typename Base::iterator;
 using const_iterator = typename Base::const_iterator;
 using const_reference = typename Base::const_reference;
 using reference = typename Base::reference;
 using const_pointer = typename Base::const_pointer;
 using pointer = typename Base::pointer;
 using This = Vector<T>;
 using TType = T;

 Vector(Common::LibContext * context);
 ~Vector();

 int pushBack(const T & v) __attribute__((warn_unused_result));
 size_t size() const;
 void clear();
 const_reference operator[](size_t n) const;
 reference operator[](size_t n);
 bool empty() const;

 iterator begin();
 const_iterator begin() const;
 iterator end();
 const_iterator end() const;

 int32_t reserve(int32_t size) __attribute__((warn_unused_result));
 size_t capacity() const;
 int32_t resize(uint32_t size) __attribute__((warn_unused_result));
 void popBack();

 int32_t insert(iterator position, const T& x, iterator & result) __attribute__((warn_unused_result));
 int32_t insert(const_iterator position, const T& x, const_iterator & result) __attribute__((warn_unused_result));
 int32_t erase(iterator position, iterator & result) __attribute__((warn_unused_result));
 int32_t erase(const_iterator position, const_iterator & result) __attribute__((warn_unused_result));

 int32_t copyFrom(const Vector<T> &src) __attribute__((warn_unused_result));

private:
 Vector();
 void setContext(Common::LibContext * context);
 Vector(const Vector& rhs) = delete;
 Vector& operator=(const Vector& rhs) = delete;
 Common::LibContext * m_context;
};

}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/intrusive_ptr.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/intrusive_ptr.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace Common {

class LibContext;

template <typename T>
class IntrusivePtr
{
 typedef IntrusivePtr<T> this_type;

public:
 using value_type = T;

 IntrusivePtr();
 IntrusivePtr(T *p, Common::LibContext * context);
 IntrusivePtr(T *p, void(*deleter)(T*), Common::LibContext * context);
 IntrusivePtr(IntrusivePtr<T> &ptr);
 IntrusivePtr(IntrusivePtr<T> const &ptr);

 ~IntrusivePtr();

 IntrusivePtr<T> &operator=(IntrusivePtr<T> &r);
 IntrusivePtr<T> &operator=(IntrusivePtr<T> const &r);

 template <class Y> IntrusivePtr<Y> &operator=(IntrusivePtr<Y> const &r);
 template <class Y> IntrusivePtr<Y> & copyFrom(Y *p, Common::LibContext * context);

 void reset(T *p = nullptr);
 T* get() const;
 void(*get_deleter())(T*);
 T& operator*() const;
 T* operator->() const;

 T* get_ref();

 explicit operator bool() const;

protected:
 void add_ref();
 void release_ref();
 void assign(T *p, void(*deleter)(T*), Common::LibContext * context);
 T * m_ptr;
 void(*m_deleter)(T*);
 Common::LibContext * m_context;
};

}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/string.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/string.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace Common {

class LibContext;

class String : public RefObject
{
public:
 static void intrusive_ptr_add_ref(String * c);
 static void intrusive_ptr_sub_ref(String * c);

 String(Common::LibContext * context);
 ~String();

 int32_t copyFrom(const char * src) __attribute__((warn_unused_result));
 int32_t copyFrom(const String & src) __attribute__((warn_unused_result));
 int32_t append(const char * src) __attribute__((warn_unused_result));
 int32_t append(const String & src) __attribute__((warn_unused_result));
 size_t size() const;
 size_t length() const;
 size_t find(const String & s) const;
 size_t find(const String & s, size_t position) const;
 void clear();
 bool operator==(const String & src);
 bool operator==(const char * src);
 const char * c_str() const;
 int32_t replace(size_t start, size_t size, String & str) __attribute__((warn_unused_result));
 bool empty() const;
 static size_t npos;

 String();
 void setContext(Common::LibContext * context);

private:
 char * m_ptr;
 size_t m_size;
 Common::LibContext * m_context;

 String(const String& rhs) = delete;
 String& operator=(const String& rhs) = delete;
};

}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3




namespace sce {
 namespace Np {
  namespace CppWebApi {
   namespace Common {




    class InitParams {
    public:
     size_t numWorkers;
     SceKernelCpumask mask;
     int32_t threadPriority;
     size_t threadStackSize;
     int32_t poolSize;

     InitParams();
     ~InitParams();
    };




    class ParameterBaseImpl;

    class ParameterBase {
    public:
     friend class LibContextImpl;

     ParameterBase();
     ~ParameterBase();

     int32_t setRequestHeader(const char *fieldName, const char *value);
     int32_t unSetRequestHeader(const char *fieldName);

     int32_t setWebtraceTagHeader(const char * value);
     int32_t unSetWebtraceTagHeader();

     int32_t initialize(LibContext &ctx);
     int32_t terminate();
     bool isInitialized() const;

    protected:
     ParameterBaseImpl *m_impl;
    };

    class LibContext ;



    int32_t initialize(const InitParams &params, LibContext &ctx);



    int32_t terminate(LibContext &ctx);



    bool isWebApiError(int32_t error);

    template <typename T, typename RHT > class TransactionBase;
    template <typename T, typename RHT > class Transaction;
    template <typename T, typename RHT > class UpStreamTransaction;
    template <typename RHT > class DownStreamTransaction;
    template <typename T, typename RHT > class UpDownStreamTransaction;
    class LibContextImpl;
    class Initializer;
    class ResponseHeaderBase;

    template <typename T, typename RHT> class TransactionImpl;




    class LibContext {
    public:
     LibContext();

     typedef struct MemoryStats {
      size_t poolSize;
      size_t maxInuseSize;
      size_t currentInuseSize;
     } MemoryStats;

     friend class LibContextImpl;
     friend class Initializer;

     template <typename T, typename RHT >
     friend class TransactionBase;
     template <typename T, typename RHT >
     friend class Transaction;
     template <typename T, typename RHT >
     friend class UpStreamTransaction;
     template <typename RHT >
     friend class DownStreamTransaction;
     template <typename T, typename RHT >
     friend class UpDownStreamTransaction;

     int32_t getMemoryStats(MemoryStats & stats);

    private:
     LibContextImpl * m_impl;

     int32_t initialize(const InitParams & param, void **);
     void terminate();

     template <typename T, typename RHT>
     int32_t createTransaction(TransactionBase<T, RHT> &trans);
     template <typename T, typename RHT>
     int32_t createTransaction(Transaction<T, RHT> &trans);
     template <typename T, typename RHT>
     int32_t createTransaction(UpStreamTransaction<T, RHT> &trans);
     template <typename RHT>
     int32_t createTransaction(DownStreamTransaction<RHT> &trans);
     template <typename T, typename RHT>
     int32_t createTransaction(UpDownStreamTransaction<T, RHT> &trans);

     template <typename T, typename RHT>
     int32_t destroyTransaction(TransactionBase<T, RHT> &trans);
     template <typename T, typename RHT>
     int32_t destroyTransaction(Transaction<T, RHT> &trans);
     template <typename T, typename RHT>
     int32_t destroyTransaction(UpStreamTransaction<T, RHT> &trans);
     template <typename RHT>
     int32_t destroyTransaction(DownStreamTransaction<RHT> &trans);
     template <typename T, typename RHT>
     int32_t destroyTransaction(UpDownStreamTransaction<T, RHT> &trans);
     template <typename T, typename RHT>
     int32_t destroyTransaction(TransactionImpl<T, RHT> **transImpl, LibContextImpl **libCtxImpl);

    };


    typedef int64_t TransactionId;
    typedef int32_t ReturnCode;




    template <typename T, typename RHT = Common::IntrusivePtr<Common::ResponseHeaderBase> >
    class TransactionBase {
    public:
     TransactionBase(const TransactionBase<T, RHT> &src);
     TransactionBase<T, RHT>& operator=(const TransactionBase<T, RHT> &src);




     int32_t start(LibContext *ctx);




     int32_t finish();




     int32_t abort();




     int32_t getResponseHeaders(RHT &headers) const;

     void setResponseInformationOption(SceNpWebApi2ResponseInformationOption *respInfoOpt);
     SceNpWebApi2ResponseInformationOption* getResponseInformationOption();

     TransactionId getId() const;
     LibContext* getLibContext();

     friend class LibContext;
     friend class LibContextImpl;

    protected:
     TransactionBase();
     ~TransactionBase();
     LibContextImpl *m_ctxImpl;
     TransactionImpl<T, RHT> *m_impl;

    private:
     int32_t setNpWebApi2ReqId(int64_t reqId);
    };




    template <typename T, typename RHT = Common::IntrusivePtr<Common::ResponseHeaderBase> >
    class Transaction : public TransactionBase<T, RHT> {
    public:
     Transaction();
     ~Transaction();
     Transaction(const Transaction<T, RHT> &src);




     int32_t getResponse(T &response) const;
     bool hasResponse() const;

     int32_t setOnFinishedCallback(
      void (*onSucceededCallback)(TransactionId, ReturnCode, T, void*),
      void (*onFailedCallback)(TransactionId, ReturnCode, void*),
      void *userdata);

     friend class LibContext;
     friend class LibContextImpl;
    };

    class DefaultResponse
    {
    public:
     DefaultResponse();
     ~DefaultResponse();
    };

    class ResponseHeaderBaseImpl;
    class ResponseHeaderBase : public Common::RefObject
    {
    public:
     ResponseHeaderBase();
     ~ResponseHeaderBase();

     int32_t getHeaderValue(const char* fieldName, IntrusivePtr<Common::String> &value);

     static int32_t create(
      Common::LibContext * context,
      Common::IntrusivePtr<ResponseHeaderBase> &headersPtr,
      int64_t reqId
     );
     static void destroy(
      ResponseHeaderBase *headers
     );

     static int32_t parse(Common::LibContext* context, int64_t npWebApi2ReqId, Common::IntrusivePtr<ResponseHeaderBase>* headersPtr);
    protected:

     ResponseHeaderBaseImpl* m_pbaseimpl;
    };




    template <typename T, typename RHT = Common::IntrusivePtr<Common::ResponseHeaderBase> >
    class UpStreamTransaction : public TransactionBase<T, RHT> {
    public:
     UpStreamTransaction();
     ~UpStreamTransaction();
     UpStreamTransaction(const UpStreamTransaction<T, RHT> &src);

     int32_t start(LibContext *ctx, size_t contentLength);
     int32_t sendData(const void *buf, size_t bufSize);
     int32_t getResponse(T &response) const;

     friend class LibContext;
     friend class LibContextImpl;

    private:
     int32_t start(LibContext *ctx) = delete;
    };




    template <typename RHT = Common::IntrusivePtr<Common::ResponseHeaderBase> >
    class DownStreamTransaction : public TransactionBase<Common::DefaultResponse, RHT> {
    public:
     DownStreamTransaction();
     ~DownStreamTransaction();
     DownStreamTransaction(const DownStreamTransaction<RHT> &src);

     int32_t start(LibContext *ctx);
     int32_t finish();
     int32_t readData(char *buf, size_t bufSize);

     friend class LibContext;
     friend class LibContextImpl;
    };




    template <typename T, typename RHT = Common::IntrusivePtr<Common::ResponseHeaderBase> >
    class UpDownStreamTransaction : public TransactionBase<T, RHT> {
    public:
     UpDownStreamTransaction();
     ~UpDownStreamTransaction();
     UpDownStreamTransaction(const UpDownStreamTransaction<T, RHT> &src);

     int32_t start(LibContext *ctx, size_t contentLength);
     int32_t sendData(const void *buf, size_t bufSize);
     int32_t readData(char *buf, size_t bufSize);

     friend class LibContext;
     friend class LibContextImpl;
    };

   }
  }
 }
}

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/activities.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/activities/v1/userActivities/ActivityApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/activities/v1/userActivities/ActivityApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/ErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/ErrorResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\json2.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\json2.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\json2.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\json2.h" 2 3




namespace sce{
namespace Json{
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\json2.h" 3
enum ValueType
{
 kValueTypeNull = 0,
 kValueTypeBoolean,
 kValueTypeInteger,
 kValueTypeUInteger,
 kValueTypeReal,
 kValueTypeString,
 kValueTypeArray,
 kValueTypeObject,
};

enum SpecialFloatFormatType
{
 kSpecialFloatFormatTypeString,
 kSpecialFloatFormatTypeNull,
 kSpecialFloatFormatTypeSymbol
};

enum FunctionType
{
 kFunctionTypeReference,
 kFunctionTypeSetting
};

class MemAllocator
{
public:
 MemAllocator();
 virtual ~MemAllocator();
 virtual void* allocate(size_t size, void *userData) =0;
 virtual void deallocate(void *ptr, void *userData) =0;
 virtual void notifyError (int32_t error, size_t size, void* userData );
};

extern void* Malloc(size_t size);
extern void Free(void *ptr);

class Value;
class Parser;
class InputStream;
struct RootParam;
class ImplAccessor;
class String;

typedef const Value& (*TypeMismatchFunction)(ValueType accessType, const Value* errValue, const Value* parent, void* context);
typedef const Value (*SpecialFloatFunction)(FunctionType type, double errValue, const Value* parent, void* context, bool *returnError);
typedef void (*ElementAccessFailureFunction)(int32_t error, const String* key, const size_t* index, const Value* parent, const Value* errValue, void* context);

class String
{
public:
 String();
 String(const char*);
 String(const String&);
 ~String();

 int32_t compare( const String& ) const;
 int32_t compare( const char* ) const;
 size_t size() const;
 size_t length() const;
 unsigned char at(size_t pos) const;
 bool empty() const;
 const char* c_str() const;

 String& append( const String& );
 String& append( const char* );
 String& append( const char*, size_t );

 void clear();

 size_t find (const String& str, size_t pos = 0) const;
 size_t find (const char* s, size_t pos = 0) const;
 size_t find (const char* s, size_t pos, size_t n) const;
 size_t find (char c, size_t pos = 0) const;
 size_t rfind (const String& str, size_t pos = npos) const;
 size_t rfind (const char* s, size_t pos = npos) const;
 size_t rfind (const char* s, size_t pos, size_t n) const;
 size_t rfind (char c, size_t pos = npos) const;
 void resize (size_t n);
 String substr (size_t pos = 0, size_t len = npos) const;

 size_t capacity() const;
 void reserve(size_t res_arg = 0);

 bool operator==(const String&) const;
 bool operator==(const char*) const;

 String& operator=(const String&);
 String& operator+=(const char*);
 String& operator+=(unsigned char);

 static const size_t npos;

friend class ImplAccessor;
private:
 void* m_impl;
};


class Array
{

public:
 class iterator{
 public:
  iterator();
  iterator(const iterator&);
  ~iterator();

  bool operator!= (const iterator&) const;
  Value* operator-> () const;
  Value& operator* () const;

  iterator& operator ++ ();
  iterator& operator ++ (int);

  void advance(size_t off);

  iterator& operator = (const iterator&);

 friend class ImplAccessor;
 private:
  void* m_itimpl;
 };

 typedef iterator const_iterator;


public:
 Array();
 Array(const Array&);
 ~Array();

 iterator begin() const;
 iterator end() const ;
 iterator insert(const iterator&, const Value&);
 iterator erase(const iterator&);
 Value& back() const;
 Value& front() const;

 void clear();
 size_t size() const ;
 void push_back(const Value &val);
 void push_front(const Value &val);
 void pop_back();
 void pop_front();
 bool empty() const;

 Array& operator=(const Array&);

friend class ImplAccessor;
private:
 void copyArray(const Array& a);
 void* m_impl;


};

class Object;
class Value
{
 friend class Parser;
 friend class Object;
 friend class Array;

private:
 Value* m_parent;
 RootParam* m_rootparam;
 union {
  bool m_boolean;
  int64_t m_integer;
  uint64_t m_uinteger;
  double m_real;
  String* m_string;
  Array* m_array;
  Object* m_object;
 };
 char _padding[4];
 ValueType m_type;
public:
 ~Value();
 Value();
 Value(ValueType type);
 Value(bool b);
 Value(int64_t l);
 Value(uint64_t ul);
 Value(double n);
 Value(const char* s);
 Value(const String& s);
 Value(const Array& a);
 Value(const Object& o);
 Value(const Value& x);

 Value& operator=(const Value& x);
 operator bool() const;

 String toString() const
 {
  String str;
  toString(str);
  return str;
 }
 void toString(String& dst) const;

 typedef const Value& (*NullAccessFunction)(ValueType accesstype, const Value* parent, void* context);
 typedef int32_t (*DataReceiveFunction)(String& buf, void* userdata);
 int32_t serialize(String& buf, DataReceiveFunction func, void *userdata);
 int32_t serialize(String& dst);
 int32_t serialize(DataReceiveFunction func, void *userdata);

 void swap(Value& rhs);
 void clear();

 void set(ValueType type);
 void set(bool b);
 void set(int64_t l);
 void set(uint64_t ul);
 void set(double n);
 void set(const char* s);
 void set(const String& s);
 void set(const Array& a);
 void set(const Object& o);
 void set(const Value& x);

 static const String* s_nullstring;
 static const Array* s_nullarray;
 static const Object* s_nullobject;
 static const int64_t s_nullinteger;
 static const uint64_t s_nulluinteger;
 static const double s_nullreal;
 static const bool s_nullbool;

 ValueType getType() const;

 String* referString();
 Array* referArray();
 Object* referObject();
 const int64_t* referInteger();
 const uint64_t* referUInteger();
 const double* referReal();
 const bool* referBoolean();

 Value* referValue(size_t index);
 Value* referValue(const String& key);

 const String& getString() const;
 const Array& getArray() const;
 const Object& getObject() const;
 const int64_t& getInteger() const;
 const uint64_t& getUInteger() const;
 const double& getReal() const;
 const bool& getBoolean() const;

 const Value& getValue(size_t index) const;
 const Value& getValue(const String& key) const;
 const Value& operator[](size_t index) const;
 const Value& operator[](const String& key) const;
 const Value& operator[](const char *key) const;

 int32_t count() const;

 int32_t setNullAccessCallBack(NullAccessFunction func, void* context);
 int32_t setTypeMismatchHandler(TypeMismatchFunction func, void* context);
 int32_t setSpecialFloatHandler(SpecialFloatFunction func, void* context);
 int32_t setElementAccessFailureHandler(ElementAccessFailureFunction func, void* context);

private:
 int32_t setParent(const Value* parent);
 const Value* getRoot() const;
 int32_t serialize_internal(String& buf, DataReceiveFunction func, void *userdata, Value* parent=__null);
 bool invokeErrorHandlerForGetEachTypeValue(ValueType type, const Value** val) const;
 bool invokeTypeMismatchHandler(ValueType type, const Value** val) const;
 bool invokeNullAccessCallback(ValueType type, const Value** val) const;
 bool invokeGlobalTypeMismatchHandler(ValueType type, const Value** val) const;
 bool invokeGlobalNullAccessCallback(ValueType type, const Value** val) const;
 bool invokeSpecialFloatHandler(Value& val, FunctionType type, double errorValue, bool* returnError = __null) const;
 void invokeElementAccessFailureHandler(int32_t error, const String* key, const size_t* index) const;
 void clearHandlers(Value& val);
 void set(double n, int32_t* error);
 bool setSpecialFloat(double n);
 bool specialFloatToString(String& dst) const;
 void switchValue(Value& v);
 bool needWarning() const;
 void outputTypeMismatchWarning(ValueType type) const;
 void outputElementAccessFailureWarning(int32_t err, const Json::String *key, const size_t *index) const;
};


class Object
{
public:
 class Pair{
 public:
  Pair();
  Pair(const String& srcstr, const Value& srcval);
  ~Pair();
 public:
  String first;
  char _padding[4];
  Value second;
 };

 class iterator{
 public:
  iterator();
  iterator(const iterator&);
  ~iterator();

  bool operator == (const iterator&) const;
  bool operator != (const iterator&) const;

  iterator& operator ++ ();
  iterator& operator ++ (int);

  Pair* operator -> () const;
  Pair& operator * () const;

  iterator& operator = (const iterator&);

  void advance(size_t off);

 friend class ImplAccessor;
 private:
  void* m_itimpl;
 };

 typedef iterator const_iterator;

public:
 Object();
 Object(const Object&);

 ~Object();

 size_t size() const;

 iterator begin() const ;
 iterator end() const ;
 iterator find(const String& key) const ;
 iterator insert(const Pair& objpair);
 void erase(const String& key);
 void clear();
 bool empty() const;

 Value& operator[] (const String& key);
 Object& operator=(const Object&);

friend class ImplAccessor;
private:
 void copyObject(const Object& o);
 void* m_impl;
};

class Parser
{
public:
 typedef int32_t (*DataProvideFunction)(char& data, void* userdata);
 static int32_t parse(Value& dst, DataProvideFunction func, void *userdata);
 static int32_t parse(Value& dst, const char *src, size_t siz_src);
 static int32_t parse(Value& dst, const char *path);

private:
 static int parseQuadHex(InputStream& is);
 static bool parseCodePoint(String& str, InputStream& is);
 static bool parseString(String& s, InputStream& is);
 static bool parseArray(Value& v, InputStream& is, Value* parent, int32_t& error);
 static bool parseObject(Value& v, InputStream& is, Value* parent, int32_t& error);
 static bool parseString(Value& v, InputStream& is, Value* parent);
 static bool parseNumber(Value& v, InputStream& is, Value* parent, int32_t& error);
 static bool parseValue(Value& v, InputStream& is, Value* parent, int32_t& error);

};

class InitParameter
{
public:
 InitParameter()
  : allocator(0), userData(0), filebuffersize(0) {}

 InitParameter(MemAllocator *al, void *ud, size_t fbsiz)
  : allocator(al), userData(ud), filebuffersize(fbsiz) {}

 MemAllocator* allocator;
 void* userData;
 size_t filebuffersize;
};

class InitParameter2
{
public:
 InitParameter2();

 void setAllocator(MemAllocator* al, void* ud);
 void setFileBufferSize(size_t size);
 void setSpecialFloatFormatType(SpecialFloatFormatType type);

 MemAllocator* getAllocator() const;
 void* getUserData() const;
 size_t getFileBufferSize() const;
 SpecialFloatFormatType getSpecialFloatFormatType() const;

private:
 MemAllocator* m_allocator;
 void* m_userData;
 size_t m_filebuffersize;
 SpecialFloatFormatType m_floatType;
 uint32_t m_reserved[3];
};

class Initializer
{
public:
 Initializer();
 ~Initializer();
 int32_t initialize(const InitParameter* initparam);
 int32_t initialize(const InitParameter2* initparam);
 int32_t terminate();
 int32_t setGlobalTypeMismatchHandler(TypeMismatchFunction func, void* context);
 int32_t setGlobalNullAccessCallBack(Value::NullAccessFunction func, void* context);
 int32_t setGlobalSpecialFloatHandler(SpecialFloatFunction func, void* context);
 int32_t setGlobalElementAccessFailureHandler(ElementAccessFailureFunction func, void* context);

 typedef void(*AllocatorInfoFunction)(int32_t infono, ValueType accesstype, void* context);
 static int32_t setAllocatorInfoCallBack(AllocatorInfoFunction func, void* context);



 int32_t setGlobalNullAccessCallback(Value::NullAccessFunction func, void* context);

private:
 bool initstatus;
 int32_t initializeInternal();
 void clearGlobalHandlers();
};

inline Object::Pair make_pair(const String& srcstr, const Value& srcval)
{
 return Object::Pair(srcstr, srcval);
}

}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/ErrorResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Activities {
namespace V1 {
namespace UserActivities {

class Error : public Common::RefObject
{
public:

 int32_t getCode() const;
 void setCode(const int32_t &code);


 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool reasonIsSet() const;
 void unsetReason();
 const Common::String & getReason() const;
 int32_t setReason(const char* reason) __attribute__((warn_unused_result));


 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 bool sourceIsSet() const;
 void unsetSource();
 const Common::String & getSource() const;
 int32_t setSource(const char* source) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Activities::V1::UserActivities::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 int32_t m_code;

 Common::String m_message;

 Common::String m_reason;
 bool m_reasonIsSet;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;

 Common::String m_source;
 bool m_sourceIsSet;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t code,
  const char* message,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/ErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Activities {
namespace V1 {
namespace UserActivities {

class ErrorResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorResponse(Common::LibContext * context);
 friend class ErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Activities::V1::UserActivities::ErrorResponse>;

 ~ErrorResponse();

protected:
    ErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;


};

class ErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<Error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);


 static void destroy(ErrorResponse *instance);
};
using PsnErrorObject = ErrorResponse;
using PsnErrorObjectFactory = ErrorResponseFactory;


}
}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/activities/v1/userActivities/ActivityApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/GetUsersActivitiesResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/GetUsersActivitiesResponse.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/UserActivities.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/UserActivities.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/Activity.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/Activity.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Activities {
namespace V1 {
namespace UserActivities {

class Activity : public Common::RefObject
{
public:

 const Common::String & getActivityId() const;
 int32_t setActivityId(const char* activityId) __attribute__((warn_unused_result));


 const Common::String & getName() const;
 int32_t setName(const char* name) __attribute__((warn_unused_result));


 bool getHidden() const;
 void setHidden(const bool &hidden);


 bool matchIdIsSet() const;
 void unsetMatchId();
 const Common::String & getMatchId() const;
 int32_t setMatchId(const char* matchId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Activity(Common::LibContext * context);
 friend class ActivityFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Activities::V1::UserActivities::Activity>;

 ~Activity();

private:
 Common::LibContext * m_context;

 Common::String m_activityId;

 Common::String m_name;

 bool m_hidden;

 Common::String m_matchId;
 bool m_matchIdIsSet;


    Activity();
};

class ActivityFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* activityId,
  const char* name,
  bool hidden,
  sce::Np::CppWebApi::Common::IntrusivePtr<Activity> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Activity> *instancePtr);


 static void destroy(Activity *instance);
};


}
}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/UserActivities.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Activities {
namespace V1 {
namespace UserActivities {

class UserActivities : public Common::RefObject
{
public:

 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Activity>>> getActivities();
 int32_t setActivities(const Common::Vector<Common::IntrusivePtr<Activity>> &activities) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 UserActivities(Common::LibContext * context);
 friend class UserActivitiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Activities::V1::UserActivities::UserActivities>;

 ~UserActivities();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Activity>>> m_activities;


    UserActivities();
};

class UserActivitiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* accountId,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Activity>>>::value_type &activities,
  sce::Np::CppWebApi::Common::IntrusivePtr<UserActivities> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<UserActivities> *instancePtr);


 static void destroy(UserActivities *instance);
};


}
}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Activities/V1/UserActivities/GetUsersActivitiesResponse.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Activities {
namespace V1 {
namespace UserActivities {

class GetUsersActivitiesResponse : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<UserActivities>>> getUsers();
 int32_t setUsers(const Common::Vector<Common::IntrusivePtr<UserActivities>> &users) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetUsersActivitiesResponse(Common::LibContext * context);
 friend class GetUsersActivitiesResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Activities::V1::UserActivities::GetUsersActivitiesResponse>;

 ~GetUsersActivitiesResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<UserActivities>>> m_users;


    GetUsersActivitiesResponse();
};

class GetUsersActivitiesResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<UserActivities>>>::value_type &users,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetUsersActivitiesResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetUsersActivitiesResponse> *instancePtr);


 static void destroy(GetUsersActivitiesResponse *instance);
};


}
}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/activities/v1/userActivities/ActivityApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace Activities {
namespace V1 {
namespace UserActivities {

class ActivityApi {
public:

 class ParameterToGetUserActivities : public Common::ParameterBase {
 public:
  ParameterToGetUserActivities();
  ~ParameterToGetUserActivities();

  int32_t initialize(
   Common::LibContext * context
   , Common::IntrusivePtr<Common::Vector<Common::String>> accountIds
   );

  int32_t terminate();

  bool isInitialized() const;


  Common::IntrusivePtr<Common::Vector<Common::String>> getaccountIds() const;
  void setaccountIds(Common::IntrusivePtr<Common::Vector<Common::String>> accountIds);


  const Common::String& getacceptLanguage() const;
  int32_t setacceptLanguage(const char* acceptLanguage) __attribute__((warn_unused_result));
  void unsetacceptLanguage();
  bool hasacceptLanguage() const;


  int32_t getnpServiceLabel() const;
  void setnpServiceLabel(int32_t npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;

  struct ParameterImplToGetUserActivities;

 private:
  struct ParameterImplToGetUserActivities *m_pimpl;

  ParameterToGetUserActivities(ParameterToGetUserActivities &param);
  ParameterToGetUserActivities(const ParameterToGetUserActivities &param);
  ParameterToGetUserActivities& operator=(ParameterToGetUserActivities &param);
  ParameterToGetUserActivities& operator=(const ParameterToGetUserActivities &param);
 };

 static int32_t getUserActivities(
  int32_t npwebapiUserCtxId,
  const ParameterToGetUserActivities &param,
  Common::Transaction<Common::IntrusivePtr<GetUsersActivitiesResponse>> &transaction
  );

private:
 ActivityApi();
 ~ActivityApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/activities.h" 2 3
# 323 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/advanced_player_profile.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/advancedplayerprofile/v1/StatsApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/advancedplayerprofile/v1/StatsApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ErrorResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class Error : public Common::RefObject
{
public:

 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 bool codeIsSet() const;
 void unsetCode();
 int32_t getCode() const;
 void setCode(const int32_t &code);


 bool messageIsSet() const;
 void unsetMessage();
 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;

 int32_t m_code;
 bool m_codeIsSet;

 Common::String m_message;
 bool m_messageIsSet;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class ErrorResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorResponse(Common::LibContext * context);
 friend class ErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::ErrorResponse>;

 ~ErrorResponse();

protected:
    ErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;


};

class ErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<Error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);


 static void destroy(ErrorResponse *instance);
};
using PsnErrorObject = ErrorResponse;
using PsnErrorObjectFactory = ErrorResponseFactory;


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/advancedplayerprofile/v1/StatsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Bandwidth.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Bandwidth.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/BandwidthProperties.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/BandwidthProperties.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/BandwidthUpstreamMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/BandwidthUpstreamMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class BandwidthUpstreamMetrics : public Common::RefObject
{
public:

 int32_t getAverage() const;
 void setAverage(const int32_t &average);


 int32_t getConfidenceScore() const;
 void setConfidenceScore(const int32_t &confidenceScore);


 int32_t getStandardDeviation() const;
 void setStandardDeviation(const int32_t &standardDeviation);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 BandwidthUpstreamMetrics(Common::LibContext * context);
 friend class BandwidthUpstreamMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::BandwidthUpstreamMetrics>;

 ~BandwidthUpstreamMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_average;

 int32_t m_confidenceScore;

 int32_t m_standardDeviation;


    BandwidthUpstreamMetrics();
};

class BandwidthUpstreamMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t average,
  int32_t confidenceScore,
  int32_t standardDeviation,
  sce::Np::CppWebApi::Common::IntrusivePtr<BandwidthUpstreamMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<BandwidthUpstreamMetrics> *instancePtr);


 static void destroy(BandwidthUpstreamMetrics *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/BandwidthProperties.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/BandwidthDownstreamMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/BandwidthDownstreamMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class BandwidthDownstreamMetrics : public Common::RefObject
{
public:

 int32_t getAverage() const;
 void setAverage(const int32_t &average);


 int32_t getConfidenceScore() const;
 void setConfidenceScore(const int32_t &confidenceScore);


 int32_t getStandardDeviation() const;
 void setStandardDeviation(const int32_t &standardDeviation);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 BandwidthDownstreamMetrics(Common::LibContext * context);
 friend class BandwidthDownstreamMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::BandwidthDownstreamMetrics>;

 ~BandwidthDownstreamMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_average;

 int32_t m_confidenceScore;

 int32_t m_standardDeviation;


    BandwidthDownstreamMetrics();
};

class BandwidthDownstreamMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t average,
  int32_t confidenceScore,
  int32_t standardDeviation,
  sce::Np::CppWebApi::Common::IntrusivePtr<BandwidthDownstreamMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<BandwidthDownstreamMetrics> *instancePtr);


 static void destroy(BandwidthDownstreamMetrics *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/BandwidthProperties.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class BandwidthProperties : public Common::RefObject
{
public:

 Common::IntrusivePtr<BandwidthDownstreamMetrics> getDownstream() const;
 int32_t setDownstream(const Common::IntrusivePtr<BandwidthDownstreamMetrics> &downstream) __attribute__((warn_unused_result));


 Common::IntrusivePtr<BandwidthUpstreamMetrics> getUpstream() const;
 int32_t setUpstream(const Common::IntrusivePtr<BandwidthUpstreamMetrics> &upstream) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 BandwidthProperties(Common::LibContext * context);
 friend class BandwidthPropertiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::BandwidthProperties>;

 ~BandwidthProperties();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<BandwidthDownstreamMetrics> m_downstream;

 Common::IntrusivePtr<BandwidthUpstreamMetrics> m_upstream;


    BandwidthProperties();
};

class BandwidthPropertiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<BandwidthDownstreamMetrics> downstream,
  Common::IntrusivePtr<BandwidthUpstreamMetrics> upstream,
  sce::Np::CppWebApi::Common::IntrusivePtr<BandwidthProperties> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<BandwidthProperties> *instancePtr);


 static void destroy(BandwidthProperties *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Bandwidth.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class Bandwidth : public Common::RefObject
{
public:

 bool globalIsSet() const;
 void unsetGlobal();
 Common::IntrusivePtr<BandwidthProperties> getGlobal() const;
 int32_t setGlobal(const Common::IntrusivePtr<BandwidthProperties> &global) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Bandwidth(Common::LibContext * context);
 friend class BandwidthFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::Bandwidth>;

 ~Bandwidth();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<BandwidthProperties> m_global;
 bool m_globalIsSet;


    Bandwidth();
};

class BandwidthFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Bandwidth> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Bandwidth> *instancePtr);


 static void destroy(Bandwidth *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Reputation.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Reputation.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ReputationProperties.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ReputationProperties.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class ReputationProperties : public Common::RefObject
{
public:

 int32_t getGoodSport() const;
 void setGoodSport(const int32_t &goodSport);


 int32_t getHelpful() const;
 void setHelpful(const int32_t &helpful);


 int32_t getLeader() const;
 void setLeader(const int32_t &leader);


 int32_t getNumberOfMatches() const;
 void setNumberOfMatches(const int32_t &numberOfMatches);


 int32_t getWelcoming() const;
 void setWelcoming(const int32_t &welcoming);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ReputationProperties(Common::LibContext * context);
 friend class ReputationPropertiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::ReputationProperties>;

 ~ReputationProperties();

private:
 Common::LibContext * m_context;

 int32_t m_goodSport;

 int32_t m_helpful;

 int32_t m_leader;

 int32_t m_numberOfMatches;

 int32_t m_welcoming;


    ReputationProperties();
};

class ReputationPropertiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t goodSport,
  int32_t helpful,
  int32_t leader,
  int32_t numberOfMatches,
  int32_t welcoming,
  sce::Np::CppWebApi::Common::IntrusivePtr<ReputationProperties> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ReputationProperties> *instancePtr);


 static void destroy(ReputationProperties *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Reputation.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class Reputation : public Common::RefObject
{
public:

 bool globalIsSet() const;
 void unsetGlobal();
 Common::IntrusivePtr<ReputationProperties> getGlobal() const;
 int32_t setGlobal(const Common::IntrusivePtr<ReputationProperties> &global) __attribute__((warn_unused_result));


 bool perFranchiseIsSet() const;
 void unsetPerFranchise();
 Common::IntrusivePtr<ReputationProperties> getPerFranchise() const;
 int32_t setPerFranchise(const Common::IntrusivePtr<ReputationProperties> &perFranchise) __attribute__((warn_unused_result));


 bool perGameIsSet() const;
 void unsetPerGame();
 Common::IntrusivePtr<ReputationProperties> getPerGame() const;
 int32_t setPerGame(const Common::IntrusivePtr<ReputationProperties> &perGame) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Reputation(Common::LibContext * context);
 friend class ReputationFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::Reputation>;

 ~Reputation();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<ReputationProperties> m_global;
 bool m_globalIsSet;

 Common::IntrusivePtr<ReputationProperties> m_perFranchise;
 bool m_perFranchiseIsSet;

 Common::IntrusivePtr<ReputationProperties> m_perGame;
 bool m_perGameIsSet;


    Reputation();
};

class ReputationFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Reputation> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Reputation> *instancePtr);


 static void destroy(Reputation *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Mmr.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Mmr.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MmrProperties.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MmrProperties.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class MmrProperties : public Common::RefObject
{
public:

 int32_t getRating() const;
 void setRating(const int32_t &rating);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MmrProperties(Common::LibContext * context);
 friend class MmrPropertiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::MmrProperties>;

 ~MmrProperties();

private:
 Common::LibContext * m_context;

 int32_t m_rating;


    MmrProperties();
};

class MmrPropertiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t rating,
  sce::Np::CppWebApi::Common::IntrusivePtr<MmrProperties> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MmrProperties> *instancePtr);


 static void destroy(MmrProperties *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Mmr.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class Mmr : public Common::RefObject
{
public:

 bool perFranchiseIsSet() const;
 void unsetPerFranchise();
 Common::IntrusivePtr<MmrProperties> getPerFranchise() const;
 int32_t setPerFranchise(const Common::IntrusivePtr<MmrProperties> &perFranchise) __attribute__((warn_unused_result));


 bool perGenreIsSet() const;
 void unsetPerGenre();
 Common::IntrusivePtr<MmrProperties> getPerGenre() const;
 int32_t setPerGenre(const Common::IntrusivePtr<MmrProperties> &perGenre) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Mmr(Common::LibContext * context);
 friend class MmrFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::Mmr>;

 ~Mmr();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<MmrProperties> m_perFranchise;
 bool m_perFranchiseIsSet;

 Common::IntrusivePtr<MmrProperties> m_perGenre;
 bool m_perGenreIsSet;


    Mmr();
};

class MmrFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Mmr> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Mmr> *instancePtr);


 static void destroy(Mmr *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivity.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivity.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivityProperties.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivityProperties.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivityFrom.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivityFrom.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivityToMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivityToMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class NatConnectivityToMetrics : public Common::RefObject
{
public:

 int32_t getConfidenceScore() const;
 void setConfidenceScore(const int32_t &confidenceScore);


 int32_t getSuccessRate() const;
 void setSuccessRate(const int32_t &successRate);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 NatConnectivityToMetrics(Common::LibContext * context);
 friend class NatConnectivityToMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::NatConnectivityToMetrics>;

 ~NatConnectivityToMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_confidenceScore;

 int32_t m_successRate;


    NatConnectivityToMetrics();
};

class NatConnectivityToMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t confidenceScore,
  int32_t successRate,
  sce::Np::CppWebApi::Common::IntrusivePtr<NatConnectivityToMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<NatConnectivityToMetrics> *instancePtr);


 static void destroy(NatConnectivityToMetrics *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivityFrom.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class NatConnectivityFrom : public Common::RefObject
{
public:

 Common::IntrusivePtr<NatConnectivityToMetrics> getToNat1() const;
 int32_t setToNat1(const Common::IntrusivePtr<NatConnectivityToMetrics> &toNat1) __attribute__((warn_unused_result));


 Common::IntrusivePtr<NatConnectivityToMetrics> getToNat2() const;
 int32_t setToNat2(const Common::IntrusivePtr<NatConnectivityToMetrics> &toNat2) __attribute__((warn_unused_result));


 Common::IntrusivePtr<NatConnectivityToMetrics> getToNat3() const;
 int32_t setToNat3(const Common::IntrusivePtr<NatConnectivityToMetrics> &toNat3) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 NatConnectivityFrom(Common::LibContext * context);
 friend class NatConnectivityFromFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::NatConnectivityFrom>;

 ~NatConnectivityFrom();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<NatConnectivityToMetrics> m_toNat1;

 Common::IntrusivePtr<NatConnectivityToMetrics> m_toNat2;

 Common::IntrusivePtr<NatConnectivityToMetrics> m_toNat3;


    NatConnectivityFrom();
};

class NatConnectivityFromFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<NatConnectivityToMetrics> toNat1,
  Common::IntrusivePtr<NatConnectivityToMetrics> toNat2,
  Common::IntrusivePtr<NatConnectivityToMetrics> toNat3,
  sce::Np::CppWebApi::Common::IntrusivePtr<NatConnectivityFrom> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<NatConnectivityFrom> *instancePtr);


 static void destroy(NatConnectivityFrom *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivityProperties.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class NatConnectivityProperties : public Common::RefObject
{
public:

 Common::IntrusivePtr<NatConnectivityFrom> getFromNat1() const;
 int32_t setFromNat1(const Common::IntrusivePtr<NatConnectivityFrom> &fromNat1) __attribute__((warn_unused_result));


 Common::IntrusivePtr<NatConnectivityFrom> getFromNat2() const;
 int32_t setFromNat2(const Common::IntrusivePtr<NatConnectivityFrom> &fromNat2) __attribute__((warn_unused_result));


 Common::IntrusivePtr<NatConnectivityFrom> getFromNat3() const;
 int32_t setFromNat3(const Common::IntrusivePtr<NatConnectivityFrom> &fromNat3) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 NatConnectivityProperties(Common::LibContext * context);
 friend class NatConnectivityPropertiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::NatConnectivityProperties>;

 ~NatConnectivityProperties();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<NatConnectivityFrom> m_fromNat1;

 Common::IntrusivePtr<NatConnectivityFrom> m_fromNat2;

 Common::IntrusivePtr<NatConnectivityFrom> m_fromNat3;


    NatConnectivityProperties();
};

class NatConnectivityPropertiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<NatConnectivityFrom> fromNat1,
  Common::IntrusivePtr<NatConnectivityFrom> fromNat2,
  Common::IntrusivePtr<NatConnectivityFrom> fromNat3,
  sce::Np::CppWebApi::Common::IntrusivePtr<NatConnectivityProperties> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<NatConnectivityProperties> *instancePtr);


 static void destroy(NatConnectivityProperties *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/NatConnectivity.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class NatConnectivity : public Common::RefObject
{
public:

 bool globalIsSet() const;
 void unsetGlobal();
 Common::IntrusivePtr<NatConnectivityProperties> getGlobal() const;
 int32_t setGlobal(const Common::IntrusivePtr<NatConnectivityProperties> &global) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 NatConnectivity(Common::LibContext * context);
 friend class NatConnectivityFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::NatConnectivity>;

 ~NatConnectivity();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<NatConnectivityProperties> m_global;
 bool m_globalIsSet;


    NatConnectivity();
};

class NatConnectivityFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<NatConnectivity> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<NatConnectivity> *instancePtr);


 static void destroy(NatConnectivity *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQuality.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQuality.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQualityProperties.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQualityProperties.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQualityWirelessMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQualityWirelessMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class ConnectionQualityWirelessMetrics : public Common::RefObject
{
public:

 int32_t getConfidenceScore() const;
 void setConfidenceScore(const int32_t &confidenceScore);


 double getJitter() const;
 void setJitter(const double &jitter);


 int32_t getPacketLossRate() const;
 void setPacketLossRate(const int32_t &packetLossRate);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ConnectionQualityWirelessMetrics(Common::LibContext * context);
 friend class ConnectionQualityWirelessMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::ConnectionQualityWirelessMetrics>;

 ~ConnectionQualityWirelessMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_confidenceScore;

 double m_jitter;

 int32_t m_packetLossRate;


    ConnectionQualityWirelessMetrics();
};

class ConnectionQualityWirelessMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t confidenceScore,
  double jitter,
  int32_t packetLossRate,
  sce::Np::CppWebApi::Common::IntrusivePtr<ConnectionQualityWirelessMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ConnectionQualityWirelessMetrics> *instancePtr);


 static void destroy(ConnectionQualityWirelessMetrics *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQualityProperties.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQualityWiredMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQualityWiredMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class ConnectionQualityWiredMetrics : public Common::RefObject
{
public:

 int32_t getConfidenceScore() const;
 void setConfidenceScore(const int32_t &confidenceScore);


 double getJitter() const;
 void setJitter(const double &jitter);


 int32_t getPacketLossRate() const;
 void setPacketLossRate(const int32_t &packetLossRate);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ConnectionQualityWiredMetrics(Common::LibContext * context);
 friend class ConnectionQualityWiredMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::ConnectionQualityWiredMetrics>;

 ~ConnectionQualityWiredMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_confidenceScore;

 double m_jitter;

 int32_t m_packetLossRate;


    ConnectionQualityWiredMetrics();
};

class ConnectionQualityWiredMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t confidenceScore,
  double jitter,
  int32_t packetLossRate,
  sce::Np::CppWebApi::Common::IntrusivePtr<ConnectionQualityWiredMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ConnectionQualityWiredMetrics> *instancePtr);


 static void destroy(ConnectionQualityWiredMetrics *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQualityProperties.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class ConnectionQualityProperties : public Common::RefObject
{
public:

 Common::IntrusivePtr<ConnectionQualityWiredMetrics> getWired() const;
 int32_t setWired(const Common::IntrusivePtr<ConnectionQualityWiredMetrics> &wired) __attribute__((warn_unused_result));


 Common::IntrusivePtr<ConnectionQualityWirelessMetrics> getWireless() const;
 int32_t setWireless(const Common::IntrusivePtr<ConnectionQualityWirelessMetrics> &wireless) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ConnectionQualityProperties(Common::LibContext * context);
 friend class ConnectionQualityPropertiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::ConnectionQualityProperties>;

 ~ConnectionQualityProperties();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<ConnectionQualityWiredMetrics> m_wired;

 Common::IntrusivePtr<ConnectionQualityWirelessMetrics> m_wireless;


    ConnectionQualityProperties();
};

class ConnectionQualityPropertiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<ConnectionQualityWiredMetrics> wired,
  Common::IntrusivePtr<ConnectionQualityWirelessMetrics> wireless,
  sce::Np::CppWebApi::Common::IntrusivePtr<ConnectionQualityProperties> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ConnectionQualityProperties> *instancePtr);


 static void destroy(ConnectionQualityProperties *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/ConnectionQuality.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class ConnectionQuality : public Common::RefObject
{
public:

 bool globalIsSet() const;
 void unsetGlobal();
 Common::IntrusivePtr<ConnectionQualityProperties> getGlobal() const;
 int32_t setGlobal(const Common::IntrusivePtr<ConnectionQualityProperties> &global) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ConnectionQuality(Common::LibContext * context);
 friend class ConnectionQualityFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::ConnectionQuality>;

 ~ConnectionQuality();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<ConnectionQualityProperties> m_global;
 bool m_globalIsSet;


    ConnectionQuality();
};

class ConnectionQualityFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ConnectionQuality> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ConnectionQuality> *instancePtr);


 static void destroy(ConnectionQuality *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMuted.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMuted.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMutedProperties.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMutedProperties.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMutedInPartyMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMutedInPartyMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class FrequentlyMutedInPartyMetrics : public Common::RefObject
{
public:

 int32_t getConfidenceScore() const;
 void setConfidenceScore(const int32_t &confidenceScore);


 int32_t getNumberOfTimes() const;
 void setNumberOfTimes(const int32_t &numberOfTimes);


 int32_t getPercentileRank() const;
 void setPercentileRank(const int32_t &percentileRank);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FrequentlyMutedInPartyMetrics(Common::LibContext * context);
 friend class FrequentlyMutedInPartyMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::FrequentlyMutedInPartyMetrics>;

 ~FrequentlyMutedInPartyMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_confidenceScore;

 int32_t m_numberOfTimes;

 int32_t m_percentileRank;


    FrequentlyMutedInPartyMetrics();
};

class FrequentlyMutedInPartyMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t confidenceScore,
  int32_t numberOfTimes,
  int32_t percentileRank,
  sce::Np::CppWebApi::Common::IntrusivePtr<FrequentlyMutedInPartyMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FrequentlyMutedInPartyMetrics> *instancePtr);


 static void destroy(FrequentlyMutedInPartyMetrics *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMutedProperties.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMutedInGameMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMutedInGameMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class FrequentlyMutedInGameMetrics : public Common::RefObject
{
public:

 int32_t getConfidenceScore() const;
 void setConfidenceScore(const int32_t &confidenceScore);


 int32_t getNumberOfTimes() const;
 void setNumberOfTimes(const int32_t &numberOfTimes);


 int32_t getPercentileRank() const;
 void setPercentileRank(const int32_t &percentileRank);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FrequentlyMutedInGameMetrics(Common::LibContext * context);
 friend class FrequentlyMutedInGameMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::FrequentlyMutedInGameMetrics>;

 ~FrequentlyMutedInGameMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_confidenceScore;

 int32_t m_numberOfTimes;

 int32_t m_percentileRank;


    FrequentlyMutedInGameMetrics();
};

class FrequentlyMutedInGameMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t confidenceScore,
  int32_t numberOfTimes,
  int32_t percentileRank,
  sce::Np::CppWebApi::Common::IntrusivePtr<FrequentlyMutedInGameMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FrequentlyMutedInGameMetrics> *instancePtr);


 static void destroy(FrequentlyMutedInGameMetrics *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMutedProperties.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class FrequentlyMutedProperties : public Common::RefObject
{
public:

 Common::IntrusivePtr<FrequentlyMutedInGameMetrics> getInGame() const;
 int32_t setInGame(const Common::IntrusivePtr<FrequentlyMutedInGameMetrics> &inGame) __attribute__((warn_unused_result));


 Common::IntrusivePtr<FrequentlyMutedInPartyMetrics> getInParty() const;
 int32_t setInParty(const Common::IntrusivePtr<FrequentlyMutedInPartyMetrics> &inParty) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FrequentlyMutedProperties(Common::LibContext * context);
 friend class FrequentlyMutedPropertiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::FrequentlyMutedProperties>;

 ~FrequentlyMutedProperties();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<FrequentlyMutedInGameMetrics> m_inGame;

 Common::IntrusivePtr<FrequentlyMutedInPartyMetrics> m_inParty;


    FrequentlyMutedProperties();
};

class FrequentlyMutedPropertiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<FrequentlyMutedInGameMetrics> inGame,
  Common::IntrusivePtr<FrequentlyMutedInPartyMetrics> inParty,
  sce::Np::CppWebApi::Common::IntrusivePtr<FrequentlyMutedProperties> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FrequentlyMutedProperties> *instancePtr);


 static void destroy(FrequentlyMutedProperties *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/FrequentlyMuted.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class FrequentlyMuted : public Common::RefObject
{
public:

 bool globalIsSet() const;
 void unsetGlobal();
 Common::IntrusivePtr<FrequentlyMutedProperties> getGlobal() const;
 int32_t setGlobal(const Common::IntrusivePtr<FrequentlyMutedProperties> &global) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FrequentlyMuted(Common::LibContext * context);
 friend class FrequentlyMutedFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::FrequentlyMuted>;

 ~FrequentlyMuted();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<FrequentlyMutedProperties> m_global;
 bool m_globalIsSet;


    FrequentlyMuted();
};

class FrequentlyMutedFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<FrequentlyMuted> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FrequentlyMuted> *instancePtr);


 static void destroy(FrequentlyMuted *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/PlayStyle.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/PlayStyle.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/PlayStyleProperties.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/PlayStyleProperties.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class PlayStyleProperties : public Common::RefObject
{
public:

 int32_t getChallenge() const;
 void setChallenge(const int32_t &challenge);


 int32_t getCompetitive() const;
 void setCompetitive(const int32_t &competitive);


 int32_t getOpenEnded() const;
 void setOpenEnded(const int32_t &openEnded);


 int32_t getProgress() const;
 void setProgress(const int32_t &progress);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayStyleProperties(Common::LibContext * context);
 friend class PlayStylePropertiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::PlayStyleProperties>;

 ~PlayStyleProperties();

private:
 Common::LibContext * m_context;

 int32_t m_challenge;

 int32_t m_competitive;

 int32_t m_openEnded;

 int32_t m_progress;


    PlayStyleProperties();
};

class PlayStylePropertiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t challenge,
  int32_t competitive,
  int32_t openEnded,
  int32_t progress,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayStyleProperties> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayStyleProperties> *instancePtr);


 static void destroy(PlayStyleProperties *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/PlayStyle.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class PlayStyle : public Common::RefObject
{
public:

 bool globalIsSet() const;
 void unsetGlobal();
 Common::IntrusivePtr<PlayStyleProperties> getGlobal() const;
 int32_t setGlobal(const Common::IntrusivePtr<PlayStyleProperties> &global) __attribute__((warn_unused_result));


 bool perFranchiseIsSet() const;
 void unsetPerFranchise();
 Common::IntrusivePtr<PlayStyleProperties> getPerFranchise() const;
 int32_t setPerFranchise(const Common::IntrusivePtr<PlayStyleProperties> &perFranchise) __attribute__((warn_unused_result));


 bool perGameIsSet() const;
 void unsetPerGame();
 Common::IntrusivePtr<PlayStyleProperties> getPerGame() const;
 int32_t setPerGame(const Common::IntrusivePtr<PlayStyleProperties> &perGame) __attribute__((warn_unused_result));


 bool perGenreIsSet() const;
 void unsetPerGenre();
 Common::IntrusivePtr<PlayStyleProperties> getPerGenre() const;
 int32_t setPerGenre(const Common::IntrusivePtr<PlayStyleProperties> &perGenre) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayStyle(Common::LibContext * context);
 friend class PlayStyleFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::PlayStyle>;

 ~PlayStyle();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<PlayStyleProperties> m_global;
 bool m_globalIsSet;

 Common::IntrusivePtr<PlayStyleProperties> m_perFranchise;
 bool m_perFranchiseIsSet;

 Common::IntrusivePtr<PlayStyleProperties> m_perGame;
 bool m_perGameIsSet;

 Common::IntrusivePtr<PlayStyleProperties> m_perGenre;
 bool m_perGenreIsSet;


    PlayStyle();
};

class PlayStyleFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayStyle> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayStyle> *instancePtr);


 static void destroy(PlayStyle *instance);
};


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRate.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRate.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateProperties.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateProperties.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateQuitMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateQuitMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class MatchCompletionRateQuitMetrics : public Common::RefObject
{
public:

 int32_t getCompletionRatePerReasons() const;
 void setCompletionRatePerReasons(const int32_t &completionRatePerReasons);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MatchCompletionRateQuitMetrics(Common::LibContext * context);
 friend class MatchCompletionRateQuitMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::MatchCompletionRateQuitMetrics>;

 ~MatchCompletionRateQuitMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_completionRatePerReasons;


    MatchCompletionRateQuitMetrics();
};

class MatchCompletionRateQuitMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t completionRatePerReasons,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRateQuitMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRateQuitMetrics> *instancePtr);


 static void destroy(MatchCompletionRateQuitMetrics *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateProperties.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateCompletedMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateCompletedMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class MatchCompletionRateCompletedMetrics : public Common::RefObject
{
public:

 int32_t getCompletionRatePerReasons() const;
 void setCompletionRatePerReasons(const int32_t &completionRatePerReasons);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MatchCompletionRateCompletedMetrics(Common::LibContext * context);
 friend class MatchCompletionRateCompletedMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::MatchCompletionRateCompletedMetrics>;

 ~MatchCompletionRateCompletedMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_completionRatePerReasons;


    MatchCompletionRateCompletedMetrics();
};

class MatchCompletionRateCompletedMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t completionRatePerReasons,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRateCompletedMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRateCompletedMetrics> *instancePtr);


 static void destroy(MatchCompletionRateCompletedMetrics *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateProperties.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateDisconnectedMetrics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateDisconnectedMetrics.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class MatchCompletionRateDisconnectedMetrics : public Common::RefObject
{
public:

 int32_t getCompletionRatePerReasons() const;
 void setCompletionRatePerReasons(const int32_t &completionRatePerReasons);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MatchCompletionRateDisconnectedMetrics(Common::LibContext * context);
 friend class MatchCompletionRateDisconnectedMetricsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::MatchCompletionRateDisconnectedMetrics>;

 ~MatchCompletionRateDisconnectedMetrics();

private:
 Common::LibContext * m_context;

 int32_t m_completionRatePerReasons;


    MatchCompletionRateDisconnectedMetrics();
};

class MatchCompletionRateDisconnectedMetricsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t completionRatePerReasons,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRateDisconnectedMetrics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRateDisconnectedMetrics> *instancePtr);


 static void destroy(MatchCompletionRateDisconnectedMetrics *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRateProperties.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class MatchCompletionRateProperties : public Common::RefObject
{
public:

 Common::IntrusivePtr<MatchCompletionRateCompletedMetrics> getCompleted() const;
 int32_t setCompleted(const Common::IntrusivePtr<MatchCompletionRateCompletedMetrics> &completed) __attribute__((warn_unused_result));


 int32_t getConfidenceScore() const;
 void setConfidenceScore(const int32_t &confidenceScore);


 Common::IntrusivePtr<MatchCompletionRateDisconnectedMetrics> getDisconnected() const;
 int32_t setDisconnected(const Common::IntrusivePtr<MatchCompletionRateDisconnectedMetrics> &disconnected) __attribute__((warn_unused_result));


 Common::IntrusivePtr<MatchCompletionRateQuitMetrics> getQuit() const;
 int32_t setQuit(const Common::IntrusivePtr<MatchCompletionRateQuitMetrics> &quit) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MatchCompletionRateProperties(Common::LibContext * context);
 friend class MatchCompletionRatePropertiesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::MatchCompletionRateProperties>;

 ~MatchCompletionRateProperties();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<MatchCompletionRateCompletedMetrics> m_completed;

 int32_t m_confidenceScore;

 Common::IntrusivePtr<MatchCompletionRateDisconnectedMetrics> m_disconnected;

 Common::IntrusivePtr<MatchCompletionRateQuitMetrics> m_quit;


    MatchCompletionRateProperties();
};

class MatchCompletionRatePropertiesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<MatchCompletionRateCompletedMetrics> completed,
  int32_t confidenceScore,
  Common::IntrusivePtr<MatchCompletionRateDisconnectedMetrics> disconnected,
  Common::IntrusivePtr<MatchCompletionRateQuitMetrics> quit,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRateProperties> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRateProperties> *instancePtr);


 static void destroy(MatchCompletionRateProperties *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/MatchCompletionRate.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class MatchCompletionRate : public Common::RefObject
{
public:

 bool globalIsSet() const;
 void unsetGlobal();
 Common::IntrusivePtr<MatchCompletionRateProperties> getGlobal() const;
 int32_t setGlobal(const Common::IntrusivePtr<MatchCompletionRateProperties> &global) __attribute__((warn_unused_result));


 bool perFranchiseIsSet() const;
 void unsetPerFranchise();
 Common::IntrusivePtr<MatchCompletionRateProperties> getPerFranchise() const;
 int32_t setPerFranchise(const Common::IntrusivePtr<MatchCompletionRateProperties> &perFranchise) __attribute__((warn_unused_result));


 bool perGameIsSet() const;
 void unsetPerGame();
 Common::IntrusivePtr<MatchCompletionRateProperties> getPerGame() const;
 int32_t setPerGame(const Common::IntrusivePtr<MatchCompletionRateProperties> &perGame) __attribute__((warn_unused_result));


 bool perGenreIsSet() const;
 void unsetPerGenre();
 Common::IntrusivePtr<MatchCompletionRateProperties> getPerGenre() const;
 int32_t setPerGenre(const Common::IntrusivePtr<MatchCompletionRateProperties> &perGenre) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MatchCompletionRate(Common::LibContext * context);
 friend class MatchCompletionRateFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::MatchCompletionRate>;

 ~MatchCompletionRate();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<MatchCompletionRateProperties> m_global;
 bool m_globalIsSet;

 Common::IntrusivePtr<MatchCompletionRateProperties> m_perFranchise;
 bool m_perFranchiseIsSet;

 Common::IntrusivePtr<MatchCompletionRateProperties> m_perGame;
 bool m_perGameIsSet;

 Common::IntrusivePtr<MatchCompletionRateProperties> m_perGenre;
 bool m_perGenreIsSet;


    MatchCompletionRate();
};

class MatchCompletionRateFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRate> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchCompletionRate> *instancePtr);


 static void destroy(MatchCompletionRate *instance);
};


}
}
}
}
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/AdvancedPlayerProfile/V1/Stats.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class Stats : public PsnErrorObject
{
public:

 bool bandwidthIsSet() const;
 void unsetBandwidth();
 Common::IntrusivePtr<Bandwidth> getBandwidth() const;
 int32_t setBandwidth(const Common::IntrusivePtr<Bandwidth> &bandwidth) __attribute__((warn_unused_result));


 bool connectionQualityIsSet() const;
 void unsetConnectionQuality();
 Common::IntrusivePtr<ConnectionQuality> getConnectionQuality() const;
 int32_t setConnectionQuality(const Common::IntrusivePtr<ConnectionQuality> &connectionQuality) __attribute__((warn_unused_result));


 bool frequentlyMutedIsSet() const;
 void unsetFrequentlyMuted();
 Common::IntrusivePtr<FrequentlyMuted> getFrequentlyMuted() const;
 int32_t setFrequentlyMuted(const Common::IntrusivePtr<FrequentlyMuted> &frequentlyMuted) __attribute__((warn_unused_result));


 bool matchCompletionRateIsSet() const;
 void unsetMatchCompletionRate();
 Common::IntrusivePtr<MatchCompletionRate> getMatchCompletionRate() const;
 int32_t setMatchCompletionRate(const Common::IntrusivePtr<MatchCompletionRate> &matchCompletionRate) __attribute__((warn_unused_result));


 bool mmrIsSet() const;
 void unsetMmr();
 Common::IntrusivePtr<Mmr> getMmr() const;
 int32_t setMmr(const Common::IntrusivePtr<Mmr> &mmr) __attribute__((warn_unused_result));


 bool natConnectivityIsSet() const;
 void unsetNatConnectivity();
 Common::IntrusivePtr<NatConnectivity> getNatConnectivity() const;
 int32_t setNatConnectivity(const Common::IntrusivePtr<NatConnectivity> &natConnectivity) __attribute__((warn_unused_result));


 bool playStyleIsSet() const;
 void unsetPlayStyle();
 Common::IntrusivePtr<PlayStyle> getPlayStyle() const;
 int32_t setPlayStyle(const Common::IntrusivePtr<PlayStyle> &playStyle) __attribute__((warn_unused_result));


 bool reputationIsSet() const;
 void unsetReputation();
 Common::IntrusivePtr<Reputation> getReputation() const;
 int32_t setReputation(const Common::IntrusivePtr<Reputation> &reputation) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Stats(Common::LibContext * context);
 friend class StatsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::AdvancedPlayerProfile::V1::Stats>;

 ~Stats();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Bandwidth> m_bandwidth;
 bool m_bandwidthIsSet;

 Common::IntrusivePtr<ConnectionQuality> m_connectionQuality;
 bool m_connectionQualityIsSet;

 Common::IntrusivePtr<FrequentlyMuted> m_frequentlyMuted;
 bool m_frequentlyMutedIsSet;

 Common::IntrusivePtr<MatchCompletionRate> m_matchCompletionRate;
 bool m_matchCompletionRateIsSet;

 Common::IntrusivePtr<Mmr> m_mmr;
 bool m_mmrIsSet;

 Common::IntrusivePtr<NatConnectivity> m_natConnectivity;
 bool m_natConnectivityIsSet;

 Common::IntrusivePtr<PlayStyle> m_playStyle;
 bool m_playStyleIsSet;

 Common::IntrusivePtr<Reputation> m_reputation;
 bool m_reputationIsSet;


    Stats();
};

class StatsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Stats> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Stats> *instancePtr);


 static void destroy(Stats *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/advancedplayerprofile/v1/StatsApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace AdvancedPlayerProfile {
namespace V1 {

class StatsApi {
public:

 class ParameterToGetStats : public Common::ParameterBase {
 public:
  ParameterToGetStats();
  ~ParameterToGetStats();

  int32_t initialize(
   Common::LibContext * context
   , SceNpServiceLabel npServiceLabel
   );

  int32_t terminate();

  bool isInitialized() const;


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);


  const Common::String& getincludeFields() const;
  int32_t setincludeFields(const char* includeFields) __attribute__((warn_unused_result));
  void unsetincludeFields();
  bool hasincludeFields() const;

  struct ParameterImplToGetStats;

 private:
  struct ParameterImplToGetStats *m_pimpl;

  ParameterToGetStats(ParameterToGetStats &param);
  ParameterToGetStats(const ParameterToGetStats &param);
  ParameterToGetStats& operator=(ParameterToGetStats &param);
  ParameterToGetStats& operator=(const ParameterToGetStats &param);
 };

 static int32_t getStats(
  int32_t npwebapiUserCtxId,
  const ParameterToGetStats &param,
  Common::Transaction<Common::IntrusivePtr<Stats>> &transaction
  );

private:
 StatsApi();
 ~StatsApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/advanced_player_profile.h" 2 3
# 324 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/communication_restriction_status.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/communicationrestrictionstatus/v3/CommunicationRestrictionStatusApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/communicationrestrictionstatus/v3/CommunicationRestrictionStatusApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/CommunicationRestrictionStatusResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/CommunicationRestrictionStatusResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/psnWebErrorWrapper.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/psnWebErrorWrapper.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/PsnWebError.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/PsnWebError.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/Error.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/MissingElement.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/MissingElement.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace CommunicationRestrictionStatus {
namespace V3 {

class MissingElement : public Common::RefObject
{
public:

 bool nameIsSet() const;
 void unsetName();
 const Common::String & getName() const;
 int32_t setName(const char* name) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MissingElement(Common::LibContext * context);
 friend class MissingElementFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::CommunicationRestrictionStatus::V3::MissingElement>;

 ~MissingElement();

private:
 Common::LibContext * m_context;

 Common::String m_name;
 bool m_nameIsSet;


    MissingElement();
};

class MissingElementFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<MissingElement> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MissingElement> *instancePtr);


 static void destroy(MissingElement *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/Error.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/ValidationConstraintInfo.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/ValidationConstraintInfo.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace CommunicationRestrictionStatus {
namespace V3 {

class ValidationConstraintInfo : public Common::RefObject
{
public:

 const Common::String & getKey() const;
 int32_t setKey(const char* key) __attribute__((warn_unused_result));


 const Common::String & getValue() const;
 int32_t setValue(const char* value) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ValidationConstraintInfo(Common::LibContext * context);
 friend class ValidationConstraintInfoFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::CommunicationRestrictionStatus::V3::ValidationConstraintInfo>;

 ~ValidationConstraintInfo();

private:
 Common::LibContext * m_context;

 Common::String m_key;

 Common::String m_value;


    ValidationConstraintInfo();
};

class ValidationConstraintInfoFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* key,
  const char* value,
  sce::Np::CppWebApi::Common::IntrusivePtr<ValidationConstraintInfo> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ValidationConstraintInfo> *instancePtr);


 static void destroy(ValidationConstraintInfo *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/Error.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace CommunicationRestrictionStatus {
namespace V3 {

class Error : public Common::RefObject
{
public:

 bool pathIsSet() const;
 void unsetPath();
 const Common::String & getPath() const;
 int32_t setPath(const char* path) __attribute__((warn_unused_result));


 bool validationConstraintIsSet() const;
 void unsetValidationConstraint();
 const Common::String & getValidationConstraint() const;
 int32_t setValidationConstraint(const char* validationConstraint) __attribute__((warn_unused_result));


 bool validationConstraintInfoIsSet() const;
 void unsetValidationConstraintInfo();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ValidationConstraintInfo>>> getValidationConstraintInfo();
 int32_t setValidationConstraintInfo(const Common::Vector<Common::IntrusivePtr<ValidationConstraintInfo>> &validationConstraintInfo) __attribute__((warn_unused_result));


 bool messageIsSet() const;
 void unsetMessage();
 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool missingElementsIsSet() const;
 void unsetMissingElements();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<MissingElement>>> getMissingElements();
 int32_t setMissingElements(const Common::Vector<Common::IntrusivePtr<MissingElement>> &missingElements) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::CommunicationRestrictionStatus::V3::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 Common::String m_path;
 bool m_pathIsSet;

 Common::String m_validationConstraint;
 bool m_validationConstraintIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ValidationConstraintInfo>>> m_validationConstraintInfo;
 bool m_validationConstraintInfoIsSet;

 Common::String m_message;
 bool m_messageIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<MissingElement>>> m_missingElements;
 bool m_missingElementsIsSet;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/PsnWebError.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace CommunicationRestrictionStatus {
namespace V3 {

class PsnWebError : public Common::RefObject
{
public:

 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 int32_t getCode() const;
 void setCode(const int32_t &code);


 bool reasonIsSet() const;
 void unsetReason();
 const Common::String & getReason() const;
 int32_t setReason(const char* reason) __attribute__((warn_unused_result));


 bool messageIsSet() const;
 void unsetMessage();
 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool sourceIsSet() const;
 void unsetSource();
 const Common::String & getSource() const;
 int32_t setSource(const char* source) __attribute__((warn_unused_result));


 bool errorsIsSet() const;
 void unsetErrors();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Error>>> getErrors();
 int32_t setErrors(const Common::Vector<Common::IntrusivePtr<Error>> &errors) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PsnWebError(Common::LibContext * context);
 friend class PsnWebErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::CommunicationRestrictionStatus::V3::PsnWebError>;

 ~PsnWebError();

private:
 Common::LibContext * m_context;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;

 int32_t m_code;

 Common::String m_reason;
 bool m_reasonIsSet;

 Common::String m_message;
 bool m_messageIsSet;

 Common::String m_source;
 bool m_sourceIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Error>>> m_errors;
 bool m_errorsIsSet;


    PsnWebError();
};

class PsnWebErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t code,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnWebError> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnWebError> *instancePtr);


 static void destroy(PsnWebError *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/psnWebErrorWrapper.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace CommunicationRestrictionStatus {
namespace V3 {

class PsnWebErrorWrapper : public Common::RefObject
{
public:

 Common::IntrusivePtr<PsnWebError> getError() const;
 int32_t setError(const Common::IntrusivePtr<PsnWebError> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PsnWebErrorWrapper(Common::LibContext * context);
 friend class PsnWebErrorWrapperFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::CommunicationRestrictionStatus::V3::PsnWebErrorWrapper>;

 ~PsnWebErrorWrapper();

protected:
    PsnWebErrorWrapper();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<PsnWebError> m_error;


};

class PsnWebErrorWrapperFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<PsnWebError> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnWebErrorWrapper> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnWebErrorWrapper> *instancePtr);


 static void destroy(PsnWebErrorWrapper *instance);
};
using PsnErrorObject = PsnWebErrorWrapper;
using PsnErrorObjectFactory = PsnWebErrorWrapperFactory;


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/CommunicationRestrictionStatus/V3/CommunicationRestrictionStatusResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace CommunicationRestrictionStatus {
namespace V3 {

class CommunicationRestrictionStatusResponse : public PsnErrorObject
{
public:

 bool getRestricted() const;
 void setRestricted(const bool &restricted);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 CommunicationRestrictionStatusResponse(Common::LibContext * context);
 friend class CommunicationRestrictionStatusResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::CommunicationRestrictionStatus::V3::CommunicationRestrictionStatusResponse>;

 ~CommunicationRestrictionStatusResponse();

private:
 Common::LibContext * m_context;

 bool m_restricted;


    CommunicationRestrictionStatusResponse();
};

class CommunicationRestrictionStatusResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  bool restricted,
  sce::Np::CppWebApi::Common::IntrusivePtr<CommunicationRestrictionStatusResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<CommunicationRestrictionStatusResponse> *instancePtr);


 static void destroy(CommunicationRestrictionStatusResponse *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/communicationrestrictionstatus/v3/CommunicationRestrictionStatusApi.h" 2 3


namespace sce {
namespace Np {
namespace CppWebApi {
namespace CommunicationRestrictionStatus {
namespace V3 {

class CommunicationRestrictionStatusApi {
public:

 class ParameterToGetCommunicationRestrictionStatus : public Common::ParameterBase {
 public:
  ParameterToGetCommunicationRestrictionStatus();
  ~ParameterToGetCommunicationRestrictionStatus();

  int32_t initialize(
   Common::LibContext * context
   , SceNpAccountId accountIdOrMe
   );

  int32_t terminate();

  bool isInitialized() const;


  SceNpAccountId getaccountIdOrMe() const;
  void setaccountIdOrMe(SceNpAccountId accountIdOrMe);

  struct ParameterImplToGetCommunicationRestrictionStatus;

 private:
  struct ParameterImplToGetCommunicationRestrictionStatus *m_pimpl;

  ParameterToGetCommunicationRestrictionStatus(ParameterToGetCommunicationRestrictionStatus &param);
  ParameterToGetCommunicationRestrictionStatus(const ParameterToGetCommunicationRestrictionStatus &param);
  ParameterToGetCommunicationRestrictionStatus& operator=(ParameterToGetCommunicationRestrictionStatus &param);
  ParameterToGetCommunicationRestrictionStatus& operator=(const ParameterToGetCommunicationRestrictionStatus &param);
 };

 static int32_t getCommunicationRestrictionStatus(
  int32_t npwebapiUserCtxId,
  const ParameterToGetCommunicationRestrictionStatus &param,
  Common::Transaction<Common::IntrusivePtr<CommunicationRestrictionStatusResponse>> &transaction
  );

private:
 CommunicationRestrictionStatusApi();
 ~CommunicationRestrictionStatusApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/communication_restriction_status.h" 2 3
# 325 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/entitlement.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/entitlement/v2/EntitlementsApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/entitlement/v2/EntitlementsApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/Entitlement.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/Entitlement.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/FailureResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/FailureResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/FailureResponse_error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/FailureResponse_error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Entitlement {
namespace V2 {

class FailureResponse_error : public Common::RefObject
{
public:

 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 int32_t getCode() const;
 void setCode(const int32_t &code);


 bool reasonIsSet() const;
 void unsetReason();
 const Common::String & getReason() const;
 int32_t setReason(const char* reason) __attribute__((warn_unused_result));


 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool sourceIsSet() const;
 void unsetSource();
 const Common::String & getSource() const;
 int32_t setSource(const char* source) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FailureResponse_error(Common::LibContext * context);
 friend class FailureResponse_errorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Entitlement::V2::FailureResponse_error>;

 ~FailureResponse_error();

private:
 Common::LibContext * m_context;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;

 int32_t m_code;

 Common::String m_reason;
 bool m_reasonIsSet;

 Common::String m_message;

 Common::String m_source;
 bool m_sourceIsSet;


    FailureResponse_error();
};

class FailureResponse_errorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t code,
  const char* message,
  sce::Np::CppWebApi::Common::IntrusivePtr<FailureResponse_error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FailureResponse_error> *instancePtr);


 static void destroy(FailureResponse_error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/FailureResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Entitlement {
namespace V2 {

class FailureResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<FailureResponse_error> getError() const;
 int32_t setError(const Common::IntrusivePtr<FailureResponse_error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FailureResponse(Common::LibContext * context);
 friend class FailureResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Entitlement::V2::FailureResponse>;

 ~FailureResponse();

protected:
    FailureResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<FailureResponse_error> m_error;


};

class FailureResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<FailureResponse_error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<FailureResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FailureResponse> *instancePtr);


 static void destroy(FailureResponse *instance);
};
using PsnErrorObject = FailureResponse;
using PsnErrorObjectFactory = FailureResponseFactory;


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/Entitlement.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Entitlement {
namespace V2 {

class Entitlement : public PsnErrorObject
{
public:

 const Common::String & getId() const;
 int32_t setId(const char* id) __attribute__((warn_unused_result));


 SceRtcTick getActiveDate() const;
 void setActiveDate(const SceRtcTick &activeDate);


 bool inactiveDateIsSet() const;
 void unsetInactiveDate();
 SceRtcTick getInactiveDate() const;
 void setInactiveDate(const SceRtcTick &inactiveDate);


 enum class EntitlementType {
  _NOT_SET = 0,
  kUnified,
  kService,
 };
 EntitlementType getEntitlementType() const;
 void setEntitlementType(const EntitlementType &entitlementType);


 bool useCountIsSet() const;
 void unsetUseCount();
 int32_t getUseCount() const;
 void setUseCount(const int32_t &useCount);


 bool useLimitIsSet() const;
 void unsetUseLimit();
 int32_t getUseLimit() const;
 void setUseLimit(const int32_t &useLimit);


 bool packageTypeIsSet() const;
 void unsetPackageType();
 enum class PackageType {
  _NOT_SET = 0,
  kPs4gd,
  kPs4ac,
  kPs4al,
  kPs4misc,
  kPsgd,
  kPsac,
  kPsal,
  kPsmedia,
  kPsvc,
  kPscons,
  kPssubs,
  kPstrack,
  kPsil,
  kPs4gs,
  kLiveevent,
  kPspreinstall,
 };
 PackageType getPackageType() const;
 void setPackageType(const PackageType &packageType);


 bool activeFlagIsSet() const;
 void unsetActiveFlag();
 bool getActiveFlag() const;
 void setActiveFlag(const bool &activeFlag);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Entitlement(Common::LibContext * context);
 friend class EntitlementFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Entitlement::V2::Entitlement>;

 ~Entitlement();

private:
 Common::LibContext * m_context;

 Common::String m_id;

 SceRtcTick m_activeDate;

 SceRtcTick m_inactiveDate;
 bool m_inactiveDateIsSet;

 EntitlementType m_entitlementType;

 int32_t m_useCount;
 bool m_useCountIsSet;

 int32_t m_useLimit;
 bool m_useLimitIsSet;

 PackageType m_packageType;
 bool m_packageTypeIsSet;

 bool m_activeFlag;
 bool m_activeFlagIsSet;


    Entitlement();
};

class EntitlementFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* id,
  const SceRtcTick &activeDate,
  Entitlement::EntitlementType entitlementType,
  sce::Np::CppWebApi::Common::IntrusivePtr<Entitlement> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Entitlement> *instancePtr);


 static void destroy(Entitlement *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/entitlement/v2/EntitlementsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/Entitlements.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Entitlement/V2/Entitlements.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace Entitlement {
namespace V2 {

class Entitlements : public PsnErrorObject
{
public:

 bool nextOffsetIsSet() const;
 void unsetNextOffset();
 int32_t getNextOffset() const;
 void setNextOffset(const int32_t &nextOffset);


 bool previousOffsetIsSet() const;
 void unsetPreviousOffset();
 int32_t getPreviousOffset() const;
 void setPreviousOffset(const int32_t &previousOffset);


 bool entitlementsIsSet() const;
 void unsetEntitlements();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Entitlement>>> getEntitlements();
 int32_t setEntitlements(const Common::Vector<Common::IntrusivePtr<Entitlement>> &entitlements) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Entitlements(Common::LibContext * context);
 friend class EntitlementsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Entitlement::V2::Entitlements>;

 ~Entitlements();

private:
 Common::LibContext * m_context;

 int32_t m_nextOffset;
 bool m_nextOffsetIsSet;

 int32_t m_previousOffset;
 bool m_previousOffsetIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Entitlement>>> m_entitlements;
 bool m_entitlementsIsSet;


    Entitlements();
};

class EntitlementsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Entitlements> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Entitlements> *instancePtr);


 static void destroy(Entitlements *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/entitlement/v2/EntitlementsApi.h" 2 3


namespace sce {
namespace Np {
namespace CppWebApi {
namespace Entitlement {
namespace V2 {

class EntitlementsApi {
public:

 class ParameterToGetEntitlement : public Common::ParameterBase {
 public:
  ParameterToGetEntitlement();
  ~ParameterToGetEntitlement();

  enum class ServiceName {
   _NOT_SET = 0,
   kPssdc,
   kCce,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* entitlementLabel
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getentitlementLabel() const;
  int32_t setentitlementLabel(const char* entitlementLabel) __attribute__((warn_unused_result));


  const Common::String& getserviceLabel() const;
  int32_t setserviceLabel(const char* serviceLabel) __attribute__((warn_unused_result));
  void unsetserviceLabel();
  bool hasserviceLabel() const;


  ServiceName getserviceName() const;
  void setserviceName(ServiceName serviceName);
  void unsetserviceName();
  bool hasserviceName() const;

  struct ParameterImplToGetEntitlement;

 private:
  struct ParameterImplToGetEntitlement *m_pimpl;

  ParameterToGetEntitlement(ParameterToGetEntitlement &param);
  ParameterToGetEntitlement(const ParameterToGetEntitlement &param);
  ParameterToGetEntitlement& operator=(ParameterToGetEntitlement &param);
  ParameterToGetEntitlement& operator=(const ParameterToGetEntitlement &param);
 };

 static int32_t getEntitlement(
  int32_t npwebapiUserCtxId,
  const ParameterToGetEntitlement &param,
  Common::Transaction<Common::IntrusivePtr<Entitlement>> &transaction
  );

 class ParameterToListEntitlements : public Common::ParameterBase {
 public:
  ParameterToListEntitlements();
  ~ParameterToListEntitlements();

  enum class ServiceName {
   _NOT_SET = 0,
   kPssdc,
   kCce,
  };

  int32_t initialize(
   Common::LibContext * context
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getserviceLabel() const;
  int32_t setserviceLabel(const char* serviceLabel) __attribute__((warn_unused_result));
  void unsetserviceLabel();
  bool hasserviceLabel() const;


  ServiceName getserviceName() const;
  void setserviceName(ServiceName serviceName);
  void unsetserviceName();
  bool hasserviceName() const;


  int32_t getoffset() const;
  void setoffset(int32_t offset);
  void unsetoffset();
  bool hasoffset() const;


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;


  const Common::String& getids() const;
  int32_t setids(const char* ids) __attribute__((warn_unused_result));
  void unsetids();
  bool hasids() const;


  const Common::String& getpackageType() const;
  int32_t setpackageType(const char* packageType) __attribute__((warn_unused_result));
  void unsetpackageType();
  bool haspackageType() const;


  const Common::String& getentitlementTypes() const;
  int32_t setentitlementTypes(const char* entitlementTypes) __attribute__((warn_unused_result));
  void unsetentitlementTypes();
  bool hasentitlementTypes() const;


  const Common::String& getsort() const;
  int32_t setsort(const char* sort) __attribute__((warn_unused_result));
  void unsetsort();
  bool hassort() const;


  const Common::String& getdirection() const;
  int32_t setdirection(const char* direction) __attribute__((warn_unused_result));
  void unsetdirection();
  bool hasdirection() const;

  struct ParameterImplToListEntitlements;

 private:
  struct ParameterImplToListEntitlements *m_pimpl;

  ParameterToListEntitlements(ParameterToListEntitlements &param);
  ParameterToListEntitlements(const ParameterToListEntitlements &param);
  ParameterToListEntitlements& operator=(ParameterToListEntitlements &param);
  ParameterToListEntitlements& operator=(const ParameterToListEntitlements &param);
 };

 static int32_t listEntitlements(
  int32_t npwebapiUserCtxId,
  const ParameterToListEntitlements &param,
  Common::Transaction<Common::IntrusivePtr<Entitlements>> &transaction
  );

private:
 EntitlementsApi();
 ~EntitlementsApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/entitlement.h" 2 3
# 326 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/in_game_catalog.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ingamecatalog/v5/ContainerApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ingamecatalog/v5/ContainerApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Container.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Container.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContainerRating.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContainerRating.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContainerRatingCount.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContainerRatingCount.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class ContainerRatingCount : public Common::RefObject
{
public:

 bool countIsSet() const;
 void unsetCount();
 int32_t getCount() const;
 void setCount(const int32_t &count);


 bool scoreIsSet() const;
 void unsetScore();
 int32_t getScore() const;
 void setScore(const int32_t &score);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ContainerRatingCount(Common::LibContext * context);
 friend class ContainerRatingCountFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::ContainerRatingCount>;

 ~ContainerRatingCount();

private:
 Common::LibContext * m_context;

 int32_t m_count;
 bool m_countIsSet;

 int32_t m_score;
 bool m_scoreIsSet;


    ContainerRatingCount();
};

class ContainerRatingCountFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContainerRatingCount> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContainerRatingCount> *instancePtr);


 static void destroy(ContainerRatingCount *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContainerRating.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class ContainerRating : public Common::RefObject
{
public:

 bool scoreIsSet() const;
 void unsetScore();
 float getScore() const;
 void setScore(const float &score);


 bool countIsSet() const;
 void unsetCount();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContainerRatingCount>>> getCount();
 int32_t setCount(const Common::Vector<Common::IntrusivePtr<ContainerRatingCount>> &count) __attribute__((warn_unused_result));


 bool totalIsSet() const;
 void unsetTotal();
 int32_t getTotal() const;
 void setTotal(const int32_t &total);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ContainerRating(Common::LibContext * context);
 friend class ContainerRatingFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::ContainerRating>;

 ~ContainerRating();

private:
 Common::LibContext * m_context;

 float m_score;
 bool m_scoreIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContainerRatingCount>>> m_count;
 bool m_countIsSet;

 int32_t m_total;
 bool m_totalIsSet;


    ContainerRating();
};

class ContainerRatingFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContainerRating> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContainerRating> *instancePtr);


 static void destroy(ContainerRating *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Container.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContentDescriptor.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContentDescriptor.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class ContentDescriptor : public Common::RefObject
{
public:

 const Common::String & getName() const;
 int32_t setName(const char* name) __attribute__((warn_unused_result));


 bool urlIsSet() const;
 void unsetUrl();
 const Common::String & getUrl() const;
 int32_t setUrl(const char* url) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ContentDescriptor(Common::LibContext * context);
 friend class ContentDescriptorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::ContentDescriptor>;

 ~ContentDescriptor();

private:
 Common::LibContext * m_context;

 Common::String m_name;

 Common::String m_url;
 bool m_urlIsSet;


    ContentDescriptor();
};

class ContentDescriptorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* name,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContentDescriptor> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContentDescriptor> *instancePtr);


 static void destroy(ContentDescriptor *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Container.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Product.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Product.h" 2 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Publisher.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Publisher.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Image.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Image.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class Image : public Common::RefObject
{
public:

 const Common::String & getUrl() const;
 int32_t setUrl(const char* url) __attribute__((warn_unused_result));


 bool formatIsSet() const;
 void unsetFormat();
 enum class Format {
  _NOT_SET = 0,
  kJpeg,
  kPng,
  kGif,
  kWebp,
 };
 Format getFormat() const;
 void setFormat(const Format &format);


 bool typeIsSet() const;
 void unsetType();
 enum class Type {
  _NOT_SET = 0,
  kPsnJacket,
  kPsnThumbnail,
  kBivlJacket,
  kBivlThumbnail,
  kXperiaThumbnail,
  kXperiaJacket,
  kTamThumbnail,
  kTamJacket,
  kVitaThumbnail,
  kMaster,
  kPdpBackground1080,
  kPdpBackground720,
  kPdpForeground,
 };
 Type getType() const;
 void setType(const Type &type);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Image(Common::LibContext * context);
 friend class ImageFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::Image>;

 ~Image();

private:
 Common::LibContext * m_context;

 Common::String m_url;

 Format m_format;
 bool m_formatIsSet;

 Type m_type;
 bool m_typeIsSet;


    Image();
};

class ImageFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* url,
  sce::Np::CppWebApi::Common::IntrusivePtr<Image> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Image> *instancePtr);


 static void destroy(Image *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Publisher.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class Publisher : public Common::RefObject
{
public:

 bool nameIsSet() const;
 void unsetName();
 const Common::String & getName() const;
 int32_t setName(const char* name) __attribute__((warn_unused_result));


 bool iconIsSet() const;
 void unsetIcon();
 Common::IntrusivePtr<Image> getIcon() const;
 int32_t setIcon(const Common::IntrusivePtr<Image> &icon) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Publisher(Common::LibContext * context);
 friend class PublisherFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::Publisher>;

 ~Publisher();

private:
 Common::LibContext * m_context;

 Common::String m_name;
 bool m_nameIsSet;

 Common::IntrusivePtr<Image> m_icon;
 bool m_iconIsSet;


    Publisher();
};

class PublisherFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Publisher> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Publisher> *instancePtr);


 static void destroy(Publisher *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Product.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContainerMedia.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContainerMedia.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class ContainerMedia : public Common::RefObject
{
public:

 bool imagesIsSet() const;
 void unsetImages();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Image>>> getImages();
 int32_t setImages(const Common::Vector<Common::IntrusivePtr<Image>> &images) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ContainerMedia(Common::LibContext * context);
 friend class ContainerMediaFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::ContainerMedia>;

 ~ContainerMedia();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Image>>> m_images;
 bool m_imagesIsSet;


    ContainerMedia();
};

class ContainerMediaFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContainerMedia> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContainerMedia> *instancePtr);


 static void destroy(ContainerMedia *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Product.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContentType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContentType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

 enum class ContentType {
  _NOT_SET = 0,
  kGame,
  kMovie,
  kApp,
  kTvshow,
 };


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Product.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContentRating.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContentRating.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class ContentRating : public Common::RefObject
{
public:

 bool nameIsSet() const;
 void unsetName();
 const Common::String & getName() const;
 int32_t setName(const char* name) __attribute__((warn_unused_result));


 bool systemIsSet() const;
 void unsetSystem();
 const Common::String & getSystem() const;
 int32_t setSystem(const char* system) __attribute__((warn_unused_result));


 bool urlIsSet() const;
 void unsetUrl();
 const Common::String & getUrl() const;
 int32_t setUrl(const char* url) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ContentRating(Common::LibContext * context);
 friend class ContentRatingFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::ContentRating>;

 ~ContentRating();

private:
 Common::LibContext * m_context;

 Common::String m_name;
 bool m_nameIsSet;

 Common::String m_system;
 bool m_systemIsSet;

 Common::String m_url;
 bool m_urlIsSet;


    ContentRating();
};

class ContentRatingFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContentRating> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContentRating> *instancePtr);


 static void destroy(ContentRating *instance);
};


}
}
}
}
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Product.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContentInteractiveElement.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ContentInteractiveElement.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class ContentInteractiveElement : public Common::RefObject
{
public:

 const Common::String & getName() const;
 int32_t setName(const char* name) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ContentInteractiveElement(Common::LibContext * context);
 friend class ContentInteractiveElementFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::ContentInteractiveElement>;

 ~ContentInteractiveElement();

private:
 Common::LibContext * m_context;

 Common::String m_name;


    ContentInteractiveElement();
};

class ContentInteractiveElementFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* name,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContentInteractiveElement> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ContentInteractiveElement> *instancePtr);


 static void destroy(ContentInteractiveElement *instance);
};


}
}
}
}
}
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Product.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Sku.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Sku.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Annotation.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Annotation.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

 enum class Annotation {
  _NOT_SET = 0,
  kNone,
  kBlueBag,
  kRedBag,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Sku.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class Sku : public Common::RefObject
{
public:

 bool idIsSet() const;
 void unsetId();
 const Common::String & getId() const;
 int32_t setId(const char* id) __attribute__((warn_unused_result));


 bool nameIsSet() const;
 void unsetName();
 const Common::String & getName() const;
 int32_t setName(const char* name) __attribute__((warn_unused_result));


 bool labelIsSet() const;
 void unsetLabel();
 const Common::String & getLabel() const;
 int32_t setLabel(const char* label) __attribute__((warn_unused_result));


 bool endDateIsSet() const;
 void unsetEndDate();
 const Common::String & getEndDate() const;
 int32_t setEndDate(const char* endDate) __attribute__((warn_unused_result));


 bool typeIsSet() const;
 void unsetType();
 const Common::String & getType() const;
 int32_t setType(const char* type) __attribute__((warn_unused_result));


 bool priceIsSet() const;
 void unsetPrice();
 int32_t getPrice() const;
 void setPrice(const int32_t &price);


 bool displayPriceIsSet() const;
 void unsetDisplayPrice();
 const Common::String & getDisplayPrice() const;
 int32_t setDisplayPrice(const char* displayPrice) __attribute__((warn_unused_result));


 bool originalPriceIsSet() const;
 void unsetOriginalPrice();
 int32_t getOriginalPrice() const;
 void setOriginalPrice(const int32_t &originalPrice);


 bool displayOriginalPriceIsSet() const;
 void unsetDisplayOriginalPrice();
 const Common::String & getDisplayOriginalPrice() const;
 int32_t setDisplayOriginalPrice(const char* displayOriginalPrice) __attribute__((warn_unused_result));


 int32_t getUseLimit() const;
 void setUseLimit(const int32_t &useLimit);


 bool plusUpsellPriceIsSet() const;
 void unsetPlusUpsellPrice();
 int32_t getPlusUpsellPrice() const;
 void setPlusUpsellPrice(const int32_t &plusUpsellPrice);


 bool displayPlusUpsellPriceIsSet() const;
 void unsetDisplayPlusUpsellPrice();
 const Common::String & getDisplayPlusUpsellPrice() const;
 int32_t setDisplayPlusUpsellPrice(const char* displayPlusUpsellPrice) __attribute__((warn_unused_result));


 bool isPlusPriceIsSet() const;
 void unsetIsPlusPrice();
 bool getIsPlusPrice() const;
 void setIsPlusPrice(const bool &isPlusPrice);


 bool annotationNameIsSet() const;
 void unsetAnnotationName();
 Annotation getAnnotationName() const;
 void setAnnotationName(const Annotation &annotationName);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Sku(Common::LibContext * context);
 friend class SkuFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::Sku>;

 ~Sku();

private:
 Common::LibContext * m_context;

 Common::String m_id;
 bool m_idIsSet;

 Common::String m_name;
 bool m_nameIsSet;

 Common::String m_label;
 bool m_labelIsSet;

 Common::String m_endDate;
 bool m_endDateIsSet;

 Common::String m_type;
 bool m_typeIsSet;

 int32_t m_price;
 bool m_priceIsSet;

 Common::String m_displayPrice;
 bool m_displayPriceIsSet;

 int32_t m_originalPrice;
 bool m_originalPriceIsSet;

 Common::String m_displayOriginalPrice;
 bool m_displayOriginalPriceIsSet;

 int32_t m_useLimit;

 int32_t m_plusUpsellPrice;
 bool m_plusUpsellPriceIsSet;

 Common::String m_displayPlusUpsellPrice;
 bool m_displayPlusUpsellPriceIsSet;

 bool m_isPlusPrice;
 bool m_isPlusPriceIsSet;

 Annotation m_annotationName;
 bool m_annotationNameIsSet;


    Sku();
};

class SkuFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t useLimit,
  sce::Np::CppWebApi::Common::IntrusivePtr<Sku> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Sku> *instancePtr);


 static void destroy(Sku *instance);
};


}
}
}
}
}
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Product.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class Product : public Common::RefObject
{
public:

 const Common::String & getId() const;
 int32_t setId(const char* id) __attribute__((warn_unused_result));


 bool labelIsSet() const;
 void unsetLabel();
 const Common::String & getLabel() const;
 int32_t setLabel(const char* label) __attribute__((warn_unused_result));


 bool ageLimitIsSet() const;
 void unsetAgeLimit();
 int32_t getAgeLimit() const;
 void setAgeLimit(const int32_t &ageLimit);


 const Common::String & getDisplayName() const;
 int32_t setDisplayName(const char* displayName) __attribute__((warn_unused_result));


 bool releaseDateIsSet() const;
 void unsetReleaseDate();
 const Common::String & getReleaseDate() const;
 int32_t setReleaseDate(const char* releaseDate) __attribute__((warn_unused_result));


 bool ratingIsSet() const;
 void unsetRating();
 Common::IntrusivePtr<ContainerRating> getRating() const;
 int32_t setRating(const Common::IntrusivePtr<ContainerRating> &rating) __attribute__((warn_unused_result));


 bool contentRatingIsSet() const;
 void unsetContentRating();
 Common::IntrusivePtr<ContentRating> getContentRating() const;
 int32_t setContentRating(const Common::IntrusivePtr<ContentRating> &contentRating) __attribute__((warn_unused_result));


 bool contentDescriptorsIsSet() const;
 void unsetContentDescriptors();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContentDescriptor>>> getContentDescriptors();
 int32_t setContentDescriptors(const Common::Vector<Common::IntrusivePtr<ContentDescriptor>> &contentDescriptors) __attribute__((warn_unused_result));


 bool contentInteractiveElementsIsSet() const;
 void unsetContentInteractiveElements();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContentInteractiveElement>>> getContentInteractiveElements();
 int32_t setContentInteractiveElements(const Common::Vector<Common::IntrusivePtr<ContentInteractiveElement>> &contentInteractiveElements) __attribute__((warn_unused_result));


 bool contentTypeIsSet() const;
 void unsetContentType();
 ContentType getContentType() const;
 void setContentType(const ContentType &contentType);


 bool descriptionIsSet() const;
 void unsetDescription();
 const Common::String & getDescription() const;
 int32_t setDescription(const char* description) __attribute__((warn_unused_result));


 bool platformsIsSet() const;
 void unsetPlatforms();
 Common::IntrusivePtr<Common::Vector<Common::String>> getPlatforms();
 int32_t setPlatforms(const Common::Vector<Common::String> &platforms) __attribute__((warn_unused_result));


 bool publisherIsSet() const;
 void unsetPublisher();
 Common::IntrusivePtr<Publisher> getPublisher() const;
 int32_t setPublisher(const Common::IntrusivePtr<Publisher> &publisher) __attribute__((warn_unused_result));


 bool versionIsSet() const;
 void unsetVersion();
 int32_t getVersion() const;
 void setVersion(const int32_t &version);


 bool mediaIsSet() const;
 void unsetMedia();
 Common::IntrusivePtr<ContainerMedia> getMedia() const;
 int32_t setMedia(const Common::IntrusivePtr<ContainerMedia> &media) __attribute__((warn_unused_result));


 const Common::String & getType() const;
 int32_t setType(const char* type) __attribute__((warn_unused_result));


 bool skusIsSet() const;
 void unsetSkus();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Sku>>> getSkus();
 int32_t setSkus(const Common::Vector<Common::IntrusivePtr<Sku>> &skus) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Product(Common::LibContext * context);
 friend class ProductFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::Product>;

 ~Product();

private:
 Common::LibContext * m_context;

 Common::String m_id;

 Common::String m_label;
 bool m_labelIsSet;

 int32_t m_ageLimit;
 bool m_ageLimitIsSet;

 Common::String m_displayName;

 Common::String m_releaseDate;
 bool m_releaseDateIsSet;

 Common::IntrusivePtr<ContainerRating> m_rating;
 bool m_ratingIsSet;

 Common::IntrusivePtr<ContentRating> m_contentRating;
 bool m_contentRatingIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContentDescriptor>>> m_contentDescriptors;
 bool m_contentDescriptorsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContentInteractiveElement>>> m_contentInteractiveElements;
 bool m_contentInteractiveElementsIsSet;

 ContentType m_contentType;
 bool m_contentTypeIsSet;

 Common::String m_description;
 bool m_descriptionIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_platforms;
 bool m_platformsIsSet;

 Common::IntrusivePtr<Publisher> m_publisher;
 bool m_publisherIsSet;

 int32_t m_version;
 bool m_versionIsSet;

 Common::IntrusivePtr<ContainerMedia> m_media;
 bool m_mediaIsSet;

 Common::String m_type;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Sku>>> m_skus;
 bool m_skusIsSet;


    Product();
};

class ProductFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* id,
  const char* displayName,
  const char* type,
  sce::Np::CppWebApi::Common::IntrusivePtr<Product> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Product> *instancePtr);


 static void destroy(Product *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Container.h" 2 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ErrorEntity.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ErrorEntity.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class Error : public Common::RefObject
{
public:

 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 bool codeIsSet() const;
 void unsetCode();
 int32_t getCode() const;
 void setCode(const int32_t &code);


 bool messageIsSet() const;
 void unsetMessage();
 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool reasonIsSet() const;
 void unsetReason();
 const Common::String & getReason() const;
 int32_t setReason(const char* reason) __attribute__((warn_unused_result));


 bool sourceIsSet() const;
 void unsetSource();
 const Common::String & getSource() const;
 int32_t setSource(const char* source) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;

 int32_t m_code;
 bool m_codeIsSet;

 Common::String m_message;
 bool m_messageIsSet;

 Common::String m_reason;
 bool m_reasonIsSet;

 Common::String m_source;
 bool m_sourceIsSet;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/ErrorEntity.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class ErrorEntity : public Common::RefObject
{
public:

 bool errorIsSet() const;
 void unsetError();
 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorEntity(Common::LibContext * context);
 friend class ErrorEntityFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::ErrorEntity>;

 ~ErrorEntity();

protected:
    ErrorEntity();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;
 bool m_errorIsSet;


};

class ErrorEntityFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorEntity> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorEntity> *instancePtr);


 static void destroy(ErrorEntity *instance);
};
using PsnErrorObject = ErrorEntity;
using PsnErrorObjectFactory = ErrorEntityFactory;


}
}
}
}
}
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/InGameCatalog/V5/Container.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class Container : public PsnErrorObject
{
public:

 const Common::String & getId() const;
 int32_t setId(const char* id) __attribute__((warn_unused_result));


 bool labelIsSet() const;
 void unsetLabel();
 const Common::String & getLabel() const;
 int32_t setLabel(const char* label) __attribute__((warn_unused_result));


 bool ageLimitIsSet() const;
 void unsetAgeLimit();
 int32_t getAgeLimit() const;
 void setAgeLimit(const int32_t &ageLimit);


 const Common::String & getDisplayName() const;
 int32_t setDisplayName(const char* displayName) __attribute__((warn_unused_result));


 bool releaseDateIsSet() const;
 void unsetReleaseDate();
 const Common::String & getReleaseDate() const;
 int32_t setReleaseDate(const char* releaseDate) __attribute__((warn_unused_result));


 bool ratingIsSet() const;
 void unsetRating();
 Common::IntrusivePtr<ContainerRating> getRating() const;
 int32_t setRating(const Common::IntrusivePtr<ContainerRating> &rating) __attribute__((warn_unused_result));


 bool contentRatingIsSet() const;
 void unsetContentRating();
 Common::IntrusivePtr<ContentRating> getContentRating() const;
 int32_t setContentRating(const Common::IntrusivePtr<ContentRating> &contentRating) __attribute__((warn_unused_result));


 bool contentDescriptorsIsSet() const;
 void unsetContentDescriptors();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContentDescriptor>>> getContentDescriptors();
 int32_t setContentDescriptors(const Common::Vector<Common::IntrusivePtr<ContentDescriptor>> &contentDescriptors) __attribute__((warn_unused_result));


 bool contentInteractiveElementsIsSet() const;
 void unsetContentInteractiveElements();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContentInteractiveElement>>> getContentInteractiveElements();
 int32_t setContentInteractiveElements(const Common::Vector<Common::IntrusivePtr<ContentInteractiveElement>> &contentInteractiveElements) __attribute__((warn_unused_result));


 bool contentTypeIsSet() const;
 void unsetContentType();
 ContentType getContentType() const;
 void setContentType(const ContentType &contentType);


 bool descriptionIsSet() const;
 void unsetDescription();
 const Common::String & getDescription() const;
 int32_t setDescription(const char* description) __attribute__((warn_unused_result));


 bool platformsIsSet() const;
 void unsetPlatforms();
 Common::IntrusivePtr<Common::Vector<Common::String>> getPlatforms();
 int32_t setPlatforms(const Common::Vector<Common::String> &platforms) __attribute__((warn_unused_result));


 bool publisherIsSet() const;
 void unsetPublisher();
 Common::IntrusivePtr<Publisher> getPublisher() const;
 int32_t setPublisher(const Common::IntrusivePtr<Publisher> &publisher) __attribute__((warn_unused_result));


 bool versionIsSet() const;
 void unsetVersion();
 int32_t getVersion() const;
 void setVersion(const int32_t &version);


 bool mediaIsSet() const;
 void unsetMedia();
 Common::IntrusivePtr<ContainerMedia> getMedia() const;
 int32_t setMedia(const Common::IntrusivePtr<ContainerMedia> &media) __attribute__((warn_unused_result));


 const Common::String & getType() const;
 int32_t setType(const char* type) __attribute__((warn_unused_result));


 bool skusIsSet() const;
 void unsetSkus();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Sku>>> getSkus();
 int32_t setSkus(const Common::Vector<Common::IntrusivePtr<Sku>> &skus) __attribute__((warn_unused_result));


 bool childrenIsSet() const;
 void unsetChildren();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Product>>> getChildren();
 int32_t setChildren(const Common::Vector<Common::IntrusivePtr<Product>> &children) __attribute__((warn_unused_result));


 bool totalItemCountIsSet() const;
 void unsetTotalItemCount();
 int32_t getTotalItemCount() const;
 void setTotalItemCount(const int32_t &totalItemCount);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Container(Common::LibContext * context);
 friend class ContainerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::InGameCatalog::V5::Container>;

 ~Container();

private:
 Common::LibContext * m_context;

 Common::String m_id;

 Common::String m_label;
 bool m_labelIsSet;

 int32_t m_ageLimit;
 bool m_ageLimitIsSet;

 Common::String m_displayName;

 Common::String m_releaseDate;
 bool m_releaseDateIsSet;

 Common::IntrusivePtr<ContainerRating> m_rating;
 bool m_ratingIsSet;

 Common::IntrusivePtr<ContentRating> m_contentRating;
 bool m_contentRatingIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContentDescriptor>>> m_contentDescriptors;
 bool m_contentDescriptorsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ContentInteractiveElement>>> m_contentInteractiveElements;
 bool m_contentInteractiveElementsIsSet;

 ContentType m_contentType;
 bool m_contentTypeIsSet;

 Common::String m_description;
 bool m_descriptionIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_platforms;
 bool m_platformsIsSet;

 Common::IntrusivePtr<Publisher> m_publisher;
 bool m_publisherIsSet;

 int32_t m_version;
 bool m_versionIsSet;

 Common::IntrusivePtr<ContainerMedia> m_media;
 bool m_mediaIsSet;

 Common::String m_type;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Sku>>> m_skus;
 bool m_skusIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Product>>> m_children;
 bool m_childrenIsSet;

 int32_t m_totalItemCount;
 bool m_totalItemCountIsSet;


    Container();
};

class ContainerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* id,
  const char* displayName,
  const char* type,
  sce::Np::CppWebApi::Common::IntrusivePtr<Container> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Container> *instancePtr);


 static void destroy(Container *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ingamecatalog/v5/ContainerApi.h" 2 3


namespace sce {
namespace Np {
namespace CppWebApi {
namespace InGameCatalog {
namespace V5 {

class ContainerApi {
public:

 class ParameterToGetContainer : public Common::ParameterBase {
 public:
  ParameterToGetContainer();
  ~ParameterToGetContainer();

  enum class Direction {
   _NOT_SET = 0,
   kAsc,
   kDesc,
  };

  enum class Sort {
   _NOT_SET = 0,
   kName,
   kPrice,
   kReleaseDate,
  };

  enum class ServiceName {
   _NOT_SET = 0,
   kPssdc,
   kCce,
  };

  int32_t initialize(
   Common::LibContext * context
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getcontainerIds() const;
  int32_t setcontainerIds(const char* containerIds) __attribute__((warn_unused_result));
  void unsetcontainerIds();
  bool hascontainerIds() const;


  int32_t getoffset() const;
  void setoffset(int32_t offset);
  void unsetoffset();
  bool hasoffset() const;


  bool getkeepHtmlTag() const;
  void setkeepHtmlTag(bool keepHtmlTag);
  void unsetkeepHtmlTag();
  bool haskeepHtmlTag() const;


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;


  Direction getdirection() const;
  void setdirection(Direction direction);
  void unsetdirection();
  bool hasdirection() const;


  Sort getsort() const;
  void setsort(Sort sort);
  void unsetsort();
  bool hassort() const;


  int32_t getserviceLabel() const;
  void setserviceLabel(int32_t serviceLabel);
  void unsetserviceLabel();
  bool hasserviceLabel() const;


  ServiceName getserviceName() const;
  void setserviceName(ServiceName serviceName);
  void unsetserviceName();
  bool hasserviceName() const;


  bool getuseFree() const;
  void setuseFree(bool useFree);
  void unsetuseFree();
  bool hasuseFree() const;


  bool getuseCurrencySymbol() const;
  void setuseCurrencySymbol(bool useCurrencySymbol);
  void unsetuseCurrencySymbol();
  bool hasuseCurrencySymbol() const;


  const Common::String& getacceptLanguage() const;
  int32_t setacceptLanguage(const char* acceptLanguage) __attribute__((warn_unused_result));
  void unsetacceptLanguage();
  bool hasacceptLanguage() const;

  struct ParameterImplToGetContainer;

 private:
  struct ParameterImplToGetContainer *m_pimpl;

  ParameterToGetContainer(ParameterToGetContainer &param);
  ParameterToGetContainer(const ParameterToGetContainer &param);
  ParameterToGetContainer& operator=(ParameterToGetContainer &param);
  ParameterToGetContainer& operator=(const ParameterToGetContainer &param);
 };

 static int32_t getContainer(
  int32_t npwebapiUserCtxId,
  const ParameterToGetContainer &param,
  Common::Transaction<Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Container>>>> &transaction
  );

private:
 ContainerApi();
 ~ContainerApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/in_game_catalog.h" 2 3
# 327 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/BoardsApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/BoardsApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/ErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/ErrorResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class Error : public Common::RefObject
{
public:

 int32_t getCode() const;
 void setCode(const int32_t &code);


 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 int32_t m_code;

 Common::String m_message;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t code,
  const char* message,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/ErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class ErrorResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorResponse(Common::LibContext * context);
 friend class ErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::ErrorResponse>;

 ~ErrorResponse();

protected:
    ErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;


};

class ErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<Error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);


 static void destroy(ErrorResponse *instance);
};
using PsnErrorObject = ErrorResponse;
using PsnErrorObjectFactory = ErrorResponseFactory;


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/BoardsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetBoardDefinitionResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetBoardDefinitionResponseBody.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/SortMode.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/SortMode.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

 enum class SortMode {
  _NOT_SET = 0,
  kAsc,
  kDesc,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetBoardDefinitionResponseBody.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/UpdateMode.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/UpdateMode.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

 enum class UpdateMode {
  _NOT_SET = 0,
  kWithBestScore,
  kAlways,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetBoardDefinitionResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class GetBoardDefinitionResponseBody : public PsnErrorObject
{
public:

 bool entryLimitIsSet() const;
 void unsetEntryLimit();
 int32_t getEntryLimit() const;
 void setEntryLimit(const int32_t &entryLimit);


 bool largeDataNumLimitIsSet() const;
 void unsetLargeDataNumLimit();
 int32_t getLargeDataNumLimit() const;
 void setLargeDataNumLimit(const int32_t &largeDataNumLimit);


 bool largeDataSizeLimitIsSet() const;
 void unsetLargeDataSizeLimit();
 int64_t getLargeDataSizeLimit() const;
 void setLargeDataSizeLimit(const int64_t &largeDataSizeLimit);


 bool maxScoreLimitIsSet() const;
 void unsetMaxScoreLimit();
 int64_t getMaxScoreLimit() const;
 void setMaxScoreLimit(const int64_t &maxScoreLimit);


 bool minScoreLimitIsSet() const;
 void unsetMinScoreLimit();
 int64_t getMinScoreLimit() const;
 void setMinScoreLimit(const int64_t &minScoreLimit);


 bool sortModeIsSet() const;
 void unsetSortMode();
 SortMode getSortMode() const;
 void setSortMode(const SortMode &sortMode);


 bool updateModeIsSet() const;
 void unsetUpdateMode();
 UpdateMode getUpdateMode() const;
 void setUpdateMode(const UpdateMode &updateMode);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetBoardDefinitionResponseBody(Common::LibContext * context);
 friend class GetBoardDefinitionResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::GetBoardDefinitionResponseBody>;

 ~GetBoardDefinitionResponseBody();

private:
 Common::LibContext * m_context;

 int32_t m_entryLimit;
 bool m_entryLimitIsSet;

 int32_t m_largeDataNumLimit;
 bool m_largeDataNumLimitIsSet;

 int64_t m_largeDataSizeLimit;
 bool m_largeDataSizeLimitIsSet;

 int64_t m_maxScoreLimit;
 bool m_maxScoreLimitIsSet;

 int64_t m_minScoreLimit;
 bool m_minScoreLimitIsSet;

 SortMode m_sortMode;
 bool m_sortModeIsSet;

 UpdateMode m_updateMode;
 bool m_updateModeIsSet;


    GetBoardDefinitionResponseBody();
};

class GetBoardDefinitionResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetBoardDefinitionResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetBoardDefinitionResponseBody> *instancePtr);


 static void destroy(GetBoardDefinitionResponseBody *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/BoardsApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class BoardsApi {
public:

 class ParameterToGetBoardDefinition : public Common::ParameterBase {
 public:
  ParameterToGetBoardDefinition();
  ~ParameterToGetBoardDefinition();

  int32_t initialize(
   Common::LibContext * context
   , int32_t boardId
   );

  int32_t terminate();

  bool isInitialized() const;


  int32_t getboardId() const;
  void setboardId(int32_t boardId);


  const Common::String& getfields() const;
  int32_t setfields(const char* fields) __attribute__((warn_unused_result));
  void unsetfields();
  bool hasfields() const;


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;

  struct ParameterImplToGetBoardDefinition;

 private:
  struct ParameterImplToGetBoardDefinition *m_pimpl;

  ParameterToGetBoardDefinition(ParameterToGetBoardDefinition &param);
  ParameterToGetBoardDefinition(const ParameterToGetBoardDefinition &param);
  ParameterToGetBoardDefinition& operator=(ParameterToGetBoardDefinition &param);
  ParameterToGetBoardDefinition& operator=(const ParameterToGetBoardDefinition &param);
 };

 static int32_t getBoardDefinition(
  int32_t npwebapiUserCtxId,
  const ParameterToGetBoardDefinition &param,
  Common::Transaction<Common::IntrusivePtr<GetBoardDefinitionResponseBody>> &transaction
  );

private:
 BoardsApi();
 ~BoardsApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/RecordApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/RecordApi.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/RecordLargeDataResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/RecordLargeDataResponseBody.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class RecordLargeDataResponseBody : public PsnErrorObject
{
public:

 const Common::String & getObjectId() const;
 int32_t setObjectId(const char* objectId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RecordLargeDataResponseBody(Common::LibContext * context);
 friend class RecordLargeDataResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::RecordLargeDataResponseBody>;

 ~RecordLargeDataResponseBody();

private:
 Common::LibContext * m_context;

 Common::String m_objectId;


    RecordLargeDataResponseBody();
};

class RecordLargeDataResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* objectId,
  sce::Np::CppWebApi::Common::IntrusivePtr<RecordLargeDataResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RecordLargeDataResponseBody> *instancePtr);


 static void destroy(RecordLargeDataResponseBody *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/RecordApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/RecordScoreRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/RecordScoreRequestBody.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/binary.h" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/common/binary.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace Common {
class LibContext;

class Binary : public Common::RefObject
{
 char * m_ptr;
 size_t m_size;
 Common::LibContext * m_context;

 Binary(const Binary& rhs) = delete;
 Binary& operator=(const Binary& rhs) = delete;

public:
 static void intrusive_ptr_add_ref(Binary * c);
 static void intrusive_ptr_sub_ref(Binary * c);

 Binary(Common::LibContext * context);
 ~Binary();

 size_t size() const;
 void clear();
 const void * getBinary() const;
 int32_t setBinary(const void * p, size_t size) __attribute__((warn_unused_result));
 int32_t appendBinary(const void * p, size_t size) __attribute__((warn_unused_result));
};

}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/RecordScoreRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class RecordScoreRequestBody : public Common::RefObject
{
public:

 bool commentIsSet() const;
 void unsetComment();
 const Common::String & getComment() const;
 int32_t setComment(const char* comment) __attribute__((warn_unused_result));


 bool comparedDateTimeIsSet() const;
 void unsetComparedDateTime();
 SceRtcTick getComparedDateTime() const;
 void setComparedDateTime(const SceRtcTick &comparedDateTime);


 bool needsTmpRankIsSet() const;
 void unsetNeedsTmpRank();
 bool getNeedsTmpRank() const;
 void setNeedsTmpRank(const bool &needsTmpRank);


 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 SceNpServiceLabel getNpServiceLabel() const;
 void setNpServiceLabel(const SceNpServiceLabel &npServiceLabel);


 bool pcIdIsSet() const;
 void unsetPcId();
 int32_t getPcId() const;
 void setPcId(const int32_t &pcId);


 int64_t getScore() const;
 void setScore(const int64_t &score);


 bool smallDataIsSet() const;
 void unsetSmallData();
 const Common::IntrusivePtr<Common::Binary> & getSmallData() const;
 int32_t setSmallData(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool waitsForDataIsSet() const;
 void unsetWaitsForData();
 bool getWaitsForData() const;
 void setWaitsForData(const bool &waitsForData);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RecordScoreRequestBody(Common::LibContext * context);
 friend class RecordScoreRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::RecordScoreRequestBody>;

 ~RecordScoreRequestBody();

private:
 Common::LibContext * m_context;

 Common::String m_comment;
 bool m_commentIsSet;

 SceRtcTick m_comparedDateTime;
 bool m_comparedDateTimeIsSet;

 bool m_needsTmpRank;
 bool m_needsTmpRankIsSet;

 SceNpServiceLabel m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 int32_t m_pcId;
 bool m_pcIdIsSet;

 int64_t m_score;

 Common::IntrusivePtr<Common::Binary> m_smallData;
 bool m_smallDataIsSet;

 bool m_waitsForData;
 bool m_waitsForDataIsSet;


    RecordScoreRequestBody();
};

class RecordScoreRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int64_t score,
  sce::Np::CppWebApi::Common::IntrusivePtr<RecordScoreRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RecordScoreRequestBody> *instancePtr);


 static void destroy(RecordScoreRequestBody *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/RecordApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/RecordScoreResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/RecordScoreResponseBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class RecordScoreResponseBody : public PsnErrorObject
{
public:

 int32_t getTmpRank() const;
 void setTmpRank(const int32_t &tmpRank);


 int32_t getTmpSerialRank() const;
 void setTmpSerialRank(const int32_t &tmpSerialRank);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RecordScoreResponseBody(Common::LibContext * context);
 friend class RecordScoreResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::RecordScoreResponseBody>;

 ~RecordScoreResponseBody();

private:
 Common::LibContext * m_context;

 int32_t m_tmpRank;

 int32_t m_tmpSerialRank;


    RecordScoreResponseBody();
};

class RecordScoreResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t tmpRank,
  int32_t tmpSerialRank,
  sce::Np::CppWebApi::Common::IntrusivePtr<RecordScoreResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RecordScoreResponseBody> *instancePtr);


 static void destroy(RecordScoreResponseBody *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/RecordApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class RecordApi {
public:

 class ParameterToRecordLargeData : public Common::ParameterBase {
 public:
  ParameterToRecordLargeData();
  ~ParameterToRecordLargeData();

  enum class XPsnAtomicOperation {
   _NOT_SET = 0,
   kEnd,
  };

  int32_t initialize(
   Common::LibContext * context
   , int32_t boardId
   , XPsnAtomicOperation xPsnAtomicOperation
   , const char* xPsnAtomicOperationId
   );

  int32_t terminate();

  bool isInitialized() const;


  int32_t getboardId() const;
  void setboardId(int32_t boardId);


  XPsnAtomicOperation getxPsnAtomicOperation() const;
  void setxPsnAtomicOperation(XPsnAtomicOperation xPsnAtomicOperation);


  const Common::String& getxPsnAtomicOperationId() const;
  int32_t setxPsnAtomicOperationId(const char* xPsnAtomicOperationId) __attribute__((warn_unused_result));


  SceNpServiceLabel getxPsnNpServiceLabel() const;
  void setxPsnNpServiceLabel(SceNpServiceLabel xPsnNpServiceLabel);
  void unsetxPsnNpServiceLabel();
  bool hasxPsnNpServiceLabel() const;

  struct ParameterImplToRecordLargeData;

 protected:
  struct ParameterImplToRecordLargeData *m_pimpl;

  ParameterToRecordLargeData(ParameterToRecordLargeData &param);
  ParameterToRecordLargeData(const ParameterToRecordLargeData &param);
  ParameterToRecordLargeData& operator=(ParameterToRecordLargeData &param);
  ParameterToRecordLargeData& operator=(const ParameterToRecordLargeData &param);
 };

 class ParameterWithBinaryRequestBodyToRecordLargeData : public ParameterToRecordLargeData {
 public:
  ParameterWithBinaryRequestBodyToRecordLargeData();
  ~ParameterWithBinaryRequestBodyToRecordLargeData();

  int32_t initialize(
   Common::LibContext * context
   , int32_t boardId
   , XPsnAtomicOperation xPsnAtomicOperation
   , const char* xPsnAtomicOperationId
   , const uint8_t *requestBody
   , size_t requestBodySize
   );

  int32_t terminate();

  const Common::IntrusivePtr<Common::Binary> & getRequestBody() const;
  int32_t setRequestBody(const uint8_t *requestBody, size_t requestBodySize) __attribute__((warn_unused_result));

 };

 static int32_t recordLargeData(
  int32_t npwebapiUserCtxId,
  const ParameterWithBinaryRequestBodyToRecordLargeData &param,
  Common::Transaction<Common::IntrusivePtr<RecordLargeDataResponseBody>> &transaction
  );

 static int32_t recordLargeData(
  int32_t npwebapiUserCtxId,
  const ParameterToRecordLargeData &param,
  Common::UpStreamTransaction<Common::IntrusivePtr<RecordLargeDataResponseBody>> &transaction
  );

 class ParameterToRecordScore : public Common::ParameterBase {
 public:
  ParameterToRecordScore();
  ~ParameterToRecordScore();

  enum class XPsnAtomicOperation {
   _NOT_SET = 0,
   kBegin,
  };

  int32_t initialize(
   Common::LibContext * context
   , int32_t boardId
   , Common::IntrusivePtr< RecordScoreRequestBody > recordScoreRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  int32_t getboardId() const;
  void setboardId(int32_t boardId);


  Common::IntrusivePtr< RecordScoreRequestBody > getrecordScoreRequestBody() const;
  void setrecordScoreRequestBody(Common::IntrusivePtr< RecordScoreRequestBody > recordScoreRequestBody);


  XPsnAtomicOperation getxPsnAtomicOperation() const;
  void setxPsnAtomicOperation(XPsnAtomicOperation xPsnAtomicOperation);
  void unsetxPsnAtomicOperation();
  bool hasxPsnAtomicOperation() const;

  struct ParameterImplToRecordScore;

 private:
  struct ParameterImplToRecordScore *m_pimpl;

  ParameterToRecordScore(ParameterToRecordScore &param);
  ParameterToRecordScore(const ParameterToRecordScore &param);
  ParameterToRecordScore& operator=(ParameterToRecordScore &param);
  ParameterToRecordScore& operator=(const ParameterToRecordScore &param);
 };

 class RecordScoreResponseHeaders : public sce::Np::CppWebApi::Common::ResponseHeaderBase
 {
 public:
  RecordScoreResponseHeaders();
  ~RecordScoreResponseHeaders();
  static void intrusive_ptr_add_ref(RecordScoreResponseHeaders * c);
  static void intrusive_ptr_sub_ref(RecordScoreResponseHeaders * c);

  static int32_t create(
   Common::LibContext * context,
   Common::IntrusivePtr<RecordScoreResponseHeaders> &headersPtr,
   int64_t reqId
   );
  static void destroy(
   RecordScoreResponseHeaders *headers
   );


  const Common::String & getXPsnAtomicOperationId() const;
  int32_t setXPsnAtomicOperationId(const Common::String& XPsnAtomicOperationId) __attribute__((warn_unused_result));
  void unsetXPsnAtomicOperationId();
  bool hasXPsnAtomicOperationId() const;

  struct RecordScoreResponseHeadersImpl;

 private:
  struct RecordScoreResponseHeadersImpl *m_pimpl;

  RecordScoreResponseHeaders(RecordScoreResponseHeaders &param);
  RecordScoreResponseHeaders(const RecordScoreResponseHeaders &param);
  RecordScoreResponseHeaders& operator=(RecordScoreResponseHeaders &param);
  RecordScoreResponseHeaders& operator=(const RecordScoreResponseHeaders &param);
 };

 static int32_t recordScore(
  int32_t npwebapiUserCtxId,
  const ParameterToRecordScore &param,
  Common::Transaction<Common::IntrusivePtr<RecordScoreResponseBody>, Common::IntrusivePtr<RecordScoreResponseHeaders>> &transaction
  );

private:
 RecordApi();
 ~RecordApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/ViewApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/ViewApi.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetRankingRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetRankingRequestBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/Group.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/Group.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

 enum class Group {
  _NOT_SET = 0,
  kFriends,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetRankingRequestBody.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/User.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/User.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class User : public Common::RefObject
{
public:

 bool accountIdIsSet() const;
 void unsetAccountId();
 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool pcIdIsSet() const;
 void unsetPcId();
 int32_t getPcId() const;
 void setPcId(const int32_t &pcId);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 User(Common::LibContext * context);
 friend class UserFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::User>;

 ~User();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;
 bool m_accountIdIsSet;

 int32_t m_pcId;
 bool m_pcIdIsSet;


    User();
};

class UserFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<User> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<User> *instancePtr);


 static void destroy(User *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetRankingRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class GetRankingRequestBody : public Common::RefObject
{
public:

 bool centerToEdgeLimitIsSet() const;
 void unsetCenterToEdgeLimit();
 int32_t getCenterToEdgeLimit() const;
 void setCenterToEdgeLimit(const int32_t &centerToEdgeLimit);


 bool groupIsSet() const;
 void unsetGroup();
 Group getGroup() const;
 void setGroup(const Group &group);


 bool limitIsSet() const;
 void unsetLimit();
 int32_t getLimit() const;
 void setLimit(const int32_t &limit);


 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 SceNpServiceLabel getNpServiceLabel() const;
 void setNpServiceLabel(const SceNpServiceLabel &npServiceLabel);


 bool offsetIsSet() const;
 void unsetOffset();
 int32_t getOffset() const;
 void setOffset(const int32_t &offset);


 bool startSerialRankIsSet() const;
 void unsetStartSerialRank();
 int32_t getStartSerialRank() const;
 void setStartSerialRank(const int32_t &startSerialRank);


 bool userCenteredAroundIsSet() const;
 void unsetUserCenteredAround();
 Common::IntrusivePtr<User> getUserCenteredAround() const;
 int32_t setUserCenteredAround(const Common::IntrusivePtr<User> &userCenteredAround) __attribute__((warn_unused_result));


 bool usersIsSet() const;
 void unsetUsers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<User>>> getUsers();
 int32_t setUsers(const Common::Vector<Common::IntrusivePtr<User>> &users) __attribute__((warn_unused_result));


 bool needsRecordedDateTimeIsSet() const;
 void unsetNeedsRecordedDateTime();
 bool getNeedsRecordedDateTime() const;
 void setNeedsRecordedDateTime(const bool &needsRecordedDateTime);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetRankingRequestBody(Common::LibContext * context);
 friend class GetRankingRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::GetRankingRequestBody>;

 ~GetRankingRequestBody();

private:
 Common::LibContext * m_context;

 int32_t m_centerToEdgeLimit;
 bool m_centerToEdgeLimitIsSet;

 Group m_group;
 bool m_groupIsSet;

 int32_t m_limit;
 bool m_limitIsSet;

 SceNpServiceLabel m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 int32_t m_offset;
 bool m_offsetIsSet;

 int32_t m_startSerialRank;
 bool m_startSerialRankIsSet;

 Common::IntrusivePtr<User> m_userCenteredAround;
 bool m_userCenteredAroundIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<User>>> m_users;
 bool m_usersIsSet;

 bool m_needsRecordedDateTime;
 bool m_needsRecordedDateTimeIsSet;


    GetRankingRequestBody();
};

class GetRankingRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetRankingRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetRankingRequestBody> *instancePtr);


 static void destroy(GetRankingRequestBody *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/ViewApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetRankingResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetRankingResponseBody.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/Entry.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/Entry.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class Entry : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool commentIsSet() const;
 void unsetComment();
 const Common::String & getComment() const;
 int32_t setComment(const char* comment) __attribute__((warn_unused_result));


 int32_t getHighestRank() const;
 void setHighestRank(const int32_t &highestRank);


 int32_t getHighestSerialRank() const;
 void setHighestSerialRank(const int32_t &highestSerialRank);


 bool objectIdIsSet() const;
 void unsetObjectId();
 const Common::String & getObjectId() const;
 int32_t setObjectId(const char* objectId) __attribute__((warn_unused_result));


 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 bool pcIdIsSet() const;
 void unsetPcId();
 int32_t getPcId() const;
 void setPcId(const int32_t &pcId);


 int32_t getRank() const;
 void setRank(const int32_t &rank);


 int64_t getScore() const;
 void setScore(const int64_t &score);


 int32_t getSerialRank() const;
 void setSerialRank(const int32_t &serialRank);


 bool smallDataIsSet() const;
 void unsetSmallData();
 const Common::IntrusivePtr<Common::Binary> & getSmallData() const;
 int32_t setSmallData(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool recordedDateTimeIsSet() const;
 void unsetRecordedDateTime();
 SceRtcTick getRecordedDateTime() const;
 void setRecordedDateTime(const SceRtcTick &recordedDateTime);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Entry(Common::LibContext * context);
 friend class EntryFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::Entry>;

 ~Entry();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 Common::String m_comment;
 bool m_commentIsSet;

 int32_t m_highestRank;

 int32_t m_highestSerialRank;

 Common::String m_objectId;
 bool m_objectIdIsSet;

 SceNpOnlineId m_onlineId;

 int32_t m_pcId;
 bool m_pcIdIsSet;

 int32_t m_rank;

 int64_t m_score;

 int32_t m_serialRank;

 Common::IntrusivePtr<Common::Binary> m_smallData;
 bool m_smallDataIsSet;

 SceRtcTick m_recordedDateTime;
 bool m_recordedDateTimeIsSet;


    Entry();
};

class EntryFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  int32_t highestRank,
  int32_t highestSerialRank,
  const SceNpOnlineId &onlineId,
  int32_t rank,
  int64_t score,
  int32_t serialRank,
  sce::Np::CppWebApi::Common::IntrusivePtr<Entry> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Entry> *instancePtr);


 static void destroy(Entry *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Leaderboards/V1/GetRankingResponseBody.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class GetRankingResponseBody : public PsnErrorObject
{
public:

 bool entriesIsSet() const;
 void unsetEntries();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Entry>>> getEntries();
 int32_t setEntries(const Common::Vector<Common::IntrusivePtr<Entry>> &entries) __attribute__((warn_unused_result));


 SceRtcTick getLastUpdatedDateTime() const;
 void setLastUpdatedDateTime(const SceRtcTick &lastUpdatedDateTime);


 int32_t getTotalEntryCount() const;
 void setTotalEntryCount(const int32_t &totalEntryCount);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetRankingResponseBody(Common::LibContext * context);
 friend class GetRankingResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Leaderboards::V1::GetRankingResponseBody>;

 ~GetRankingResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Entry>>> m_entries;
 bool m_entriesIsSet;

 SceRtcTick m_lastUpdatedDateTime;

 int32_t m_totalEntryCount;


    GetRankingResponseBody();
};

class GetRankingResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceRtcTick &lastUpdatedDateTime,
  int32_t totalEntryCount,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetRankingResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetRankingResponseBody> *instancePtr);


 static void destroy(GetRankingResponseBody *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards/v1/ViewApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace Leaderboards {
namespace V1 {

class ViewApi {
public:

 class ParameterToGetLargeDataByObjectId : public Common::ParameterBase {
 public:
  ParameterToGetLargeDataByObjectId();
  ~ParameterToGetLargeDataByObjectId();

  int32_t initialize(
   Common::LibContext * context
   , const char* objectId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getobjectId() const;
  int32_t setobjectId(const char* objectId) __attribute__((warn_unused_result));


  const Common::String& getrange() const;
  int32_t setrange(const char* range) __attribute__((warn_unused_result));
  void unsetrange();
  bool hasrange() const;


  const Common::String& getifMatch() const;
  int32_t setifMatch(const char* ifMatch) __attribute__((warn_unused_result));
  void unsetifMatch();
  bool hasifMatch() const;


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;

  struct ParameterImplToGetLargeDataByObjectId;

 private:
  struct ParameterImplToGetLargeDataByObjectId *m_pimpl;

  ParameterToGetLargeDataByObjectId(ParameterToGetLargeDataByObjectId &param);
  ParameterToGetLargeDataByObjectId(const ParameterToGetLargeDataByObjectId &param);
  ParameterToGetLargeDataByObjectId& operator=(ParameterToGetLargeDataByObjectId &param);
  ParameterToGetLargeDataByObjectId& operator=(const ParameterToGetLargeDataByObjectId &param);
 };

 class GetLargeDataByObjectIdResponseHeaders : public sce::Np::CppWebApi::Common::ResponseHeaderBase
 {
 public:
  GetLargeDataByObjectIdResponseHeaders();
  ~GetLargeDataByObjectIdResponseHeaders();
  static void intrusive_ptr_add_ref(GetLargeDataByObjectIdResponseHeaders * c);
  static void intrusive_ptr_sub_ref(GetLargeDataByObjectIdResponseHeaders * c);

  static int32_t create(
   Common::LibContext * context,
   Common::IntrusivePtr<GetLargeDataByObjectIdResponseHeaders> &headersPtr,
   int64_t reqId
   );
  static void destroy(
   GetLargeDataByObjectIdResponseHeaders *headers
   );


  const Common::String & getETag() const;
  int32_t setETag(const Common::String& ETag) __attribute__((warn_unused_result));
  void unsetETag();
  bool hasETag() const;


  const Common::String & getLastModified() const;
  int32_t setLastModified(const Common::String& LastModified) __attribute__((warn_unused_result));
  void unsetLastModified();
  bool hasLastModified() const;

  struct GetLargeDataByObjectIdResponseHeadersImpl;

 private:
  struct GetLargeDataByObjectIdResponseHeadersImpl *m_pimpl;

  GetLargeDataByObjectIdResponseHeaders(GetLargeDataByObjectIdResponseHeaders &param);
  GetLargeDataByObjectIdResponseHeaders(const GetLargeDataByObjectIdResponseHeaders &param);
  GetLargeDataByObjectIdResponseHeaders& operator=(GetLargeDataByObjectIdResponseHeaders &param);
  GetLargeDataByObjectIdResponseHeaders& operator=(const GetLargeDataByObjectIdResponseHeaders &param);
 };

 static int32_t getLargeDataByObjectId(
  int32_t npwebapiUserCtxId,
  const ParameterToGetLargeDataByObjectId &param,
  Common::Transaction<Common::IntrusivePtr < Common::Binary >, Common::IntrusivePtr<GetLargeDataByObjectIdResponseHeaders>> &transaction
  );

 static int32_t getLargeDataByObjectId(
  int32_t npwebapiUserCtxId,
  const ParameterToGetLargeDataByObjectId &param,
  Common::DownStreamTransaction<Common::IntrusivePtr<GetLargeDataByObjectIdResponseHeaders>> &transaction
  );

 class ParameterToGetRanking : public Common::ParameterBase {
 public:
  ParameterToGetRanking();
  ~ParameterToGetRanking();

  int32_t initialize(
   Common::LibContext * context
   , int32_t boardId
   );

  int32_t terminate();

  bool isInitialized() const;


  int32_t getboardId() const;
  void setboardId(int32_t boardId);


  Common::IntrusivePtr< GetRankingRequestBody > getgetRankingRequestBody() const;
  void setgetRankingRequestBody(Common::IntrusivePtr< GetRankingRequestBody > getRankingRequestBody);
  void unsetgetRankingRequestBody();
  bool hasgetRankingRequestBody() const;

  struct ParameterImplToGetRanking;

 private:
  struct ParameterImplToGetRanking *m_pimpl;

  ParameterToGetRanking(ParameterToGetRanking &param);
  ParameterToGetRanking(const ParameterToGetRanking &param);
  ParameterToGetRanking& operator=(ParameterToGetRanking &param);
  ParameterToGetRanking& operator=(const ParameterToGetRanking &param);
 };

 static int32_t getRanking(
  int32_t npwebapiUserCtxId,
  const ParameterToGetRanking &param,
  Common::Transaction<Common::IntrusivePtr<GetRankingResponseBody>> &transaction
  );

private:
 ViewApi();
 ~ViewApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/leaderboards.h" 2 3
# 328 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/CreateMatchRequest.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/CreateMatchRequest.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestInGameRoster.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestInGameRoster.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchPlayer.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/PlayerType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/PlayerType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class PlayerType {
  _NOT_SET = 0,
  kPsnPlayer,
  kNonPsnPlayer,
  kNpc,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchPlayer.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestMatchPlayer : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 PlayerType getPlayerType() const;
 void setPlayerType(const PlayerType &playerType);


 bool playerNameIsSet() const;
 void unsetPlayerName();
 const Common::String & getPlayerName() const;
 int32_t setPlayerName(const char* playerName) __attribute__((warn_unused_result));


 bool accountIdIsSet() const;
 void unsetAccountId();
 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestMatchPlayer(Common::LibContext * context);
 friend class RequestMatchPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestMatchPlayer>;

 ~RequestMatchPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 PlayerType m_playerType;

 Common::String m_playerName;
 bool m_playerNameIsSet;

 Common::String m_accountId;
 bool m_accountIdIsSet;


    RequestMatchPlayer();
};

class RequestMatchPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  PlayerType playerType,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMatchPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMatchPlayer> *instancePtr);


 static void destroy(RequestMatchPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestInGameRoster.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchTeam.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchTeam.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMember.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMember.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestMember : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestMember(Common::LibContext * context);
 friend class RequestMemberFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestMember>;

 ~RequestMember();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;


    RequestMember();
};

class RequestMemberFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMember> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMember> *instancePtr);


 static void destroy(RequestMember *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchTeam.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestMatchTeam : public Common::RefObject
{
public:

 const Common::String & getTeamId() const;
 int32_t setTeamId(const char* teamId) __attribute__((warn_unused_result));


 bool teamNameIsSet() const;
 void unsetTeamName();
 const Common::String & getTeamName() const;
 int32_t setTeamName(const char* teamName) __attribute__((warn_unused_result));


 bool membersIsSet() const;
 void unsetMembers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestMember>>> getMembers();
 int32_t setMembers(const Common::Vector<Common::IntrusivePtr<RequestMember>> &members) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestMatchTeam(Common::LibContext * context);
 friend class RequestMatchTeamFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestMatchTeam>;

 ~RequestMatchTeam();

private:
 Common::LibContext * m_context;

 Common::String m_teamId;

 Common::String m_teamName;
 bool m_teamNameIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestMember>>> m_members;
 bool m_membersIsSet;


    RequestMatchTeam();
};

class RequestMatchTeamFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* teamId,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMatchTeam> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMatchTeam> *instancePtr);


 static void destroy(RequestMatchTeam *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestInGameRoster.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestInGameRoster : public Common::RefObject
{
public:

 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestMatchPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<RequestMatchPlayer>> &players) __attribute__((warn_unused_result));


 bool teamsIsSet() const;
 void unsetTeams();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestMatchTeam>>> getTeams();
 int32_t setTeams(const Common::Vector<Common::IntrusivePtr<RequestMatchTeam>> &teams) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestInGameRoster(Common::LibContext * context);
 friend class RequestInGameRosterFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestInGameRoster>;

 ~RequestInGameRoster();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestMatchPlayer>>> m_players;
 bool m_playersIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestMatchTeam>>> m_teams;
 bool m_teamsIsSet;


    RequestInGameRoster();
};

class RequestInGameRosterFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestInGameRoster> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestInGameRoster> *instancePtr);


 static void destroy(RequestInGameRoster *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/CreateMatchRequest.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class CreateMatchRequest : public Common::RefObject
{
public:

 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 int32_t getNpServiceLabel() const;
 void setNpServiceLabel(const int32_t &npServiceLabel);


 const Common::String & getActivityId() const;
 int32_t setActivityId(const char* activityId) __attribute__((warn_unused_result));


 bool zoneIdIsSet() const;
 void unsetZoneId();
 const Common::String & getZoneId() const;
 int32_t setZoneId(const char* zoneId) __attribute__((warn_unused_result));


 bool expirationTimeIsSet() const;
 void unsetExpirationTime();
 int32_t getExpirationTime() const;
 void setExpirationTime(const int32_t &expirationTime);


 bool cancellationTimeIsSet() const;
 void unsetCancellationTime();
 int32_t getCancellationTime() const;
 void setCancellationTime(const int32_t &cancellationTime);


 bool customDataIsSet() const;
 void unsetCustomData();
 const Common::String & getCustomData() const;
 int32_t setCustomData(const char* customData) __attribute__((warn_unused_result));


 bool inGameRosterIsSet() const;
 void unsetInGameRoster();
 Common::IntrusivePtr<RequestInGameRoster> getInGameRoster() const;
 int32_t setInGameRoster(const Common::IntrusivePtr<RequestInGameRoster> &inGameRoster) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 CreateMatchRequest(Common::LibContext * context);
 friend class CreateMatchRequestFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::CreateMatchRequest>;

 ~CreateMatchRequest();

private:
 Common::LibContext * m_context;

 int32_t m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 Common::String m_activityId;

 Common::String m_zoneId;
 bool m_zoneIdIsSet;

 int32_t m_expirationTime;
 bool m_expirationTimeIsSet;

 int32_t m_cancellationTime;
 bool m_cancellationTimeIsSet;

 Common::String m_customData;
 bool m_customDataIsSet;

 Common::IntrusivePtr<RequestInGameRoster> m_inGameRoster;
 bool m_inGameRosterIsSet;


    CreateMatchRequest();
};

class CreateMatchRequestFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* activityId,
  sce::Np::CppWebApi::Common::IntrusivePtr<CreateMatchRequest> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<CreateMatchRequest> *instancePtr);


 static void destroy(CreateMatchRequest *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/CreateMatchResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/CreateMatchResponse.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ErrorResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class Error : public Common::RefObject
{
public:

 int32_t getCode() const;
 void setCode(const int32_t &code);


 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool reasonIsSet() const;
 void unsetReason();
 const Common::String & getReason() const;
 int32_t setReason(const char* reason) __attribute__((warn_unused_result));


 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 bool sourceIsSet() const;
 void unsetSource();
 const Common::String & getSource() const;
 int32_t setSource(const char* source) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 int32_t m_code;

 Common::String m_message;

 Common::String m_reason;
 bool m_reasonIsSet;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;

 Common::String m_source;
 bool m_sourceIsSet;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t code,
  const char* message,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ErrorResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorResponse(Common::LibContext * context);
 friend class ErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ErrorResponse>;

 ~ErrorResponse();

protected:
    ErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;


};

class ErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<Error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);


 static void destroy(ErrorResponse *instance);
};
using PsnErrorObject = ErrorResponse;
using PsnErrorObjectFactory = ErrorResponseFactory;


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/CreateMatchResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class CreateMatchResponse : public PsnErrorObject
{
public:

 const Common::String & getMatchId() const;
 int32_t setMatchId(const char* matchId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 CreateMatchResponse(Common::LibContext * context);
 friend class CreateMatchResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::CreateMatchResponse>;

 ~CreateMatchResponse();

private:
 Common::LibContext * m_context;

 Common::String m_matchId;


    CreateMatchResponse();
};

class CreateMatchResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* matchId,
  sce::Np::CppWebApi::Common::IntrusivePtr<CreateMatchResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<CreateMatchResponse> *instancePtr);


 static void destroy(CreateMatchResponse *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/CompetitionType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/CompetitionType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class CompetitionType {
  _NOT_SET = 0,
  kCompetitive,
  kCooperative,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseInGameRoster.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseInGameRoster.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchTeam.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchTeam.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMember.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMember.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseMember : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 bool getJoinFlag() const;
 void setJoinFlag(const bool &joinFlag);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseMember(Common::LibContext * context);
 friend class ResponseMemberFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseMember>;

 ~ResponseMember();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 bool m_joinFlag;


    ResponseMember();
};

class ResponseMemberFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  bool joinFlag,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMember> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMember> *instancePtr);


 static void destroy(ResponseMember *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchTeam.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseMatchTeam : public Common::RefObject
{
public:

 const Common::String & getTeamId() const;
 int32_t setTeamId(const char* teamId) __attribute__((warn_unused_result));


 bool teamNameIsSet() const;
 void unsetTeamName();
 const Common::String & getTeamName() const;
 int32_t setTeamName(const char* teamName) __attribute__((warn_unused_result));


 bool membersIsSet() const;
 void unsetMembers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseMember>>> getMembers();
 int32_t setMembers(const Common::Vector<Common::IntrusivePtr<ResponseMember>> &members) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseMatchTeam(Common::LibContext * context);
 friend class ResponseMatchTeamFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseMatchTeam>;

 ~ResponseMatchTeam();

private:
 Common::LibContext * m_context;

 Common::String m_teamId;

 Common::String m_teamName;
 bool m_teamNameIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseMember>>> m_members;
 bool m_membersIsSet;


    ResponseMatchTeam();
};

class ResponseMatchTeamFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* teamId,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMatchTeam> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMatchTeam> *instancePtr);


 static void destroy(ResponseMatchTeam *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseInGameRoster.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchPlayer.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseMatchPlayer : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 PlayerType getPlayerType() const;
 void setPlayerType(const PlayerType &playerType);


 bool playerNameIsSet() const;
 void unsetPlayerName();
 const Common::String & getPlayerName() const;
 int32_t setPlayerName(const char* playerName) __attribute__((warn_unused_result));


 bool accountIdIsSet() const;
 void unsetAccountId();
 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 bool onlineIdIsSet() const;
 void unsetOnlineId();
 const Common::String & getOnlineId() const;
 int32_t setOnlineId(const char* onlineId) __attribute__((warn_unused_result));


 bool getJoinFlag() const;
 void setJoinFlag(const bool &joinFlag);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseMatchPlayer(Common::LibContext * context);
 friend class ResponseMatchPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseMatchPlayer>;

 ~ResponseMatchPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 PlayerType m_playerType;

 Common::String m_playerName;
 bool m_playerNameIsSet;

 Common::String m_accountId;
 bool m_accountIdIsSet;

 Common::String m_onlineId;
 bool m_onlineIdIsSet;

 bool m_joinFlag;


    ResponseMatchPlayer();
};

class ResponseMatchPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  PlayerType playerType,
  bool joinFlag,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMatchPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMatchPlayer> *instancePtr);


 static void destroy(ResponseMatchPlayer *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseInGameRoster.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseInGameRoster : public Common::RefObject
{
public:

 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseMatchPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<ResponseMatchPlayer>> &players) __attribute__((warn_unused_result));


 bool teamsIsSet() const;
 void unsetTeams();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseMatchTeam>>> getTeams();
 int32_t setTeams(const Common::Vector<Common::IntrusivePtr<ResponseMatchTeam>> &teams) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseInGameRoster(Common::LibContext * context);
 friend class ResponseInGameRosterFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseInGameRoster>;

 ~ResponseInGameRoster();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseMatchPlayer>>> m_players;
 bool m_playersIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseMatchTeam>>> m_teams;
 bool m_teamsIsSet;


    ResponseInGameRoster();
};

class ResponseInGameRosterFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseInGameRoster> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseInGameRoster> *instancePtr);


 static void destroy(ResponseInGameRoster *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResultType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResultType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class ResultType {
  _NOT_SET = 0,
  kScore,
  kResult,
 };


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GroupingType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GroupingType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class GroupingType {
  _NOT_SET = 0,
  kTeamMatch,
  kNonTeamMatch,
 };


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchStatistics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchStatistics.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponsePlayerStatistic.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponsePlayerStatistic.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/AdditionalStatistic.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/AdditionalStatistic.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class AdditionalStatistic : public Common::RefObject
{
public:

 const Common::String & getStatsKey() const;
 int32_t setStatsKey(const char* statsKey) __attribute__((warn_unused_result));


 const Common::String & getStatsValue() const;
 int32_t setStatsValue(const char* statsValue) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 AdditionalStatistic(Common::LibContext * context);
 friend class AdditionalStatisticFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::AdditionalStatistic>;

 ~AdditionalStatistic();

private:
 Common::LibContext * m_context;

 Common::String m_statsKey;

 Common::String m_statsValue;


    AdditionalStatistic();
};

class AdditionalStatisticFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* statsKey,
  const char* statsValue,
  sce::Np::CppWebApi::Common::IntrusivePtr<AdditionalStatistic> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<AdditionalStatistic> *instancePtr);


 static void destroy(AdditionalStatistic *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponsePlayerStatistic.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponsePlayerStatistic : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> getStats();
 int32_t setStats(const Common::Vector<Common::IntrusivePtr<AdditionalStatistic>> &stats) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponsePlayerStatistic(Common::LibContext * context);
 friend class ResponsePlayerStatisticFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponsePlayerStatistic>;

 ~ResponsePlayerStatistic();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> m_stats;


    ResponsePlayerStatistic();
};

class ResponsePlayerStatisticFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>>::value_type &stats,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerStatistic> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerStatistic> *instancePtr);


 static void destroy(ResponsePlayerStatistic *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchStatistics.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamStatistic.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamStatistic.h" 2 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamMemberStatistic.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamMemberStatistic.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseTeamMemberStatistic : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> getStats();
 int32_t setStats(const Common::Vector<Common::IntrusivePtr<AdditionalStatistic>> &stats) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseTeamMemberStatistic(Common::LibContext * context);
 friend class ResponseTeamMemberStatisticFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseTeamMemberStatistic>;

 ~ResponseTeamMemberStatistic();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> m_stats;


    ResponseTeamMemberStatistic();
};

class ResponseTeamMemberStatisticFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>>::value_type &stats,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseTeamMemberStatistic> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseTeamMemberStatistic> *instancePtr);


 static void destroy(ResponseTeamMemberStatistic *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamStatistic.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseTeamStatistic : public Common::RefObject
{
public:

 const Common::String & getTeamId() const;
 int32_t setTeamId(const char* teamId) __attribute__((warn_unused_result));


 bool statsIsSet() const;
 void unsetStats();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> getStats();
 int32_t setStats(const Common::Vector<Common::IntrusivePtr<AdditionalStatistic>> &stats) __attribute__((warn_unused_result));


 bool teamMemberStatisticsIsSet() const;
 void unsetTeamMemberStatistics();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseTeamMemberStatistic>>> getTeamMemberStatistics();
 int32_t setTeamMemberStatistics(const Common::Vector<Common::IntrusivePtr<ResponseTeamMemberStatistic>> &teamMemberStatistics) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseTeamStatistic(Common::LibContext * context);
 friend class ResponseTeamStatisticFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseTeamStatistic>;

 ~ResponseTeamStatistic();

private:
 Common::LibContext * m_context;

 Common::String m_teamId;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> m_stats;
 bool m_statsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseTeamMemberStatistic>>> m_teamMemberStatistics;
 bool m_teamMemberStatisticsIsSet;


    ResponseTeamStatistic();
};

class ResponseTeamStatisticFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* teamId,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseTeamStatistic> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseTeamStatistic> *instancePtr);


 static void destroy(ResponseTeamStatistic *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchStatistics.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseMatchStatistics : public Common::RefObject
{
public:

 bool playerStatisticsIsSet() const;
 void unsetPlayerStatistics();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerStatistic>>> getPlayerStatistics();
 int32_t setPlayerStatistics(const Common::Vector<Common::IntrusivePtr<ResponsePlayerStatistic>> &playerStatistics) __attribute__((warn_unused_result));


 bool teamStatisticsIsSet() const;
 void unsetTeamStatistics();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseTeamStatistic>>> getTeamStatistics();
 int32_t setTeamStatistics(const Common::Vector<Common::IntrusivePtr<ResponseTeamStatistic>> &teamStatistics) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseMatchStatistics(Common::LibContext * context);
 friend class ResponseMatchStatisticsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseMatchStatistics>;

 ~ResponseMatchStatistics();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerStatistic>>> m_playerStatistics;
 bool m_playerStatisticsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseTeamStatistic>>> m_teamStatistics;
 bool m_teamStatisticsIsSet;


    ResponseMatchStatistics();
};

class ResponseMatchStatisticsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMatchStatistics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMatchStatistics> *instancePtr);


 static void destroy(ResponseMatchStatistics *instance);
};


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class ResponseMatchType {
  _NOT_SET = 0,
  kStandard,
  kPsnTournament,
 };


}
}
}
}
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchResults.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchResults.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseCooperativeResult.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseCooperativeResult.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class ResponseCooperativeResult {
  _NOT_SET = 0,
  kSuccess,
  kUnfinished,
  kFailed,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchResults.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseCompetitiveResult.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseCompetitiveResult.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponsePlayerResults.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponsePlayerResults.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponsePlayerResults : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 int32_t getRank() const;
 void setRank(const int32_t &rank);


 bool scoreIsSet() const;
 void unsetScore();
 double getScore() const;
 void setScore(const double &score);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponsePlayerResults(Common::LibContext * context);
 friend class ResponsePlayerResultsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponsePlayerResults>;

 ~ResponsePlayerResults();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 int32_t m_rank;

 double m_score;
 bool m_scoreIsSet;


    ResponsePlayerResults();
};

class ResponsePlayerResultsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  int32_t rank,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerResults> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerResults> *instancePtr);


 static void destroy(ResponsePlayerResults *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseCompetitiveResult.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamResults.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamResults.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamMemberResult.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamMemberResult.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseTeamMemberResult : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 double getScore() const;
 void setScore(const double &score);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseTeamMemberResult(Common::LibContext * context);
 friend class ResponseTeamMemberResultFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseTeamMemberResult>;

 ~ResponseTeamMemberResult();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 double m_score;


    ResponseTeamMemberResult();
};

class ResponseTeamMemberResultFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  double score,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseTeamMemberResult> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseTeamMemberResult> *instancePtr);


 static void destroy(ResponseTeamMemberResult *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseTeamResults.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseTeamResults : public Common::RefObject
{
public:

 const Common::String & getTeamId() const;
 int32_t setTeamId(const char* teamId) __attribute__((warn_unused_result));


 int32_t getRank() const;
 void setRank(const int32_t &rank);


 bool scoreIsSet() const;
 void unsetScore();
 double getScore() const;
 void setScore(const double &score);


 bool teamMemberResultsIsSet() const;
 void unsetTeamMemberResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseTeamMemberResult>>> getTeamMemberResults();
 int32_t setTeamMemberResults(const Common::Vector<Common::IntrusivePtr<ResponseTeamMemberResult>> &teamMemberResults) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseTeamResults(Common::LibContext * context);
 friend class ResponseTeamResultsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseTeamResults>;

 ~ResponseTeamResults();

private:
 Common::LibContext * m_context;

 Common::String m_teamId;

 int32_t m_rank;

 double m_score;
 bool m_scoreIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseTeamMemberResult>>> m_teamMemberResults;
 bool m_teamMemberResultsIsSet;


    ResponseTeamResults();
};

class ResponseTeamResultsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* teamId,
  int32_t rank,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseTeamResults> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseTeamResults> *instancePtr);


 static void destroy(ResponseTeamResults *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseCompetitiveResult.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseCompetitiveResult : public Common::RefObject
{
public:

 bool playerResultsIsSet() const;
 void unsetPlayerResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerResults>>> getPlayerResults();
 int32_t setPlayerResults(const Common::Vector<Common::IntrusivePtr<ResponsePlayerResults>> &playerResults) __attribute__((warn_unused_result));


 bool teamResultsIsSet() const;
 void unsetTeamResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseTeamResults>>> getTeamResults();
 int32_t setTeamResults(const Common::Vector<Common::IntrusivePtr<ResponseTeamResults>> &teamResults) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseCompetitiveResult(Common::LibContext * context);
 friend class ResponseCompetitiveResultFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseCompetitiveResult>;

 ~ResponseCompetitiveResult();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerResults>>> m_playerResults;
 bool m_playerResultsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseTeamResults>>> m_teamResults;
 bool m_teamResultsIsSet;


    ResponseCompetitiveResult();
};

class ResponseCompetitiveResultFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseCompetitiveResult> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseCompetitiveResult> *instancePtr);


 static void destroy(ResponseCompetitiveResult *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchResults.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResultsVersion.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResultsVersion.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class ResultsVersion {
  _NOT_SET = 0,
  k1,
 };


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ResponseMatchResults.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ResponseMatchResults : public Common::RefObject
{
public:

 ResultsVersion getVersion() const;
 void setVersion(const ResultsVersion &version);


 bool cooperativeResultIsSet() const;
 void unsetCooperativeResult();
 ResponseCooperativeResult getCooperativeResult() const;
 void setCooperativeResult(const ResponseCooperativeResult &cooperativeResult);


 bool competitiveResultIsSet() const;
 void unsetCompetitiveResult();
 Common::IntrusivePtr<ResponseCompetitiveResult> getCompetitiveResult() const;
 int32_t setCompetitiveResult(const Common::IntrusivePtr<ResponseCompetitiveResult> &competitiveResult) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseMatchResults(Common::LibContext * context);
 friend class ResponseMatchResultsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ResponseMatchResults>;

 ~ResponseMatchResults();

private:
 Common::LibContext * m_context;

 ResultsVersion m_version;

 ResponseCooperativeResult m_cooperativeResult;
 bool m_cooperativeResultIsSet;

 Common::IntrusivePtr<ResponseCompetitiveResult> m_competitiveResult;
 bool m_competitiveResultIsSet;


    ResponseMatchResults();
};

class ResponseMatchResultsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  ResultsVersion version,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMatchResults> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseMatchResults> *instancePtr);


 static void destroy(ResponseMatchResults *instance);
};


}
}
}
}
}
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Status.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Status.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class Status {
  _NOT_SET = 0,
  kScheduled,
  kWaiting,
  kPlaying,
  kOnhold,
  kCancelled,
  kCompleted,
 };


}
}
}
}
}
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Task.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Task.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/TaskAvailability.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/TaskAvailability.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class TaskAvailability {
  _NOT_SET = 0,
  kAvailable,
  kUnavailable,
 };


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Task.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/TaskStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/TaskStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class TaskStatus {
  _NOT_SET = 0,
  kWaiting,
  kPlaying,
  kCompleted,
 };


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Task.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Subtask.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Subtask.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/SubtaskStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/SubtaskStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class SubtaskStatus {
  _NOT_SET = 0,
  kWaiting,
  kPlaying,
  kCompleted,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Subtask.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/SubtaskAvailability.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/SubtaskAvailability.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class SubtaskAvailability {
  _NOT_SET = 0,
  kAvailable,
  kUnavailable,
 };


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Subtask.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class Subtask : public Common::RefObject
{
public:

 const Common::String & getActivityId() const;
 int32_t setActivityId(const char* activityId) __attribute__((warn_unused_result));


 SubtaskStatus getStatus() const;
 void setStatus(const SubtaskStatus &status);


 SubtaskAvailability getAvailability() const;
 void setAvailability(const SubtaskAvailability &availability);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Subtask(Common::LibContext * context);
 friend class SubtaskFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::Subtask>;

 ~Subtask();

private:
 Common::LibContext * m_context;

 Common::String m_activityId;

 SubtaskStatus m_status;

 SubtaskAvailability m_availability;


    Subtask();
};

class SubtaskFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* activityId,
  SubtaskStatus status,
  SubtaskAvailability availability,
  sce::Np::CppWebApi::Common::IntrusivePtr<Subtask> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Subtask> *instancePtr);


 static void destroy(Subtask *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/Task.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class Task : public Common::RefObject
{
public:

 const Common::String & getActivityId() const;
 int32_t setActivityId(const char* activityId) __attribute__((warn_unused_result));


 TaskStatus getStatus() const;
 void setStatus(const TaskStatus &status);


 TaskAvailability getAvailability() const;
 void setAvailability(const TaskAvailability &availability);


 bool subtasksIsSet() const;
 void unsetSubtasks();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Subtask>>> getSubtasks();
 int32_t setSubtasks(const Common::Vector<Common::IntrusivePtr<Subtask>> &subtasks) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Task(Common::LibContext * context);
 friend class TaskFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::Task>;

 ~Task();

private:
 Common::LibContext * m_context;

 Common::String m_activityId;

 TaskStatus m_status;

 TaskAvailability m_availability;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Subtask>>> m_subtasks;
 bool m_subtasksIsSet;


    Task();
};

class TaskFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* activityId,
  TaskStatus status,
  TaskAvailability availability,
  sce::Np::CppWebApi::Common::IntrusivePtr<Task> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Task> *instancePtr);


 static void destroy(Task *instance);
};


}
}
}
}
}
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/GetMatchDetailResponse.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class GetMatchDetailResponse : public PsnErrorObject
{
public:

 const Common::String & getMatchId() const;
 int32_t setMatchId(const char* matchId) __attribute__((warn_unused_result));


 bool matchTypeIsSet() const;
 void unsetMatchType();
 ResponseMatchType getMatchType() const;
 void setMatchType(const ResponseMatchType &matchType);


 Status getStatus() const;
 void setStatus(const Status &status);


 const Common::String & getActivityId() const;
 int32_t setActivityId(const char* activityId) __attribute__((warn_unused_result));


 GroupingType getGroupingType() const;
 void setGroupingType(const GroupingType &groupingType);


 CompetitionType getCompetitionType() const;
 void setCompetitionType(const CompetitionType &competitionType);


 ResultType getResultType() const;
 void setResultType(const ResultType &resultType);


 bool zoneIdIsSet() const;
 void unsetZoneId();
 const Common::String & getZoneId() const;
 int32_t setZoneId(const char* zoneId) __attribute__((warn_unused_result));


 int32_t getExpirationTime() const;
 void setExpirationTime(const int32_t &expirationTime);


 bool cancellationTimeIsSet() const;
 void unsetCancellationTime();
 int32_t getCancellationTime() const;
 void setCancellationTime(const int32_t &cancellationTime);


 bool matchStartTimestampIsSet() const;
 void unsetMatchStartTimestamp();
 const Common::String & getMatchStartTimestamp() const;
 int32_t setMatchStartTimestamp(const char* matchStartTimestamp) __attribute__((warn_unused_result));


 bool matchEndTimestampIsSet() const;
 void unsetMatchEndTimestamp();
 const Common::String & getMatchEndTimestamp() const;
 int32_t setMatchEndTimestamp(const char* matchEndTimestamp) __attribute__((warn_unused_result));


 bool lastPausedTimestampIsSet() const;
 void unsetLastPausedTimestamp();
 const Common::String & getLastPausedTimestamp() const;
 int32_t setLastPausedTimestamp(const char* lastPausedTimestamp) __attribute__((warn_unused_result));


 bool customDataIsSet() const;
 void unsetCustomData();
 const Common::String & getCustomData() const;
 int32_t setCustomData(const char* customData) __attribute__((warn_unused_result));


 bool inGameRosterIsSet() const;
 void unsetInGameRoster();
 Common::IntrusivePtr<ResponseInGameRoster> getInGameRoster() const;
 int32_t setInGameRoster(const Common::IntrusivePtr<ResponseInGameRoster> &inGameRoster) __attribute__((warn_unused_result));


 bool matchResultsIsSet() const;
 void unsetMatchResults();
 Common::IntrusivePtr<ResponseMatchResults> getMatchResults() const;
 int32_t setMatchResults(const Common::IntrusivePtr<ResponseMatchResults> &matchResults) __attribute__((warn_unused_result));


 bool matchStatisticsIsSet() const;
 void unsetMatchStatistics();
 Common::IntrusivePtr<ResponseMatchStatistics> getMatchStatistics() const;
 int32_t setMatchStatistics(const Common::IntrusivePtr<ResponseMatchStatistics> &matchStatistics) __attribute__((warn_unused_result));


 bool tasksIsSet() const;
 void unsetTasks();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Task>>> getTasks();
 int32_t setTasks(const Common::Vector<Common::IntrusivePtr<Task>> &tasks) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetMatchDetailResponse(Common::LibContext * context);
 friend class GetMatchDetailResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::GetMatchDetailResponse>;

 ~GetMatchDetailResponse();

private:
 Common::LibContext * m_context;

 Common::String m_matchId;

 ResponseMatchType m_matchType;
 bool m_matchTypeIsSet;

 Status m_status;

 Common::String m_activityId;

 GroupingType m_groupingType;

 CompetitionType m_competitionType;

 ResultType m_resultType;

 Common::String m_zoneId;
 bool m_zoneIdIsSet;

 int32_t m_expirationTime;

 int32_t m_cancellationTime;
 bool m_cancellationTimeIsSet;

 Common::String m_matchStartTimestamp;
 bool m_matchStartTimestampIsSet;

 Common::String m_matchEndTimestamp;
 bool m_matchEndTimestampIsSet;

 Common::String m_lastPausedTimestamp;
 bool m_lastPausedTimestampIsSet;

 Common::String m_customData;
 bool m_customDataIsSet;

 Common::IntrusivePtr<ResponseInGameRoster> m_inGameRoster;
 bool m_inGameRosterIsSet;

 Common::IntrusivePtr<ResponseMatchResults> m_matchResults;
 bool m_matchResultsIsSet;

 Common::IntrusivePtr<ResponseMatchStatistics> m_matchStatistics;
 bool m_matchStatisticsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Task>>> m_tasks;
 bool m_tasksIsSet;


    GetMatchDetailResponse();
};

class GetMatchDetailResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* matchId,
  Status status,
  const char* activityId,
  GroupingType groupingType,
  CompetitionType competitionType,
  ResultType resultType,
  int32_t expirationTime,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetMatchDetailResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetMatchDetailResponse> *instancePtr);


 static void destroy(GetMatchDetailResponse *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/JoinMatchRequest.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/JoinMatchRequest.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/AddedPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/AddedPlayer.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class AddedPlayer : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 PlayerType getPlayerType() const;
 void setPlayerType(const PlayerType &playerType);


 bool playerNameIsSet() const;
 void unsetPlayerName();
 const Common::String & getPlayerName() const;
 int32_t setPlayerName(const char* playerName) __attribute__((warn_unused_result));


 bool accountIdIsSet() const;
 void unsetAccountId();
 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 bool teamIdIsSet() const;
 void unsetTeamId();
 const Common::String & getTeamId() const;
 int32_t setTeamId(const char* teamId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 AddedPlayer(Common::LibContext * context);
 friend class AddedPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::AddedPlayer>;

 ~AddedPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 PlayerType m_playerType;

 Common::String m_playerName;
 bool m_playerNameIsSet;

 Common::String m_accountId;
 bool m_accountIdIsSet;

 Common::String m_teamId;
 bool m_teamIdIsSet;


    AddedPlayer();
};

class AddedPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  PlayerType playerType,
  sce::Np::CppWebApi::Common::IntrusivePtr<AddedPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<AddedPlayer> *instancePtr);


 static void destroy(AddedPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/JoinMatchRequest.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class JoinMatchRequest : public Common::RefObject
{
public:

 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 int32_t getNpServiceLabel() const;
 void setNpServiceLabel(const int32_t &npServiceLabel);


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AddedPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<AddedPlayer>> &players) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 JoinMatchRequest(Common::LibContext * context);
 friend class JoinMatchRequestFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::JoinMatchRequest>;

 ~JoinMatchRequest();

private:
 Common::LibContext * m_context;

 int32_t m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AddedPlayer>>> m_players;


    JoinMatchRequest();
};

class JoinMatchRequestFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AddedPlayer>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<JoinMatchRequest> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<JoinMatchRequest> *instancePtr);


 static void destroy(JoinMatchRequest *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/LeaveMatchRequest.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/LeaveMatchRequest.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RemovedPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RemovedPlayer.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/LeaveReason.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/LeaveReason.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class LeaveReason {
  _NOT_SET = 0,
  kDisconnected,
  kFinished,
  kQuit,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RemovedPlayer.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RemovedPlayer : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 bool reasonIsSet() const;
 void unsetReason();
 LeaveReason getReason() const;
 void setReason(const LeaveReason &reason);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RemovedPlayer(Common::LibContext * context);
 friend class RemovedPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RemovedPlayer>;

 ~RemovedPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 LeaveReason m_reason;
 bool m_reasonIsSet;


    RemovedPlayer();
};

class RemovedPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  sce::Np::CppWebApi::Common::IntrusivePtr<RemovedPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RemovedPlayer> *instancePtr);


 static void destroy(RemovedPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/LeaveMatchRequest.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class LeaveMatchRequest : public Common::RefObject
{
public:

 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 int32_t getNpServiceLabel() const;
 void setNpServiceLabel(const int32_t &npServiceLabel);


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RemovedPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<RemovedPlayer>> &players) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 LeaveMatchRequest(Common::LibContext * context);
 friend class LeaveMatchRequestFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::LeaveMatchRequest>;

 ~LeaveMatchRequest();

private:
 Common::LibContext * m_context;

 int32_t m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RemovedPlayer>>> m_players;


    LeaveMatchRequest();
};

class LeaveMatchRequestFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RemovedPlayer>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<LeaveMatchRequest> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<LeaveMatchRequest> *instancePtr);


 static void destroy(LeaveMatchRequest *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ReportResultsRequest.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ReportResultsRequest.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchResults.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchResults.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestCompetitiveResult.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestCompetitiveResult.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamResults.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamResults.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamMemberResult.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamMemberResult.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestTeamMemberResult : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 double getScore() const;
 void setScore(const double &score);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestTeamMemberResult(Common::LibContext * context);
 friend class RequestTeamMemberResultFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestTeamMemberResult>;

 ~RequestTeamMemberResult();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 double m_score;


    RequestTeamMemberResult();
};

class RequestTeamMemberResultFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  double score,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTeamMemberResult> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTeamMemberResult> *instancePtr);


 static void destroy(RequestTeamMemberResult *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamResults.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestTeamResults : public Common::RefObject
{
public:

 const Common::String & getTeamId() const;
 int32_t setTeamId(const char* teamId) __attribute__((warn_unused_result));


 int32_t getRank() const;
 void setRank(const int32_t &rank);


 bool scoreIsSet() const;
 void unsetScore();
 double getScore() const;
 void setScore(const double &score);


 bool teamMemberResultsIsSet() const;
 void unsetTeamMemberResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamMemberResult>>> getTeamMemberResults();
 int32_t setTeamMemberResults(const Common::Vector<Common::IntrusivePtr<RequestTeamMemberResult>> &teamMemberResults) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestTeamResults(Common::LibContext * context);
 friend class RequestTeamResultsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestTeamResults>;

 ~RequestTeamResults();

private:
 Common::LibContext * m_context;

 Common::String m_teamId;

 int32_t m_rank;

 double m_score;
 bool m_scoreIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamMemberResult>>> m_teamMemberResults;
 bool m_teamMemberResultsIsSet;


    RequestTeamResults();
};

class RequestTeamResultsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* teamId,
  int32_t rank,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTeamResults> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTeamResults> *instancePtr);


 static void destroy(RequestTeamResults *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestCompetitiveResult.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestPlayerResults.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestPlayerResults.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestPlayerResults : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 int32_t getRank() const;
 void setRank(const int32_t &rank);


 bool scoreIsSet() const;
 void unsetScore();
 double getScore() const;
 void setScore(const double &score);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestPlayerResults(Common::LibContext * context);
 friend class RequestPlayerResultsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestPlayerResults>;

 ~RequestPlayerResults();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 int32_t m_rank;

 double m_score;
 bool m_scoreIsSet;


    RequestPlayerResults();
};

class RequestPlayerResultsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  int32_t rank,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerResults> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerResults> *instancePtr);


 static void destroy(RequestPlayerResults *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestCompetitiveResult.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestCompetitiveResult : public Common::RefObject
{
public:

 bool playerResultsIsSet() const;
 void unsetPlayerResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerResults>>> getPlayerResults();
 int32_t setPlayerResults(const Common::Vector<Common::IntrusivePtr<RequestPlayerResults>> &playerResults) __attribute__((warn_unused_result));


 bool teamResultsIsSet() const;
 void unsetTeamResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamResults>>> getTeamResults();
 int32_t setTeamResults(const Common::Vector<Common::IntrusivePtr<RequestTeamResults>> &teamResults) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestCompetitiveResult(Common::LibContext * context);
 friend class RequestCompetitiveResultFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestCompetitiveResult>;

 ~RequestCompetitiveResult();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerResults>>> m_playerResults;
 bool m_playerResultsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamResults>>> m_teamResults;
 bool m_teamResultsIsSet;


    RequestCompetitiveResult();
};

class RequestCompetitiveResultFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestCompetitiveResult> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestCompetitiveResult> *instancePtr);


 static void destroy(RequestCompetitiveResult *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchResults.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestCooperativeResult.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestCooperativeResult.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class RequestCooperativeResult {
  _NOT_SET = 0,
  kSuccess,
  kUnfinished,
  kFailed,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchResults.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestMatchResults : public Common::RefObject
{
public:

 ResultsVersion getVersion() const;
 void setVersion(const ResultsVersion &version);


 bool cooperativeResultIsSet() const;
 void unsetCooperativeResult();
 RequestCooperativeResult getCooperativeResult() const;
 void setCooperativeResult(const RequestCooperativeResult &cooperativeResult);


 bool competitiveResultIsSet() const;
 void unsetCompetitiveResult();
 Common::IntrusivePtr<RequestCompetitiveResult> getCompetitiveResult() const;
 int32_t setCompetitiveResult(const Common::IntrusivePtr<RequestCompetitiveResult> &competitiveResult) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestMatchResults(Common::LibContext * context);
 friend class RequestMatchResultsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestMatchResults>;

 ~RequestMatchResults();

private:
 Common::LibContext * m_context;

 ResultsVersion m_version;

 RequestCooperativeResult m_cooperativeResult;
 bool m_cooperativeResultIsSet;

 Common::IntrusivePtr<RequestCompetitiveResult> m_competitiveResult;
 bool m_competitiveResultIsSet;


    RequestMatchResults();
};

class RequestMatchResultsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  ResultsVersion version,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMatchResults> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMatchResults> *instancePtr);


 static void destroy(RequestMatchResults *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ReportResultsRequest.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchStatistics.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchStatistics.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamStatistic.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamStatistic.h" 2 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamMemberStatistic.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamMemberStatistic.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestTeamMemberStatistic : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> getStats();
 int32_t setStats(const Common::Vector<Common::IntrusivePtr<AdditionalStatistic>> &stats) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestTeamMemberStatistic(Common::LibContext * context);
 friend class RequestTeamMemberStatisticFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestTeamMemberStatistic>;

 ~RequestTeamMemberStatistic();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> m_stats;


    RequestTeamMemberStatistic();
};

class RequestTeamMemberStatisticFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>>::value_type &stats,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTeamMemberStatistic> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTeamMemberStatistic> *instancePtr);


 static void destroy(RequestTeamMemberStatistic *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTeamStatistic.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestTeamStatistic : public Common::RefObject
{
public:

 const Common::String & getTeamId() const;
 int32_t setTeamId(const char* teamId) __attribute__((warn_unused_result));


 bool statsIsSet() const;
 void unsetStats();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> getStats();
 int32_t setStats(const Common::Vector<Common::IntrusivePtr<AdditionalStatistic>> &stats) __attribute__((warn_unused_result));


 bool teamMemberStatisticsIsSet() const;
 void unsetTeamMemberStatistics();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamMemberStatistic>>> getTeamMemberStatistics();
 int32_t setTeamMemberStatistics(const Common::Vector<Common::IntrusivePtr<RequestTeamMemberStatistic>> &teamMemberStatistics) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestTeamStatistic(Common::LibContext * context);
 friend class RequestTeamStatisticFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestTeamStatistic>;

 ~RequestTeamStatistic();

private:
 Common::LibContext * m_context;

 Common::String m_teamId;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> m_stats;
 bool m_statsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamMemberStatistic>>> m_teamMemberStatistics;
 bool m_teamMemberStatisticsIsSet;


    RequestTeamStatistic();
};

class RequestTeamStatisticFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* teamId,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTeamStatistic> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTeamStatistic> *instancePtr);


 static void destroy(RequestTeamStatistic *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchStatistics.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestPlayerStatistic.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestPlayerStatistic.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestPlayerStatistic : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> getStats();
 int32_t setStats(const Common::Vector<Common::IntrusivePtr<AdditionalStatistic>> &stats) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestPlayerStatistic(Common::LibContext * context);
 friend class RequestPlayerStatisticFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestPlayerStatistic>;

 ~RequestPlayerStatistic();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>> m_stats;


    RequestPlayerStatistic();
};

class RequestPlayerStatisticFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<AdditionalStatistic>>>::value_type &stats,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerStatistic> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerStatistic> *instancePtr);


 static void destroy(RequestPlayerStatistic *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestMatchStatistics.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestMatchStatistics : public Common::RefObject
{
public:

 bool playerStatisticsIsSet() const;
 void unsetPlayerStatistics();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerStatistic>>> getPlayerStatistics();
 int32_t setPlayerStatistics(const Common::Vector<Common::IntrusivePtr<RequestPlayerStatistic>> &playerStatistics) __attribute__((warn_unused_result));


 bool teamStatisticsIsSet() const;
 void unsetTeamStatistics();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamStatistic>>> getTeamStatistics();
 int32_t setTeamStatistics(const Common::Vector<Common::IntrusivePtr<RequestTeamStatistic>> &teamStatistics) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestMatchStatistics(Common::LibContext * context);
 friend class RequestMatchStatisticsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestMatchStatistics>;

 ~RequestMatchStatistics();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerStatistic>>> m_playerStatistics;
 bool m_playerStatisticsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamStatistic>>> m_teamStatistics;
 bool m_teamStatisticsIsSet;


    RequestMatchStatistics();
};

class RequestMatchStatisticsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMatchStatistics> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestMatchStatistics> *instancePtr);


 static void destroy(RequestMatchStatistics *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ReportResultsRequest.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ReportResultsRequest : public Common::RefObject
{
public:

 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 int32_t getNpServiceLabel() const;
 void setNpServiceLabel(const int32_t &npServiceLabel);


 Common::IntrusivePtr<RequestMatchResults> getMatchResults() const;
 int32_t setMatchResults(const Common::IntrusivePtr<RequestMatchResults> &matchResults) __attribute__((warn_unused_result));


 bool matchStatisticsIsSet() const;
 void unsetMatchStatistics();
 Common::IntrusivePtr<RequestMatchStatistics> getMatchStatistics() const;
 int32_t setMatchStatistics(const Common::IntrusivePtr<RequestMatchStatistics> &matchStatistics) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ReportResultsRequest(Common::LibContext * context);
 friend class ReportResultsRequestFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ReportResultsRequest>;

 ~ReportResultsRequest();

private:
 Common::LibContext * m_context;

 int32_t m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 Common::IntrusivePtr<RequestMatchResults> m_matchResults;

 Common::IntrusivePtr<RequestMatchStatistics> m_matchStatistics;
 bool m_matchStatisticsIsSet;


    ReportResultsRequest();
};

class ReportResultsRequestFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<RequestMatchResults> matchResults,
  sce::Np::CppWebApi::Common::IntrusivePtr<ReportResultsRequest> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ReportResultsRequest> *instancePtr);


 static void destroy(ReportResultsRequest *instance);
};


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateMatchDetailRequest.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateMatchDetailRequest.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ChildActivity.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ChildActivity.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ChildActivityStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ChildActivityStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class ChildActivityStatus {
  _NOT_SET = 0,
  kWaiting,
  kPlaying,
  kCompleted,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ChildActivity.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ChildActivityAvailability.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ChildActivityAvailability.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class ChildActivityAvailability {
  _NOT_SET = 0,
  kAvailable,
  kUnavailable,
 };


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/ChildActivity.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class ChildActivity : public Common::RefObject
{
public:

 const Common::String & getActivityId() const;
 int32_t setActivityId(const char* activityId) __attribute__((warn_unused_result));


 bool statusIsSet() const;
 void unsetStatus();
 ChildActivityStatus getStatus() const;
 void setStatus(const ChildActivityStatus &status);


 bool availabilityIsSet() const;
 void unsetAvailability();
 ChildActivityAvailability getAvailability() const;
 void setAvailability(const ChildActivityAvailability &availability);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ChildActivity(Common::LibContext * context);
 friend class ChildActivityFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::ChildActivity>;

 ~ChildActivity();

private:
 Common::LibContext * m_context;

 Common::String m_activityId;

 ChildActivityStatus m_status;
 bool m_statusIsSet;

 ChildActivityAvailability m_availability;
 bool m_availabilityIsSet;


    ChildActivity();
};

class ChildActivityFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* activityId,
  sce::Np::CppWebApi::Common::IntrusivePtr<ChildActivity> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ChildActivity> *instancePtr);


 static void destroy(ChildActivity *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateMatchDetailRequest.h" 2 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTemporaryMatchResults.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTemporaryMatchResults.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTemporaryCompetitiveResult.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTemporaryCompetitiveResult.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTemporaryTeamResults.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTemporaryTeamResults.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestTemporaryTeamResults : public Common::RefObject
{
public:

 const Common::String & getTeamId() const;
 int32_t setTeamId(const char* teamId) __attribute__((warn_unused_result));


 int32_t getRank() const;
 void setRank(const int32_t &rank);


 bool scoreIsSet() const;
 void unsetScore();
 double getScore() const;
 void setScore(const double &score);


 bool teamMemberResultsIsSet() const;
 void unsetTeamMemberResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamMemberResult>>> getTeamMemberResults();
 int32_t setTeamMemberResults(const Common::Vector<Common::IntrusivePtr<RequestTeamMemberResult>> &teamMemberResults) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestTemporaryTeamResults(Common::LibContext * context);
 friend class RequestTemporaryTeamResultsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestTemporaryTeamResults>;

 ~RequestTemporaryTeamResults();

private:
 Common::LibContext * m_context;

 Common::String m_teamId;

 int32_t m_rank;

 double m_score;
 bool m_scoreIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTeamMemberResult>>> m_teamMemberResults;
 bool m_teamMemberResultsIsSet;


    RequestTemporaryTeamResults();
};

class RequestTemporaryTeamResultsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* teamId,
  int32_t rank,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTemporaryTeamResults> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTemporaryTeamResults> *instancePtr);


 static void destroy(RequestTemporaryTeamResults *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTemporaryCompetitiveResult.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestTemporaryCompetitiveResult : public Common::RefObject
{
public:

 bool playerResultsIsSet() const;
 void unsetPlayerResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerResults>>> getPlayerResults();
 int32_t setPlayerResults(const Common::Vector<Common::IntrusivePtr<RequestPlayerResults>> &playerResults) __attribute__((warn_unused_result));


 bool teamResultsIsSet() const;
 void unsetTeamResults();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTemporaryTeamResults>>> getTeamResults();
 int32_t setTeamResults(const Common::Vector<Common::IntrusivePtr<RequestTemporaryTeamResults>> &teamResults) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestTemporaryCompetitiveResult(Common::LibContext * context);
 friend class RequestTemporaryCompetitiveResultFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestTemporaryCompetitiveResult>;

 ~RequestTemporaryCompetitiveResult();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerResults>>> m_playerResults;
 bool m_playerResultsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestTemporaryTeamResults>>> m_teamResults;
 bool m_teamResultsIsSet;


    RequestTemporaryCompetitiveResult();
};

class RequestTemporaryCompetitiveResultFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTemporaryCompetitiveResult> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTemporaryCompetitiveResult> *instancePtr);


 static void destroy(RequestTemporaryCompetitiveResult *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/RequestTemporaryMatchResults.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class RequestTemporaryMatchResults : public Common::RefObject
{
public:

 ResultsVersion getVersion() const;
 void setVersion(const ResultsVersion &version);


 Common::IntrusivePtr<RequestTemporaryCompetitiveResult> getCompetitiveResult() const;
 int32_t setCompetitiveResult(const Common::IntrusivePtr<RequestTemporaryCompetitiveResult> &competitiveResult) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestTemporaryMatchResults(Common::LibContext * context);
 friend class RequestTemporaryMatchResultsFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::RequestTemporaryMatchResults>;

 ~RequestTemporaryMatchResults();

private:
 Common::LibContext * m_context;

 ResultsVersion m_version;

 Common::IntrusivePtr<RequestTemporaryCompetitiveResult> m_competitiveResult;


    RequestTemporaryMatchResults();
};

class RequestTemporaryMatchResultsFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  ResultsVersion version,
  Common::IntrusivePtr<RequestTemporaryCompetitiveResult> competitiveResult,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTemporaryMatchResults> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestTemporaryMatchResults> *instancePtr);


 static void destroy(RequestTemporaryMatchResults *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateMatchDetailRequest.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class UpdateMatchDetailRequest : public Common::RefObject
{
public:

 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 int32_t getNpServiceLabel() const;
 void setNpServiceLabel(const int32_t &npServiceLabel);


 bool zoneIdIsSet() const;
 void unsetZoneId();
 const Common::String & getZoneId() const;
 int32_t setZoneId(const char* zoneId) __attribute__((warn_unused_result));


 bool expirationTimeIsSet() const;
 void unsetExpirationTime();
 int32_t getExpirationTime() const;
 void setExpirationTime(const int32_t &expirationTime);


 bool customDataIsSet() const;
 void unsetCustomData();
 const Common::String & getCustomData() const;
 int32_t setCustomData(const char* customData) __attribute__((warn_unused_result));


 bool inGameRosterIsSet() const;
 void unsetInGameRoster();
 Common::IntrusivePtr<RequestInGameRoster> getInGameRoster() const;
 int32_t setInGameRoster(const Common::IntrusivePtr<RequestInGameRoster> &inGameRoster) __attribute__((warn_unused_result));


 bool matchResultsIsSet() const;
 void unsetMatchResults();
 Common::IntrusivePtr<RequestTemporaryMatchResults> getMatchResults() const;
 int32_t setMatchResults(const Common::IntrusivePtr<RequestTemporaryMatchResults> &matchResults) __attribute__((warn_unused_result));


 bool matchStatisticsIsSet() const;
 void unsetMatchStatistics();
 Common::IntrusivePtr<RequestMatchStatistics> getMatchStatistics() const;
 int32_t setMatchStatistics(const Common::IntrusivePtr<RequestMatchStatistics> &matchStatistics) __attribute__((warn_unused_result));


 bool childActivitiesIsSet() const;
 void unsetChildActivities();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ChildActivity>>> getChildActivities();
 int32_t setChildActivities(const Common::Vector<Common::IntrusivePtr<ChildActivity>> &childActivities) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 UpdateMatchDetailRequest(Common::LibContext * context);
 friend class UpdateMatchDetailRequestFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::UpdateMatchDetailRequest>;

 ~UpdateMatchDetailRequest();

private:
 Common::LibContext * m_context;

 int32_t m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 Common::String m_zoneId;
 bool m_zoneIdIsSet;

 int32_t m_expirationTime;
 bool m_expirationTimeIsSet;

 Common::String m_customData;
 bool m_customDataIsSet;

 Common::IntrusivePtr<RequestInGameRoster> m_inGameRoster;
 bool m_inGameRosterIsSet;

 Common::IntrusivePtr<RequestTemporaryMatchResults> m_matchResults;
 bool m_matchResultsIsSet;

 Common::IntrusivePtr<RequestMatchStatistics> m_matchStatistics;
 bool m_matchStatisticsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ChildActivity>>> m_childActivities;
 bool m_childActivitiesIsSet;


    UpdateMatchDetailRequest();
};

class UpdateMatchDetailRequestFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<UpdateMatchDetailRequest> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<UpdateMatchDetailRequest> *instancePtr);


 static void destroy(UpdateMatchDetailRequest *instance);
};


}
}
}
}
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateMatchStatusRequest.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateMatchStatusRequest.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

 enum class UpdateStatus {
  _NOT_SET = 0,
  kPlaying,
  kOnhold,
  kCancelled,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matches/V1/UpdateMatchStatusRequest.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class UpdateMatchStatusRequest : public Common::RefObject
{
public:

 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 int32_t getNpServiceLabel() const;
 void setNpServiceLabel(const int32_t &npServiceLabel);


 UpdateStatus getStatus() const;
 void setStatus(const UpdateStatus &status);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 UpdateMatchStatusRequest(Common::LibContext * context);
 friend class UpdateMatchStatusRequestFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matches::V1::UpdateMatchStatusRequest>;

 ~UpdateMatchStatusRequest();

private:
 Common::LibContext * m_context;

 int32_t m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 UpdateStatus m_status;


    UpdateMatchStatusRequest();
};

class UpdateMatchStatusRequestFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  UpdateStatus status,
  sce::Np::CppWebApi::Common::IntrusivePtr<UpdateMatchStatusRequest> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<UpdateMatchStatusRequest> *instancePtr);


 static void destroy(UpdateMatchStatusRequest *instance);
};


}
}
}
}
}
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches/v1/MatchApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matches {
namespace V1 {

class MatchApi {
public:

 class ParameterToCreateMatch : public Common::ParameterBase {
 public:
  ParameterToCreateMatch();
  ~ParameterToCreateMatch();

  int32_t initialize(
   Common::LibContext * context
   , Common::IntrusivePtr< CreateMatchRequest > createMatchRequest
   );

  int32_t terminate();

  bool isInitialized() const;


  Common::IntrusivePtr< CreateMatchRequest > getcreateMatchRequest() const;
  void setcreateMatchRequest(Common::IntrusivePtr< CreateMatchRequest > createMatchRequest);

  struct ParameterImplToCreateMatch;

 private:
  struct ParameterImplToCreateMatch *m_pimpl;

  ParameterToCreateMatch(ParameterToCreateMatch &param);
  ParameterToCreateMatch(const ParameterToCreateMatch &param);
  ParameterToCreateMatch& operator=(ParameterToCreateMatch &param);
  ParameterToCreateMatch& operator=(const ParameterToCreateMatch &param);
 };

 static int32_t createMatch(
  int32_t npwebapiUserCtxId,
  const ParameterToCreateMatch &param,
  Common::Transaction<Common::IntrusivePtr<CreateMatchResponse>> &transaction
  );

 class ParameterToGetMatchDetail : public Common::ParameterBase {
 public:
  ParameterToGetMatchDetail();
  ~ParameterToGetMatchDetail();

  enum class View {
   _NOT_SET = 0,
   kV1_0,
   kV2_0,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* matchId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getmatchId() const;
  int32_t setmatchId(const char* matchId) __attribute__((warn_unused_result));


  int32_t getnpServiceLabel() const;
  void setnpServiceLabel(int32_t npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;


  View getview() const;
  void setview(View view);
  void unsetview();
  bool hasview() const;

  struct ParameterImplToGetMatchDetail;

 private:
  struct ParameterImplToGetMatchDetail *m_pimpl;

  ParameterToGetMatchDetail(ParameterToGetMatchDetail &param);
  ParameterToGetMatchDetail(const ParameterToGetMatchDetail &param);
  ParameterToGetMatchDetail& operator=(ParameterToGetMatchDetail &param);
  ParameterToGetMatchDetail& operator=(const ParameterToGetMatchDetail &param);
 };

 static int32_t getMatchDetail(
  int32_t npwebapiUserCtxId,
  const ParameterToGetMatchDetail &param,
  Common::Transaction<Common::IntrusivePtr<GetMatchDetailResponse>> &transaction
  );

 class ParameterToJoinMatch : public Common::ParameterBase {
 public:
  ParameterToJoinMatch();
  ~ParameterToJoinMatch();

  int32_t initialize(
   Common::LibContext * context
   , const char* matchId
   , Common::IntrusivePtr< JoinMatchRequest > joinMatchRequest
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getmatchId() const;
  int32_t setmatchId(const char* matchId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< JoinMatchRequest > getjoinMatchRequest() const;
  void setjoinMatchRequest(Common::IntrusivePtr< JoinMatchRequest > joinMatchRequest);

  struct ParameterImplToJoinMatch;

 private:
  struct ParameterImplToJoinMatch *m_pimpl;

  ParameterToJoinMatch(ParameterToJoinMatch &param);
  ParameterToJoinMatch(const ParameterToJoinMatch &param);
  ParameterToJoinMatch& operator=(ParameterToJoinMatch &param);
  ParameterToJoinMatch& operator=(const ParameterToJoinMatch &param);
 };

 static int32_t joinMatch(
  int32_t npwebapiUserCtxId,
  const ParameterToJoinMatch &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToLeaveMatch : public Common::ParameterBase {
 public:
  ParameterToLeaveMatch();
  ~ParameterToLeaveMatch();

  int32_t initialize(
   Common::LibContext * context
   , const char* matchId
   , Common::IntrusivePtr< LeaveMatchRequest > leaveMatchRequest
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getmatchId() const;
  int32_t setmatchId(const char* matchId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< LeaveMatchRequest > getleaveMatchRequest() const;
  void setleaveMatchRequest(Common::IntrusivePtr< LeaveMatchRequest > leaveMatchRequest);

  struct ParameterImplToLeaveMatch;

 private:
  struct ParameterImplToLeaveMatch *m_pimpl;

  ParameterToLeaveMatch(ParameterToLeaveMatch &param);
  ParameterToLeaveMatch(const ParameterToLeaveMatch &param);
  ParameterToLeaveMatch& operator=(ParameterToLeaveMatch &param);
  ParameterToLeaveMatch& operator=(const ParameterToLeaveMatch &param);
 };

 static int32_t leaveMatch(
  int32_t npwebapiUserCtxId,
  const ParameterToLeaveMatch &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToReportResults : public Common::ParameterBase {
 public:
  ParameterToReportResults();
  ~ParameterToReportResults();

  int32_t initialize(
   Common::LibContext * context
   , const char* matchId
   , Common::IntrusivePtr< ReportResultsRequest > reportResultsRequest
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getmatchId() const;
  int32_t setmatchId(const char* matchId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< ReportResultsRequest > getreportResultsRequest() const;
  void setreportResultsRequest(Common::IntrusivePtr< ReportResultsRequest > reportResultsRequest);

  struct ParameterImplToReportResults;

 private:
  struct ParameterImplToReportResults *m_pimpl;

  ParameterToReportResults(ParameterToReportResults &param);
  ParameterToReportResults(const ParameterToReportResults &param);
  ParameterToReportResults& operator=(ParameterToReportResults &param);
  ParameterToReportResults& operator=(const ParameterToReportResults &param);
 };

 static int32_t reportResults(
  int32_t npwebapiUserCtxId,
  const ParameterToReportResults &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToUpdateMatchDetail : public Common::ParameterBase {
 public:
  ParameterToUpdateMatchDetail();
  ~ParameterToUpdateMatchDetail();

  int32_t initialize(
   Common::LibContext * context
   , const char* matchId
   , Common::IntrusivePtr< UpdateMatchDetailRequest > updateMatchDetailRequest
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getmatchId() const;
  int32_t setmatchId(const char* matchId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< UpdateMatchDetailRequest > getupdateMatchDetailRequest() const;
  void setupdateMatchDetailRequest(Common::IntrusivePtr< UpdateMatchDetailRequest > updateMatchDetailRequest);

  struct ParameterImplToUpdateMatchDetail;

 private:
  struct ParameterImplToUpdateMatchDetail *m_pimpl;

  ParameterToUpdateMatchDetail(ParameterToUpdateMatchDetail &param);
  ParameterToUpdateMatchDetail(const ParameterToUpdateMatchDetail &param);
  ParameterToUpdateMatchDetail& operator=(ParameterToUpdateMatchDetail &param);
  ParameterToUpdateMatchDetail& operator=(const ParameterToUpdateMatchDetail &param);
 };

 static int32_t updateMatchDetail(
  int32_t npwebapiUserCtxId,
  const ParameterToUpdateMatchDetail &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToUpdateMatchStatus : public Common::ParameterBase {
 public:
  ParameterToUpdateMatchStatus();
  ~ParameterToUpdateMatchStatus();

  int32_t initialize(
   Common::LibContext * context
   , const char* matchId
   , Common::IntrusivePtr< UpdateMatchStatusRequest > updateMatchStatusRequest
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getmatchId() const;
  int32_t setmatchId(const char* matchId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< UpdateMatchStatusRequest > getupdateMatchStatusRequest() const;
  void setupdateMatchStatusRequest(Common::IntrusivePtr< UpdateMatchStatusRequest > updateMatchStatusRequest);

  struct ParameterImplToUpdateMatchStatus;

 private:
  struct ParameterImplToUpdateMatchStatus *m_pimpl;

  ParameterToUpdateMatchStatus(ParameterToUpdateMatchStatus &param);
  ParameterToUpdateMatchStatus(const ParameterToUpdateMatchStatus &param);
  ParameterToUpdateMatchStatus& operator=(ParameterToUpdateMatchStatus &param);
  ParameterToUpdateMatchStatus& operator=(const ParameterToUpdateMatchStatus &param);
 };

 static int32_t updateMatchStatus(
  int32_t npwebapiUserCtxId,
  const ParameterToUpdateMatchStatus &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

private:
 MatchApi();
 ~MatchApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matches.h" 2 3
# 329 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking/v1/Api.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking/v1/Api.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/ErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/ErrorResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class Error : public Common::RefObject
{
public:

 int64_t getCode() const;
 void setCode(const int64_t &code);


 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 int64_t m_code;

 Common::String m_message;

 Common::String m_referenceId;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int64_t code,
  const char* message,
  const char* referenceId,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/ErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class ErrorResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorResponse(Common::LibContext * context);
 friend class ErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::ErrorResponse>;

 ~ErrorResponse();

protected:
    ErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;


};

class ErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<Error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);


 static void destroy(ErrorResponse *instance);
};
using PsnErrorObject = ErrorResponse;
using PsnErrorObjectFactory = ErrorResponseFactory;


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking/v1/Api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetOfferResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetOfferResponseBody.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Location.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Location.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class Location : public Common::RefObject
{
public:

 bool gameSessionIdIsSet() const;
 void unsetGameSessionId();
 const Common::String & getGameSessionId() const;
 int32_t setGameSessionId(const char* gameSessionId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Location(Common::LibContext * context);
 friend class LocationFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::Location>;

 ~Location();

private:
 Common::LibContext * m_context;

 Common::String m_gameSessionId;
 bool m_gameSessionIdIsSet;


    Location();
};

class LocationFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Location> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Location> *instancePtr);


 static void destroy(Location *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetOfferResponseBody.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Cause.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Cause.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class Cause : public Common::RefObject
{
public:

 bool sourceIsSet() const;
 void unsetSource();
 const Common::String & getSource() const;
 int32_t setSource(const char* source) __attribute__((warn_unused_result));


 bool codeIsSet() const;
 void unsetCode();
 int64_t getCode() const;
 void setCode(const int64_t &code);


 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Cause(Common::LibContext * context);
 friend class CauseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::Cause>;

 ~Cause();

private:
 Common::LibContext * m_context;

 Common::String m_source;
 bool m_sourceIsSet;

 int64_t m_code;
 bool m_codeIsSet;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;


    Cause();
};

class CauseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Cause> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Cause> *instancePtr);


 static void destroy(Cause *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetOfferResponseBody.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/OfferStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/OfferStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

 enum class OfferStatus {
  _NOT_SET = 0,
  kPlacing,
  kCompleted,
  kFailed,
 };


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetOfferResponseBody.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForOfferRead.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForOfferRead.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Platform.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Platform.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

 enum class Platform {
  _NOT_SET = 0,
  kPs4,
  kPs5,
  kProspero,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForOfferRead.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class PlayerForOfferRead : public Common::RefObject
{
public:

 bool accountIdIsSet() const;
 void unsetAccountId();
 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool onlineIdIsSet() const;
 void unsetOnlineId();
 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 bool platformIsSet() const;
 void unsetPlatform();
 Platform getPlatform() const;
 void setPlatform(const Platform &platform);


 bool teamNameIsSet() const;
 void unsetTeamName();
 const Common::String & getTeamName() const;
 int32_t setTeamName(const char* teamName) __attribute__((warn_unused_result));


 bool ticketIdIsSet() const;
 void unsetTicketId();
 const Common::String & getTicketId() const;
 int32_t setTicketId(const char* ticketId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerForOfferRead(Common::LibContext * context);
 friend class PlayerForOfferReadFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::PlayerForOfferRead>;

 ~PlayerForOfferRead();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;
 bool m_accountIdIsSet;

 SceNpOnlineId m_onlineId;
 bool m_onlineIdIsSet;

 Platform m_platform;
 bool m_platformIsSet;

 Common::String m_teamName;
 bool m_teamNameIsSet;

 Common::String m_ticketId;
 bool m_ticketIdIsSet;


    PlayerForOfferRead();
};

class PlayerForOfferReadFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerForOfferRead> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerForOfferRead> *instancePtr);


 static void destroy(PlayerForOfferRead *instance);
};


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetOfferResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class GetOfferResponseBody : public PsnErrorObject
{
public:

 bool offerIdIsSet() const;
 void unsetOfferId();
 const Common::String & getOfferId() const;
 int32_t setOfferId(const char* offerId) __attribute__((warn_unused_result));


 bool rulesetNameIsSet() const;
 void unsetRulesetName();
 const Common::String & getRulesetName() const;
 int32_t setRulesetName(const char* rulesetName) __attribute__((warn_unused_result));


 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForOfferRead>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<PlayerForOfferRead>> &players) __attribute__((warn_unused_result));


 bool statusIsSet() const;
 void unsetStatus();
 OfferStatus getStatus() const;
 void setStatus(const OfferStatus &status);


 bool locationIsSet() const;
 void unsetLocation();
 Common::IntrusivePtr<Location> getLocation() const;
 int32_t setLocation(const Common::IntrusivePtr<Location> &location) __attribute__((warn_unused_result));


 bool causeIsSet() const;
 void unsetCause();
 Common::IntrusivePtr<Cause> getCause() const;
 int32_t setCause(const Common::IntrusivePtr<Cause> &cause) __attribute__((warn_unused_result));


 bool createdDateTimeIsSet() const;
 void unsetCreatedDateTime();
 SceRtcTick getCreatedDateTime() const;
 void setCreatedDateTime(const SceRtcTick &createdDateTime);


 bool updatedDateTimeIsSet() const;
 void unsetUpdatedDateTime();
 SceRtcTick getUpdatedDateTime() const;
 void setUpdatedDateTime(const SceRtcTick &updatedDateTime);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetOfferResponseBody(Common::LibContext * context);
 friend class GetOfferResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::GetOfferResponseBody>;

 ~GetOfferResponseBody();

private:
 Common::LibContext * m_context;

 Common::String m_offerId;
 bool m_offerIdIsSet;

 Common::String m_rulesetName;
 bool m_rulesetNameIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForOfferRead>>> m_players;
 bool m_playersIsSet;

 OfferStatus m_status;
 bool m_statusIsSet;

 Common::IntrusivePtr<Location> m_location;
 bool m_locationIsSet;

 Common::IntrusivePtr<Cause> m_cause;
 bool m_causeIsSet;

 SceRtcTick m_createdDateTime;
 bool m_createdDateTimeIsSet;

 SceRtcTick m_updatedDateTime;
 bool m_updatedDateTimeIsSet;


    GetOfferResponseBody();
};

class GetOfferResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetOfferResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetOfferResponseBody> *instancePtr);


 static void destroy(GetOfferResponseBody *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking/v1/Api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetTicketResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetTicketResponseBody.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Attribute.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Attribute.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/AttributeType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/AttributeType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

 enum class AttributeType {
  _NOT_SET = 0,
  kString,
  kNumber,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Attribute.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class Attribute : public Common::RefObject
{
public:

 const Common::String & getName() const;
 int32_t setName(const char* name) __attribute__((warn_unused_result));


 AttributeType getType() const;
 void setType(const AttributeType &type);


 const Common::String & getValue() const;
 int32_t setValue(const char* value) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Attribute(Common::LibContext * context);
 friend class AttributeFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::Attribute>;

 ~Attribute();

private:
 Common::LibContext * m_context;

 Common::String m_name;

 AttributeType m_type;

 Common::String m_value;


    Attribute();
};

class AttributeFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* name,
  AttributeType type,
  const char* value,
  sce::Np::CppWebApi::Common::IntrusivePtr<Attribute> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Attribute> *instancePtr);


 static void destroy(Attribute *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetTicketResponseBody.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForRead.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForRead.h" 2 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForRead.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class PlayerForRead : public Common::RefObject
{
public:

 bool accountIdIsSet() const;
 void unsetAccountId();
 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool onlineIdIsSet() const;
 void unsetOnlineId();
 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 bool platformIsSet() const;
 void unsetPlatform();
 Platform getPlatform() const;
 void setPlatform(const Platform &platform);


 bool teamNameIsSet() const;
 void unsetTeamName();
 const Common::String & getTeamName() const;
 int32_t setTeamName(const char* teamName) __attribute__((warn_unused_result));


 bool natTypeIsSet() const;
 void unsetNatType();
 int32_t getNatType() const;
 void setNatType(const int32_t &natType);


 bool playerAttributesIsSet() const;
 void unsetPlayerAttributes();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> getPlayerAttributes();
 int32_t setPlayerAttributes(const Common::Vector<Common::IntrusivePtr<Attribute>> &playerAttributes) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerForRead(Common::LibContext * context);
 friend class PlayerForReadFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::PlayerForRead>;

 ~PlayerForRead();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;
 bool m_accountIdIsSet;

 SceNpOnlineId m_onlineId;
 bool m_onlineIdIsSet;

 Platform m_platform;
 bool m_platformIsSet;

 Common::String m_teamName;
 bool m_teamNameIsSet;

 int32_t m_natType;
 bool m_natTypeIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> m_playerAttributes;
 bool m_playerAttributesIsSet;


    PlayerForRead();
};

class PlayerForReadFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerForRead> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerForRead> *instancePtr);


 static void destroy(PlayerForRead *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetTicketResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Submitter.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/Submitter.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class Submitter : public Common::RefObject
{
public:

 bool accountIdIsSet() const;
 void unsetAccountId();
 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool platformIsSet() const;
 void unsetPlatform();
 Platform getPlatform() const;
 void setPlatform(const Platform &platform);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Submitter(Common::LibContext * context);
 friend class SubmitterFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::Submitter>;

 ~Submitter();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;
 bool m_accountIdIsSet;

 Platform m_platform;
 bool m_platformIsSet;


    Submitter();
};

class SubmitterFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Submitter> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Submitter> *instancePtr);


 static void destroy(Submitter *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetTicketResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/TicketStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/TicketStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

 enum class TicketStatus {
  _NOT_SET = 0,
  kQueued,
  kSearching,
  kCompleted,
  kTimedOut,
  kFailed,
 };


}
}
}
}
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/GetTicketResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class GetTicketResponseBody : public PsnErrorObject
{
public:

 bool ticketIdIsSet() const;
 void unsetTicketId();
 const Common::String & getTicketId() const;
 int32_t setTicketId(const char* ticketId) __attribute__((warn_unused_result));


 bool rulesetNameIsSet() const;
 void unsetRulesetName();
 const Common::String & getRulesetName() const;
 int32_t setRulesetName(const char* rulesetName) __attribute__((warn_unused_result));


 bool ticketAttributesIsSet() const;
 void unsetTicketAttributes();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> getTicketAttributes();
 int32_t setTicketAttributes(const Common::Vector<Common::IntrusivePtr<Attribute>> &ticketAttributes) __attribute__((warn_unused_result));


 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForRead>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<PlayerForRead>> &players) __attribute__((warn_unused_result));


 bool statusIsSet() const;
 void unsetStatus();
 TicketStatus getStatus() const;
 void setStatus(const TicketStatus &status);


 bool offerIdIsSet() const;
 void unsetOfferId();
 const Common::String & getOfferId() const;
 int32_t setOfferId(const char* offerId) __attribute__((warn_unused_result));


 bool submitterIsSet() const;
 void unsetSubmitter();
 Common::IntrusivePtr<Submitter> getSubmitter() const;
 int32_t setSubmitter(const Common::IntrusivePtr<Submitter> &submitter) __attribute__((warn_unused_result));


 bool locationIsSet() const;
 void unsetLocation();
 Common::IntrusivePtr<Location> getLocation() const;
 int32_t setLocation(const Common::IntrusivePtr<Location> &location) __attribute__((warn_unused_result));


 bool createdDateTimeIsSet() const;
 void unsetCreatedDateTime();
 SceRtcTick getCreatedDateTime() const;
 void setCreatedDateTime(const SceRtcTick &createdDateTime);


 bool updatedDateTimeIsSet() const;
 void unsetUpdatedDateTime();
 SceRtcTick getUpdatedDateTime() const;
 void setUpdatedDateTime(const SceRtcTick &updatedDateTime);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetTicketResponseBody(Common::LibContext * context);
 friend class GetTicketResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::GetTicketResponseBody>;

 ~GetTicketResponseBody();

private:
 Common::LibContext * m_context;

 Common::String m_ticketId;
 bool m_ticketIdIsSet;

 Common::String m_rulesetName;
 bool m_rulesetNameIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> m_ticketAttributes;
 bool m_ticketAttributesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForRead>>> m_players;
 bool m_playersIsSet;

 TicketStatus m_status;
 bool m_statusIsSet;

 Common::String m_offerId;
 bool m_offerIdIsSet;

 Common::IntrusivePtr<Submitter> m_submitter;
 bool m_submitterIsSet;

 Common::IntrusivePtr<Location> m_location;
 bool m_locationIsSet;

 SceRtcTick m_createdDateTime;
 bool m_createdDateTimeIsSet;

 SceRtcTick m_updatedDateTime;
 bool m_updatedDateTimeIsSet;


    GetTicketResponseBody();
};

class GetTicketResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetTicketResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetTicketResponseBody> *instancePtr);


 static void destroy(GetTicketResponseBody *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking/v1/Api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/ListUserTicketsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/ListUserTicketsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/UserTicket.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/UserTicket.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class UserTicket : public Common::RefObject
{
public:

 bool ticketIdIsSet() const;
 void unsetTicketId();
 const Common::String & getTicketId() const;
 int32_t setTicketId(const char* ticketId) __attribute__((warn_unused_result));


 bool statusIsSet() const;
 void unsetStatus();
 TicketStatus getStatus() const;
 void setStatus(const TicketStatus &status);


 bool rulesetNameIsSet() const;
 void unsetRulesetName();
 const Common::String & getRulesetName() const;
 int32_t setRulesetName(const char* rulesetName) __attribute__((warn_unused_result));


 bool platformIsSet() const;
 void unsetPlatform();
 Platform getPlatform() const;
 void setPlatform(const Platform &platform);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 UserTicket(Common::LibContext * context);
 friend class UserTicketFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::UserTicket>;

 ~UserTicket();

private:
 Common::LibContext * m_context;

 Common::String m_ticketId;
 bool m_ticketIdIsSet;

 TicketStatus m_status;
 bool m_statusIsSet;

 Common::String m_rulesetName;
 bool m_rulesetNameIsSet;

 Platform m_platform;
 bool m_platformIsSet;


    UserTicket();
};

class UserTicketFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<UserTicket> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<UserTicket> *instancePtr);


 static void destroy(UserTicket *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/ListUserTicketsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class ListUserTicketsResponseBody : public PsnErrorObject
{
public:

 bool ticketsIsSet() const;
 void unsetTickets();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<UserTicket>>> getTickets();
 int32_t setTickets(const Common::Vector<Common::IntrusivePtr<UserTicket>> &tickets) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ListUserTicketsResponseBody(Common::LibContext * context);
 friend class ListUserTicketsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::ListUserTicketsResponseBody>;

 ~ListUserTicketsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<UserTicket>>> m_tickets;
 bool m_ticketsIsSet;


    ListUserTicketsResponseBody();
};

class ListUserTicketsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<ListUserTicketsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ListUserTicketsResponseBody> *instancePtr);


 static void destroy(ListUserTicketsResponseBody *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking/v1/Api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/SubmitTicketRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/SubmitTicketRequestBody.h" 2 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForTicketCreate.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForTicketCreate.h" 2 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/PlayerForTicketCreate.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class PlayerForTicketCreate : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 Platform getPlatform() const;
 void setPlatform(const Platform &platform);


 bool teamNameIsSet() const;
 void unsetTeamName();
 const Common::String & getTeamName() const;
 int32_t setTeamName(const char* teamName) __attribute__((warn_unused_result));


 bool natTypeIsSet() const;
 void unsetNatType();
 int32_t getNatType() const;
 void setNatType(const int32_t &natType);


 bool playerAttributesIsSet() const;
 void unsetPlayerAttributes();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> getPlayerAttributes();
 int32_t setPlayerAttributes(const Common::Vector<Common::IntrusivePtr<Attribute>> &playerAttributes) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerForTicketCreate(Common::LibContext * context);
 friend class PlayerForTicketCreateFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::PlayerForTicketCreate>;

 ~PlayerForTicketCreate();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 Platform m_platform;

 Common::String m_teamName;
 bool m_teamNameIsSet;

 int32_t m_natType;
 bool m_natTypeIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> m_playerAttributes;
 bool m_playerAttributesIsSet;


    PlayerForTicketCreate();
};

class PlayerForTicketCreateFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  Platform platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerForTicketCreate> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerForTicketCreate> *instancePtr);


 static void destroy(PlayerForTicketCreate *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/SubmitTicketRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class SubmitTicketRequestBody : public Common::RefObject
{
public:

 const Common::String & getRulesetName() const;
 int32_t setRulesetName(const char* rulesetName) __attribute__((warn_unused_result));


 bool ticketAttributesIsSet() const;
 void unsetTicketAttributes();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> getTicketAttributes();
 int32_t setTicketAttributes(const Common::Vector<Common::IntrusivePtr<Attribute>> &ticketAttributes) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate>> &players) __attribute__((warn_unused_result));


 bool locationIsSet() const;
 void unsetLocation();
 Common::IntrusivePtr<Location> getLocation() const;
 int32_t setLocation(const Common::IntrusivePtr<Location> &location) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SubmitTicketRequestBody(Common::LibContext * context);
 friend class SubmitTicketRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::SubmitTicketRequestBody>;

 ~SubmitTicketRequestBody();

private:
 Common::LibContext * m_context;

 Common::String m_rulesetName;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> m_ticketAttributes;
 bool m_ticketAttributesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate>>> m_players;

 Common::IntrusivePtr<Location> m_location;
 bool m_locationIsSet;


    SubmitTicketRequestBody();
};

class SubmitTicketRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* rulesetName,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<SubmitTicketRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SubmitTicketRequestBody> *instancePtr);


 static void destroy(SubmitTicketRequestBody *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking/v1/Api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/SubmitTicketResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/SubmitTicketResponseBody.h" 2 3
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/Matchmaking/V1/SubmitTicketResponseBody.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class SubmitTicketResponseBody : public PsnErrorObject
{
public:

 bool ticketIdIsSet() const;
 void unsetTicketId();
 const Common::String & getTicketId() const;
 int32_t setTicketId(const char* ticketId) __attribute__((warn_unused_result));


 bool rulesetNameIsSet() const;
 void unsetRulesetName();
 const Common::String & getRulesetName() const;
 int32_t setRulesetName(const char* rulesetName) __attribute__((warn_unused_result));


 bool ticketAttributesIsSet() const;
 void unsetTicketAttributes();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> getTicketAttributes();
 int32_t setTicketAttributes(const Common::Vector<Common::IntrusivePtr<Attribute>> &ticketAttributes) __attribute__((warn_unused_result));


 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate>> &players) __attribute__((warn_unused_result));


 bool statusIsSet() const;
 void unsetStatus();
 TicketStatus getStatus() const;
 void setStatus(const TicketStatus &status);


 bool submitterIsSet() const;
 void unsetSubmitter();
 Common::IntrusivePtr<Submitter> getSubmitter() const;
 int32_t setSubmitter(const Common::IntrusivePtr<Submitter> &submitter) __attribute__((warn_unused_result));


 bool locationIsSet() const;
 void unsetLocation();
 Common::IntrusivePtr<Location> getLocation() const;
 int32_t setLocation(const Common::IntrusivePtr<Location> &location) __attribute__((warn_unused_result));


 bool createdDateTimeIsSet() const;
 void unsetCreatedDateTime();
 SceRtcTick getCreatedDateTime() const;
 void setCreatedDateTime(const SceRtcTick &createdDateTime);


 bool updatedDateTimeIsSet() const;
 void unsetUpdatedDateTime();
 SceRtcTick getUpdatedDateTime() const;
 void setUpdatedDateTime(const SceRtcTick &updatedDateTime);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SubmitTicketResponseBody(Common::LibContext * context);
 friend class SubmitTicketResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::Matchmaking::V1::SubmitTicketResponseBody>;

 ~SubmitTicketResponseBody();

private:
 Common::LibContext * m_context;

 Common::String m_ticketId;
 bool m_ticketIdIsSet;

 Common::String m_rulesetName;
 bool m_rulesetNameIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Attribute>>> m_ticketAttributes;
 bool m_ticketAttributesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate>>> m_players;
 bool m_playersIsSet;

 TicketStatus m_status;
 bool m_statusIsSet;

 Common::IntrusivePtr<Submitter> m_submitter;
 bool m_submitterIsSet;

 Common::IntrusivePtr<Location> m_location;
 bool m_locationIsSet;

 SceRtcTick m_createdDateTime;
 bool m_createdDateTimeIsSet;

 SceRtcTick m_updatedDateTime;
 bool m_updatedDateTimeIsSet;


    SubmitTicketResponseBody();
};

class SubmitTicketResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<SubmitTicketResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SubmitTicketResponseBody> *instancePtr);


 static void destroy(SubmitTicketResponseBody *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking/v1/Api.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace Matchmaking {
namespace V1 {

class Api {
public:

 class ParameterToCancelTicket : public Common::ParameterBase {
 public:
  ParameterToCancelTicket();
  ~ParameterToCancelTicket();

  int32_t initialize(
   Common::LibContext * context
   , const char* ticketId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getticketId() const;
  int32_t setticketId(const char* ticketId) __attribute__((warn_unused_result));

  struct ParameterImplToCancelTicket;

 private:
  struct ParameterImplToCancelTicket *m_pimpl;

  ParameterToCancelTicket(ParameterToCancelTicket &param);
  ParameterToCancelTicket(const ParameterToCancelTicket &param);
  ParameterToCancelTicket& operator=(ParameterToCancelTicket &param);
  ParameterToCancelTicket& operator=(const ParameterToCancelTicket &param);
 };

 static int32_t cancelTicket(
  int32_t npwebapiUserCtxId,
  const ParameterToCancelTicket &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToGetOffer : public Common::ParameterBase {
 public:
  ParameterToGetOffer();
  ~ParameterToGetOffer();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* offerId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getofferId() const;
  int32_t setofferId(const char* offerId) __attribute__((warn_unused_result));


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;


  const Common::String& getview() const;
  int32_t setview(const char* view) __attribute__((warn_unused_result));
  void unsetview();
  bool hasview() const;

  struct ParameterImplToGetOffer;

 private:
  struct ParameterImplToGetOffer *m_pimpl;

  ParameterToGetOffer(ParameterToGetOffer &param);
  ParameterToGetOffer(const ParameterToGetOffer &param);
  ParameterToGetOffer& operator=(ParameterToGetOffer &param);
  ParameterToGetOffer& operator=(const ParameterToGetOffer &param);
 };

 static int32_t getOffer(
  int32_t npwebapiUserCtxId,
  const ParameterToGetOffer &param,
  Common::Transaction<Common::IntrusivePtr<GetOfferResponseBody>> &transaction
  );

 class ParameterToGetTicket : public Common::ParameterBase {
 public:
  ParameterToGetTicket();
  ~ParameterToGetTicket();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* ticketId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getticketId() const;
  int32_t setticketId(const char* ticketId) __attribute__((warn_unused_result));


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;


  const Common::String& getview() const;
  int32_t setview(const char* view) __attribute__((warn_unused_result));
  void unsetview();
  bool hasview() const;

  struct ParameterImplToGetTicket;

 private:
  struct ParameterImplToGetTicket *m_pimpl;

  ParameterToGetTicket(ParameterToGetTicket &param);
  ParameterToGetTicket(const ParameterToGetTicket &param);
  ParameterToGetTicket& operator=(ParameterToGetTicket &param);
  ParameterToGetTicket& operator=(const ParameterToGetTicket &param);
 };

 static int32_t getTicket(
  int32_t npwebapiUserCtxId,
  const ParameterToGetTicket &param,
  Common::Transaction<Common::IntrusivePtr<GetTicketResponseBody>> &transaction
  );

 class ParameterToListUserTickets : public Common::ParameterBase {
 public:
  ParameterToListUserTickets();
  ~ParameterToListUserTickets();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;


  const Common::String& getplatformFilter() const;
  int32_t setplatformFilter(const char* platformFilter) __attribute__((warn_unused_result));
  void unsetplatformFilter();
  bool hasplatformFilter() const;


  const Common::String& getrulesetFilter() const;
  int32_t setrulesetFilter(const char* rulesetFilter) __attribute__((warn_unused_result));
  void unsetrulesetFilter();
  bool hasrulesetFilter() const;

  struct ParameterImplToListUserTickets;

 private:
  struct ParameterImplToListUserTickets *m_pimpl;

  ParameterToListUserTickets(ParameterToListUserTickets &param);
  ParameterToListUserTickets(const ParameterToListUserTickets &param);
  ParameterToListUserTickets& operator=(ParameterToListUserTickets &param);
  ParameterToListUserTickets& operator=(const ParameterToListUserTickets &param);
 };

 static int32_t listUserTickets(
  int32_t npwebapiUserCtxId,
  const ParameterToListUserTickets &param,
  Common::Transaction<Common::IntrusivePtr<ListUserTicketsResponseBody>> &transaction
  );

 class ParameterToSubmitTicket : public Common::ParameterBase {
 public:
  ParameterToSubmitTicket();
  ~ParameterToSubmitTicket();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , Common::IntrusivePtr< SubmitTicketRequestBody > submitTicketRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  Common::IntrusivePtr< SubmitTicketRequestBody > getsubmitTicketRequestBody() const;
  void setsubmitTicketRequestBody(Common::IntrusivePtr< SubmitTicketRequestBody > submitTicketRequestBody);


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToSubmitTicket;

 private:
  struct ParameterImplToSubmitTicket *m_pimpl;

  ParameterToSubmitTicket(ParameterToSubmitTicket &param);
  ParameterToSubmitTicket(const ParameterToSubmitTicket &param);
  ParameterToSubmitTicket& operator=(ParameterToSubmitTicket &param);
  ParameterToSubmitTicket& operator=(const ParameterToSubmitTicket &param);
 };

 static int32_t submitTicket(
  int32_t npwebapiUserCtxId,
  const ParameterToSubmitTicket &param,
  Common::Transaction<Common::IntrusivePtr<SubmitTicketResponseBody>> &transaction
  );

private:
 Api();
 ~Api();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/matchmaking.h" 2 3
# 330 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/profanity_filter.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/profanityfilter/v2/ProfanityApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/profanityfilter/v2/ProfanityApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/FilterProfanityResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/FilterProfanityResponse.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/webApiErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/webApiErrorResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/WebApiErrorResponse_error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/WebApiErrorResponse_error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace ProfanityFilter {
namespace V2 {

class WebApiErrorResponse_error : public Common::RefObject
{
public:

 bool codeIsSet() const;
 void unsetCode();
 int32_t getCode() const;
 void setCode(const int32_t &code);


 bool messageIsSet() const;
 void unsetMessage();
 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool statusIsSet() const;
 void unsetStatus();
 int32_t getStatus() const;
 void setStatus(const int32_t &status);


 bool tidIsSet() const;
 void unsetTid();
 const Common::String & getTid() const;
 int32_t setTid(const char* tid) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 WebApiErrorResponse_error(Common::LibContext * context);
 friend class WebApiErrorResponse_errorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::ProfanityFilter::V2::WebApiErrorResponse_error>;

 ~WebApiErrorResponse_error();

private:
 Common::LibContext * m_context;

 int32_t m_code;
 bool m_codeIsSet;

 Common::String m_message;
 bool m_messageIsSet;

 int32_t m_status;
 bool m_statusIsSet;

 Common::String m_tid;
 bool m_tidIsSet;


    WebApiErrorResponse_error();
};

class WebApiErrorResponse_errorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<WebApiErrorResponse_error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<WebApiErrorResponse_error> *instancePtr);


 static void destroy(WebApiErrorResponse_error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/webApiErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace ProfanityFilter {
namespace V2 {

class WebApiErrorResponse : public Common::RefObject
{
public:

 bool errorIsSet() const;
 void unsetError();
 Common::IntrusivePtr<WebApiErrorResponse_error> getError() const;
 int32_t setError(const Common::IntrusivePtr<WebApiErrorResponse_error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 WebApiErrorResponse(Common::LibContext * context);
 friend class WebApiErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::ProfanityFilter::V2::WebApiErrorResponse>;

 ~WebApiErrorResponse();

protected:
    WebApiErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<WebApiErrorResponse_error> m_error;
 bool m_errorIsSet;


};

class WebApiErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<WebApiErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<WebApiErrorResponse> *instancePtr);


 static void destroy(WebApiErrorResponse *instance);
};
using PsnErrorObject = WebApiErrorResponse;
using PsnErrorObjectFactory = WebApiErrorResponseFactory;


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/FilterProfanityResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace ProfanityFilter {
namespace V2 {

class FilterProfanityResponse : public PsnErrorObject
{
public:

 bool messageIsSet() const;
 void unsetMessage();
 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool statusIsSet() const;
 void unsetStatus();
 const Common::String & getStatus() const;
 int32_t setStatus(const char* status) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FilterProfanityResponse(Common::LibContext * context);
 friend class FilterProfanityResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::ProfanityFilter::V2::FilterProfanityResponse>;

 ~FilterProfanityResponse();

private:
 Common::LibContext * m_context;

 Common::String m_message;
 bool m_messageIsSet;

 Common::String m_status;
 bool m_statusIsSet;


    FilterProfanityResponse();
};

class FilterProfanityResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<FilterProfanityResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FilterProfanityResponse> *instancePtr);


 static void destroy(FilterProfanityResponse *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/profanityfilter/v2/ProfanityApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/TestForProfanityResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/TestForProfanityResponse.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace ProfanityFilter {
namespace V2 {

class TestForProfanityResponse : public PsnErrorObject
{
public:

 bool messageIsSet() const;
 void unsetMessage();
 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool statusIsSet() const;
 void unsetStatus();
 const Common::String & getStatus() const;
 int32_t setStatus(const char* status) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 TestForProfanityResponse(Common::LibContext * context);
 friend class TestForProfanityResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::ProfanityFilter::V2::TestForProfanityResponse>;

 ~TestForProfanityResponse();

private:
 Common::LibContext * m_context;

 Common::String m_message;
 bool m_messageIsSet;

 Common::String m_status;
 bool m_statusIsSet;


    TestForProfanityResponse();
};

class TestForProfanityResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<TestForProfanityResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<TestForProfanityResponse> *instancePtr);


 static void destroy(TestForProfanityResponse *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/profanityfilter/v2/ProfanityApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/WebApiFilterRequest.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/ProfanityFilter/V2/WebApiFilterRequest.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace ProfanityFilter {
namespace V2 {

class WebApiFilterRequest : public Common::RefObject
{
public:

 const Common::String & getText() const;
 int32_t setText(const char* text) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 WebApiFilterRequest(Common::LibContext * context);
 friend class WebApiFilterRequestFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::ProfanityFilter::V2::WebApiFilterRequest>;

 ~WebApiFilterRequest();

private:
 Common::LibContext * m_context;

 Common::String m_text;


    WebApiFilterRequest();
};

class WebApiFilterRequestFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* text,
  sce::Np::CppWebApi::Common::IntrusivePtr<WebApiFilterRequest> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<WebApiFilterRequest> *instancePtr);


 static void destroy(WebApiFilterRequest *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/profanityfilter/v2/ProfanityApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace ProfanityFilter {
namespace V2 {

class ProfanityApi {
public:

 class ParameterToFilterProfanity : public Common::ParameterBase {
 public:
  ParameterToFilterProfanity();
  ~ParameterToFilterProfanity();

  int32_t initialize(
   Common::LibContext * context
   , const char* locale
   , const char* serviceLabel
   , Common::IntrusivePtr< WebApiFilterRequest > webApiFilterRequest
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getlocale() const;
  int32_t setlocale(const char* locale) __attribute__((warn_unused_result));


  const Common::String& getserviceLabel() const;
  int32_t setserviceLabel(const char* serviceLabel) __attribute__((warn_unused_result));


  Common::IntrusivePtr< WebApiFilterRequest > getwebApiFilterRequest() const;
  void setwebApiFilterRequest(Common::IntrusivePtr< WebApiFilterRequest > webApiFilterRequest);

  struct ParameterImplToFilterProfanity;

 private:
  struct ParameterImplToFilterProfanity *m_pimpl;

  ParameterToFilterProfanity(ParameterToFilterProfanity &param);
  ParameterToFilterProfanity(const ParameterToFilterProfanity &param);
  ParameterToFilterProfanity& operator=(ParameterToFilterProfanity &param);
  ParameterToFilterProfanity& operator=(const ParameterToFilterProfanity &param);
 };

 static int32_t filterProfanity(
  int32_t npwebapiUserCtxId,
  const ParameterToFilterProfanity &param,
  Common::Transaction<Common::IntrusivePtr<FilterProfanityResponse>> &transaction
  );

 class ParameterToTestForProfanity : public Common::ParameterBase {
 public:
  ParameterToTestForProfanity();
  ~ParameterToTestForProfanity();

  int32_t initialize(
   Common::LibContext * context
   , const char* locale
   , const char* serviceLabel
   , Common::IntrusivePtr< WebApiFilterRequest > webApiFilterRequest
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getlocale() const;
  int32_t setlocale(const char* locale) __attribute__((warn_unused_result));


  const Common::String& getserviceLabel() const;
  int32_t setserviceLabel(const char* serviceLabel) __attribute__((warn_unused_result));


  Common::IntrusivePtr< WebApiFilterRequest > getwebApiFilterRequest() const;
  void setwebApiFilterRequest(Common::IntrusivePtr< WebApiFilterRequest > webApiFilterRequest);

  struct ParameterImplToTestForProfanity;

 private:
  struct ParameterImplToTestForProfanity *m_pimpl;

  ParameterToTestForProfanity(ParameterToTestForProfanity &param);
  ParameterToTestForProfanity(const ParameterToTestForProfanity &param);
  ParameterToTestForProfanity& operator=(ParameterToTestForProfanity &param);
  ParameterToTestForProfanity& operator=(const ParameterToTestForProfanity &param);
 };

 static int32_t testForProfanity(
  int32_t npwebapiUserCtxId,
  const ParameterToTestForProfanity &param,
  Common::Transaction<Common::IntrusivePtr<TestForProfanityResponse>> &transaction
  );

private:
 ProfanityApi();
 ~ProfanityApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/profanity_filter.h" 2 3
# 331 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/session_manager.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ErrorResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class Error : public Common::RefObject
{
public:

 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 int64_t getCode() const;
 void setCode(const int64_t &code);


 bool reasonIsSet() const;
 void unsetReason();
 const Common::String & getReason() const;
 int32_t setReason(const char* reason) __attribute__((warn_unused_result));


 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool sourceIsSet() const;
 void unsetSource();
 const Common::String & getSource() const;
 int32_t setSource(const char* source) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;

 int64_t m_code;

 Common::String m_reason;
 bool m_reasonIsSet;

 Common::String m_message;

 Common::String m_source;
 bool m_sourceIsSet;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int64_t code,
  const char* message,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ErrorResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorResponse(Common::LibContext * context);
 friend class ErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ErrorResponse>;

 ~ErrorResponse();

protected:
    ErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;


};

class ErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<Error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);


 static void destroy(ErrorResponse *instance);
};
using PsnErrorObject = ErrorResponse;
using PsnErrorObjectFactory = ErrorResponseFactory;


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetGameSessionsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetGameSessionsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionForRead.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionForRead.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchAttributes.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchAttributes.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class SearchAttributes : public Common::RefObject
{
public:

 bool string1IsSet() const;
 void unsetString1();
 const Common::String & getString1() const;
 int32_t setString1(const char* string1) __attribute__((warn_unused_result));


 bool string2IsSet() const;
 void unsetString2();
 const Common::String & getString2() const;
 int32_t setString2(const char* string2) __attribute__((warn_unused_result));


 bool string3IsSet() const;
 void unsetString3();
 const Common::String & getString3() const;
 int32_t setString3(const char* string3) __attribute__((warn_unused_result));


 bool string4IsSet() const;
 void unsetString4();
 const Common::String & getString4() const;
 int32_t setString4(const char* string4) __attribute__((warn_unused_result));


 bool string5IsSet() const;
 void unsetString5();
 const Common::String & getString5() const;
 int32_t setString5(const char* string5) __attribute__((warn_unused_result));


 bool string6IsSet() const;
 void unsetString6();
 const Common::String & getString6() const;
 int32_t setString6(const char* string6) __attribute__((warn_unused_result));


 bool string7IsSet() const;
 void unsetString7();
 const Common::String & getString7() const;
 int32_t setString7(const char* string7) __attribute__((warn_unused_result));


 bool string8IsSet() const;
 void unsetString8();
 const Common::String & getString8() const;
 int32_t setString8(const char* string8) __attribute__((warn_unused_result));


 bool string9IsSet() const;
 void unsetString9();
 const Common::String & getString9() const;
 int32_t setString9(const char* string9) __attribute__((warn_unused_result));


 bool string10IsSet() const;
 void unsetString10();
 const Common::String & getString10() const;
 int32_t setString10(const char* string10) __attribute__((warn_unused_result));


 bool integer1IsSet() const;
 void unsetInteger1();
 int32_t getInteger1() const;
 void setInteger1(const int32_t &integer1);


 bool integer2IsSet() const;
 void unsetInteger2();
 int32_t getInteger2() const;
 void setInteger2(const int32_t &integer2);


 bool integer3IsSet() const;
 void unsetInteger3();
 int32_t getInteger3() const;
 void setInteger3(const int32_t &integer3);


 bool integer4IsSet() const;
 void unsetInteger4();
 int32_t getInteger4() const;
 void setInteger4(const int32_t &integer4);


 bool integer5IsSet() const;
 void unsetInteger5();
 int32_t getInteger5() const;
 void setInteger5(const int32_t &integer5);


 bool integer6IsSet() const;
 void unsetInteger6();
 int32_t getInteger6() const;
 void setInteger6(const int32_t &integer6);


 bool integer7IsSet() const;
 void unsetInteger7();
 int32_t getInteger7() const;
 void setInteger7(const int32_t &integer7);


 bool integer8IsSet() const;
 void unsetInteger8();
 int32_t getInteger8() const;
 void setInteger8(const int32_t &integer8);


 bool integer9IsSet() const;
 void unsetInteger9();
 int32_t getInteger9() const;
 void setInteger9(const int32_t &integer9);


 bool integer10IsSet() const;
 void unsetInteger10();
 int32_t getInteger10() const;
 void setInteger10(const int32_t &integer10);


 bool boolean1IsSet() const;
 void unsetBoolean1();
 bool getBoolean1() const;
 void setBoolean1(const bool &boolean1);


 bool boolean2IsSet() const;
 void unsetBoolean2();
 bool getBoolean2() const;
 void setBoolean2(const bool &boolean2);


 bool boolean3IsSet() const;
 void unsetBoolean3();
 bool getBoolean3() const;
 void setBoolean3(const bool &boolean3);


 bool boolean4IsSet() const;
 void unsetBoolean4();
 bool getBoolean4() const;
 void setBoolean4(const bool &boolean4);


 bool boolean5IsSet() const;
 void unsetBoolean5();
 bool getBoolean5() const;
 void setBoolean5(const bool &boolean5);


 bool boolean6IsSet() const;
 void unsetBoolean6();
 bool getBoolean6() const;
 void setBoolean6(const bool &boolean6);


 bool boolean7IsSet() const;
 void unsetBoolean7();
 bool getBoolean7() const;
 void setBoolean7(const bool &boolean7);


 bool boolean8IsSet() const;
 void unsetBoolean8();
 bool getBoolean8() const;
 void setBoolean8(const bool &boolean8);


 bool boolean9IsSet() const;
 void unsetBoolean9();
 bool getBoolean9() const;
 void setBoolean9(const bool &boolean9);


 bool boolean10IsSet() const;
 void unsetBoolean10();
 bool getBoolean10() const;
 void setBoolean10(const bool &boolean10);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SearchAttributes(Common::LibContext * context);
 friend class SearchAttributesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::SearchAttributes>;

 ~SearchAttributes();

private:
 Common::LibContext * m_context;

 Common::String m_string1;
 bool m_string1IsSet;

 Common::String m_string2;
 bool m_string2IsSet;

 Common::String m_string3;
 bool m_string3IsSet;

 Common::String m_string4;
 bool m_string4IsSet;

 Common::String m_string5;
 bool m_string5IsSet;

 Common::String m_string6;
 bool m_string6IsSet;

 Common::String m_string7;
 bool m_string7IsSet;

 Common::String m_string8;
 bool m_string8IsSet;

 Common::String m_string9;
 bool m_string9IsSet;

 Common::String m_string10;
 bool m_string10IsSet;

 int32_t m_integer1;
 bool m_integer1IsSet;

 int32_t m_integer2;
 bool m_integer2IsSet;

 int32_t m_integer3;
 bool m_integer3IsSet;

 int32_t m_integer4;
 bool m_integer4IsSet;

 int32_t m_integer5;
 bool m_integer5IsSet;

 int32_t m_integer6;
 bool m_integer6IsSet;

 int32_t m_integer7;
 bool m_integer7IsSet;

 int32_t m_integer8;
 bool m_integer8IsSet;

 int32_t m_integer9;
 bool m_integer9IsSet;

 int32_t m_integer10;
 bool m_integer10IsSet;

 bool m_boolean1;
 bool m_boolean1IsSet;

 bool m_boolean2;
 bool m_boolean2IsSet;

 bool m_boolean3;
 bool m_boolean3IsSet;

 bool m_boolean4;
 bool m_boolean4IsSet;

 bool m_boolean5;
 bool m_boolean5IsSet;

 bool m_boolean6;
 bool m_boolean6IsSet;

 bool m_boolean7;
 bool m_boolean7IsSet;

 bool m_boolean8;
 bool m_boolean8IsSet;

 bool m_boolean9;
 bool m_boolean9IsSet;

 bool m_boolean10;
 bool m_boolean10IsSet;


    SearchAttributes();
};

class SearchAttributesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<SearchAttributes> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SearchAttributes> *instancePtr);


 static void destroy(SearchAttributes *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionForRead.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionMemberForRead.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionMemberForRead.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionPlayer.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinState.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinState.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class JoinState {
  _NOT_SET = 0,
  kJoined,
  kReserved,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionPlayer.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GameSessionPlayer : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 const Common::String & getJoinTimestamp() const;
 int32_t setJoinTimestamp(const char* joinTimestamp) __attribute__((warn_unused_result));


 bool natTypeIsSet() const;
 void unsetNatType();
 int32_t getNatType() const;
 void setNatType(const int32_t &natType);


 bool joinStateIsSet() const;
 void unsetJoinState();
 JoinState getJoinState() const;
 void setJoinState(const JoinState &joinState);


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GameSessionPlayer(Common::LibContext * context);
 friend class GameSessionPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GameSessionPlayer>;

 ~GameSessionPlayer();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 SceNpOnlineId m_onlineId;

 Common::String m_platform;

 Common::String m_joinTimestamp;

 int32_t m_natType;
 bool m_natTypeIsSet;

 JoinState m_joinState;
 bool m_joinStateIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    GameSessionPlayer();
};

class GameSessionPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const SceNpOnlineId &onlineId,
  const char* platform,
  const char* joinTimestamp,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionPlayer> *instancePtr);


 static void destroy(GameSessionPlayer *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionMemberForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionSpectator.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionSpectator.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GameSessionSpectator : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 const Common::String & getJoinTimestamp() const;
 int32_t setJoinTimestamp(const char* joinTimestamp) __attribute__((warn_unused_result));


 bool natTypeIsSet() const;
 void unsetNatType();
 int32_t getNatType() const;
 void setNatType(const int32_t &natType);


 bool joinStateIsSet() const;
 void unsetJoinState();
 JoinState getJoinState() const;
 void setJoinState(const JoinState &joinState);


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GameSessionSpectator(Common::LibContext * context);
 friend class GameSessionSpectatorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GameSessionSpectator>;

 ~GameSessionSpectator();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 SceNpOnlineId m_onlineId;

 Common::String m_platform;

 Common::String m_joinTimestamp;

 int32_t m_natType;
 bool m_natTypeIsSet;

 JoinState m_joinState;
 bool m_joinStateIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    GameSessionSpectator();
};

class GameSessionSpectatorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const SceNpOnlineId &onlineId,
  const char* platform,
  const char* joinTimestamp,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionSpectator> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionSpectator> *instancePtr);


 static void destroy(GameSessionSpectator *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionMemberForRead.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GameSessionMemberForRead : public Common::RefObject
{
public:

 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<GameSessionPlayer>> &players) __attribute__((warn_unused_result));


 bool spectatorsIsSet() const;
 void unsetSpectators();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionSpectator>>> getSpectators();
 int32_t setSpectators(const Common::Vector<Common::IntrusivePtr<GameSessionSpectator>> &spectators) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GameSessionMemberForRead(Common::LibContext * context);
 friend class GameSessionMemberForReadFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GameSessionMemberForRead>;

 ~GameSessionMemberForRead();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionPlayer>>> m_players;
 bool m_playersIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionSpectator>>> m_spectators;
 bool m_spectatorsIsSet;


    GameSessionMemberForRead();
};

class GameSessionMemberForReadFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionMemberForRead> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionMemberForRead> *instancePtr);


 static void destroy(GameSessionMemberForRead *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/MatchmakingForRead.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/MatchmakingForRead.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class MatchmakingForRead : public Common::RefObject
{
public:

 const Common::String & getOfferId() const;
 int32_t setOfferId(const char* offerId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MatchmakingForRead(Common::LibContext * context);
 friend class MatchmakingForReadFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::MatchmakingForRead>;

 ~MatchmakingForRead();

private:
 Common::LibContext * m_context;

 Common::String m_offerId;


    MatchmakingForRead();
};

class MatchmakingForReadFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* offerId,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchmakingForRead> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MatchmakingForRead> *instancePtr);


 static void destroy(MatchmakingForRead *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/Representative.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/Representative.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class Representative : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Representative(Common::LibContext * context);
 friend class RepresentativeFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::Representative>;

 ~Representative();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 SceNpOnlineId m_onlineId;

 Common::String m_platform;


    Representative();
};

class RepresentativeFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const SceNpOnlineId &onlineId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<Representative> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Representative> *instancePtr);


 static void destroy(Representative *instance);
};


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionForRead.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GameSessionForRead : public Common::RefObject
{
public:

 bool sessionIdIsSet() const;
 void unsetSessionId();
 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 bool createdTimestampIsSet() const;
 void unsetCreatedTimestamp();
 const Common::String & getCreatedTimestamp() const;
 int32_t setCreatedTimestamp(const char* createdTimestamp) __attribute__((warn_unused_result));


 bool maxPlayersIsSet() const;
 void unsetMaxPlayers();
 int32_t getMaxPlayers() const;
 void setMaxPlayers(const int32_t &maxPlayers);


 bool maxSpectatorsIsSet() const;
 void unsetMaxSpectators();
 int32_t getMaxSpectators() const;
 void setMaxSpectators(const int32_t &maxSpectators);


 bool memberIsSet() const;
 void unsetMember();
 Common::IntrusivePtr<GameSessionMemberForRead> getMember() const;
 int32_t setMember(const Common::IntrusivePtr<GameSessionMemberForRead> &member) __attribute__((warn_unused_result));


 bool joinDisabledIsSet() const;
 void unsetJoinDisabled();
 bool getJoinDisabled() const;
 void setJoinDisabled(const bool &joinDisabled);


 bool supportedPlatformsIsSet() const;
 void unsetSupportedPlatforms();
 Common::IntrusivePtr<Common::Vector<Common::String>> getSupportedPlatforms();
 int32_t setSupportedPlatforms(const Common::Vector<Common::String> &supportedPlatforms) __attribute__((warn_unused_result));


 bool representativeIsSet() const;
 void unsetRepresentative();
 Common::IntrusivePtr<Representative> getRepresentative() const;
 int32_t setRepresentative(const Common::IntrusivePtr<Representative> &representative) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool customData2IsSet() const;
 void unsetCustomData2();
 const Common::IntrusivePtr<Common::Binary> & getCustomData2() const;
 int32_t setCustomData2(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool usePlayerSessionIsSet() const;
 void unsetUsePlayerSession();
 bool getUsePlayerSession() const;
 void setUsePlayerSession(const bool &usePlayerSession);


 bool matchmakingIsSet() const;
 void unsetMatchmaking();
 Common::IntrusivePtr<MatchmakingForRead> getMatchmaking() const;
 int32_t setMatchmaking(const Common::IntrusivePtr<MatchmakingForRead> &matchmaking) __attribute__((warn_unused_result));


 bool reservationTimeoutSecondsIsSet() const;
 void unsetReservationTimeoutSeconds();
 int32_t getReservationTimeoutSeconds() const;
 void setReservationTimeoutSeconds(const int32_t &reservationTimeoutSeconds);


 bool searchIndexIsSet() const;
 void unsetSearchIndex();
 const Common::String & getSearchIndex() const;
 int32_t setSearchIndex(const char* searchIndex) __attribute__((warn_unused_result));


 bool searchAttributesIsSet() const;
 void unsetSearchAttributes();
 Common::IntrusivePtr<SearchAttributes> getSearchAttributes() const;
 int32_t setSearchAttributes(const Common::IntrusivePtr<SearchAttributes> &searchAttributes) __attribute__((warn_unused_result));


 bool searchableIsSet() const;
 void unsetSearchable();
 bool getSearchable() const;
 void setSearchable(const bool &searchable);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GameSessionForRead(Common::LibContext * context);
 friend class GameSessionForReadFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GameSessionForRead>;

 ~GameSessionForRead();

private:
 Common::LibContext * m_context;

 Common::String m_sessionId;
 bool m_sessionIdIsSet;

 Common::String m_createdTimestamp;
 bool m_createdTimestampIsSet;

 int32_t m_maxPlayers;
 bool m_maxPlayersIsSet;

 int32_t m_maxSpectators;
 bool m_maxSpectatorsIsSet;

 Common::IntrusivePtr<GameSessionMemberForRead> m_member;
 bool m_memberIsSet;

 bool m_joinDisabled;
 bool m_joinDisabledIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_supportedPlatforms;
 bool m_supportedPlatformsIsSet;

 Common::IntrusivePtr<Representative> m_representative;
 bool m_representativeIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;

 Common::IntrusivePtr<Common::Binary> m_customData2;
 bool m_customData2IsSet;

 bool m_usePlayerSession;
 bool m_usePlayerSessionIsSet;

 Common::IntrusivePtr<MatchmakingForRead> m_matchmaking;
 bool m_matchmakingIsSet;

 int32_t m_reservationTimeoutSeconds;
 bool m_reservationTimeoutSecondsIsSet;

 Common::String m_searchIndex;
 bool m_searchIndexIsSet;

 Common::IntrusivePtr<SearchAttributes> m_searchAttributes;
 bool m_searchAttributesIsSet;

 bool m_searchable;
 bool m_searchableIsSet;


    GameSessionForRead();
};

class GameSessionForReadFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionForRead> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionForRead> *instancePtr);


 static void destroy(GameSessionForRead *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetGameSessionsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GetGameSessionsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionForRead>>> getGameSessions();
 int32_t setGameSessions(const Common::Vector<Common::IntrusivePtr<GameSessionForRead>> &gameSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetGameSessionsResponseBody(Common::LibContext * context);
 friend class GetGameSessionsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GetGameSessionsResponseBody>;

 ~GetGameSessionsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionForRead>>> m_gameSessions;


    GetGameSessionsResponseBody();
};

class GetGameSessionsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionForRead>>>::value_type &gameSessions,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetGameSessionsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetGameSessionsResponseBody> *instancePtr);


 static void destroy(GetGameSessionsResponseBody *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdGameSessionsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdGameSessionsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinedGameSessionWithPlatform.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinedGameSessionWithPlatform.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class JoinedGameSessionWithPlatform : public Common::RefObject
{
public:

 bool sessionIdIsSet() const;
 void unsetSessionId();
 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 bool platformIsSet() const;
 void unsetPlatform();
 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 bool joinStateIsSet() const;
 void unsetJoinState();
 JoinState getJoinState() const;
 void setJoinState(const JoinState &joinState);


 bool usePlayerSessionIsSet() const;
 void unsetUsePlayerSession();
 bool getUsePlayerSession() const;
 void setUsePlayerSession(const bool &usePlayerSession);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 JoinedGameSessionWithPlatform(Common::LibContext * context);
 friend class JoinedGameSessionWithPlatformFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::JoinedGameSessionWithPlatform>;

 ~JoinedGameSessionWithPlatform();

private:
 Common::LibContext * m_context;

 Common::String m_sessionId;
 bool m_sessionIdIsSet;

 Common::String m_platform;
 bool m_platformIsSet;

 JoinState m_joinState;
 bool m_joinStateIsSet;

 bool m_usePlayerSession;
 bool m_usePlayerSessionIsSet;


    JoinedGameSessionWithPlatform();
};

class JoinedGameSessionWithPlatformFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<JoinedGameSessionWithPlatform> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<JoinedGameSessionWithPlatform> *instancePtr);


 static void destroy(JoinedGameSessionWithPlatform *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdGameSessionsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GetUsersAccountIdGameSessionsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinedGameSessionWithPlatform>>> getGameSessions();
 int32_t setGameSessions(const Common::Vector<Common::IntrusivePtr<JoinedGameSessionWithPlatform>> &gameSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetUsersAccountIdGameSessionsResponseBody(Common::LibContext * context);
 friend class GetUsersAccountIdGameSessionsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GetUsersAccountIdGameSessionsResponseBody>;

 ~GetUsersAccountIdGameSessionsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinedGameSessionWithPlatform>>> m_gameSessions;


    GetUsersAccountIdGameSessionsResponseBody();
};

class GetUsersAccountIdGameSessionsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinedGameSessionWithPlatform>>>::value_type &gameSessions,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetUsersAccountIdGameSessionsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetUsersAccountIdGameSessionsResponseBody> *instancePtr);


 static void destroy(GetUsersAccountIdGameSessionsResponseBody *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchGameSessionsSearchAttributesRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchGameSessionsSearchAttributesRequestBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PatchGameSessionsSearchAttributesRequestBody : public Common::RefObject
{
public:

 bool string1IsSet() const;
 void unsetString1();
 const Common::String & getString1() const;
 int32_t setString1(const char* string1) __attribute__((warn_unused_result));


 bool string2IsSet() const;
 void unsetString2();
 const Common::String & getString2() const;
 int32_t setString2(const char* string2) __attribute__((warn_unused_result));


 bool string3IsSet() const;
 void unsetString3();
 const Common::String & getString3() const;
 int32_t setString3(const char* string3) __attribute__((warn_unused_result));


 bool string4IsSet() const;
 void unsetString4();
 const Common::String & getString4() const;
 int32_t setString4(const char* string4) __attribute__((warn_unused_result));


 bool string5IsSet() const;
 void unsetString5();
 const Common::String & getString5() const;
 int32_t setString5(const char* string5) __attribute__((warn_unused_result));


 bool string6IsSet() const;
 void unsetString6();
 const Common::String & getString6() const;
 int32_t setString6(const char* string6) __attribute__((warn_unused_result));


 bool string7IsSet() const;
 void unsetString7();
 const Common::String & getString7() const;
 int32_t setString7(const char* string7) __attribute__((warn_unused_result));


 bool string8IsSet() const;
 void unsetString8();
 const Common::String & getString8() const;
 int32_t setString8(const char* string8) __attribute__((warn_unused_result));


 bool string9IsSet() const;
 void unsetString9();
 const Common::String & getString9() const;
 int32_t setString9(const char* string9) __attribute__((warn_unused_result));


 bool string10IsSet() const;
 void unsetString10();
 const Common::String & getString10() const;
 int32_t setString10(const char* string10) __attribute__((warn_unused_result));


 bool integer1IsSet() const;
 void unsetInteger1();
 int32_t getInteger1() const;
 void setInteger1(const int32_t &integer1);


 bool integer2IsSet() const;
 void unsetInteger2();
 int32_t getInteger2() const;
 void setInteger2(const int32_t &integer2);


 bool integer3IsSet() const;
 void unsetInteger3();
 int32_t getInteger3() const;
 void setInteger3(const int32_t &integer3);


 bool integer4IsSet() const;
 void unsetInteger4();
 int32_t getInteger4() const;
 void setInteger4(const int32_t &integer4);


 bool integer5IsSet() const;
 void unsetInteger5();
 int32_t getInteger5() const;
 void setInteger5(const int32_t &integer5);


 bool integer6IsSet() const;
 void unsetInteger6();
 int32_t getInteger6() const;
 void setInteger6(const int32_t &integer6);


 bool integer7IsSet() const;
 void unsetInteger7();
 int32_t getInteger7() const;
 void setInteger7(const int32_t &integer7);


 bool integer8IsSet() const;
 void unsetInteger8();
 int32_t getInteger8() const;
 void setInteger8(const int32_t &integer8);


 bool integer9IsSet() const;
 void unsetInteger9();
 int32_t getInteger9() const;
 void setInteger9(const int32_t &integer9);


 bool integer10IsSet() const;
 void unsetInteger10();
 int32_t getInteger10() const;
 void setInteger10(const int32_t &integer10);


 bool boolean1IsSet() const;
 void unsetBoolean1();
 bool getBoolean1() const;
 void setBoolean1(const bool &boolean1);


 bool boolean2IsSet() const;
 void unsetBoolean2();
 bool getBoolean2() const;
 void setBoolean2(const bool &boolean2);


 bool boolean3IsSet() const;
 void unsetBoolean3();
 bool getBoolean3() const;
 void setBoolean3(const bool &boolean3);


 bool boolean4IsSet() const;
 void unsetBoolean4();
 bool getBoolean4() const;
 void setBoolean4(const bool &boolean4);


 bool boolean5IsSet() const;
 void unsetBoolean5();
 bool getBoolean5() const;
 void setBoolean5(const bool &boolean5);


 bool boolean6IsSet() const;
 void unsetBoolean6();
 bool getBoolean6() const;
 void setBoolean6(const bool &boolean6);


 bool boolean7IsSet() const;
 void unsetBoolean7();
 bool getBoolean7() const;
 void setBoolean7(const bool &boolean7);


 bool boolean8IsSet() const;
 void unsetBoolean8();
 bool getBoolean8() const;
 void setBoolean8(const bool &boolean8);


 bool boolean9IsSet() const;
 void unsetBoolean9();
 bool getBoolean9() const;
 void setBoolean9(const bool &boolean9);


 bool boolean10IsSet() const;
 void unsetBoolean10();
 bool getBoolean10() const;
 void setBoolean10(const bool &boolean10);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PatchGameSessionsSearchAttributesRequestBody(Common::LibContext * context);
 friend class PatchGameSessionsSearchAttributesRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PatchGameSessionsSearchAttributesRequestBody>;

 ~PatchGameSessionsSearchAttributesRequestBody();

private:
 Common::LibContext * m_context;

 Common::String m_string1;
 bool m_string1IsSet;

 Common::String m_string2;
 bool m_string2IsSet;

 Common::String m_string3;
 bool m_string3IsSet;

 Common::String m_string4;
 bool m_string4IsSet;

 Common::String m_string5;
 bool m_string5IsSet;

 Common::String m_string6;
 bool m_string6IsSet;

 Common::String m_string7;
 bool m_string7IsSet;

 Common::String m_string8;
 bool m_string8IsSet;

 Common::String m_string9;
 bool m_string9IsSet;

 Common::String m_string10;
 bool m_string10IsSet;

 int32_t m_integer1;
 bool m_integer1IsSet;

 int32_t m_integer2;
 bool m_integer2IsSet;

 int32_t m_integer3;
 bool m_integer3IsSet;

 int32_t m_integer4;
 bool m_integer4IsSet;

 int32_t m_integer5;
 bool m_integer5IsSet;

 int32_t m_integer6;
 bool m_integer6IsSet;

 int32_t m_integer7;
 bool m_integer7IsSet;

 int32_t m_integer8;
 bool m_integer8IsSet;

 int32_t m_integer9;
 bool m_integer9IsSet;

 int32_t m_integer10;
 bool m_integer10IsSet;

 bool m_boolean1;
 bool m_boolean1IsSet;

 bool m_boolean2;
 bool m_boolean2IsSet;

 bool m_boolean3;
 bool m_boolean3IsSet;

 bool m_boolean4;
 bool m_boolean4IsSet;

 bool m_boolean5;
 bool m_boolean5IsSet;

 bool m_boolean6;
 bool m_boolean6IsSet;

 bool m_boolean7;
 bool m_boolean7IsSet;

 bool m_boolean8;
 bool m_boolean8IsSet;

 bool m_boolean9;
 bool m_boolean9IsSet;

 bool m_boolean10;
 bool m_boolean10IsSet;


    PatchGameSessionsSearchAttributesRequestBody();
};

class PatchGameSessionsSearchAttributesRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchGameSessionsSearchAttributesRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchGameSessionsSearchAttributesRequestBody> *instancePtr);


 static void destroy(PatchGameSessionsSearchAttributesRequestBody *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchGameSessionsSessionIdMembersAccountIdRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchGameSessionsSessionIdMembersAccountIdRequestBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PatchGameSessionsSessionIdMembersAccountIdRequestBody : public Common::RefObject
{
public:

 bool natTypeIsSet() const;
 void unsetNatType();
 int32_t getNatType() const;
 void setNatType(const int32_t &natType);


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PatchGameSessionsSessionIdMembersAccountIdRequestBody(Common::LibContext * context);
 friend class PatchGameSessionsSessionIdMembersAccountIdRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PatchGameSessionsSessionIdMembersAccountIdRequestBody>;

 ~PatchGameSessionsSessionIdMembersAccountIdRequestBody();

private:
 Common::LibContext * m_context;

 int32_t m_natType;
 bool m_natTypeIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    PatchGameSessionsSessionIdMembersAccountIdRequestBody();
};

class PatchGameSessionsSessionIdMembersAccountIdRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchGameSessionsSessionIdMembersAccountIdRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchGameSessionsSessionIdMembersAccountIdRequestBody> *instancePtr);


 static void destroy(PatchGameSessionsSessionIdMembersAccountIdRequestBody *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchGameSessionsSessionIdRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchGameSessionsSessionIdRequestBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PatchGameSessionsSessionIdRequestBody : public Common::RefObject
{
public:

 bool maxPlayersIsSet() const;
 void unsetMaxPlayers();
 int32_t getMaxPlayers() const;
 void setMaxPlayers(const int32_t &maxPlayers);


 bool maxSpectatorsIsSet() const;
 void unsetMaxSpectators();
 int32_t getMaxSpectators() const;
 void setMaxSpectators(const int32_t &maxSpectators);


 bool joinDisabledIsSet() const;
 void unsetJoinDisabled();
 bool getJoinDisabled() const;
 void setJoinDisabled(const bool &joinDisabled);


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool customData2IsSet() const;
 void unsetCustomData2();
 const Common::IntrusivePtr<Common::Binary> & getCustomData2() const;
 int32_t setCustomData2(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool searchableIsSet() const;
 void unsetSearchable();
 bool getSearchable() const;
 void setSearchable(const bool &searchable);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PatchGameSessionsSessionIdRequestBody(Common::LibContext * context);
 friend class PatchGameSessionsSessionIdRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PatchGameSessionsSessionIdRequestBody>;

 ~PatchGameSessionsSessionIdRequestBody();

private:
 Common::LibContext * m_context;

 int32_t m_maxPlayers;
 bool m_maxPlayersIsSet;

 int32_t m_maxSpectators;
 bool m_maxSpectatorsIsSet;

 bool m_joinDisabled;
 bool m_joinDisabledIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;

 Common::IntrusivePtr<Common::Binary> m_customData2;
 bool m_customData2IsSet;

 bool m_searchable;
 bool m_searchableIsSet;


    PatchGameSessionsSessionIdRequestBody();
};

class PatchGameSessionsSessionIdRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchGameSessionsSessionIdRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchGameSessionsSessionIdRequestBody> *instancePtr);


 static void destroy(PatchGameSessionsSessionIdRequestBody *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsRequestBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSession.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSession.h" 2 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionMemberPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionMemberPlayer.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionPlayer.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/InitialJoinState.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/InitialJoinState.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class InitialJoinState {
  _NOT_SET = 0,
  kJoined,
  kReserved,
 };


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionPlayer.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionPushContext.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSessionPushContext.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GameSessionPushContext : public Common::RefObject
{
public:

 const Common::String & getPushContextId() const;
 int32_t setPushContextId(const char* pushContextId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GameSessionPushContext(Common::LibContext * context);
 friend class GameSessionPushContextFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GameSessionPushContext>;

 ~GameSessionPushContext();

private:
 Common::LibContext * m_context;

 Common::String m_pushContextId;


    GameSessionPushContext();
};

class GameSessionPushContextFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* pushContextId,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionPushContext> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSessionPushContext> *instancePtr);


 static void destroy(GameSessionPushContext *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionPlayer.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestGameSessionPlayer : public Common::RefObject
{
public:

 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 bool pushContextsIsSet() const;
 void unsetPushContexts();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionPushContext>>> getPushContexts();
 int32_t setPushContexts(const Common::Vector<Common::IntrusivePtr<GameSessionPushContext>> &pushContexts) __attribute__((warn_unused_result));


 bool natTypeIsSet() const;
 void unsetNatType();
 int32_t getNatType() const;
 void setNatType(const int32_t &natType);


 bool joinStateIsSet() const;
 void unsetJoinState();
 InitialJoinState getJoinState() const;
 void setJoinState(const InitialJoinState &joinState);


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestGameSessionPlayer(Common::LibContext * context);
 friend class RequestGameSessionPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestGameSessionPlayer>;

 ~RequestGameSessionPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;

 Common::String m_platform;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionPushContext>>> m_pushContexts;
 bool m_pushContextsIsSet;

 int32_t m_natType;
 bool m_natTypeIsSet;

 InitialJoinState m_joinState;
 bool m_joinStateIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    RequestGameSessionPlayer();
};

class RequestGameSessionPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestGameSessionPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestGameSessionPlayer> *instancePtr);


 static void destroy(RequestGameSessionPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionMemberPlayer.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestGameSessionMemberPlayer : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<RequestGameSessionPlayer>> &players) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestGameSessionMemberPlayer(Common::LibContext * context);
 friend class RequestGameSessionMemberPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestGameSessionMemberPlayer>;

 ~RequestGameSessionMemberPlayer();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSessionPlayer>>> m_players;


    RequestGameSessionMemberPlayer();
};

class RequestGameSessionMemberPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSessionPlayer>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestGameSessionMemberPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestGameSessionMemberPlayer> *instancePtr);


 static void destroy(RequestGameSessionMemberPlayer *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSession.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestGameSession : public Common::RefObject
{
public:

 int32_t getMaxPlayers() const;
 void setMaxPlayers(const int32_t &maxPlayers);


 bool maxSpectatorsIsSet() const;
 void unsetMaxSpectators();
 int32_t getMaxSpectators() const;
 void setMaxSpectators(const int32_t &maxSpectators);


 Common::IntrusivePtr<RequestGameSessionMemberPlayer> getMember() const;
 int32_t setMember(const Common::IntrusivePtr<RequestGameSessionMemberPlayer> &member) __attribute__((warn_unused_result));


 bool joinDisabledIsSet() const;
 void unsetJoinDisabled();
 bool getJoinDisabled() const;
 void setJoinDisabled(const bool &joinDisabled);


 Common::IntrusivePtr<Common::Vector<Common::String>> getSupportedPlatforms();
 int32_t setSupportedPlatforms(const Common::Vector<Common::String> &supportedPlatforms) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool customData2IsSet() const;
 void unsetCustomData2();
 const Common::IntrusivePtr<Common::Binary> & getCustomData2() const;
 int32_t setCustomData2(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool usePlayerSessionIsSet() const;
 void unsetUsePlayerSession();
 bool getUsePlayerSession() const;
 void setUsePlayerSession(const bool &usePlayerSession);


 bool reservationTimeoutSecondsIsSet() const;
 void unsetReservationTimeoutSeconds();
 int32_t getReservationTimeoutSeconds() const;
 void setReservationTimeoutSeconds(const int32_t &reservationTimeoutSeconds);


 bool searchIndexIsSet() const;
 void unsetSearchIndex();
 const Common::String & getSearchIndex() const;
 int32_t setSearchIndex(const char* searchIndex) __attribute__((warn_unused_result));


 bool searchAttributesIsSet() const;
 void unsetSearchAttributes();
 Common::IntrusivePtr<SearchAttributes> getSearchAttributes() const;
 int32_t setSearchAttributes(const Common::IntrusivePtr<SearchAttributes> &searchAttributes) __attribute__((warn_unused_result));


 bool searchableIsSet() const;
 void unsetSearchable();
 bool getSearchable() const;
 void setSearchable(const bool &searchable);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestGameSession(Common::LibContext * context);
 friend class RequestGameSessionFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestGameSession>;

 ~RequestGameSession();

private:
 Common::LibContext * m_context;

 int32_t m_maxPlayers;

 int32_t m_maxSpectators;
 bool m_maxSpectatorsIsSet;

 Common::IntrusivePtr<RequestGameSessionMemberPlayer> m_member;

 bool m_joinDisabled;
 bool m_joinDisabledIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_supportedPlatforms;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;

 Common::IntrusivePtr<Common::Binary> m_customData2;
 bool m_customData2IsSet;

 bool m_usePlayerSession;
 bool m_usePlayerSessionIsSet;

 int32_t m_reservationTimeoutSeconds;
 bool m_reservationTimeoutSecondsIsSet;

 Common::String m_searchIndex;
 bool m_searchIndexIsSet;

 Common::IntrusivePtr<SearchAttributes> m_searchAttributes;
 bool m_searchAttributesIsSet;

 bool m_searchable;
 bool m_searchableIsSet;


    RequestGameSession();
};

class RequestGameSessionFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t maxPlayers,
  Common::IntrusivePtr<RequestGameSessionMemberPlayer> member,
  const Common::IntrusivePtr<Common::Vector<Common::String>>::value_type &supportedPlatforms,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestGameSession> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestGameSession> *instancePtr);


 static void destroy(RequestGameSession *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSession>>> getGameSessions();
 int32_t setGameSessions(const Common::Vector<Common::IntrusivePtr<RequestGameSession>> &gameSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsRequestBody(Common::LibContext * context);
 friend class PostGameSessionsRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsRequestBody>;

 ~PostGameSessionsRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSession>>> m_gameSessions;


    PostGameSessionsRequestBody();
};

class PostGameSessionsRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSession>>>::value_type &gameSessions,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsRequestBody> *instancePtr);


 static void destroy(PostGameSessionsRequestBody *instance);
};


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSession.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSession.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponseGameSessionMemberPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponseGameSessionMemberPlayer.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponseGameSessionPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponseGameSessionPlayer.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ResponseGameSessionPlayer : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseGameSessionPlayer(Common::LibContext * context);
 friend class ResponseGameSessionPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ResponseGameSessionPlayer>;

 ~ResponseGameSessionPlayer();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 Common::String m_platform;


    ResponseGameSessionPlayer();
};

class ResponseGameSessionPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseGameSessionPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseGameSessionPlayer> *instancePtr);


 static void destroy(ResponseGameSessionPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponseGameSessionMemberPlayer.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ResponseGameSessionMemberPlayer : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer>> &players) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseGameSessionMemberPlayer(Common::LibContext * context);
 friend class ResponseGameSessionMemberPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ResponseGameSessionMemberPlayer>;

 ~ResponseGameSessionMemberPlayer();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer>>> m_players;


    ResponseGameSessionMemberPlayer();
};

class ResponseGameSessionMemberPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseGameSessionMemberPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseGameSessionMemberPlayer> *instancePtr);


 static void destroy(ResponseGameSessionMemberPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GameSession.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GameSession : public Common::RefObject
{
public:

 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 Common::IntrusivePtr<ResponseGameSessionMemberPlayer> getMember() const;
 int32_t setMember(const Common::IntrusivePtr<ResponseGameSessionMemberPlayer> &member) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GameSession(Common::LibContext * context);
 friend class GameSessionFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GameSession>;

 ~GameSession();

private:
 Common::LibContext * m_context;

 Common::String m_sessionId;

 Common::IntrusivePtr<ResponseGameSessionMemberPlayer> m_member;


    GameSession();
};

class GameSessionFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* sessionId,
  Common::IntrusivePtr<ResponseGameSessionMemberPlayer> member,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSession> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GameSession> *instancePtr);


 static void destroy(GameSession *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSession>>> getGameSessions();
 int32_t setGameSessions(const Common::Vector<Common::IntrusivePtr<GameSession>> &gameSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsResponseBody(Common::LibContext * context);
 friend class PostGameSessionsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsResponseBody>;

 ~PostGameSessionsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSession>>> m_gameSessions;


    PostGameSessionsResponseBody();
};

class PostGameSessionsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSession>>>::value_type &gameSessions,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsResponseBody> *instancePtr);


 static void destroy(PostGameSessionsResponseBody *instance);
};


}
}
}
}
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSearchRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSearchRequestBody.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchCondition.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchCondition.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchOperator.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchOperator.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class SearchOperator {
  _NOT_SET = 0,
  kEqual,
  kNotEqual,
  kGreaterThan,
  kLessThan,
  kGreaterThanOrEqual,
  kLessThanOrEqual,
  kIn,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchCondition.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchAttribute.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchAttribute.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class SearchAttribute {
  _NOT_SET = 0,
  kMaxplayers,
  kNumplayerslots,
  kMaxspectators,
  kNumspectatorslots,
  kJoindisabled,
  kNattype,
  kSearchattributesInteger1,
  kSearchattributesInteger2,
  kSearchattributesInteger3,
  kSearchattributesInteger4,
  kSearchattributesInteger5,
  kSearchattributesInteger6,
  kSearchattributesInteger7,
  kSearchattributesInteger8,
  kSearchattributesInteger9,
  kSearchattributesInteger10,
  kSearchattributesBoolean1,
  kSearchattributesBoolean2,
  kSearchattributesBoolean3,
  kSearchattributesBoolean4,
  kSearchattributesBoolean5,
  kSearchattributesBoolean6,
  kSearchattributesBoolean7,
  kSearchattributesBoolean8,
  kSearchattributesBoolean9,
  kSearchattributesBoolean10,
  kSearchattributesString1,
  kSearchattributesString2,
  kSearchattributesString3,
  kSearchattributesString4,
  kSearchattributesString5,
  kSearchattributesString6,
  kSearchattributesString7,
  kSearchattributesString8,
  kSearchattributesString9,
  kSearchattributesString10,
 };


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchCondition.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class SearchCondition : public Common::RefObject
{
public:

 SearchAttribute getAttribute() const;
 void setAttribute(const SearchAttribute &attribute);


 SearchOperator getOperator() const;
 void setOperator(const SearchOperator &_operator);


 bool valueIsSet() const;
 void unsetValue();
 const Common::String & getValue() const;
 int32_t setValue(const char* value) __attribute__((warn_unused_result));


 bool valuesIsSet() const;
 void unsetValues();
 Common::IntrusivePtr<Common::Vector<Common::String>> getValues();
 int32_t setValues(const Common::Vector<Common::String> &values) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SearchCondition(Common::LibContext * context);
 friend class SearchConditionFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::SearchCondition>;

 ~SearchCondition();

private:
 Common::LibContext * m_context;

 SearchAttribute m_attribute;

 SearchOperator m__operator;

 Common::String m_value;
 bool m_valueIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_values;
 bool m_valuesIsSet;


    SearchCondition();
};

class SearchConditionFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  SearchAttribute attribute,
  SearchOperator _operator,
  sce::Np::CppWebApi::Common::IntrusivePtr<SearchCondition> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SearchCondition> *instancePtr);


 static void destroy(SearchCondition *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSearchRequestBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsSearchRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<SearchCondition>>> getConditions();
 int32_t setConditions(const Common::Vector<Common::IntrusivePtr<SearchCondition>> &conditions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsSearchRequestBody(Common::LibContext * context);
 friend class PostGameSessionsSearchRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsSearchRequestBody>;

 ~PostGameSessionsSearchRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<SearchCondition>>> m_conditions;


    PostGameSessionsSearchRequestBody();
};

class PostGameSessionsSearchRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<SearchCondition>>>::value_type &conditions,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSearchRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSearchRequestBody> *instancePtr);


 static void destroy(PostGameSessionsSearchRequestBody *instance);
};


}
}
}
}
}
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSearchResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSearchResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchGameSession.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SearchGameSession.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class SearchGameSession : public Common::RefObject
{
public:

 bool sessionIdIsSet() const;
 void unsetSessionId();
 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SearchGameSession(Common::LibContext * context);
 friend class SearchGameSessionFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::SearchGameSession>;

 ~SearchGameSession();

private:
 Common::LibContext * m_context;

 Common::String m_sessionId;
 bool m_sessionIdIsSet;


    SearchGameSession();
};

class SearchGameSessionFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<SearchGameSession> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SearchGameSession> *instancePtr);


 static void destroy(SearchGameSession *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSearchResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsSearchResponseBody : public PsnErrorObject
{
public:

 bool gameSessionsIsSet() const;
 void unsetGameSessions();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<SearchGameSession>>> getGameSessions();
 int32_t setGameSessions(const Common::Vector<Common::IntrusivePtr<SearchGameSession>> &gameSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsSearchResponseBody(Common::LibContext * context);
 friend class PostGameSessionsSearchResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsSearchResponseBody>;

 ~PostGameSessionsSearchResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<SearchGameSession>>> m_gameSessions;
 bool m_gameSessionsIsSet;


    PostGameSessionsSearchResponseBody();
};

class PostGameSessionsSearchResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSearchResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSearchResponseBody> *instancePtr);


 static void destroy(PostGameSessionsSearchResponseBody *instance);
};


}
}
}
}
}
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberPlayersRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberPlayersRequestBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestJoinGameSessionPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestJoinGameSessionPlayer.h" 2 3
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestJoinGameSessionPlayer.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestJoinGameSessionPlayer : public Common::RefObject
{
public:

 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 bool pushContextsIsSet() const;
 void unsetPushContexts();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionPushContext>>> getPushContexts();
 int32_t setPushContexts(const Common::Vector<Common::IntrusivePtr<GameSessionPushContext>> &pushContexts) __attribute__((warn_unused_result));


 bool natTypeIsSet() const;
 void unsetNatType();
 int32_t getNatType() const;
 void setNatType(const int32_t &natType);


 bool joinStateIsSet() const;
 void unsetJoinState();
 InitialJoinState getJoinState() const;
 void setJoinState(const InitialJoinState &joinState);


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestJoinGameSessionPlayer(Common::LibContext * context);
 friend class RequestJoinGameSessionPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestJoinGameSessionPlayer>;

 ~RequestJoinGameSessionPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;

 Common::String m_platform;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionPushContext>>> m_pushContexts;
 bool m_pushContextsIsSet;

 int32_t m_natType;
 bool m_natTypeIsSet;

 InitialJoinState m_joinState;
 bool m_joinStateIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    RequestJoinGameSessionPlayer();
};

class RequestJoinGameSessionPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestJoinGameSessionPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestJoinGameSessionPlayer> *instancePtr);


 static void destroy(RequestJoinGameSessionPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberPlayersRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsSessionIdMemberPlayersRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestJoinGameSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<RequestJoinGameSessionPlayer>> &players) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsSessionIdMemberPlayersRequestBody(Common::LibContext * context);
 friend class PostGameSessionsSessionIdMemberPlayersRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsSessionIdMemberPlayersRequestBody>;

 ~PostGameSessionsSessionIdMemberPlayersRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestJoinGameSessionPlayer>>> m_players;


    PostGameSessionsSessionIdMemberPlayersRequestBody();
};

class PostGameSessionsSessionIdMemberPlayersRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestJoinGameSessionPlayer>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdMemberPlayersRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdMemberPlayersRequestBody> *instancePtr);


 static void destroy(PostGameSessionsSessionIdMemberPlayersRequestBody *instance);
};


}
}
}
}
}
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberPlayersResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberPlayersResponseBody.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsSessionIdMemberPlayersResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer>> &players) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsSessionIdMemberPlayersResponseBody(Common::LibContext * context);
 friend class PostGameSessionsSessionIdMemberPlayersResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsSessionIdMemberPlayersResponseBody>;

 ~PostGameSessionsSessionIdMemberPlayersResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer>>> m_players;


    PostGameSessionsSessionIdMemberPlayersResponseBody();
};

class PostGameSessionsSessionIdMemberPlayersResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdMemberPlayersResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdMemberPlayersResponseBody> *instancePtr);


 static void destroy(PostGameSessionsSessionIdMemberPlayersResponseBody *instance);
};


}
}
}
}
}
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberSpectatorsRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberSpectatorsRequestBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionSpectator.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionSpectator.h" 2 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestGameSessionSpectator.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestGameSessionSpectator : public Common::RefObject
{
public:

 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 bool pushContextsIsSet() const;
 void unsetPushContexts();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionPushContext>>> getPushContexts();
 int32_t setPushContexts(const Common::Vector<Common::IntrusivePtr<GameSessionPushContext>> &pushContexts) __attribute__((warn_unused_result));


 bool natTypeIsSet() const;
 void unsetNatType();
 int32_t getNatType() const;
 void setNatType(const int32_t &natType);


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestGameSessionSpectator(Common::LibContext * context);
 friend class RequestGameSessionSpectatorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestGameSessionSpectator>;

 ~RequestGameSessionSpectator();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;

 Common::String m_platform;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<GameSessionPushContext>>> m_pushContexts;
 bool m_pushContextsIsSet;

 int32_t m_natType;
 bool m_natTypeIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    RequestGameSessionSpectator();
};

class RequestGameSessionSpectatorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestGameSessionSpectator> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestGameSessionSpectator> *instancePtr);


 static void destroy(RequestGameSessionSpectator *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberSpectatorsRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsSessionIdMemberSpectatorsRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSessionSpectator>>> getSpectators();
 int32_t setSpectators(const Common::Vector<Common::IntrusivePtr<RequestGameSessionSpectator>> &spectators) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsSessionIdMemberSpectatorsRequestBody(Common::LibContext * context);
 friend class PostGameSessionsSessionIdMemberSpectatorsRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsSessionIdMemberSpectatorsRequestBody>;

 ~PostGameSessionsSessionIdMemberSpectatorsRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSessionSpectator>>> m_spectators;


    PostGameSessionsSessionIdMemberSpectatorsRequestBody();
};

class PostGameSessionsSessionIdMemberSpectatorsRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestGameSessionSpectator>>>::value_type &spectators,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdMemberSpectatorsRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdMemberSpectatorsRequestBody> *instancePtr);


 static void destroy(PostGameSessionsSessionIdMemberSpectatorsRequestBody *instance);
};


}
}
}
}
}
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberSpectatorsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberSpectatorsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponseGameSessionSpectator.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponseGameSessionSpectator.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ResponseGameSessionSpectator : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponseGameSessionSpectator(Common::LibContext * context);
 friend class ResponseGameSessionSpectatorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ResponseGameSessionSpectator>;

 ~ResponseGameSessionSpectator();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 Common::String m_platform;


    ResponseGameSessionSpectator();
};

class ResponseGameSessionSpectatorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseGameSessionSpectator> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponseGameSessionSpectator> *instancePtr);


 static void destroy(ResponseGameSessionSpectator *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdMemberSpectatorsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsSessionIdMemberSpectatorsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionSpectator>>> getSpectators();
 int32_t setSpectators(const Common::Vector<Common::IntrusivePtr<ResponseGameSessionSpectator>> &spectators) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsSessionIdMemberSpectatorsResponseBody(Common::LibContext * context);
 friend class PostGameSessionsSessionIdMemberSpectatorsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsSessionIdMemberSpectatorsResponseBody>;

 ~PostGameSessionsSessionIdMemberSpectatorsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionSpectator>>> m_spectators;


    PostGameSessionsSessionIdMemberSpectatorsResponseBody();
};

class PostGameSessionsSessionIdMemberSpectatorsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionSpectator>>>::value_type &spectators,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdMemberSpectatorsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdMemberSpectatorsResponseBody> *instancePtr);


 static void destroy(PostGameSessionsSessionIdMemberSpectatorsResponseBody *instance);
};


}
}
}
}
}
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdSessionMessageRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdSessionMessageRequestBody.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/MemberWithMultiPlatform.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/MemberWithMultiPlatform.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class MemberWithMultiPlatform : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 MemberWithMultiPlatform(Common::LibContext * context);
 friend class MemberWithMultiPlatformFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::MemberWithMultiPlatform>;

 ~MemberWithMultiPlatform();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 Common::String m_platform;


    MemberWithMultiPlatform();
};

class MemberWithMultiPlatformFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<MemberWithMultiPlatform> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<MemberWithMultiPlatform> *instancePtr);


 static void destroy(MemberWithMultiPlatform *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsSessionIdSessionMessageRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsSessionIdSessionMessageRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<MemberWithMultiPlatform>>> getTo();
 int32_t setTo(const Common::Vector<Common::IntrusivePtr<MemberWithMultiPlatform>> &to) __attribute__((warn_unused_result));


 const Common::String & getPayload() const;
 int32_t setPayload(const char* payload) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsSessionIdSessionMessageRequestBody(Common::LibContext * context);
 friend class PostGameSessionsSessionIdSessionMessageRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsSessionIdSessionMessageRequestBody>;

 ~PostGameSessionsSessionIdSessionMessageRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<MemberWithMultiPlatform>>> m_to;

 Common::String m_payload;


    PostGameSessionsSessionIdSessionMessageRequestBody();
};

class PostGameSessionsSessionIdSessionMessageRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<MemberWithMultiPlatform>>>::value_type &to,
  const char* payload,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdSessionMessageRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsSessionIdSessionMessageRequestBody> *instancePtr);


 static void destroy(PostGameSessionsSessionIdSessionMessageRequestBody *instance);
};


}
}
}
}
}
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsTouchResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostGameSessionsTouchResponseBody.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostGameSessionsTouchResponseBody : public PsnErrorObject
{
public:

 bool touchedDateTimeIsSet() const;
 void unsetTouchedDateTime();
 SceRtcTick getTouchedDateTime() const;
 void setTouchedDateTime(const SceRtcTick &touchedDateTime);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostGameSessionsTouchResponseBody(Common::LibContext * context);
 friend class PostGameSessionsTouchResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostGameSessionsTouchResponseBody>;

 ~PostGameSessionsTouchResponseBody();

private:
 Common::LibContext * m_context;

 SceRtcTick m_touchedDateTime;
 bool m_touchedDateTimeIsSet;


    PostGameSessionsTouchResponseBody();
};

class PostGameSessionsTouchResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsTouchResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostGameSessionsTouchResponseBody> *instancePtr);


 static void destroy(PostGameSessionsTouchResponseBody *instance);
};


}
}
}
}
}
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PutGameSessionsSearchAttributesRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PutGameSessionsSearchAttributesRequestBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PutGameSessionsSearchAttributesRequestBody : public Common::RefObject
{
public:

 bool string1IsSet() const;
 void unsetString1();
 const Common::String & getString1() const;
 int32_t setString1(const char* string1) __attribute__((warn_unused_result));


 bool string2IsSet() const;
 void unsetString2();
 const Common::String & getString2() const;
 int32_t setString2(const char* string2) __attribute__((warn_unused_result));


 bool string3IsSet() const;
 void unsetString3();
 const Common::String & getString3() const;
 int32_t setString3(const char* string3) __attribute__((warn_unused_result));


 bool string4IsSet() const;
 void unsetString4();
 const Common::String & getString4() const;
 int32_t setString4(const char* string4) __attribute__((warn_unused_result));


 bool string5IsSet() const;
 void unsetString5();
 const Common::String & getString5() const;
 int32_t setString5(const char* string5) __attribute__((warn_unused_result));


 bool string6IsSet() const;
 void unsetString6();
 const Common::String & getString6() const;
 int32_t setString6(const char* string6) __attribute__((warn_unused_result));


 bool string7IsSet() const;
 void unsetString7();
 const Common::String & getString7() const;
 int32_t setString7(const char* string7) __attribute__((warn_unused_result));


 bool string8IsSet() const;
 void unsetString8();
 const Common::String & getString8() const;
 int32_t setString8(const char* string8) __attribute__((warn_unused_result));


 bool string9IsSet() const;
 void unsetString9();
 const Common::String & getString9() const;
 int32_t setString9(const char* string9) __attribute__((warn_unused_result));


 bool string10IsSet() const;
 void unsetString10();
 const Common::String & getString10() const;
 int32_t setString10(const char* string10) __attribute__((warn_unused_result));


 bool integer1IsSet() const;
 void unsetInteger1();
 int32_t getInteger1() const;
 void setInteger1(const int32_t &integer1);


 bool integer2IsSet() const;
 void unsetInteger2();
 int32_t getInteger2() const;
 void setInteger2(const int32_t &integer2);


 bool integer3IsSet() const;
 void unsetInteger3();
 int32_t getInteger3() const;
 void setInteger3(const int32_t &integer3);


 bool integer4IsSet() const;
 void unsetInteger4();
 int32_t getInteger4() const;
 void setInteger4(const int32_t &integer4);


 bool integer5IsSet() const;
 void unsetInteger5();
 int32_t getInteger5() const;
 void setInteger5(const int32_t &integer5);


 bool integer6IsSet() const;
 void unsetInteger6();
 int32_t getInteger6() const;
 void setInteger6(const int32_t &integer6);


 bool integer7IsSet() const;
 void unsetInteger7();
 int32_t getInteger7() const;
 void setInteger7(const int32_t &integer7);


 bool integer8IsSet() const;
 void unsetInteger8();
 int32_t getInteger8() const;
 void setInteger8(const int32_t &integer8);


 bool integer9IsSet() const;
 void unsetInteger9();
 int32_t getInteger9() const;
 void setInteger9(const int32_t &integer9);


 bool integer10IsSet() const;
 void unsetInteger10();
 int32_t getInteger10() const;
 void setInteger10(const int32_t &integer10);


 bool boolean1IsSet() const;
 void unsetBoolean1();
 bool getBoolean1() const;
 void setBoolean1(const bool &boolean1);


 bool boolean2IsSet() const;
 void unsetBoolean2();
 bool getBoolean2() const;
 void setBoolean2(const bool &boolean2);


 bool boolean3IsSet() const;
 void unsetBoolean3();
 bool getBoolean3() const;
 void setBoolean3(const bool &boolean3);


 bool boolean4IsSet() const;
 void unsetBoolean4();
 bool getBoolean4() const;
 void setBoolean4(const bool &boolean4);


 bool boolean5IsSet() const;
 void unsetBoolean5();
 bool getBoolean5() const;
 void setBoolean5(const bool &boolean5);


 bool boolean6IsSet() const;
 void unsetBoolean6();
 bool getBoolean6() const;
 void setBoolean6(const bool &boolean6);


 bool boolean7IsSet() const;
 void unsetBoolean7();
 bool getBoolean7() const;
 void setBoolean7(const bool &boolean7);


 bool boolean8IsSet() const;
 void unsetBoolean8();
 bool getBoolean8() const;
 void setBoolean8(const bool &boolean8);


 bool boolean9IsSet() const;
 void unsetBoolean9();
 bool getBoolean9() const;
 void setBoolean9(const bool &boolean9);


 bool boolean10IsSet() const;
 void unsetBoolean10();
 bool getBoolean10() const;
 void setBoolean10(const bool &boolean10);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PutGameSessionsSearchAttributesRequestBody(Common::LibContext * context);
 friend class PutGameSessionsSearchAttributesRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PutGameSessionsSearchAttributesRequestBody>;

 ~PutGameSessionsSearchAttributesRequestBody();

private:
 Common::LibContext * m_context;

 Common::String m_string1;
 bool m_string1IsSet;

 Common::String m_string2;
 bool m_string2IsSet;

 Common::String m_string3;
 bool m_string3IsSet;

 Common::String m_string4;
 bool m_string4IsSet;

 Common::String m_string5;
 bool m_string5IsSet;

 Common::String m_string6;
 bool m_string6IsSet;

 Common::String m_string7;
 bool m_string7IsSet;

 Common::String m_string8;
 bool m_string8IsSet;

 Common::String m_string9;
 bool m_string9IsSet;

 Common::String m_string10;
 bool m_string10IsSet;

 int32_t m_integer1;
 bool m_integer1IsSet;

 int32_t m_integer2;
 bool m_integer2IsSet;

 int32_t m_integer3;
 bool m_integer3IsSet;

 int32_t m_integer4;
 bool m_integer4IsSet;

 int32_t m_integer5;
 bool m_integer5IsSet;

 int32_t m_integer6;
 bool m_integer6IsSet;

 int32_t m_integer7;
 bool m_integer7IsSet;

 int32_t m_integer8;
 bool m_integer8IsSet;

 int32_t m_integer9;
 bool m_integer9IsSet;

 int32_t m_integer10;
 bool m_integer10IsSet;

 bool m_boolean1;
 bool m_boolean1IsSet;

 bool m_boolean2;
 bool m_boolean2IsSet;

 bool m_boolean3;
 bool m_boolean3IsSet;

 bool m_boolean4;
 bool m_boolean4IsSet;

 bool m_boolean5;
 bool m_boolean5IsSet;

 bool m_boolean6;
 bool m_boolean6IsSet;

 bool m_boolean7;
 bool m_boolean7IsSet;

 bool m_boolean8;
 bool m_boolean8IsSet;

 bool m_boolean9;
 bool m_boolean9IsSet;

 bool m_boolean10;
 bool m_boolean10IsSet;


    PutGameSessionsSearchAttributesRequestBody();
};

class PutGameSessionsSearchAttributesRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PutGameSessionsSearchAttributesRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PutGameSessionsSearchAttributesRequestBody> *instancePtr);


 static void destroy(PutGameSessionsSearchAttributesRequestBody *instance);
};


}
}
}
}
}
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/GameSessionsApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GameSessionsApi {
public:

 class ParameterToCreateGameSessions : public Common::ParameterBase {
 public:
  ParameterToCreateGameSessions();
  ~ParameterToCreateGameSessions();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , Common::IntrusivePtr< PostGameSessionsRequestBody > postGameSessionsRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  Common::IntrusivePtr< PostGameSessionsRequestBody > getpostGameSessionsRequestBody() const;
  void setpostGameSessionsRequestBody(Common::IntrusivePtr< PostGameSessionsRequestBody > postGameSessionsRequestBody);


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToCreateGameSessions;

 private:
  struct ParameterImplToCreateGameSessions *m_pimpl;

  ParameterToCreateGameSessions(ParameterToCreateGameSessions &param);
  ParameterToCreateGameSessions(const ParameterToCreateGameSessions &param);
  ParameterToCreateGameSessions& operator=(ParameterToCreateGameSessions &param);
  ParameterToCreateGameSessions& operator=(const ParameterToCreateGameSessions &param);
 };

 static int32_t createGameSessions(
  int32_t npwebapiUserCtxId,
  const ParameterToCreateGameSessions &param,
  Common::Transaction<Common::IntrusivePtr<PostGameSessionsResponseBody>> &transaction
  );

 class ParameterToDeleteGameSession : public Common::ParameterBase {
 public:
  ParameterToDeleteGameSession();
  ~ParameterToDeleteGameSession();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));

  struct ParameterImplToDeleteGameSession;

 private:
  struct ParameterImplToDeleteGameSession *m_pimpl;

  ParameterToDeleteGameSession(ParameterToDeleteGameSession &param);
  ParameterToDeleteGameSession(const ParameterToDeleteGameSession &param);
  ParameterToDeleteGameSession& operator=(ParameterToDeleteGameSession &param);
  ParameterToDeleteGameSession& operator=(const ParameterToDeleteGameSession &param);
 };

 static int32_t deleteGameSession(
  int32_t npwebapiUserCtxId,
  const ParameterToDeleteGameSession &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToGetGameSessions : public Common::ParameterBase {
 public:
  ParameterToGetGameSessions();
  ~ParameterToGetGameSessions();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* xPSNSESSIONMANAGERSESSIONIDS
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getxPSNSESSIONMANAGERSESSIONIDS() const;
  int32_t setxPSNSESSIONMANAGERSESSIONIDS(const char* xPSNSESSIONMANAGERSESSIONIDS) __attribute__((warn_unused_result));


  const Common::String& getacceptLanguage() const;
  int32_t setacceptLanguage(const char* acceptLanguage) __attribute__((warn_unused_result));
  void unsetacceptLanguage();
  bool hasacceptLanguage() const;


  Common::IntrusivePtr<Common::Vector<Common::String>> getfields() const;
  void setfields(Common::IntrusivePtr<Common::Vector<Common::String>> fields);
  void unsetfields();
  bool hasfields() const;


  const Common::String& getjoinStateFilter() const;
  int32_t setjoinStateFilter(const char* joinStateFilter) __attribute__((warn_unused_result));
  void unsetjoinStateFilter();
  bool hasjoinStateFilter() const;


  const Common::String& getusePlayerSessionFilter() const;
  int32_t setusePlayerSessionFilter(const char* usePlayerSessionFilter) __attribute__((warn_unused_result));
  void unsetusePlayerSessionFilter();
  bool hasusePlayerSessionFilter() const;


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;


  const Common::String& getview() const;
  int32_t setview(const char* view) __attribute__((warn_unused_result));
  void unsetview();
  bool hasview() const;


  Common::IntrusivePtr<Common::Vector<Common::String>> getincludeFields() const;
  void setincludeFields(Common::IntrusivePtr<Common::Vector<Common::String>> includeFields);
  void unsetincludeFields();
  bool hasincludeFields() const;

  struct ParameterImplToGetGameSessions;

 private:
  struct ParameterImplToGetGameSessions *m_pimpl;

  ParameterToGetGameSessions(ParameterToGetGameSessions &param);
  ParameterToGetGameSessions(const ParameterToGetGameSessions &param);
  ParameterToGetGameSessions& operator=(ParameterToGetGameSessions &param);
  ParameterToGetGameSessions& operator=(const ParameterToGetGameSessions &param);
 };

 static int32_t getGameSessions(
  int32_t npwebapiUserCtxId,
  const ParameterToGetGameSessions &param,
  Common::Transaction<Common::IntrusivePtr<GetGameSessionsResponseBody>> &transaction
  );

 class ParameterToGetJoinedGameSessionsByUser : public Common::ParameterBase {
 public:
  ParameterToGetJoinedGameSessionsByUser();
  ~ParameterToGetJoinedGameSessionsByUser();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  Common::IntrusivePtr<Common::Vector<Common::String>> getfields() const;
  void setfields(Common::IntrusivePtr<Common::Vector<Common::String>> fields);
  void unsetfields();
  bool hasfields() const;


  const Common::String& getmemberFilter() const;
  int32_t setmemberFilter(const char* memberFilter) __attribute__((warn_unused_result));
  void unsetmemberFilter();
  bool hasmemberFilter() const;


  const Common::String& getplatformFilter() const;
  int32_t setplatformFilter(const char* platformFilter) __attribute__((warn_unused_result));
  void unsetplatformFilter();
  bool hasplatformFilter() const;


  const Common::String& getjoinStateFilter() const;
  int32_t setjoinStateFilter(const char* joinStateFilter) __attribute__((warn_unused_result));
  void unsetjoinStateFilter();
  bool hasjoinStateFilter() const;


  const Common::String& getusePlayerSessionFilter() const;
  int32_t setusePlayerSessionFilter(const char* usePlayerSessionFilter) __attribute__((warn_unused_result));
  void unsetusePlayerSessionFilter();
  bool hasusePlayerSessionFilter() const;


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToGetJoinedGameSessionsByUser;

 private:
  struct ParameterImplToGetJoinedGameSessionsByUser *m_pimpl;

  ParameterToGetJoinedGameSessionsByUser(ParameterToGetJoinedGameSessionsByUser &param);
  ParameterToGetJoinedGameSessionsByUser(const ParameterToGetJoinedGameSessionsByUser &param);
  ParameterToGetJoinedGameSessionsByUser& operator=(ParameterToGetJoinedGameSessionsByUser &param);
  ParameterToGetJoinedGameSessionsByUser& operator=(const ParameterToGetJoinedGameSessionsByUser &param);
 };

 static int32_t getJoinedGameSessionsByUser(
  int32_t npwebapiUserCtxId,
  const ParameterToGetJoinedGameSessionsByUser &param,
  Common::Transaction<Common::IntrusivePtr<GetUsersAccountIdGameSessionsResponseBody>> &transaction
  );

 class ParameterToJoinGameSessionAsPlayer : public Common::ParameterBase {
 public:
  ParameterToJoinGameSessionAsPlayer();
  ~ParameterToJoinGameSessionAsPlayer();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PostGameSessionsSessionIdMemberPlayersRequestBody > postGameSessionsSessionIdMemberPlayersRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostGameSessionsSessionIdMemberPlayersRequestBody > getpostGameSessionsSessionIdMemberPlayersRequestBody() const;
  void setpostGameSessionsSessionIdMemberPlayersRequestBody(Common::IntrusivePtr< PostGameSessionsSessionIdMemberPlayersRequestBody > postGameSessionsSessionIdMemberPlayersRequestBody);


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToJoinGameSessionAsPlayer;

 private:
  struct ParameterImplToJoinGameSessionAsPlayer *m_pimpl;

  ParameterToJoinGameSessionAsPlayer(ParameterToJoinGameSessionAsPlayer &param);
  ParameterToJoinGameSessionAsPlayer(const ParameterToJoinGameSessionAsPlayer &param);
  ParameterToJoinGameSessionAsPlayer& operator=(ParameterToJoinGameSessionAsPlayer &param);
  ParameterToJoinGameSessionAsPlayer& operator=(const ParameterToJoinGameSessionAsPlayer &param);
 };

 static int32_t joinGameSessionAsPlayer(
  int32_t npwebapiUserCtxId,
  const ParameterToJoinGameSessionAsPlayer &param,
  Common::Transaction<Common::IntrusivePtr<PostGameSessionsSessionIdMemberPlayersResponseBody>> &transaction
  );

 class ParameterToJoinGameSessionAsSpectator : public Common::ParameterBase {
 public:
  ParameterToJoinGameSessionAsSpectator();
  ~ParameterToJoinGameSessionAsSpectator();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PostGameSessionsSessionIdMemberSpectatorsRequestBody > postGameSessionsSessionIdMemberSpectatorsRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostGameSessionsSessionIdMemberSpectatorsRequestBody > getpostGameSessionsSessionIdMemberSpectatorsRequestBody() const;
  void setpostGameSessionsSessionIdMemberSpectatorsRequestBody(Common::IntrusivePtr< PostGameSessionsSessionIdMemberSpectatorsRequestBody > postGameSessionsSessionIdMemberSpectatorsRequestBody);


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToJoinGameSessionAsSpectator;

 private:
  struct ParameterImplToJoinGameSessionAsSpectator *m_pimpl;

  ParameterToJoinGameSessionAsSpectator(ParameterToJoinGameSessionAsSpectator &param);
  ParameterToJoinGameSessionAsSpectator(const ParameterToJoinGameSessionAsSpectator &param);
  ParameterToJoinGameSessionAsSpectator& operator=(ParameterToJoinGameSessionAsSpectator &param);
  ParameterToJoinGameSessionAsSpectator& operator=(const ParameterToJoinGameSessionAsSpectator &param);
 };

 static int32_t joinGameSessionAsSpectator(
  int32_t npwebapiUserCtxId,
  const ParameterToJoinGameSessionAsSpectator &param,
  Common::Transaction<Common::IntrusivePtr<PostGameSessionsSessionIdMemberSpectatorsResponseBody>> &transaction
  );

 class ParameterToLeaveGameSession : public Common::ParameterBase {
 public:
  ParameterToLeaveGameSession();
  ~ParameterToLeaveGameSession();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , const char* accountId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));

  struct ParameterImplToLeaveGameSession;

 private:
  struct ParameterImplToLeaveGameSession *m_pimpl;

  ParameterToLeaveGameSession(ParameterToLeaveGameSession &param);
  ParameterToLeaveGameSession(const ParameterToLeaveGameSession &param);
  ParameterToLeaveGameSession& operator=(ParameterToLeaveGameSession &param);
  ParameterToLeaveGameSession& operator=(const ParameterToLeaveGameSession &param);
 };

 static int32_t leaveGameSession(
  int32_t npwebapiUserCtxId,
  const ParameterToLeaveGameSession &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToPatchGameSessionsSearchAttributes : public Common::ParameterBase {
 public:
  ParameterToPatchGameSessionsSearchAttributes();
  ~ParameterToPatchGameSessionsSearchAttributes();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PatchGameSessionsSearchAttributesRequestBody > patchGameSessionsSearchAttributesRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PatchGameSessionsSearchAttributesRequestBody > getpatchGameSessionsSearchAttributesRequestBody() const;
  void setpatchGameSessionsSearchAttributesRequestBody(Common::IntrusivePtr< PatchGameSessionsSearchAttributesRequestBody > patchGameSessionsSearchAttributesRequestBody);

  struct ParameterImplToPatchGameSessionsSearchAttributes;

 private:
  struct ParameterImplToPatchGameSessionsSearchAttributes *m_pimpl;

  ParameterToPatchGameSessionsSearchAttributes(ParameterToPatchGameSessionsSearchAttributes &param);
  ParameterToPatchGameSessionsSearchAttributes(const ParameterToPatchGameSessionsSearchAttributes &param);
  ParameterToPatchGameSessionsSearchAttributes& operator=(ParameterToPatchGameSessionsSearchAttributes &param);
  ParameterToPatchGameSessionsSearchAttributes& operator=(const ParameterToPatchGameSessionsSearchAttributes &param);
 };

 static int32_t patchGameSessionsSearchAttributes(
  int32_t npwebapiUserCtxId,
  const ParameterToPatchGameSessionsSearchAttributes &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToPostGameSessionsSearch : public Common::ParameterBase {
 public:
  ParameterToPostGameSessionsSearch();
  ~ParameterToPostGameSessionsSearch();

  int32_t initialize(
   Common::LibContext * context
   , const char* searchIndex
   , Common::IntrusivePtr< PostGameSessionsSearchRequestBody > postGameSessionsSearchRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsearchIndex() const;
  int32_t setsearchIndex(const char* searchIndex) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostGameSessionsSearchRequestBody > getpostGameSessionsSearchRequestBody() const;
  void setpostGameSessionsSearchRequestBody(Common::IntrusivePtr< PostGameSessionsSearchRequestBody > postGameSessionsSearchRequestBody);


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;

  struct ParameterImplToPostGameSessionsSearch;

 private:
  struct ParameterImplToPostGameSessionsSearch *m_pimpl;

  ParameterToPostGameSessionsSearch(ParameterToPostGameSessionsSearch &param);
  ParameterToPostGameSessionsSearch(const ParameterToPostGameSessionsSearch &param);
  ParameterToPostGameSessionsSearch& operator=(ParameterToPostGameSessionsSearch &param);
  ParameterToPostGameSessionsSearch& operator=(const ParameterToPostGameSessionsSearch &param);
 };

 static int32_t postGameSessionsSearch(
  int32_t npwebapiUserCtxId,
  const ParameterToPostGameSessionsSearch &param,
  Common::Transaction<Common::IntrusivePtr<PostGameSessionsSearchResponseBody>> &transaction
  );

 class ParameterToPostGameSessionsTouch : public Common::ParameterBase {
 public:
  ParameterToPostGameSessionsTouch();
  ~ParameterToPostGameSessionsTouch();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));

  struct ParameterImplToPostGameSessionsTouch;

 private:
  struct ParameterImplToPostGameSessionsTouch *m_pimpl;

  ParameterToPostGameSessionsTouch(ParameterToPostGameSessionsTouch &param);
  ParameterToPostGameSessionsTouch(const ParameterToPostGameSessionsTouch &param);
  ParameterToPostGameSessionsTouch& operator=(ParameterToPostGameSessionsTouch &param);
  ParameterToPostGameSessionsTouch& operator=(const ParameterToPostGameSessionsTouch &param);
 };

 static int32_t postGameSessionsTouch(
  int32_t npwebapiUserCtxId,
  const ParameterToPostGameSessionsTouch &param,
  Common::Transaction<Common::IntrusivePtr<PostGameSessionsTouchResponseBody>> &transaction
  );

 class ParameterToPutGameSessionsSearchAttributes : public Common::ParameterBase {
 public:
  ParameterToPutGameSessionsSearchAttributes();
  ~ParameterToPutGameSessionsSearchAttributes();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PutGameSessionsSearchAttributesRequestBody > putGameSessionsSearchAttributesRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PutGameSessionsSearchAttributesRequestBody > getputGameSessionsSearchAttributesRequestBody() const;
  void setputGameSessionsSearchAttributesRequestBody(Common::IntrusivePtr< PutGameSessionsSearchAttributesRequestBody > putGameSessionsSearchAttributesRequestBody);

  struct ParameterImplToPutGameSessionsSearchAttributes;

 private:
  struct ParameterImplToPutGameSessionsSearchAttributes *m_pimpl;

  ParameterToPutGameSessionsSearchAttributes(ParameterToPutGameSessionsSearchAttributes &param);
  ParameterToPutGameSessionsSearchAttributes(const ParameterToPutGameSessionsSearchAttributes &param);
  ParameterToPutGameSessionsSearchAttributes& operator=(ParameterToPutGameSessionsSearchAttributes &param);
  ParameterToPutGameSessionsSearchAttributes& operator=(const ParameterToPutGameSessionsSearchAttributes &param);
 };

 static int32_t putGameSessionsSearchAttributes(
  int32_t npwebapiUserCtxId,
  const ParameterToPutGameSessionsSearchAttributes &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToSendGameSessionMessage : public Common::ParameterBase {
 public:
  ParameterToSendGameSessionMessage();
  ~ParameterToSendGameSessionMessage();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PostGameSessionsSessionIdSessionMessageRequestBody > postGameSessionsSessionIdSessionMessageRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostGameSessionsSessionIdSessionMessageRequestBody > getpostGameSessionsSessionIdSessionMessageRequestBody() const;
  void setpostGameSessionsSessionIdSessionMessageRequestBody(Common::IntrusivePtr< PostGameSessionsSessionIdSessionMessageRequestBody > postGameSessionsSessionIdSessionMessageRequestBody);

  struct ParameterImplToSendGameSessionMessage;

 private:
  struct ParameterImplToSendGameSessionMessage *m_pimpl;

  ParameterToSendGameSessionMessage(ParameterToSendGameSessionMessage &param);
  ParameterToSendGameSessionMessage(const ParameterToSendGameSessionMessage &param);
  ParameterToSendGameSessionMessage& operator=(ParameterToSendGameSessionMessage &param);
  ParameterToSendGameSessionMessage& operator=(const ParameterToSendGameSessionMessage &param);
 };

 static int32_t sendGameSessionMessage(
  int32_t npwebapiUserCtxId,
  const ParameterToSendGameSessionMessage &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToSetGameSessionMemberSystemProperties : public Common::ParameterBase {
 public:
  ParameterToSetGameSessionMemberSystemProperties();
  ~ParameterToSetGameSessionMemberSystemProperties();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , const char* accountId
   , Common::IntrusivePtr< PatchGameSessionsSessionIdMembersAccountIdRequestBody > patchGameSessionsSessionIdMembersAccountIdRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PatchGameSessionsSessionIdMembersAccountIdRequestBody > getpatchGameSessionsSessionIdMembersAccountIdRequestBody() const;
  void setpatchGameSessionsSessionIdMembersAccountIdRequestBody(Common::IntrusivePtr< PatchGameSessionsSessionIdMembersAccountIdRequestBody > patchGameSessionsSessionIdMembersAccountIdRequestBody);

  struct ParameterImplToSetGameSessionMemberSystemProperties;

 private:
  struct ParameterImplToSetGameSessionMemberSystemProperties *m_pimpl;

  ParameterToSetGameSessionMemberSystemProperties(ParameterToSetGameSessionMemberSystemProperties &param);
  ParameterToSetGameSessionMemberSystemProperties(const ParameterToSetGameSessionMemberSystemProperties &param);
  ParameterToSetGameSessionMemberSystemProperties& operator=(ParameterToSetGameSessionMemberSystemProperties &param);
  ParameterToSetGameSessionMemberSystemProperties& operator=(const ParameterToSetGameSessionMemberSystemProperties &param);
 };

 static int32_t setGameSessionMemberSystemProperties(
  int32_t npwebapiUserCtxId,
  const ParameterToSetGameSessionMemberSystemProperties &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToSetGameSessionProperties : public Common::ParameterBase {
 public:
  ParameterToSetGameSessionProperties();
  ~ParameterToSetGameSessionProperties();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PatchGameSessionsSessionIdRequestBody > patchGameSessionsSessionIdRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PatchGameSessionsSessionIdRequestBody > getpatchGameSessionsSessionIdRequestBody() const;
  void setpatchGameSessionsSessionIdRequestBody(Common::IntrusivePtr< PatchGameSessionsSessionIdRequestBody > patchGameSessionsSessionIdRequestBody);

  struct ParameterImplToSetGameSessionProperties;

 private:
  struct ParameterImplToSetGameSessionProperties *m_pimpl;

  ParameterToSetGameSessionProperties(ParameterToSetGameSessionProperties &param);
  ParameterToSetGameSessionProperties(const ParameterToSetGameSessionProperties &param);
  ParameterToSetGameSessionProperties& operator=(ParameterToSetGameSessionProperties &param);
  ParameterToSetGameSessionProperties& operator=(const ParameterToSetGameSessionProperties &param);
 };

 static int32_t setGameSessionProperties(
  int32_t npwebapiUserCtxId,
  const ParameterToSetGameSessionProperties &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

private:
 GameSessionsApi();
 ~GameSessionsApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/session_manager.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetFriendsPlayerSessionsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetFriendsPlayerSessionsResponseBody.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/Friend.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/Friend.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/FriendJoinedPlayerSession.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/FriendJoinedPlayerSession.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SpectatorJoinableStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/SpectatorJoinableStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class SpectatorJoinableStatus {
  _NOT_SET = 0,
  kJoinable,
  kNotJoinable,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/FriendJoinedPlayerSession.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerJoinableStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerJoinableStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class PlayerJoinableStatus {
  _NOT_SET = 0,
  kJoinable,
  kNotJoinable,
 };


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/FriendJoinedPlayerSession.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class FriendJoinedPlayerSession : public Common::RefObject
{
public:

 bool sessionIdIsSet() const;
 void unsetSessionId();
 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 bool sessionNameIsSet() const;
 void unsetSessionName();
 const Common::String & getSessionName() const;
 int32_t setSessionName(const char* sessionName) __attribute__((warn_unused_result));


 bool playerJoinableStatusIsSet() const;
 void unsetPlayerJoinableStatus();
 PlayerJoinableStatus getPlayerJoinableStatus() const;
 void setPlayerJoinableStatus(const PlayerJoinableStatus &playerJoinableStatus);


 bool spectatorJoinableStatusIsSet() const;
 void unsetSpectatorJoinableStatus();
 SpectatorJoinableStatus getSpectatorJoinableStatus() const;
 void setSpectatorJoinableStatus(const SpectatorJoinableStatus &spectatorJoinableStatus);


 bool platformIsSet() const;
 void unsetPlatform();
 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FriendJoinedPlayerSession(Common::LibContext * context);
 friend class FriendJoinedPlayerSessionFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::FriendJoinedPlayerSession>;

 ~FriendJoinedPlayerSession();

private:
 Common::LibContext * m_context;

 Common::String m_sessionId;
 bool m_sessionIdIsSet;

 Common::String m_sessionName;
 bool m_sessionNameIsSet;

 PlayerJoinableStatus m_playerJoinableStatus;
 bool m_playerJoinableStatusIsSet;

 SpectatorJoinableStatus m_spectatorJoinableStatus;
 bool m_spectatorJoinableStatusIsSet;

 Common::String m_platform;
 bool m_platformIsSet;


    FriendJoinedPlayerSession();
};

class FriendJoinedPlayerSessionFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<FriendJoinedPlayerSession> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FriendJoinedPlayerSession> *instancePtr);


 static void destroy(FriendJoinedPlayerSession *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/Friend.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class Friend : public Common::RefObject
{
public:

 bool accountIdIsSet() const;
 void unsetAccountId();
 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool onlineIdIsSet() const;
 void unsetOnlineId();
 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 bool playerSessionsIsSet() const;
 void unsetPlayerSessions();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<FriendJoinedPlayerSession>>> getPlayerSessions();
 int32_t setPlayerSessions(const Common::Vector<Common::IntrusivePtr<FriendJoinedPlayerSession>> &playerSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Friend(Common::LibContext * context);
 friend class FriendFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::Friend>;

 ~Friend();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;
 bool m_accountIdIsSet;

 SceNpOnlineId m_onlineId;
 bool m_onlineIdIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<FriendJoinedPlayerSession>>> m_playerSessions;
 bool m_playerSessionsIsSet;


    Friend();
};

class FriendFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Friend> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Friend> *instancePtr);


 static void destroy(Friend *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetFriendsPlayerSessionsResponseBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GetFriendsPlayerSessionsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Friend>>> getFriends();
 int32_t setFriends(const Common::Vector<Common::IntrusivePtr<Friend>> &friends) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetFriendsPlayerSessionsResponseBody(Common::LibContext * context);
 friend class GetFriendsPlayerSessionsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GetFriendsPlayerSessionsResponseBody>;

 ~GetFriendsPlayerSessionsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Friend>>> m_friends;


    GetFriendsPlayerSessionsResponseBody();
};

class GetFriendsPlayerSessionsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Friend>>>::value_type &friends,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetFriendsPlayerSessionsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetFriendsPlayerSessionsResponseBody> *instancePtr);


 static void destroy(GetFriendsPlayerSessionsResponseBody *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetPlayerSessionsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetPlayerSessionsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/LocalizedString.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/LocalizedString.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class LocalizedString : public Common::RefObject
{
public:

 const Common::String & getDefaultLanguage() const;
 int32_t setDefaultLanguage(const char* defaultLanguage) __attribute__((warn_unused_result));


 sce::Json::Object getLocalizedText();
 void setLocalizedText(const sce::Json::Object &localizedText);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 LocalizedString(Common::LibContext * context);
 friend class LocalizedStringFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::LocalizedString>;

 ~LocalizedString();

private:
 Common::LibContext * m_context;

 Common::String m_defaultLanguage;

 sce::Json::Object m_localizedText;


    LocalizedString();
};

class LocalizedStringFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* defaultLanguage,
  sce::Json::Object localizedText,
  sce::Np::CppWebApi::Common::IntrusivePtr<LocalizedString> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<LocalizedString> *instancePtr);


 static void destroy(LocalizedString *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/CustomInvitableUserType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/CustomInvitableUserType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class CustomInvitableUserType {
  _NOT_SET = 0,
  kNoOne,
  kLeader,
  kMember,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionMemberForRead.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionMemberForRead.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionPlayer.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PlayerSessionPlayer : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 const Common::String & getJoinTimestamp() const;
 int32_t setJoinTimestamp(const char* joinTimestamp) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerSessionPlayer(Common::LibContext * context);
 friend class PlayerSessionPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSessionPlayer>;

 ~PlayerSessionPlayer();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 SceNpOnlineId m_onlineId;

 Common::String m_platform;

 Common::String m_joinTimestamp;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    PlayerSessionPlayer();
};

class PlayerSessionPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const SceNpOnlineId &onlineId,
  const char* platform,
  const char* joinTimestamp,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionPlayer> *instancePtr);


 static void destroy(PlayerSessionPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionMemberForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionSpectator.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionSpectator.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PlayerSessionSpectator : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 const Common::String & getJoinTimestamp() const;
 int32_t setJoinTimestamp(const char* joinTimestamp) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerSessionSpectator(Common::LibContext * context);
 friend class PlayerSessionSpectatorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSessionSpectator>;

 ~PlayerSessionSpectator();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 SceNpOnlineId m_onlineId;

 Common::String m_platform;

 Common::String m_joinTimestamp;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    PlayerSessionSpectator();
};

class PlayerSessionSpectatorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const SceNpOnlineId &onlineId,
  const char* platform,
  const char* joinTimestamp,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionSpectator> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionSpectator> *instancePtr);


 static void destroy(PlayerSessionSpectator *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionMemberForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionNonPsnPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionNonPsnPlayer.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PlayerSessionNonPsnPlayer : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 const Common::String & getPlayerName() const;
 int32_t setPlayerName(const char* playerName) __attribute__((warn_unused_result));


 const Common::String & getJoinTimestamp() const;
 int32_t setJoinTimestamp(const char* joinTimestamp) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerSessionNonPsnPlayer(Common::LibContext * context);
 friend class PlayerSessionNonPsnPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSessionNonPsnPlayer>;

 ~PlayerSessionNonPsnPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 Common::String m_playerName;

 Common::String m_joinTimestamp;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    PlayerSessionNonPsnPlayer();
};

class PlayerSessionNonPsnPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  const char* playerName,
  const char* joinTimestamp,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionNonPsnPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionNonPsnPlayer> *instancePtr);


 static void destroy(PlayerSessionNonPsnPlayer *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionMemberForRead.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PlayerSessionMemberForRead : public Common::RefObject
{
public:

 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<PlayerSessionPlayer>> &players) __attribute__((warn_unused_result));


 bool spectatorsIsSet() const;
 void unsetSpectators();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionSpectator>>> getSpectators();
 int32_t setSpectators(const Common::Vector<Common::IntrusivePtr<PlayerSessionSpectator>> &spectators) __attribute__((warn_unused_result));


 bool nonPsnPlayersIsSet() const;
 void unsetNonPsnPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionNonPsnPlayer>>> getNonPsnPlayers();
 int32_t setNonPsnPlayers(const Common::Vector<Common::IntrusivePtr<PlayerSessionNonPsnPlayer>> &nonPsnPlayers) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerSessionMemberForRead(Common::LibContext * context);
 friend class PlayerSessionMemberForReadFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSessionMemberForRead>;

 ~PlayerSessionMemberForRead();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPlayer>>> m_players;
 bool m_playersIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionSpectator>>> m_spectators;
 bool m_spectatorsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionNonPsnPlayer>>> m_nonPsnPlayers;
 bool m_nonPsnPlayersIsSet;


    PlayerSessionMemberForRead();
};

class PlayerSessionMemberForReadFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionMemberForRead> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionMemberForRead> *instancePtr);


 static void destroy(PlayerSessionMemberForRead *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/CustomJoinableUserType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/CustomJoinableUserType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class CustomJoinableUserType {
  _NOT_SET = 0,
  kNoOne,
  kFriends,
  kFriendsOfFriends,
  kAnyone,
  kSpecifiedUsers,
 };


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinableUser.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinableUser.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class JoinableUser : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 JoinableUser(Common::LibContext * context);
 friend class JoinableUserFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::JoinableUser>;

 ~JoinableUser();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;


    JoinableUser();
};

class JoinableUserFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  sce::Np::CppWebApi::Common::IntrusivePtr<JoinableUser> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<JoinableUser> *instancePtr);


 static void destroy(JoinableUser *instance);
};


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/NonPsnLeader.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/NonPsnLeader.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class NonPsnLeader : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 const Common::String & getPlayerName() const;
 int32_t setPlayerName(const char* playerName) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 NonPsnLeader(Common::LibContext * context);
 friend class NonPsnLeaderFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::NonPsnLeader>;

 ~NonPsnLeader();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 Common::String m_playerName;


    NonPsnLeader();
};

class NonPsnLeaderFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  const char* playerName,
  sce::Np::CppWebApi::Common::IntrusivePtr<NonPsnLeader> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<NonPsnLeader> *instancePtr);


 static void destroy(NonPsnLeader *instance);
};


}
}
}
}
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/LeaderWithOnlineId.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/LeaderWithOnlineId.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class LeaderWithOnlineId : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 LeaderWithOnlineId(Common::LibContext * context);
 friend class LeaderWithOnlineIdFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::LeaderWithOnlineId>;

 ~LeaderWithOnlineId();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 SceNpOnlineId m_onlineId;

 Common::String m_platform;


    LeaderWithOnlineId();
};

class LeaderWithOnlineIdFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const SceNpOnlineId &onlineId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<LeaderWithOnlineId> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<LeaderWithOnlineId> *instancePtr);


 static void destroy(LeaderWithOnlineId *instance);
};


}
}
}
}
}
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionForRead.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PlayerSessionForRead : public Common::RefObject
{
public:

 bool sessionIdIsSet() const;
 void unsetSessionId();
 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 bool createdTimestampIsSet() const;
 void unsetCreatedTimestamp();
 const Common::String & getCreatedTimestamp() const;
 int32_t setCreatedTimestamp(const char* createdTimestamp) __attribute__((warn_unused_result));


 bool maxPlayersIsSet() const;
 void unsetMaxPlayers();
 int32_t getMaxPlayers() const;
 void setMaxPlayers(const int32_t &maxPlayers);


 bool maxSpectatorsIsSet() const;
 void unsetMaxSpectators();
 int32_t getMaxSpectators() const;
 void setMaxSpectators(const int32_t &maxSpectators);


 bool memberIsSet() const;
 void unsetMember();
 Common::IntrusivePtr<PlayerSessionMemberForRead> getMember() const;
 int32_t setMember(const Common::IntrusivePtr<PlayerSessionMemberForRead> &member) __attribute__((warn_unused_result));


 bool joinDisabledIsSet() const;
 void unsetJoinDisabled();
 bool getJoinDisabled() const;
 void setJoinDisabled(const bool &joinDisabled);


 bool supportedPlatformsIsSet() const;
 void unsetSupportedPlatforms();
 Common::IntrusivePtr<Common::Vector<Common::String>> getSupportedPlatforms();
 int32_t setSupportedPlatforms(const Common::Vector<Common::String> &supportedPlatforms) __attribute__((warn_unused_result));


 bool sessionNameIsSet() const;
 void unsetSessionName();
 const Common::String & getSessionName() const;
 int32_t setSessionName(const char* sessionName) __attribute__((warn_unused_result));


 bool localizedSessionNameIsSet() const;
 void unsetLocalizedSessionName();
 Common::IntrusivePtr<LocalizedString> getLocalizedSessionName() const;
 int32_t setLocalizedSessionName(const Common::IntrusivePtr<LocalizedString> &localizedSessionName) __attribute__((warn_unused_result));


 bool leaderIsSet() const;
 void unsetLeader();
 Common::IntrusivePtr<LeaderWithOnlineId> getLeader() const;
 int32_t setLeader(const Common::IntrusivePtr<LeaderWithOnlineId> &leader) __attribute__((warn_unused_result));


 bool nonPsnLeaderIsSet() const;
 void unsetNonPsnLeader();
 Common::IntrusivePtr<NonPsnLeader> getNonPsnLeader() const;
 int32_t setNonPsnLeader(const Common::IntrusivePtr<NonPsnLeader> &nonPsnLeader) __attribute__((warn_unused_result));


 bool joinableUserTypeIsSet() const;
 void unsetJoinableUserType();
 CustomJoinableUserType getJoinableUserType() const;
 void setJoinableUserType(const CustomJoinableUserType &joinableUserType);


 bool joinableSpecifiedUsersIsSet() const;
 void unsetJoinableSpecifiedUsers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinableUser>>> getJoinableSpecifiedUsers();
 int32_t setJoinableSpecifiedUsers(const Common::Vector<Common::IntrusivePtr<JoinableUser>> &joinableSpecifiedUsers) __attribute__((warn_unused_result));


 bool invitableUserTypeIsSet() const;
 void unsetInvitableUserType();
 CustomInvitableUserType getInvitableUserType() const;
 void setInvitableUserType(const CustomInvitableUserType &invitableUserType);


 bool leaderPrivilegesIsSet() const;
 void unsetLeaderPrivileges();
 Common::IntrusivePtr<Common::Vector<Common::String>> getLeaderPrivileges();
 int32_t setLeaderPrivileges(const Common::Vector<Common::String> &leaderPrivileges) __attribute__((warn_unused_result));


 bool exclusiveLeaderPrivilegesIsSet() const;
 void unsetExclusiveLeaderPrivileges();
 Common::IntrusivePtr<Common::Vector<Common::String>> getExclusiveLeaderPrivileges();
 int32_t setExclusiveLeaderPrivileges(const Common::Vector<Common::String> &exclusiveLeaderPrivileges) __attribute__((warn_unused_result));


 bool disableSystemUiMenuIsSet() const;
 void unsetDisableSystemUiMenu();
 Common::IntrusivePtr<Common::Vector<Common::String>> getDisableSystemUiMenu();
 int32_t setDisableSystemUiMenu(const Common::Vector<Common::String> &disableSystemUiMenu) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool customData2IsSet() const;
 void unsetCustomData2();
 const Common::IntrusivePtr<Common::Binary> & getCustomData2() const;
 int32_t setCustomData2(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool swapSupportedIsSet() const;
 void unsetSwapSupported();
 bool getSwapSupported() const;
 void setSwapSupported(const bool &swapSupported);


 bool nonPsnSupportedIsSet() const;
 void unsetNonPsnSupported();
 bool getNonPsnSupported() const;
 void setNonPsnSupported(const bool &nonPsnSupported);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerSessionForRead(Common::LibContext * context);
 friend class PlayerSessionForReadFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSessionForRead>;

 ~PlayerSessionForRead();

private:
 Common::LibContext * m_context;

 Common::String m_sessionId;
 bool m_sessionIdIsSet;

 Common::String m_createdTimestamp;
 bool m_createdTimestampIsSet;

 int32_t m_maxPlayers;
 bool m_maxPlayersIsSet;

 int32_t m_maxSpectators;
 bool m_maxSpectatorsIsSet;

 Common::IntrusivePtr<PlayerSessionMemberForRead> m_member;
 bool m_memberIsSet;

 bool m_joinDisabled;
 bool m_joinDisabledIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_supportedPlatforms;
 bool m_supportedPlatformsIsSet;

 Common::String m_sessionName;
 bool m_sessionNameIsSet;

 Common::IntrusivePtr<LocalizedString> m_localizedSessionName;
 bool m_localizedSessionNameIsSet;

 Common::IntrusivePtr<LeaderWithOnlineId> m_leader;
 bool m_leaderIsSet;

 Common::IntrusivePtr<NonPsnLeader> m_nonPsnLeader;
 bool m_nonPsnLeaderIsSet;

 CustomJoinableUserType m_joinableUserType;
 bool m_joinableUserTypeIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinableUser>>> m_joinableSpecifiedUsers;
 bool m_joinableSpecifiedUsersIsSet;

 CustomInvitableUserType m_invitableUserType;
 bool m_invitableUserTypeIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_leaderPrivileges;
 bool m_leaderPrivilegesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_exclusiveLeaderPrivileges;
 bool m_exclusiveLeaderPrivilegesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_disableSystemUiMenu;
 bool m_disableSystemUiMenuIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;

 Common::IntrusivePtr<Common::Binary> m_customData2;
 bool m_customData2IsSet;

 bool m_swapSupported;
 bool m_swapSupportedIsSet;

 bool m_nonPsnSupported;
 bool m_nonPsnSupportedIsSet;


    PlayerSessionForRead();
};

class PlayerSessionForReadFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionForRead> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionForRead> *instancePtr);


 static void destroy(PlayerSessionForRead *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetPlayerSessionsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GetPlayerSessionsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionForRead>>> getPlayerSessions();
 int32_t setPlayerSessions(const Common::Vector<Common::IntrusivePtr<PlayerSessionForRead>> &playerSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetPlayerSessionsResponseBody(Common::LibContext * context);
 friend class GetPlayerSessionsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GetPlayerSessionsResponseBody>;

 ~GetPlayerSessionsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionForRead>>> m_playerSessions;


    GetPlayerSessionsResponseBody();
};

class GetPlayerSessionsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionForRead>>>::value_type &playerSessions,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetPlayerSessionsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetPlayerSessionsResponseBody> *instancePtr);


 static void destroy(GetPlayerSessionsResponseBody *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdPlayerSessionsInvitationsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdPlayerSessionsInvitationsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/UsersPlayerSessionsInvitationForRead.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/UsersPlayerSessionsInvitationForRead.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/FromMember.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/FromMember.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class FromMember : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FromMember(Common::LibContext * context);
 friend class FromMemberFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::FromMember>;

 ~FromMember();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 SceNpOnlineId m_onlineId;

 Common::String m_platform;


    FromMember();
};

class FromMemberFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const SceNpOnlineId &onlineId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<FromMember> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FromMember> *instancePtr);


 static void destroy(FromMember *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/UsersPlayerSessionsInvitationForRead.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/FromNonPsnMember.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/FromNonPsnMember.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class FromNonPsnMember : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 const Common::String & getPlayerName() const;
 int32_t setPlayerName(const char* playerName) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 FromNonPsnMember(Common::LibContext * context);
 friend class FromNonPsnMemberFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::FromNonPsnMember>;

 ~FromNonPsnMember();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 Common::String m_playerName;


    FromNonPsnMember();
};

class FromNonPsnMemberFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  const char* playerName,
  sce::Np::CppWebApi::Common::IntrusivePtr<FromNonPsnMember> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<FromNonPsnMember> *instancePtr);


 static void destroy(FromNonPsnMember *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/UsersPlayerSessionsInvitationForRead.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class UsersPlayerSessionsInvitationForRead : public Common::RefObject
{
public:

 bool invitationIdIsSet() const;
 void unsetInvitationId();
 const Common::String & getInvitationId() const;
 int32_t setInvitationId(const char* invitationId) __attribute__((warn_unused_result));


 bool fromIsSet() const;
 void unsetFrom();
 Common::IntrusivePtr<FromMember> getFrom() const;
 int32_t setFrom(const Common::IntrusivePtr<FromMember> &from) __attribute__((warn_unused_result));


 bool fromNonPsnPlayerIsSet() const;
 void unsetFromNonPsnPlayer();
 Common::IntrusivePtr<FromNonPsnMember> getFromNonPsnPlayer() const;
 int32_t setFromNonPsnPlayer(const Common::IntrusivePtr<FromNonPsnMember> &fromNonPsnPlayer) __attribute__((warn_unused_result));


 bool sessionIdIsSet() const;
 void unsetSessionId();
 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 bool supportedPlatformsIsSet() const;
 void unsetSupportedPlatforms();
 Common::IntrusivePtr<Common::Vector<Common::String>> getSupportedPlatforms();
 int32_t setSupportedPlatforms(const Common::Vector<Common::String> &supportedPlatforms) __attribute__((warn_unused_result));


 bool receivedTimestampIsSet() const;
 void unsetReceivedTimestamp();
 const Common::String & getReceivedTimestamp() const;
 int32_t setReceivedTimestamp(const char* receivedTimestamp) __attribute__((warn_unused_result));


 bool invitationInvalidIsSet() const;
 void unsetInvitationInvalid();
 bool getInvitationInvalid() const;
 void setInvitationInvalid(const bool &invitationInvalid);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 UsersPlayerSessionsInvitationForRead(Common::LibContext * context);
 friend class UsersPlayerSessionsInvitationForReadFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::UsersPlayerSessionsInvitationForRead>;

 ~UsersPlayerSessionsInvitationForRead();

private:
 Common::LibContext * m_context;

 Common::String m_invitationId;
 bool m_invitationIdIsSet;

 Common::IntrusivePtr<FromMember> m_from;
 bool m_fromIsSet;

 Common::IntrusivePtr<FromNonPsnMember> m_fromNonPsnPlayer;
 bool m_fromNonPsnPlayerIsSet;

 Common::String m_sessionId;
 bool m_sessionIdIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_supportedPlatforms;
 bool m_supportedPlatformsIsSet;

 Common::String m_receivedTimestamp;
 bool m_receivedTimestampIsSet;

 bool m_invitationInvalid;
 bool m_invitationInvalidIsSet;


    UsersPlayerSessionsInvitationForRead();
};

class UsersPlayerSessionsInvitationForReadFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<UsersPlayerSessionsInvitationForRead> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<UsersPlayerSessionsInvitationForRead> *instancePtr);


 static void destroy(UsersPlayerSessionsInvitationForRead *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdPlayerSessionsInvitationsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GetUsersAccountIdPlayerSessionsInvitationsResponseBody : public PsnErrorObject
{
public:

 bool invitationsIsSet() const;
 void unsetInvitations();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<UsersPlayerSessionsInvitationForRead>>> getInvitations();
 int32_t setInvitations(const Common::Vector<Common::IntrusivePtr<UsersPlayerSessionsInvitationForRead>> &invitations) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetUsersAccountIdPlayerSessionsInvitationsResponseBody(Common::LibContext * context);
 friend class GetUsersAccountIdPlayerSessionsInvitationsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GetUsersAccountIdPlayerSessionsInvitationsResponseBody>;

 ~GetUsersAccountIdPlayerSessionsInvitationsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<UsersPlayerSessionsInvitationForRead>>> m_invitations;
 bool m_invitationsIsSet;


    GetUsersAccountIdPlayerSessionsInvitationsResponseBody();
};

class GetUsersAccountIdPlayerSessionsInvitationsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetUsersAccountIdPlayerSessionsInvitationsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetUsersAccountIdPlayerSessionsInvitationsResponseBody> *instancePtr);


 static void destroy(GetUsersAccountIdPlayerSessionsInvitationsResponseBody *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdPlayerSessionsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdPlayerSessionsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinedPlayerSessionWithPlatform.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinedPlayerSessionWithPlatform.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class JoinedPlayerSessionWithPlatform : public Common::RefObject
{
public:

 bool sessionIdIsSet() const;
 void unsetSessionId();
 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 bool platformIsSet() const;
 void unsetPlatform();
 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 JoinedPlayerSessionWithPlatform(Common::LibContext * context);
 friend class JoinedPlayerSessionWithPlatformFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::JoinedPlayerSessionWithPlatform>;

 ~JoinedPlayerSessionWithPlatform();

private:
 Common::LibContext * m_context;

 Common::String m_sessionId;
 bool m_sessionIdIsSet;

 Common::String m_platform;
 bool m_platformIsSet;


    JoinedPlayerSessionWithPlatform();
};

class JoinedPlayerSessionWithPlatformFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<JoinedPlayerSessionWithPlatform> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<JoinedPlayerSessionWithPlatform> *instancePtr);


 static void destroy(JoinedPlayerSessionWithPlatform *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/GetUsersAccountIdPlayerSessionsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class GetUsersAccountIdPlayerSessionsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinedPlayerSessionWithPlatform>>> getPlayerSessions();
 int32_t setPlayerSessions(const Common::Vector<Common::IntrusivePtr<JoinedPlayerSessionWithPlatform>> &playerSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetUsersAccountIdPlayerSessionsResponseBody(Common::LibContext * context);
 friend class GetUsersAccountIdPlayerSessionsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::GetUsersAccountIdPlayerSessionsResponseBody>;

 ~GetUsersAccountIdPlayerSessionsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinedPlayerSessionWithPlatform>>> m_playerSessions;


    GetUsersAccountIdPlayerSessionsResponseBody();
};

class GetUsersAccountIdPlayerSessionsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinedPlayerSessionWithPlatform>>>::value_type &playerSessions,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetUsersAccountIdPlayerSessionsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetUsersAccountIdPlayerSessionsResponseBody> *instancePtr);


 static void destroy(GetUsersAccountIdPlayerSessionsResponseBody *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchPlayerSessionsSessionIdMembersAccountIdRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchPlayerSessionsSessionIdMembersAccountIdRequestBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PatchPlayerSessionsSessionIdMembersAccountIdRequestBody : public Common::RefObject
{
public:

 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PatchPlayerSessionsSessionIdMembersAccountIdRequestBody(Common::LibContext * context);
 friend class PatchPlayerSessionsSessionIdMembersAccountIdRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PatchPlayerSessionsSessionIdMembersAccountIdRequestBody>;

 ~PatchPlayerSessionsSessionIdMembersAccountIdRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    PatchPlayerSessionsSessionIdMembersAccountIdRequestBody();
};

class PatchPlayerSessionsSessionIdMembersAccountIdRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchPlayerSessionsSessionIdMembersAccountIdRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchPlayerSessionsSessionIdMembersAccountIdRequestBody> *instancePtr);


 static void destroy(PatchPlayerSessionsSessionIdMembersAccountIdRequestBody *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchPlayerSessionsSessionIdRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchPlayerSessionsSessionIdRequestBody.h" 2 3
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PatchPlayerSessionsSessionIdRequestBody.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PatchPlayerSessionsSessionIdRequestBody : public Common::RefObject
{
public:

 bool maxPlayersIsSet() const;
 void unsetMaxPlayers();
 int32_t getMaxPlayers() const;
 void setMaxPlayers(const int32_t &maxPlayers);


 bool maxSpectatorsIsSet() const;
 void unsetMaxSpectators();
 int32_t getMaxSpectators() const;
 void setMaxSpectators(const int32_t &maxSpectators);


 bool joinDisabledIsSet() const;
 void unsetJoinDisabled();
 bool getJoinDisabled() const;
 void setJoinDisabled(const bool &joinDisabled);


 bool localizedSessionNameIsSet() const;
 void unsetLocalizedSessionName();
 Common::IntrusivePtr<LocalizedString> getLocalizedSessionName() const;
 int32_t setLocalizedSessionName(const Common::IntrusivePtr<LocalizedString> &localizedSessionName) __attribute__((warn_unused_result));


 bool joinableUserTypeIsSet() const;
 void unsetJoinableUserType();
 CustomJoinableUserType getJoinableUserType() const;
 void setJoinableUserType(const CustomJoinableUserType &joinableUserType);


 bool invitableUserTypeIsSet() const;
 void unsetInvitableUserType();
 CustomInvitableUserType getInvitableUserType() const;
 void setInvitableUserType(const CustomInvitableUserType &invitableUserType);


 bool leaderPrivilegesIsSet() const;
 void unsetLeaderPrivileges();
 Common::IntrusivePtr<Common::Vector<Common::String>> getLeaderPrivileges();
 int32_t setLeaderPrivileges(const Common::Vector<Common::String> &leaderPrivileges) __attribute__((warn_unused_result));


 bool exclusiveLeaderPrivilegesIsSet() const;
 void unsetExclusiveLeaderPrivileges();
 Common::IntrusivePtr<Common::Vector<Common::String>> getExclusiveLeaderPrivileges();
 int32_t setExclusiveLeaderPrivileges(const Common::Vector<Common::String> &exclusiveLeaderPrivileges) __attribute__((warn_unused_result));


 bool disableSystemUiMenuIsSet() const;
 void unsetDisableSystemUiMenu();
 Common::IntrusivePtr<Common::Vector<Common::String>> getDisableSystemUiMenu();
 int32_t setDisableSystemUiMenu(const Common::Vector<Common::String> &disableSystemUiMenu) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool customData2IsSet() const;
 void unsetCustomData2();
 const Common::IntrusivePtr<Common::Binary> & getCustomData2() const;
 int32_t setCustomData2(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool swapSupportedIsSet() const;
 void unsetSwapSupported();
 bool getSwapSupported() const;
 void setSwapSupported(const bool &swapSupported);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PatchPlayerSessionsSessionIdRequestBody(Common::LibContext * context);
 friend class PatchPlayerSessionsSessionIdRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PatchPlayerSessionsSessionIdRequestBody>;

 ~PatchPlayerSessionsSessionIdRequestBody();

private:
 Common::LibContext * m_context;

 int32_t m_maxPlayers;
 bool m_maxPlayersIsSet;

 int32_t m_maxSpectators;
 bool m_maxSpectatorsIsSet;

 bool m_joinDisabled;
 bool m_joinDisabledIsSet;

 Common::IntrusivePtr<LocalizedString> m_localizedSessionName;
 bool m_localizedSessionNameIsSet;

 CustomJoinableUserType m_joinableUserType;
 bool m_joinableUserTypeIsSet;

 CustomInvitableUserType m_invitableUserType;
 bool m_invitableUserTypeIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_leaderPrivileges;
 bool m_leaderPrivilegesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_exclusiveLeaderPrivileges;
 bool m_exclusiveLeaderPrivilegesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_disableSystemUiMenu;
 bool m_disableSystemUiMenuIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;

 Common::IntrusivePtr<Common::Binary> m_customData2;
 bool m_customData2IsSet;

 bool m_swapSupported;
 bool m_swapSupportedIsSet;


    PatchPlayerSessionsSessionIdRequestBody();
};

class PatchPlayerSessionsSessionIdRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchPlayerSessionsSessionIdRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PatchPlayerSessionsSessionIdRequestBody> *instancePtr);


 static void destroy(PatchPlayerSessionsSessionIdRequestBody *instance);
};


}
}
}
}
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsRequestBody.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSession.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSession.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/InvitableUserType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/InvitableUserType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class InvitableUserType {
  _NOT_SET = 0,
  kNoOne,
  kLeader,
  kMember,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSession.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionMemberPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionMemberPlayer.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestCreatePlayerSessionNonPsnPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestCreatePlayerSessionNonPsnPlayer.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestCreatePlayerSessionNonPsnPlayer : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 const Common::String & getPlayerName() const;
 int32_t setPlayerName(const char* playerName) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestCreatePlayerSessionNonPsnPlayer(Common::LibContext * context);
 friend class RequestCreatePlayerSessionNonPsnPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestCreatePlayerSessionNonPsnPlayer>;

 ~RequestCreatePlayerSessionNonPsnPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;

 Common::String m_playerName;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    RequestCreatePlayerSessionNonPsnPlayer();
};

class RequestCreatePlayerSessionNonPsnPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  const char* playerName,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestCreatePlayerSessionNonPsnPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestCreatePlayerSessionNonPsnPlayer> *instancePtr);


 static void destroy(RequestCreatePlayerSessionNonPsnPlayer *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionMemberPlayer.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestCreatePlayerSessionPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestCreatePlayerSessionPlayer.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionPushContext.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSessionPushContext.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PlayerSessionPushContext : public Common::RefObject
{
public:

 const Common::String & getPushContextId() const;
 int32_t setPushContextId(const char* pushContextId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerSessionPushContext(Common::LibContext * context);
 friend class PlayerSessionPushContextFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSessionPushContext>;

 ~PlayerSessionPushContext();

private:
 Common::LibContext * m_context;

 Common::String m_pushContextId;


    PlayerSessionPushContext();
};

class PlayerSessionPushContextFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* pushContextId,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionPushContext> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSessionPushContext> *instancePtr);


 static void destroy(PlayerSessionPushContext *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestCreatePlayerSessionPlayer.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestCreatePlayerSessionPlayer : public Common::RefObject
{
public:

 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>>> getPushContexts();
 int32_t setPushContexts(const Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>> &pushContexts) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestCreatePlayerSessionPlayer(Common::LibContext * context);
 friend class RequestCreatePlayerSessionPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestCreatePlayerSessionPlayer>;

 ~RequestCreatePlayerSessionPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;

 Common::String m_platform;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>>> m_pushContexts;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    RequestCreatePlayerSessionPlayer();
};

class RequestCreatePlayerSessionPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* accountId,
  const char* platform,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>>>::value_type &pushContexts,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestCreatePlayerSessionPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestCreatePlayerSessionPlayer> *instancePtr);


 static void destroy(RequestCreatePlayerSessionPlayer *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionMemberPlayer.h" 2 3



namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestPlayerSessionMemberPlayer : public Common::RefObject
{
public:

 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestCreatePlayerSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<RequestCreatePlayerSessionPlayer>> &players) __attribute__((warn_unused_result));


 bool nonPsnPlayersIsSet() const;
 void unsetNonPsnPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestCreatePlayerSessionNonPsnPlayer>>> getNonPsnPlayers();
 int32_t setNonPsnPlayers(const Common::Vector<Common::IntrusivePtr<RequestCreatePlayerSessionNonPsnPlayer>> &nonPsnPlayers) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestPlayerSessionMemberPlayer(Common::LibContext * context);
 friend class RequestPlayerSessionMemberPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestPlayerSessionMemberPlayer>;

 ~RequestPlayerSessionMemberPlayer();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestCreatePlayerSessionPlayer>>> m_players;
 bool m_playersIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestCreatePlayerSessionNonPsnPlayer>>> m_nonPsnPlayers;
 bool m_nonPsnPlayersIsSet;


 RequestPlayerSessionMemberPlayer();
};

class RequestPlayerSessionMemberPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext* context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestCreatePlayerSessionPlayer>>>::value_type& players,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSessionMemberPlayer>* instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSessionMemberPlayer> *instancePtr);


 static void destroy(RequestPlayerSessionMemberPlayer *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSession.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinableUserType.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/JoinableUserType.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

 enum class JoinableUserType {
  _NOT_SET = 0,
  kNoOne,
  kFriends,
  kFriendsOfFriends,
  kAnyone,
  kSpecifiedUsers,
 };


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSession.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestPlayerSession : public Common::RefObject
{
public:

 int32_t getMaxPlayers() const;
 void setMaxPlayers(const int32_t &maxPlayers);


 bool maxSpectatorsIsSet() const;
 void unsetMaxSpectators();
 int32_t getMaxSpectators() const;
 void setMaxSpectators(const int32_t &maxSpectators);


 Common::IntrusivePtr<RequestPlayerSessionMemberPlayer> getMember() const;
 int32_t setMember(const Common::IntrusivePtr<RequestPlayerSessionMemberPlayer> &member) __attribute__((warn_unused_result));


 bool joinDisabledIsSet() const;
 void unsetJoinDisabled();
 bool getJoinDisabled() const;
 void setJoinDisabled(const bool &joinDisabled);


 Common::IntrusivePtr<Common::Vector<Common::String>> getSupportedPlatforms();
 int32_t setSupportedPlatforms(const Common::Vector<Common::String> &supportedPlatforms) __attribute__((warn_unused_result));


 Common::IntrusivePtr<LocalizedString> getLocalizedSessionName() const;
 int32_t setLocalizedSessionName(const Common::IntrusivePtr<LocalizedString> &localizedSessionName) __attribute__((warn_unused_result));


 bool joinableUserTypeIsSet() const;
 void unsetJoinableUserType();
 JoinableUserType getJoinableUserType() const;
 void setJoinableUserType(const JoinableUserType &joinableUserType);


 bool invitableUserTypeIsSet() const;
 void unsetInvitableUserType();
 InvitableUserType getInvitableUserType() const;
 void setInvitableUserType(const InvitableUserType &invitableUserType);


 bool leaderPrivilegesIsSet() const;
 void unsetLeaderPrivileges();
 Common::IntrusivePtr<Common::Vector<Common::String>> getLeaderPrivileges();
 int32_t setLeaderPrivileges(const Common::Vector<Common::String> &leaderPrivileges) __attribute__((warn_unused_result));


 bool exclusiveLeaderPrivilegesIsSet() const;
 void unsetExclusiveLeaderPrivileges();
 Common::IntrusivePtr<Common::Vector<Common::String>> getExclusiveLeaderPrivileges();
 int32_t setExclusiveLeaderPrivileges(const Common::Vector<Common::String> &exclusiveLeaderPrivileges) __attribute__((warn_unused_result));


 bool disableSystemUiMenuIsSet() const;
 void unsetDisableSystemUiMenu();
 Common::IntrusivePtr<Common::Vector<Common::String>> getDisableSystemUiMenu();
 int32_t setDisableSystemUiMenu(const Common::Vector<Common::String> &disableSystemUiMenu) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool customData2IsSet() const;
 void unsetCustomData2();
 const Common::IntrusivePtr<Common::Binary> & getCustomData2() const;
 int32_t setCustomData2(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool swapSupportedIsSet() const;
 void unsetSwapSupported();
 bool getSwapSupported() const;
 void setSwapSupported(const bool &swapSupported);


 bool nonPsnSupportedIsSet() const;
 void unsetNonPsnSupported();
 bool getNonPsnSupported() const;
 void setNonPsnSupported(const bool &nonPsnSupported);


 bool expirationTimeIsSet() const;
 void unsetExpirationTime();
 int32_t getExpirationTime() const;
 void setExpirationTime(const int32_t &expirationTime);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestPlayerSession(Common::LibContext * context);
 friend class RequestPlayerSessionFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestPlayerSession>;

 ~RequestPlayerSession();

private:
 Common::LibContext * m_context;

 int32_t m_maxPlayers;

 int32_t m_maxSpectators;
 bool m_maxSpectatorsIsSet;

 Common::IntrusivePtr<RequestPlayerSessionMemberPlayer> m_member;

 bool m_joinDisabled;
 bool m_joinDisabledIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_supportedPlatforms;

 Common::IntrusivePtr<LocalizedString> m_localizedSessionName;

 JoinableUserType m_joinableUserType;
 bool m_joinableUserTypeIsSet;

 InvitableUserType m_invitableUserType;
 bool m_invitableUserTypeIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_leaderPrivileges;
 bool m_leaderPrivilegesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_exclusiveLeaderPrivileges;
 bool m_exclusiveLeaderPrivilegesIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_disableSystemUiMenu;
 bool m_disableSystemUiMenuIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;

 Common::IntrusivePtr<Common::Binary> m_customData2;
 bool m_customData2IsSet;

 bool m_swapSupported;
 bool m_swapSupportedIsSet;

 bool m_nonPsnSupported;
 bool m_nonPsnSupportedIsSet;

 int32_t m_expirationTime;
 bool m_expirationTimeIsSet;


    RequestPlayerSession();
};

class RequestPlayerSessionFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t maxPlayers,
  Common::IntrusivePtr<RequestPlayerSessionMemberPlayer> member,
  const Common::IntrusivePtr<Common::Vector<Common::String>>::value_type &supportedPlatforms,
  Common::IntrusivePtr<LocalizedString> localizedSessionName,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSession> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSession> *instancePtr);


 static void destroy(RequestPlayerSession *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsRequestBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSession>>> getPlayerSessions();
 int32_t setPlayerSessions(const Common::Vector<Common::IntrusivePtr<RequestPlayerSession>> &playerSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsRequestBody(Common::LibContext * context);
 friend class PostPlayerSessionsRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsRequestBody>;

 ~PostPlayerSessionsRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSession>>> m_playerSessions;


    PostPlayerSessionsRequestBody();
};

class PostPlayerSessionsRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSession>>>::value_type &playerSessions,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsRequestBody> *instancePtr);


 static void destroy(PostPlayerSessionsRequestBody *instance);
};


}
}
}
}
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSession.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSession.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionMemberPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionMemberPlayer.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionNonPsnPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionNonPsnPlayer.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ResponsePlayerSessionNonPsnPlayer : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponsePlayerSessionNonPsnPlayer(Common::LibContext * context);
 friend class ResponsePlayerSessionNonPsnPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ResponsePlayerSessionNonPsnPlayer>;

 ~ResponsePlayerSessionNonPsnPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;


    ResponsePlayerSessionNonPsnPlayer();
};

class ResponsePlayerSessionNonPsnPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionNonPsnPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionNonPsnPlayer> *instancePtr);


 static void destroy(ResponsePlayerSessionNonPsnPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionMemberPlayer.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionPlayer.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ResponsePlayerSessionPlayer : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponsePlayerSessionPlayer(Common::LibContext * context);
 friend class ResponsePlayerSessionPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ResponsePlayerSessionPlayer>;

 ~ResponsePlayerSessionPlayer();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 Common::String m_platform;


    ResponsePlayerSessionPlayer();
};

class ResponsePlayerSessionPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionPlayer> *instancePtr);


 static void destroy(ResponsePlayerSessionPlayer *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionMemberPlayer.h" 2 3



namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ResponsePlayerSessionMemberPlayer : public Common::RefObject
{
public:

 bool playersIsSet() const;
 void unsetPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer>> &players) __attribute__((warn_unused_result));


 bool nonPsnPlayersIsSet() const;
 void unsetNonPsnPlayers();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionNonPsnPlayer>>> getNonPsnPlayers();
 int32_t setNonPsnPlayers(const Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionNonPsnPlayer>> &nonPsnPlayers) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponsePlayerSessionMemberPlayer(Common::LibContext * context);
 friend class ResponsePlayerSessionMemberPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ResponsePlayerSessionMemberPlayer>;

 ~ResponsePlayerSessionMemberPlayer();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer>>> m_players;
 bool m_playersIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionNonPsnPlayer>>> m_nonPsnPlayers;
 bool m_nonPsnPlayersIsSet;


 ResponsePlayerSessionMemberPlayer();
};

class ResponsePlayerSessionMemberPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext* context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer>>>::value_type& players,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionMemberPlayer>* instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionMemberPlayer> *instancePtr);


 static void destroy(ResponsePlayerSessionMemberPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PlayerSession.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PlayerSession : public Common::RefObject
{
public:

 const Common::String & getSessionId() const;
 int32_t setSessionId(const char* sessionId) __attribute__((warn_unused_result));


 Common::IntrusivePtr<ResponsePlayerSessionMemberPlayer> getMember() const;
 int32_t setMember(const Common::IntrusivePtr<ResponsePlayerSessionMemberPlayer> &member) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PlayerSession(Common::LibContext * context);
 friend class PlayerSessionFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSession>;

 ~PlayerSession();

private:
 Common::LibContext * m_context;

 Common::String m_sessionId;

 Common::IntrusivePtr<ResponsePlayerSessionMemberPlayer> m_member;


    PlayerSession();
};

class PlayerSessionFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* sessionId,
  Common::IntrusivePtr<ResponsePlayerSessionMemberPlayer> member,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSession> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PlayerSession> *instancePtr);


 static void destroy(PlayerSession *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSession>>> getPlayerSessions();
 int32_t setPlayerSessions(const Common::Vector<Common::IntrusivePtr<PlayerSession>> &playerSessions) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsResponseBody(Common::LibContext * context);
 friend class PostPlayerSessionsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsResponseBody>;

 ~PostPlayerSessionsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSession>>> m_playerSessions;


    PostPlayerSessionsResponseBody();
};

class PostPlayerSessionsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSession>>>::value_type &playerSessions,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsResponseBody> *instancePtr);


 static void destroy(PostPlayerSessionsResponseBody *instance);
};


}
}
}
}
}
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdInvitationsRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdInvitationsRequestBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionInvitation.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionInvitation.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/To.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/To.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class To : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 To(Common::LibContext * context);
 friend class ToFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::To>;

 ~To();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;


    To();
};

class ToFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  sce::Np::CppWebApi::Common::IntrusivePtr<To> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<To> *instancePtr);


 static void destroy(To *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionInvitation.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestPlayerSessionInvitation : public Common::RefObject
{
public:

 Common::IntrusivePtr<To> getTo() const;
 int32_t setTo(const Common::IntrusivePtr<To> &to) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestPlayerSessionInvitation(Common::LibContext * context);
 friend class RequestPlayerSessionInvitationFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestPlayerSessionInvitation>;

 ~RequestPlayerSessionInvitation();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<To> m_to;


    RequestPlayerSessionInvitation();
};

class RequestPlayerSessionInvitationFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<To> to,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSessionInvitation> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSessionInvitation> *instancePtr);


 static void destroy(RequestPlayerSessionInvitation *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdInvitationsRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdInvitationsRequestBody : public Common::RefObject
{
public:

 bool invitationsIsSet() const;
 void unsetInvitations();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSessionInvitation>>> getInvitations();
 int32_t setInvitations(const Common::Vector<Common::IntrusivePtr<RequestPlayerSessionInvitation>> &invitations) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdInvitationsRequestBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdInvitationsRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdInvitationsRequestBody>;

 ~PostPlayerSessionsSessionIdInvitationsRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSessionInvitation>>> m_invitations;
 bool m_invitationsIsSet;


    PostPlayerSessionsSessionIdInvitationsRequestBody();
};

class PostPlayerSessionsSessionIdInvitationsRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdInvitationsRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdInvitationsRequestBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdInvitationsRequestBody *instance);
};


}
}
}
}
}
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdInvitationsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdInvitationsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionInvitation.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionInvitation.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ResponsePlayerSessionInvitation : public Common::RefObject
{
public:

 const Common::String & getInvitationId() const;
 int32_t setInvitationId(const char* invitationId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponsePlayerSessionInvitation(Common::LibContext * context);
 friend class ResponsePlayerSessionInvitationFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ResponsePlayerSessionInvitation>;

 ~ResponsePlayerSessionInvitation();

private:
 Common::LibContext * m_context;

 Common::String m_invitationId;


    ResponsePlayerSessionInvitation();
};

class ResponsePlayerSessionInvitationFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* invitationId,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionInvitation> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionInvitation> *instancePtr);


 static void destroy(ResponsePlayerSessionInvitation *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdInvitationsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdInvitationsResponseBody : public PsnErrorObject
{
public:

 bool invitationsIsSet() const;
 void unsetInvitations();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionInvitation>>> getInvitations();
 int32_t setInvitations(const Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionInvitation>> &invitations) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdInvitationsResponseBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdInvitationsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdInvitationsResponseBody>;

 ~PostPlayerSessionsSessionIdInvitationsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionInvitation>>> m_invitations;
 bool m_invitationsIsSet;


    PostPlayerSessionsSessionIdInvitationsResponseBody();
};

class PostPlayerSessionsSessionIdInvitationsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdInvitationsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdInvitationsResponseBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdInvitationsResponseBody *instance);
};


}
}
}
}
}
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinableUser>>> getJoinableSpecifiedUsers();
 int32_t setJoinableSpecifiedUsers(const Common::Vector<Common::IntrusivePtr<JoinableUser>> &joinableSpecifiedUsers) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody>;

 ~PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinableUser>>> m_joinableSpecifiedUsers;


    PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody();
};

class PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinableUser>>>::value_type &joinableSpecifiedUsers,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody *instance);
};


}
}
}
}
}
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinableUser>>> getJoinableSpecifiedUsers();
 int32_t setJoinableSpecifiedUsers(const Common::Vector<Common::IntrusivePtr<JoinableUser>> &joinableSpecifiedUsers) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody>;

 ~PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinableUser>>> m_joinableSpecifiedUsers;


    PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody();
};

class PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<JoinableUser>>>::value_type &joinableSpecifiedUsers,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody *instance);
};


}
}
}
}
}
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberPlayersRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberPlayersRequestBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionPlayer.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionPlayer.h" 2 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionPlayer.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestPlayerSessionPlayer : public Common::RefObject
{
public:

 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 bool pushContextsIsSet() const;
 void unsetPushContexts();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>>> getPushContexts();
 int32_t setPushContexts(const Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>> &pushContexts) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestPlayerSessionPlayer(Common::LibContext * context);
 friend class RequestPlayerSessionPlayerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestPlayerSessionPlayer>;

 ~RequestPlayerSessionPlayer();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;

 Common::String m_platform;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>>> m_pushContexts;
 bool m_pushContextsIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    RequestPlayerSessionPlayer();
};

class RequestPlayerSessionPlayerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSessionPlayer> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSessionPlayer> *instancePtr);


 static void destroy(RequestPlayerSessionPlayer *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberPlayersRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdMemberPlayersRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<RequestPlayerSessionPlayer>> &players) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdMemberPlayersRequestBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdMemberPlayersRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdMemberPlayersRequestBody>;

 ~PostPlayerSessionsSessionIdMemberPlayersRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSessionPlayer>>> m_players;


    PostPlayerSessionsSessionIdMemberPlayersRequestBody();
};

class PostPlayerSessionsSessionIdMemberPlayersRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSessionPlayer>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberPlayersRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberPlayersRequestBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdMemberPlayersRequestBody *instance);
};


}
}
}
}
}
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberPlayersResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberPlayersResponseBody.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdMemberPlayersResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer>>> getPlayers();
 int32_t setPlayers(const Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer>> &players) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdMemberPlayersResponseBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdMemberPlayersResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdMemberPlayersResponseBody>;

 ~PostPlayerSessionsSessionIdMemberPlayersResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer>>> m_players;


    PostPlayerSessionsSessionIdMemberPlayersResponseBody();
};

class PostPlayerSessionsSessionIdMemberPlayersResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer>>>::value_type &players,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberPlayersResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberPlayersResponseBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdMemberPlayersResponseBody *instance);
};


}
}
}
}
}
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberSpectatorsRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberSpectatorsRequestBody.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionSpectator.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionSpectator.h" 2 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/RequestPlayerSessionSpectator.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class RequestPlayerSessionSpectator : public Common::RefObject
{
public:

 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 bool pushContextsIsSet() const;
 void unsetPushContexts();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>>> getPushContexts();
 int32_t setPushContexts(const Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>> &pushContexts) __attribute__((warn_unused_result));


 bool customData1IsSet() const;
 void unsetCustomData1();
 const Common::IntrusivePtr<Common::Binary> & getCustomData1() const;
 int32_t setCustomData1(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 RequestPlayerSessionSpectator(Common::LibContext * context);
 friend class RequestPlayerSessionSpectatorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::RequestPlayerSessionSpectator>;

 ~RequestPlayerSessionSpectator();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;

 Common::String m_platform;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<PlayerSessionPushContext>>> m_pushContexts;
 bool m_pushContextsIsSet;

 Common::IntrusivePtr<Common::Binary> m_customData1;
 bool m_customData1IsSet;


    RequestPlayerSessionSpectator();
};

class RequestPlayerSessionSpectatorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSessionSpectator> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<RequestPlayerSessionSpectator> *instancePtr);


 static void destroy(RequestPlayerSessionSpectator *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberSpectatorsRequestBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdMemberSpectatorsRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSessionSpectator>>> getSpectators();
 int32_t setSpectators(const Common::Vector<Common::IntrusivePtr<RequestPlayerSessionSpectator>> &spectators) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdMemberSpectatorsRequestBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdMemberSpectatorsRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdMemberSpectatorsRequestBody>;

 ~PostPlayerSessionsSessionIdMemberSpectatorsRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSessionSpectator>>> m_spectators;


    PostPlayerSessionsSessionIdMemberSpectatorsRequestBody();
};

class PostPlayerSessionsSessionIdMemberSpectatorsRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<RequestPlayerSessionSpectator>>>::value_type &spectators,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberSpectatorsRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberSpectatorsRequestBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdMemberSpectatorsRequestBody *instance);
};


}
}
}
}
}
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberSpectatorsResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberSpectatorsResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionSpectator.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/ResponsePlayerSessionSpectator.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class ResponsePlayerSessionSpectator : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ResponsePlayerSessionSpectator(Common::LibContext * context);
 friend class ResponsePlayerSessionSpectatorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::ResponsePlayerSessionSpectator>;

 ~ResponsePlayerSessionSpectator();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 Common::String m_platform;


    ResponsePlayerSessionSpectator();
};

class ResponsePlayerSessionSpectatorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionSpectator> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ResponsePlayerSessionSpectator> *instancePtr);


 static void destroy(ResponsePlayerSessionSpectator *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdMemberSpectatorsResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdMemberSpectatorsResponseBody : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionSpectator>>> getSpectators();
 int32_t setSpectators(const Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionSpectator>> &spectators) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdMemberSpectatorsResponseBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdMemberSpectatorsResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdMemberSpectatorsResponseBody>;

 ~PostPlayerSessionsSessionIdMemberSpectatorsResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionSpectator>>> m_spectators;


    PostPlayerSessionsSessionIdMemberSpectatorsResponseBody();
};

class PostPlayerSessionsSessionIdMemberSpectatorsResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionSpectator>>>::value_type &spectators,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberSpectatorsResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberSpectatorsResponseBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdMemberSpectatorsResponseBody *instance);
};


}
}
}
}
}
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdSessionMessageRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PostPlayerSessionsSessionIdSessionMessageRequestBody.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PostPlayerSessionsSessionIdSessionMessageRequestBody : public Common::RefObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<MemberWithMultiPlatform>>> getTo();
 int32_t setTo(const Common::Vector<Common::IntrusivePtr<MemberWithMultiPlatform>> &to) __attribute__((warn_unused_result));


 const Common::String & getPayload() const;
 int32_t setPayload(const char* payload) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PostPlayerSessionsSessionIdSessionMessageRequestBody(Common::LibContext * context);
 friend class PostPlayerSessionsSessionIdSessionMessageRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PostPlayerSessionsSessionIdSessionMessageRequestBody>;

 ~PostPlayerSessionsSessionIdSessionMessageRequestBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<MemberWithMultiPlatform>>> m_to;

 Common::String m_payload;


    PostPlayerSessionsSessionIdSessionMessageRequestBody();
};

class PostPlayerSessionsSessionIdSessionMessageRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<MemberWithMultiPlatform>>>::value_type &to,
  const char* payload,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdSessionMessageRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PostPlayerSessionsSessionIdSessionMessageRequestBody> *instancePtr);


 static void destroy(PostPlayerSessionsSessionIdSessionMessageRequestBody *instance);
};


}
}
}
}
}
# 29 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PutPlayerSessionsNonPsnLeaderRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PutPlayerSessionsNonPsnLeaderRequestBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PutPlayerSessionsNonPsnLeaderRequestBody : public Common::RefObject
{
public:

 const Common::String & getPlayerId() const;
 int32_t setPlayerId(const char* playerId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PutPlayerSessionsNonPsnLeaderRequestBody(Common::LibContext * context);
 friend class PutPlayerSessionsNonPsnLeaderRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PutPlayerSessionsNonPsnLeaderRequestBody>;

 ~PutPlayerSessionsNonPsnLeaderRequestBody();

private:
 Common::LibContext * m_context;

 Common::String m_playerId;


    PutPlayerSessionsNonPsnLeaderRequestBody();
};

class PutPlayerSessionsNonPsnLeaderRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* playerId,
  sce::Np::CppWebApi::Common::IntrusivePtr<PutPlayerSessionsNonPsnLeaderRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PutPlayerSessionsNonPsnLeaderRequestBody> *instancePtr);


 static void destroy(PutPlayerSessionsNonPsnLeaderRequestBody *instance);
};


}
}
}
}
}
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PutPlayerSessionsSessionIdLeaderRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/SessionManager/V1/PutPlayerSessionsSessionIdLeaderRequestBody.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PutPlayerSessionsSessionIdLeaderRequestBody : public Common::RefObject
{
public:

 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 const Common::String & getPlatform() const;
 int32_t setPlatform(const char* platform) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PutPlayerSessionsSessionIdLeaderRequestBody(Common::LibContext * context);
 friend class PutPlayerSessionsSessionIdLeaderRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PutPlayerSessionsSessionIdLeaderRequestBody>;

 ~PutPlayerSessionsSessionIdLeaderRequestBody();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;

 Common::String m_platform;


    PutPlayerSessionsSessionIdLeaderRequestBody();
};

class PutPlayerSessionsSessionIdLeaderRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpAccountId &accountId,
  const char* platform,
  sce::Np::CppWebApi::Common::IntrusivePtr<PutPlayerSessionsSessionIdLeaderRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PutPlayerSessionsSessionIdLeaderRequestBody> *instancePtr);


 static void destroy(PutPlayerSessionsSessionIdLeaderRequestBody *instance);
};


}
}
}
}
}
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/sessionmanager/v1/PlayerSessionsApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace SessionManager {
namespace V1 {

class PlayerSessionsApi {
public:

 class ParameterToAddPlayerSessionJoinableSpecifiedUsers : public Common::ParameterBase {
 public:
  ParameterToAddPlayerSessionJoinableSpecifiedUsers();
  ~ParameterToAddPlayerSessionJoinableSpecifiedUsers();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody > postPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody > getpostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody() const;
  void setpostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody(Common::IntrusivePtr< PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody > postPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody);


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToAddPlayerSessionJoinableSpecifiedUsers;

 private:
  struct ParameterImplToAddPlayerSessionJoinableSpecifiedUsers *m_pimpl;

  ParameterToAddPlayerSessionJoinableSpecifiedUsers(ParameterToAddPlayerSessionJoinableSpecifiedUsers &param);
  ParameterToAddPlayerSessionJoinableSpecifiedUsers(const ParameterToAddPlayerSessionJoinableSpecifiedUsers &param);
  ParameterToAddPlayerSessionJoinableSpecifiedUsers& operator=(ParameterToAddPlayerSessionJoinableSpecifiedUsers &param);
  ParameterToAddPlayerSessionJoinableSpecifiedUsers& operator=(const ParameterToAddPlayerSessionJoinableSpecifiedUsers &param);
 };

 static int32_t addPlayerSessionJoinableSpecifiedUsers(
  int32_t npwebapiUserCtxId,
  const ParameterToAddPlayerSessionJoinableSpecifiedUsers &param,
  Common::Transaction<Common::IntrusivePtr<PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody>> &transaction
  );

 class ParameterToChangePlayerSessionLeader : public Common::ParameterBase {
 public:
  ParameterToChangePlayerSessionLeader();
  ~ParameterToChangePlayerSessionLeader();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PutPlayerSessionsSessionIdLeaderRequestBody > putPlayerSessionsSessionIdLeaderRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PutPlayerSessionsSessionIdLeaderRequestBody > getputPlayerSessionsSessionIdLeaderRequestBody() const;
  void setputPlayerSessionsSessionIdLeaderRequestBody(Common::IntrusivePtr< PutPlayerSessionsSessionIdLeaderRequestBody > putPlayerSessionsSessionIdLeaderRequestBody);


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToChangePlayerSessionLeader;

 private:
  struct ParameterImplToChangePlayerSessionLeader *m_pimpl;

  ParameterToChangePlayerSessionLeader(ParameterToChangePlayerSessionLeader &param);
  ParameterToChangePlayerSessionLeader(const ParameterToChangePlayerSessionLeader &param);
  ParameterToChangePlayerSessionLeader& operator=(ParameterToChangePlayerSessionLeader &param);
  ParameterToChangePlayerSessionLeader& operator=(const ParameterToChangePlayerSessionLeader &param);
 };

 static int32_t changePlayerSessionLeader(
  int32_t npwebapiUserCtxId,
  const ParameterToChangePlayerSessionLeader &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToCreatePlayerSessions : public Common::ParameterBase {
 public:
  ParameterToCreatePlayerSessions();
  ~ParameterToCreatePlayerSessions();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , Common::IntrusivePtr< PostPlayerSessionsRequestBody > postPlayerSessionsRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  Common::IntrusivePtr< PostPlayerSessionsRequestBody > getpostPlayerSessionsRequestBody() const;
  void setpostPlayerSessionsRequestBody(Common::IntrusivePtr< PostPlayerSessionsRequestBody > postPlayerSessionsRequestBody);


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToCreatePlayerSessions;

 private:
  struct ParameterImplToCreatePlayerSessions *m_pimpl;

  ParameterToCreatePlayerSessions(ParameterToCreatePlayerSessions &param);
  ParameterToCreatePlayerSessions(const ParameterToCreatePlayerSessions &param);
  ParameterToCreatePlayerSessions& operator=(ParameterToCreatePlayerSessions &param);
  ParameterToCreatePlayerSessions& operator=(const ParameterToCreatePlayerSessions &param);
 };

 static int32_t createPlayerSessions(
  int32_t npwebapiUserCtxId,
  const ParameterToCreatePlayerSessions &param,
  Common::Transaction<Common::IntrusivePtr<PostPlayerSessionsResponseBody>> &transaction
  );

 class ParameterToDeletePlayerSessionJoinableSpecifiedUsers : public Common::ParameterBase {
 public:
  ParameterToDeletePlayerSessionJoinableSpecifiedUsers();
  ~ParameterToDeletePlayerSessionJoinableSpecifiedUsers();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , const char* xPSNSESSIONMANAGERACCOUNTIDS
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  const Common::String& getxPSNSESSIONMANAGERACCOUNTIDS() const;
  int32_t setxPSNSESSIONMANAGERACCOUNTIDS(const char* xPSNSESSIONMANAGERACCOUNTIDS) __attribute__((warn_unused_result));


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToDeletePlayerSessionJoinableSpecifiedUsers;

 private:
  struct ParameterImplToDeletePlayerSessionJoinableSpecifiedUsers *m_pimpl;

  ParameterToDeletePlayerSessionJoinableSpecifiedUsers(ParameterToDeletePlayerSessionJoinableSpecifiedUsers &param);
  ParameterToDeletePlayerSessionJoinableSpecifiedUsers(const ParameterToDeletePlayerSessionJoinableSpecifiedUsers &param);
  ParameterToDeletePlayerSessionJoinableSpecifiedUsers& operator=(ParameterToDeletePlayerSessionJoinableSpecifiedUsers &param);
  ParameterToDeletePlayerSessionJoinableSpecifiedUsers& operator=(const ParameterToDeletePlayerSessionJoinableSpecifiedUsers &param);
 };

 static int32_t deletePlayerSessionJoinableSpecifiedUsers(
  int32_t npwebapiUserCtxId,
  const ParameterToDeletePlayerSessionJoinableSpecifiedUsers &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToDeletePlayerSessionsMemberNonPsnPlayer : public Common::ParameterBase {
 public:
  ParameterToDeletePlayerSessionsMemberNonPsnPlayer();
  ~ParameterToDeletePlayerSessionsMemberNonPsnPlayer();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , const char* playerId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  const Common::String& getplayerId() const;
  int32_t setplayerId(const char* playerId) __attribute__((warn_unused_result));


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToDeletePlayerSessionsMemberNonPsnPlayer;

 private:
  struct ParameterImplToDeletePlayerSessionsMemberNonPsnPlayer *m_pimpl;

  ParameterToDeletePlayerSessionsMemberNonPsnPlayer(ParameterToDeletePlayerSessionsMemberNonPsnPlayer &param);
  ParameterToDeletePlayerSessionsMemberNonPsnPlayer(const ParameterToDeletePlayerSessionsMemberNonPsnPlayer &param);
  ParameterToDeletePlayerSessionsMemberNonPsnPlayer& operator=(ParameterToDeletePlayerSessionsMemberNonPsnPlayer &param);
  ParameterToDeletePlayerSessionsMemberNonPsnPlayer& operator=(const ParameterToDeletePlayerSessionsMemberNonPsnPlayer &param);
 };

 static int32_t deletePlayerSessionsMemberNonPsnPlayer(
  int32_t npwebapiUserCtxId,
  const ParameterToDeletePlayerSessionsMemberNonPsnPlayer &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToGetFriendsPlayerSessions : public Common::ParameterBase {
 public:
  ParameterToGetFriendsPlayerSessions();
  ~ParameterToGetFriendsPlayerSessions();

  int32_t initialize(
   Common::LibContext * context
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getxPSNSESSIONMANAGERACCOUNTIDS() const;
  int32_t setxPSNSESSIONMANAGERACCOUNTIDS(const char* xPSNSESSIONMANAGERACCOUNTIDS) __attribute__((warn_unused_result));
  void unsetxPSNSESSIONMANAGERACCOUNTIDS();
  bool hasxPSNSESSIONMANAGERACCOUNTIDS() const;


  const Common::String& getacceptLanguage() const;
  int32_t setacceptLanguage(const char* acceptLanguage) __attribute__((warn_unused_result));
  void unsetacceptLanguage();
  bool hasacceptLanguage() const;

  struct ParameterImplToGetFriendsPlayerSessions;

 private:
  struct ParameterImplToGetFriendsPlayerSessions *m_pimpl;

  ParameterToGetFriendsPlayerSessions(ParameterToGetFriendsPlayerSessions &param);
  ParameterToGetFriendsPlayerSessions(const ParameterToGetFriendsPlayerSessions &param);
  ParameterToGetFriendsPlayerSessions& operator=(ParameterToGetFriendsPlayerSessions &param);
  ParameterToGetFriendsPlayerSessions& operator=(const ParameterToGetFriendsPlayerSessions &param);
 };

 static int32_t getFriendsPlayerSessions(
  int32_t npwebapiUserCtxId,
  const ParameterToGetFriendsPlayerSessions &param,
  Common::Transaction<Common::IntrusivePtr<GetFriendsPlayerSessionsResponseBody>> &transaction
  );

 class ParameterToGetJoinedPlayerSessionsByUser : public Common::ParameterBase {
 public:
  ParameterToGetJoinedPlayerSessionsByUser();
  ~ParameterToGetJoinedPlayerSessionsByUser();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  const Common::String& getmemberFilter() const;
  int32_t setmemberFilter(const char* memberFilter) __attribute__((warn_unused_result));
  void unsetmemberFilter();
  bool hasmemberFilter() const;


  const Common::String& getplatformFilter() const;
  int32_t setplatformFilter(const char* platformFilter) __attribute__((warn_unused_result));
  void unsetplatformFilter();
  bool hasplatformFilter() const;


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToGetJoinedPlayerSessionsByUser;

 private:
  struct ParameterImplToGetJoinedPlayerSessionsByUser *m_pimpl;

  ParameterToGetJoinedPlayerSessionsByUser(ParameterToGetJoinedPlayerSessionsByUser &param);
  ParameterToGetJoinedPlayerSessionsByUser(const ParameterToGetJoinedPlayerSessionsByUser &param);
  ParameterToGetJoinedPlayerSessionsByUser& operator=(ParameterToGetJoinedPlayerSessionsByUser &param);
  ParameterToGetJoinedPlayerSessionsByUser& operator=(const ParameterToGetJoinedPlayerSessionsByUser &param);
 };

 static int32_t getJoinedPlayerSessionsByUser(
  int32_t npwebapiUserCtxId,
  const ParameterToGetJoinedPlayerSessionsByUser &param,
  Common::Transaction<Common::IntrusivePtr<GetUsersAccountIdPlayerSessionsResponseBody>> &transaction
  );

 class ParameterToGetPlayerSessionInvitations : public Common::ParameterBase {
 public:
  ParameterToGetPlayerSessionInvitations();
  ~ParameterToGetPlayerSessionInvitations();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  Common::IntrusivePtr<Common::Vector<Common::String>> getfields() const;
  void setfields(Common::IntrusivePtr<Common::Vector<Common::String>> fields);
  void unsetfields();
  bool hasfields() const;


  const Common::String& getinvitationInvalidFilter() const;
  int32_t setinvitationInvalidFilter(const char* invitationInvalidFilter) __attribute__((warn_unused_result));
  void unsetinvitationInvalidFilter();
  bool hasinvitationInvalidFilter() const;


  const Common::String& getxPSNSESSIONMANAGERINVITATIONIDS() const;
  int32_t setxPSNSESSIONMANAGERINVITATIONIDS(const char* xPSNSESSIONMANAGERINVITATIONIDS) __attribute__((warn_unused_result));
  void unsetxPSNSESSIONMANAGERINVITATIONIDS();
  bool hasxPSNSESSIONMANAGERINVITATIONIDS() const;


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToGetPlayerSessionInvitations;

 private:
  struct ParameterImplToGetPlayerSessionInvitations *m_pimpl;

  ParameterToGetPlayerSessionInvitations(ParameterToGetPlayerSessionInvitations &param);
  ParameterToGetPlayerSessionInvitations(const ParameterToGetPlayerSessionInvitations &param);
  ParameterToGetPlayerSessionInvitations& operator=(ParameterToGetPlayerSessionInvitations &param);
  ParameterToGetPlayerSessionInvitations& operator=(const ParameterToGetPlayerSessionInvitations &param);
 };

 static int32_t getPlayerSessionInvitations(
  int32_t npwebapiUserCtxId,
  const ParameterToGetPlayerSessionInvitations &param,
  Common::Transaction<Common::IntrusivePtr<GetUsersAccountIdPlayerSessionsInvitationsResponseBody>> &transaction
  );

 class ParameterToGetPlayerSessions : public Common::ParameterBase {
 public:
  ParameterToGetPlayerSessions();
  ~ParameterToGetPlayerSessions();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* xPSNSESSIONMANAGERSESSIONIDS
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getxPSNSESSIONMANAGERSESSIONIDS() const;
  int32_t setxPSNSESSIONMANAGERSESSIONIDS(const char* xPSNSESSIONMANAGERSESSIONIDS) __attribute__((warn_unused_result));


  const Common::String& getacceptLanguage() const;
  int32_t setacceptLanguage(const char* acceptLanguage) __attribute__((warn_unused_result));
  void unsetacceptLanguage();
  bool hasacceptLanguage() const;


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));


  Common::IntrusivePtr<Common::Vector<Common::String>> getfields() const;
  void setfields(Common::IntrusivePtr<Common::Vector<Common::String>> fields);
  void unsetfields();
  bool hasfields() const;


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToGetPlayerSessions;

 private:
  struct ParameterImplToGetPlayerSessions *m_pimpl;

  ParameterToGetPlayerSessions(ParameterToGetPlayerSessions &param);
  ParameterToGetPlayerSessions(const ParameterToGetPlayerSessions &param);
  ParameterToGetPlayerSessions& operator=(ParameterToGetPlayerSessions &param);
  ParameterToGetPlayerSessions& operator=(const ParameterToGetPlayerSessions &param);
 };

 static int32_t getPlayerSessions(
  int32_t npwebapiUserCtxId,
  const ParameterToGetPlayerSessions &param,
  Common::Transaction<Common::IntrusivePtr<GetPlayerSessionsResponseBody>> &transaction
  );

 class ParameterToJoinPlayerSessionAsPlayer : public Common::ParameterBase {
 public:
  ParameterToJoinPlayerSessionAsPlayer();
  ~ParameterToJoinPlayerSessionAsPlayer();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PostPlayerSessionsSessionIdMemberPlayersRequestBody > postPlayerSessionsSessionIdMemberPlayersRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostPlayerSessionsSessionIdMemberPlayersRequestBody > getpostPlayerSessionsSessionIdMemberPlayersRequestBody() const;
  void setpostPlayerSessionsSessionIdMemberPlayersRequestBody(Common::IntrusivePtr< PostPlayerSessionsSessionIdMemberPlayersRequestBody > postPlayerSessionsSessionIdMemberPlayersRequestBody);


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;


  const Common::String& getxPSNSESSIONMANAGERREQUESTORIGIN() const;
  int32_t setxPSNSESSIONMANAGERREQUESTORIGIN(const char* xPSNSESSIONMANAGERREQUESTORIGIN) __attribute__((warn_unused_result));
  void unsetxPSNSESSIONMANAGERREQUESTORIGIN();
  bool hasxPSNSESSIONMANAGERREQUESTORIGIN() const;


  const Common::String& getxPSNSESSIONMANAGERREQUESTEXACTORIGIN() const;
  int32_t setxPSNSESSIONMANAGERREQUESTEXACTORIGIN(const char* xPSNSESSIONMANAGERREQUESTEXACTORIGIN) __attribute__((warn_unused_result));
  void unsetxPSNSESSIONMANAGERREQUESTEXACTORIGIN();
  bool hasxPSNSESSIONMANAGERREQUESTEXACTORIGIN() const;

  struct ParameterImplToJoinPlayerSessionAsPlayer;

 private:
  struct ParameterImplToJoinPlayerSessionAsPlayer *m_pimpl;

  ParameterToJoinPlayerSessionAsPlayer(ParameterToJoinPlayerSessionAsPlayer &param);
  ParameterToJoinPlayerSessionAsPlayer(const ParameterToJoinPlayerSessionAsPlayer &param);
  ParameterToJoinPlayerSessionAsPlayer& operator=(ParameterToJoinPlayerSessionAsPlayer &param);
  ParameterToJoinPlayerSessionAsPlayer& operator=(const ParameterToJoinPlayerSessionAsPlayer &param);
 };

 static int32_t joinPlayerSessionAsPlayer(
  int32_t npwebapiUserCtxId,
  const ParameterToJoinPlayerSessionAsPlayer &param,
  Common::Transaction<Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberPlayersResponseBody>> &transaction
  );

 class ParameterToJoinPlayerSessionAsSpectator : public Common::ParameterBase {
 public:
  ParameterToJoinPlayerSessionAsSpectator();
  ~ParameterToJoinPlayerSessionAsSpectator();

  enum class XPsnAcceptPlatformNamePs5 {
   _NOT_SET = 0,
   kProspero,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PostPlayerSessionsSessionIdMemberSpectatorsRequestBody > postPlayerSessionsSessionIdMemberSpectatorsRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostPlayerSessionsSessionIdMemberSpectatorsRequestBody > getpostPlayerSessionsSessionIdMemberSpectatorsRequestBody() const;
  void setpostPlayerSessionsSessionIdMemberSpectatorsRequestBody(Common::IntrusivePtr< PostPlayerSessionsSessionIdMemberSpectatorsRequestBody > postPlayerSessionsSessionIdMemberSpectatorsRequestBody);


  XPsnAcceptPlatformNamePs5 getxPsnAcceptPlatformNamePs5() const;
  void setxPsnAcceptPlatformNamePs5(XPsnAcceptPlatformNamePs5 xPsnAcceptPlatformNamePs5);
  void unsetxPsnAcceptPlatformNamePs5();
  bool hasxPsnAcceptPlatformNamePs5() const;

  struct ParameterImplToJoinPlayerSessionAsSpectator;

 private:
  struct ParameterImplToJoinPlayerSessionAsSpectator *m_pimpl;

  ParameterToJoinPlayerSessionAsSpectator(ParameterToJoinPlayerSessionAsSpectator &param);
  ParameterToJoinPlayerSessionAsSpectator(const ParameterToJoinPlayerSessionAsSpectator &param);
  ParameterToJoinPlayerSessionAsSpectator& operator=(ParameterToJoinPlayerSessionAsSpectator &param);
  ParameterToJoinPlayerSessionAsSpectator& operator=(const ParameterToJoinPlayerSessionAsSpectator &param);
 };

 static int32_t joinPlayerSessionAsSpectator(
  int32_t npwebapiUserCtxId,
  const ParameterToJoinPlayerSessionAsSpectator &param,
  Common::Transaction<Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberSpectatorsResponseBody>> &transaction
  );

 class ParameterToLeavePlayerSession : public Common::ParameterBase {
 public:
  ParameterToLeavePlayerSession();
  ~ParameterToLeavePlayerSession();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , const char* accountId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToLeavePlayerSession;

 private:
  struct ParameterImplToLeavePlayerSession *m_pimpl;

  ParameterToLeavePlayerSession(ParameterToLeavePlayerSession &param);
  ParameterToLeavePlayerSession(const ParameterToLeavePlayerSession &param);
  ParameterToLeavePlayerSession& operator=(ParameterToLeavePlayerSession &param);
  ParameterToLeavePlayerSession& operator=(const ParameterToLeavePlayerSession &param);
 };

 static int32_t leavePlayerSession(
  int32_t npwebapiUserCtxId,
  const ParameterToLeavePlayerSession &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToPutPlayerSessionsNonPsnLeader : public Common::ParameterBase {
 public:
  ParameterToPutPlayerSessionsNonPsnLeader();
  ~ParameterToPutPlayerSessionsNonPsnLeader();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PutPlayerSessionsNonPsnLeaderRequestBody > putPlayerSessionsNonPsnLeaderRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PutPlayerSessionsNonPsnLeaderRequestBody > getputPlayerSessionsNonPsnLeaderRequestBody() const;
  void setputPlayerSessionsNonPsnLeaderRequestBody(Common::IntrusivePtr< PutPlayerSessionsNonPsnLeaderRequestBody > putPlayerSessionsNonPsnLeaderRequestBody);


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToPutPlayerSessionsNonPsnLeader;

 private:
  struct ParameterImplToPutPlayerSessionsNonPsnLeader *m_pimpl;

  ParameterToPutPlayerSessionsNonPsnLeader(ParameterToPutPlayerSessionsNonPsnLeader &param);
  ParameterToPutPlayerSessionsNonPsnLeader(const ParameterToPutPlayerSessionsNonPsnLeader &param);
  ParameterToPutPlayerSessionsNonPsnLeader& operator=(ParameterToPutPlayerSessionsNonPsnLeader &param);
  ParameterToPutPlayerSessionsNonPsnLeader& operator=(const ParameterToPutPlayerSessionsNonPsnLeader &param);
 };

 static int32_t putPlayerSessionsNonPsnLeader(
  int32_t npwebapiUserCtxId,
  const ParameterToPutPlayerSessionsNonPsnLeader &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToSendPlayerSessionInvitations : public Common::ParameterBase {
 public:
  ParameterToSendPlayerSessionInvitations();
  ~ParameterToSendPlayerSessionInvitations();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PostPlayerSessionsSessionIdInvitationsRequestBody > postPlayerSessionsSessionIdInvitationsRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostPlayerSessionsSessionIdInvitationsRequestBody > getpostPlayerSessionsSessionIdInvitationsRequestBody() const;
  void setpostPlayerSessionsSessionIdInvitationsRequestBody(Common::IntrusivePtr< PostPlayerSessionsSessionIdInvitationsRequestBody > postPlayerSessionsSessionIdInvitationsRequestBody);


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToSendPlayerSessionInvitations;

 private:
  struct ParameterImplToSendPlayerSessionInvitations *m_pimpl;

  ParameterToSendPlayerSessionInvitations(ParameterToSendPlayerSessionInvitations &param);
  ParameterToSendPlayerSessionInvitations(const ParameterToSendPlayerSessionInvitations &param);
  ParameterToSendPlayerSessionInvitations& operator=(ParameterToSendPlayerSessionInvitations &param);
  ParameterToSendPlayerSessionInvitations& operator=(const ParameterToSendPlayerSessionInvitations &param);
 };

 static int32_t sendPlayerSessionInvitations(
  int32_t npwebapiUserCtxId,
  const ParameterToSendPlayerSessionInvitations &param,
  Common::Transaction<Common::IntrusivePtr<PostPlayerSessionsSessionIdInvitationsResponseBody>> &transaction
  );

 class ParameterToSendPlayerSessionMessage : public Common::ParameterBase {
 public:
  ParameterToSendPlayerSessionMessage();
  ~ParameterToSendPlayerSessionMessage();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PostPlayerSessionsSessionIdSessionMessageRequestBody > postPlayerSessionsSessionIdSessionMessageRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PostPlayerSessionsSessionIdSessionMessageRequestBody > getpostPlayerSessionsSessionIdSessionMessageRequestBody() const;
  void setpostPlayerSessionsSessionIdSessionMessageRequestBody(Common::IntrusivePtr< PostPlayerSessionsSessionIdSessionMessageRequestBody > postPlayerSessionsSessionIdSessionMessageRequestBody);

  struct ParameterImplToSendPlayerSessionMessage;

 private:
  struct ParameterImplToSendPlayerSessionMessage *m_pimpl;

  ParameterToSendPlayerSessionMessage(ParameterToSendPlayerSessionMessage &param);
  ParameterToSendPlayerSessionMessage(const ParameterToSendPlayerSessionMessage &param);
  ParameterToSendPlayerSessionMessage& operator=(ParameterToSendPlayerSessionMessage &param);
  ParameterToSendPlayerSessionMessage& operator=(const ParameterToSendPlayerSessionMessage &param);
 };

 static int32_t sendPlayerSessionMessage(
  int32_t npwebapiUserCtxId,
  const ParameterToSendPlayerSessionMessage &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToSetPlayerSessionMemberSystemProperties : public Common::ParameterBase {
 public:
  ParameterToSetPlayerSessionMemberSystemProperties();
  ~ParameterToSetPlayerSessionMemberSystemProperties();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , const char* accountId
   , Common::IntrusivePtr< PatchPlayerSessionsSessionIdMembersAccountIdRequestBody > patchPlayerSessionsSessionIdMembersAccountIdRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PatchPlayerSessionsSessionIdMembersAccountIdRequestBody > getpatchPlayerSessionsSessionIdMembersAccountIdRequestBody() const;
  void setpatchPlayerSessionsSessionIdMembersAccountIdRequestBody(Common::IntrusivePtr< PatchPlayerSessionsSessionIdMembersAccountIdRequestBody > patchPlayerSessionsSessionIdMembersAccountIdRequestBody);

  struct ParameterImplToSetPlayerSessionMemberSystemProperties;

 private:
  struct ParameterImplToSetPlayerSessionMemberSystemProperties *m_pimpl;

  ParameterToSetPlayerSessionMemberSystemProperties(ParameterToSetPlayerSessionMemberSystemProperties &param);
  ParameterToSetPlayerSessionMemberSystemProperties(const ParameterToSetPlayerSessionMemberSystemProperties &param);
  ParameterToSetPlayerSessionMemberSystemProperties& operator=(ParameterToSetPlayerSessionMemberSystemProperties &param);
  ParameterToSetPlayerSessionMemberSystemProperties& operator=(const ParameterToSetPlayerSessionMemberSystemProperties &param);
 };

 static int32_t setPlayerSessionMemberSystemProperties(
  int32_t npwebapiUserCtxId,
  const ParameterToSetPlayerSessionMemberSystemProperties &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToSetPlayerSessionProperties : public Common::ParameterBase {
 public:
  ParameterToSetPlayerSessionProperties();
  ~ParameterToSetPlayerSessionProperties();

  int32_t initialize(
   Common::LibContext * context
   , const char* sessionId
   , Common::IntrusivePtr< PatchPlayerSessionsSessionIdRequestBody > patchPlayerSessionsSessionIdRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getsessionId() const;
  int32_t setsessionId(const char* sessionId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< PatchPlayerSessionsSessionIdRequestBody > getpatchPlayerSessionsSessionIdRequestBody() const;
  void setpatchPlayerSessionsSessionIdRequestBody(Common::IntrusivePtr< PatchPlayerSessionsSessionIdRequestBody > patchPlayerSessionsSessionIdRequestBody);


  const Common::String& getxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));
  int32_t setxPSNSESSIONMANAGERNONPSNCALLERID(const char* xPSNSESSIONMANAGERNONPSNCALLERID) __attribute__((warn_unused_result, deprecated));
  void unsetxPSNSESSIONMANAGERNONPSNCALLERID() __attribute__((deprecated));
  bool hasxPSNSESSIONMANAGERNONPSNCALLERID() const __attribute__((deprecated));

  struct ParameterImplToSetPlayerSessionProperties;

 private:
  struct ParameterImplToSetPlayerSessionProperties *m_pimpl;

  ParameterToSetPlayerSessionProperties(ParameterToSetPlayerSessionProperties &param);
  ParameterToSetPlayerSessionProperties(const ParameterToSetPlayerSessionProperties &param);
  ParameterToSetPlayerSessionProperties& operator=(ParameterToSetPlayerSessionProperties &param);
  ParameterToSetPlayerSessionProperties& operator=(const ParameterToSetPlayerSessionProperties &param);
 };

 static int32_t setPlayerSessionProperties(
  int32_t npwebapiUserCtxId,
  const ParameterToSetPlayerSessionProperties &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

private:
 PlayerSessionsApi();
 ~PlayerSessionsApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/session_manager.h" 2 3
# 332 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/title_cloud_storage.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/DataApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/DataApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/ErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/ErrorResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class Error : public Common::RefObject
{
public:

 int32_t getCode() const;
 void setCode(const int32_t &code);


 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 bool reasonIsSet() const;
 void unsetReason();
 const Common::String & getReason() const;
 int32_t setReason(const char* reason) __attribute__((warn_unused_result));


 bool referenceIdIsSet() const;
 void unsetReferenceId();
 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 bool sourceIsSet() const;
 void unsetSource();
 const Common::String & getSource() const;
 int32_t setSource(const char* source) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 int32_t m_code;

 Common::String m_message;

 Common::String m_reason;
 bool m_reasonIsSet;

 Common::String m_referenceId;
 bool m_referenceIdIsSet;

 Common::String m_source;
 bool m_sourceIsSet;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int32_t code,
  const char* message,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/ErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class ErrorResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorResponse(Common::LibContext * context);
 friend class ErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::ErrorResponse>;

 ~ErrorResponse();

protected:
    ErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;


};

class ErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<Error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);


 static void destroy(ErrorResponse *instance);
};
using PsnErrorObject = ErrorResponse;
using PsnErrorObjectFactory = ErrorResponseFactory;


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/DataApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/GetMultiDataStatusesResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/GetMultiDataStatusesResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/DataStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/DataStatus.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/LastUpdatedUser.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/LastUpdatedUser.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class LastUpdatedUser : public Common::RefObject
{
public:

 bool accountIdIsSet() const;
 void unsetAccountId();
 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 bool onlineIdIsSet() const;
 void unsetOnlineId();
 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 LastUpdatedUser(Common::LibContext * context);
 friend class LastUpdatedUserFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::LastUpdatedUser>;

 ~LastUpdatedUser();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;
 bool m_accountIdIsSet;

 SceNpOnlineId m_onlineId;
 bool m_onlineIdIsSet;


    LastUpdatedUser();
};

class LastUpdatedUserFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<LastUpdatedUser> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<LastUpdatedUser> *instancePtr);


 static void destroy(LastUpdatedUser *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/DataStatus.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Owner.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Owner.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class Owner : public Common::RefObject
{
public:

 bool accountIdIsSet() const;
 void unsetAccountId();
 const Common::String & getAccountId() const;
 int32_t setAccountId(const char* accountId) __attribute__((warn_unused_result));


 bool onlineIdIsSet() const;
 void unsetOnlineId();
 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Owner(Common::LibContext * context);
 friend class OwnerFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::Owner>;

 ~Owner();

private:
 Common::LibContext * m_context;

 Common::String m_accountId;
 bool m_accountIdIsSet;

 SceNpOnlineId m_onlineId;
 bool m_onlineIdIsSet;


    Owner();
};

class OwnerFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Owner> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Owner> *instancePtr);


 static void destroy(Owner *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/DataStatus.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class DataStatus : public Common::RefObject
{
public:

 bool dataSizeIsSet() const;
 void unsetDataSize();
 int64_t getDataSize() const;
 void setDataSize(const int64_t &dataSize);


 bool infoIsSet() const;
 void unsetInfo();
 const Common::IntrusivePtr<Common::Binary> & getInfo() const;
 int32_t setInfo(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool lastUpdatedDateTimeIsSet() const;
 void unsetLastUpdatedDateTime();
 SceRtcTick getLastUpdatedDateTime() const;
 void setLastUpdatedDateTime(const SceRtcTick &lastUpdatedDateTime);


 bool lastUpdatedUserIsSet() const;
 void unsetLastUpdatedUser();
 Common::IntrusivePtr<LastUpdatedUser> getLastUpdatedUser() const;
 int32_t setLastUpdatedUser(const Common::IntrusivePtr<LastUpdatedUser> &lastUpdatedUser) __attribute__((warn_unused_result));


 bool objectIdIsSet() const;
 void unsetObjectId();
 const Common::String & getObjectId() const;
 int32_t setObjectId(const char* objectId) __attribute__((warn_unused_result));


 bool ownerIsSet() const;
 void unsetOwner();
 Common::IntrusivePtr<Owner> getOwner() const;
 int32_t setOwner(const Common::IntrusivePtr<Owner> &owner) __attribute__((warn_unused_result));


 bool slotIdIsSet() const;
 void unsetSlotId();
 int32_t getSlotId() const;
 void setSlotId(const int32_t &slotId);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 DataStatus(Common::LibContext * context);
 friend class DataStatusFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::DataStatus>;

 ~DataStatus();

private:
 Common::LibContext * m_context;

 int64_t m_dataSize;
 bool m_dataSizeIsSet;

 Common::IntrusivePtr<Common::Binary> m_info;
 bool m_infoIsSet;

 SceRtcTick m_lastUpdatedDateTime;
 bool m_lastUpdatedDateTimeIsSet;

 Common::IntrusivePtr<LastUpdatedUser> m_lastUpdatedUser;
 bool m_lastUpdatedUserIsSet;

 Common::String m_objectId;
 bool m_objectIdIsSet;

 Common::IntrusivePtr<Owner> m_owner;
 bool m_ownerIsSet;

 int32_t m_slotId;
 bool m_slotIdIsSet;


    DataStatus();
};

class DataStatusFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<DataStatus> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<DataStatus> *instancePtr);


 static void destroy(DataStatus *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/GetMultiDataStatusesResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class GetMultiDataStatusesResponseBody : public PsnErrorObject
{
public:

 bool dataStatusListIsSet() const;
 void unsetDataStatusList();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<DataStatus>>> getDataStatusList();
 int32_t setDataStatusList(const Common::Vector<Common::IntrusivePtr<DataStatus>> &dataStatusList) __attribute__((warn_unused_result));


 bool limitIsSet() const;
 void unsetLimit();
 int32_t getLimit() const;
 void setLimit(const int32_t &limit);


 bool offsetIsSet() const;
 void unsetOffset();
 int32_t getOffset() const;
 void setOffset(const int32_t &offset);


 bool totalDataStatusCountIsSet() const;
 void unsetTotalDataStatusCount();
 int32_t getTotalDataStatusCount() const;
 void setTotalDataStatusCount(const int32_t &totalDataStatusCount);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetMultiDataStatusesResponseBody(Common::LibContext * context);
 friend class GetMultiDataStatusesResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::GetMultiDataStatusesResponseBody>;

 ~GetMultiDataStatusesResponseBody();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<DataStatus>>> m_dataStatusList;
 bool m_dataStatusListIsSet;

 int32_t m_limit;
 bool m_limitIsSet;

 int32_t m_offset;
 bool m_offsetIsSet;

 int32_t m_totalDataStatusCount;
 bool m_totalDataStatusCountIsSet;


    GetMultiDataStatusesResponseBody();
};

class GetMultiDataStatusesResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetMultiDataStatusesResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetMultiDataStatusesResponseBody> *instancePtr);


 static void destroy(GetMultiDataStatusesResponseBody *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/DataApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetDataInfoRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetDataInfoRequestBody.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class SetDataInfoRequestBody : public Common::RefObject
{
public:

 bool comparedLastUpdatedDateTimeIsSet() const;
 void unsetComparedLastUpdatedDateTime();
 SceRtcTick getComparedLastUpdatedDateTime() const;
 void setComparedLastUpdatedDateTime(const SceRtcTick &comparedLastUpdatedDateTime);


 bool comparedLastUpdatedUserAccountIdIsSet() const;
 void unsetComparedLastUpdatedUserAccountId();
 const Common::String & getComparedLastUpdatedUserAccountId() const;
 int32_t setComparedLastUpdatedUserAccountId(const char* comparedLastUpdatedUserAccountId) __attribute__((warn_unused_result));


 const Common::IntrusivePtr<Common::Binary> & getInfo() const;
 int32_t setInfo(const void *binaryBuf, size_t binarySize) __attribute__((warn_unused_result));


 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 SceNpServiceLabel getNpServiceLabel() const;
 void setNpServiceLabel(const SceNpServiceLabel &npServiceLabel);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SetDataInfoRequestBody(Common::LibContext * context);
 friend class SetDataInfoRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::SetDataInfoRequestBody>;

 ~SetDataInfoRequestBody();

private:
 Common::LibContext * m_context;

 SceRtcTick m_comparedLastUpdatedDateTime;
 bool m_comparedLastUpdatedDateTimeIsSet;

 Common::String m_comparedLastUpdatedUserAccountId;
 bool m_comparedLastUpdatedUserAccountIdIsSet;

 Common::IntrusivePtr<Common::Binary> m_info;

 SceNpServiceLabel m_npServiceLabel;
 bool m_npServiceLabelIsSet;


    SetDataInfoRequestBody();
};

class SetDataInfoRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  void *info, size_t infoSize,
  sce::Np::CppWebApi::Common::IntrusivePtr<SetDataInfoRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SetDataInfoRequestBody> *instancePtr);


 static void destroy(SetDataInfoRequestBody *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/DataApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/UploadDataResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/UploadDataResponseBody.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class UploadDataResponseBody : public PsnErrorObject
{
public:

 const Common::String & getObjectId() const;
 int32_t setObjectId(const char* objectId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 UploadDataResponseBody(Common::LibContext * context);
 friend class UploadDataResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::UploadDataResponseBody>;

 ~UploadDataResponseBody();

private:
 Common::LibContext * m_context;

 Common::String m_objectId;


    UploadDataResponseBody();
};

class UploadDataResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const char* objectId,
  sce::Np::CppWebApi::Common::IntrusivePtr<UploadDataResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<UploadDataResponseBody> *instancePtr);


 static void destroy(UploadDataResponseBody *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/DataApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class DataApi {
public:

 class ParameterToDeleteMultiDataBySlot : public Common::ParameterBase {
 public:
  ParameterToDeleteMultiDataBySlot();
  ~ParameterToDeleteMultiDataBySlot();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountIds
   , int32_t slotId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountIds() const;
  int32_t setaccountIds(const char* accountIds) __attribute__((warn_unused_result));


  int32_t getslotId() const;
  void setslotId(int32_t slotId);


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;

  struct ParameterImplToDeleteMultiDataBySlot;

 private:
  struct ParameterImplToDeleteMultiDataBySlot *m_pimpl;

  ParameterToDeleteMultiDataBySlot(ParameterToDeleteMultiDataBySlot &param);
  ParameterToDeleteMultiDataBySlot(const ParameterToDeleteMultiDataBySlot &param);
  ParameterToDeleteMultiDataBySlot& operator=(ParameterToDeleteMultiDataBySlot &param);
  ParameterToDeleteMultiDataBySlot& operator=(const ParameterToDeleteMultiDataBySlot &param);
 };

 static int32_t deleteMultiDataBySlot(
  int32_t npwebapiUserCtxId,
  const ParameterToDeleteMultiDataBySlot &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToDeleteMultiDataByUser : public Common::ParameterBase {
 public:
  ParameterToDeleteMultiDataByUser();
  ~ParameterToDeleteMultiDataByUser();

  int32_t initialize(
   Common::LibContext * context
   , const char* slotIds
   , const char* accountId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getslotIds() const;
  int32_t setslotIds(const char* slotIds) __attribute__((warn_unused_result));


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;

  struct ParameterImplToDeleteMultiDataByUser;

 private:
  struct ParameterImplToDeleteMultiDataByUser *m_pimpl;

  ParameterToDeleteMultiDataByUser(ParameterToDeleteMultiDataByUser &param);
  ParameterToDeleteMultiDataByUser(const ParameterToDeleteMultiDataByUser &param);
  ParameterToDeleteMultiDataByUser& operator=(ParameterToDeleteMultiDataByUser &param);
  ParameterToDeleteMultiDataByUser& operator=(const ParameterToDeleteMultiDataByUser &param);
 };

 static int32_t deleteMultiDataByUser(
  int32_t npwebapiUserCtxId,
  const ParameterToDeleteMultiDataByUser &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToDownloadData : public Common::ParameterBase {
 public:
  ParameterToDownloadData();
  ~ParameterToDownloadData();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , int32_t slotId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  int32_t getslotId() const;
  void setslotId(int32_t slotId);


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;


  const Common::String& getobjectId() const;
  int32_t setobjectId(const char* objectId) __attribute__((warn_unused_result));
  void unsetobjectId();
  bool hasobjectId() const;


  const Common::String& getrange() const;
  int32_t setrange(const char* range) __attribute__((warn_unused_result));
  void unsetrange();
  bool hasrange() const;


  const Common::String& getifMatch() const;
  int32_t setifMatch(const char* ifMatch) __attribute__((warn_unused_result));
  void unsetifMatch();
  bool hasifMatch() const;

  struct ParameterImplToDownloadData;

 private:
  struct ParameterImplToDownloadData *m_pimpl;

  ParameterToDownloadData(ParameterToDownloadData &param);
  ParameterToDownloadData(const ParameterToDownloadData &param);
  ParameterToDownloadData& operator=(ParameterToDownloadData &param);
  ParameterToDownloadData& operator=(const ParameterToDownloadData &param);
 };

 class DownloadDataResponseHeaders : public sce::Np::CppWebApi::Common::ResponseHeaderBase
 {
 public:
  DownloadDataResponseHeaders();
  ~DownloadDataResponseHeaders();
  static void intrusive_ptr_add_ref(DownloadDataResponseHeaders * c);
  static void intrusive_ptr_sub_ref(DownloadDataResponseHeaders * c);

  static int32_t create(
   Common::LibContext * context,
   Common::IntrusivePtr<DownloadDataResponseHeaders> &headersPtr,
   int64_t reqId
   );
  static void destroy(
   DownloadDataResponseHeaders *headers
   );


  const Common::String & getLastModified() const;
  int32_t setLastModified(const Common::String& LastModified) __attribute__((warn_unused_result));
  void unsetLastModified();
  bool hasLastModified() const;


  const Common::String & getETag() const;
  int32_t setETag(const Common::String& ETag) __attribute__((warn_unused_result));
  void unsetETag();
  bool hasETag() const;

  struct DownloadDataResponseHeadersImpl;

 private:
  struct DownloadDataResponseHeadersImpl *m_pimpl;

  DownloadDataResponseHeaders(DownloadDataResponseHeaders &param);
  DownloadDataResponseHeaders(const DownloadDataResponseHeaders &param);
  DownloadDataResponseHeaders& operator=(DownloadDataResponseHeaders &param);
  DownloadDataResponseHeaders& operator=(const DownloadDataResponseHeaders &param);
 };

 static int32_t downloadData(
  int32_t npwebapiUserCtxId,
  const ParameterToDownloadData &param,
  Common::Transaction<Common::IntrusivePtr < Common::Binary >, Common::IntrusivePtr<DownloadDataResponseHeaders>> &transaction
  );

 static int32_t downloadData(
  int32_t npwebapiUserCtxId,
  const ParameterToDownloadData &param,
  Common::DownStreamTransaction<Common::IntrusivePtr<DownloadDataResponseHeaders>> &transaction
  );

 class ParameterToGetMultiDataStatusesBySlot : public Common::ParameterBase {
 public:
  ParameterToGetMultiDataStatusesBySlot();
  ~ParameterToGetMultiDataStatusesBySlot();

  enum class Sort {
   _NOT_SET = 0,
   kAccountid,
   kDatasize,
   kDate,
  };

  enum class SortMode {
   _NOT_SET = 0,
   kAsc,
   kDesc,
  };

  enum class Group {
   _NOT_SET = 0,
   kFriends,
  };

  int32_t initialize(
   Common::LibContext * context
   , int32_t slotId
   );

  int32_t terminate();

  bool isInitialized() const;


  int32_t getslotId() const;
  void setslotId(int32_t slotId);


  const Common::String& getaccountIds() const;
  int32_t setaccountIds(const char* accountIds) __attribute__((warn_unused_result));
  void unsetaccountIds();
  bool hasaccountIds() const;


  const Common::String& getfields() const;
  int32_t setfields(const char* fields) __attribute__((warn_unused_result));
  void unsetfields();
  bool hasfields() const;


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;


  int32_t getoffset() const;
  void setoffset(int32_t offset);
  void unsetoffset();
  bool hasoffset() const;


  Sort getsort() const;
  void setsort(Sort sort);
  void unsetsort();
  bool hassort() const;


  SortMode getsortMode() const;
  void setsortMode(SortMode sortMode);
  void unsetsortMode();
  bool hassortMode() const;


  Group getgroup() const;
  void setgroup(Group group);
  void unsetgroup();
  bool hasgroup() const;


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;

  struct ParameterImplToGetMultiDataStatusesBySlot;

 private:
  struct ParameterImplToGetMultiDataStatusesBySlot *m_pimpl;

  ParameterToGetMultiDataStatusesBySlot(ParameterToGetMultiDataStatusesBySlot &param);
  ParameterToGetMultiDataStatusesBySlot(const ParameterToGetMultiDataStatusesBySlot &param);
  ParameterToGetMultiDataStatusesBySlot& operator=(ParameterToGetMultiDataStatusesBySlot &param);
  ParameterToGetMultiDataStatusesBySlot& operator=(const ParameterToGetMultiDataStatusesBySlot &param);
 };

 static int32_t getMultiDataStatusesBySlot(
  int32_t npwebapiUserCtxId,
  const ParameterToGetMultiDataStatusesBySlot &param,
  Common::Transaction<Common::IntrusivePtr<GetMultiDataStatusesResponseBody>> &transaction
  );

 class ParameterToGetMultiDataStatusesByUser : public Common::ParameterBase {
 public:
  ParameterToGetMultiDataStatusesByUser();
  ~ParameterToGetMultiDataStatusesByUser();

  enum class Sort {
   _NOT_SET = 0,
   kSlotid,
   kDatasize,
   kDate,
  };

  enum class SortMode {
   _NOT_SET = 0,
   kAsc,
   kDesc,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , const char* slotIds
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  const Common::String& getslotIds() const;
  int32_t setslotIds(const char* slotIds) __attribute__((warn_unused_result));


  const Common::String& getfields() const;
  int32_t setfields(const char* fields) __attribute__((warn_unused_result));
  void unsetfields();
  bool hasfields() const;


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;


  int32_t getoffset() const;
  void setoffset(int32_t offset);
  void unsetoffset();
  bool hasoffset() const;


  Sort getsort() const;
  void setsort(Sort sort);
  void unsetsort();
  bool hassort() const;


  SortMode getsortMode() const;
  void setsortMode(SortMode sortMode);
  void unsetsortMode();
  bool hassortMode() const;


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;

  struct ParameterImplToGetMultiDataStatusesByUser;

 private:
  struct ParameterImplToGetMultiDataStatusesByUser *m_pimpl;

  ParameterToGetMultiDataStatusesByUser(ParameterToGetMultiDataStatusesByUser &param);
  ParameterToGetMultiDataStatusesByUser(const ParameterToGetMultiDataStatusesByUser &param);
  ParameterToGetMultiDataStatusesByUser& operator=(ParameterToGetMultiDataStatusesByUser &param);
  ParameterToGetMultiDataStatusesByUser& operator=(const ParameterToGetMultiDataStatusesByUser &param);
 };

 static int32_t getMultiDataStatusesByUser(
  int32_t npwebapiUserCtxId,
  const ParameterToGetMultiDataStatusesByUser &param,
  Common::Transaction<Common::IntrusivePtr<GetMultiDataStatusesResponseBody>> &transaction
  );

 class ParameterToSetDataInfo : public Common::ParameterBase {
 public:
  ParameterToSetDataInfo();
  ~ParameterToSetDataInfo();

  enum class XPsnAtomicOperation {
   _NOT_SET = 0,
   kBegin,
   kEnd,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , int32_t slotId
   , Common::IntrusivePtr< SetDataInfoRequestBody > setDataInfoRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  int32_t getslotId() const;
  void setslotId(int32_t slotId);


  Common::IntrusivePtr< SetDataInfoRequestBody > getsetDataInfoRequestBody() const;
  void setsetDataInfoRequestBody(Common::IntrusivePtr< SetDataInfoRequestBody > setDataInfoRequestBody);


  XPsnAtomicOperation getxPsnAtomicOperation() const;
  void setxPsnAtomicOperation(XPsnAtomicOperation xPsnAtomicOperation);
  void unsetxPsnAtomicOperation();
  bool hasxPsnAtomicOperation() const;


  const Common::String& getxPsnAtomicOperationId() const;
  int32_t setxPsnAtomicOperationId(const char* xPsnAtomicOperationId) __attribute__((warn_unused_result));
  void unsetxPsnAtomicOperationId();
  bool hasxPsnAtomicOperationId() const;

  struct ParameterImplToSetDataInfo;

 private:
  struct ParameterImplToSetDataInfo *m_pimpl;

  ParameterToSetDataInfo(ParameterToSetDataInfo &param);
  ParameterToSetDataInfo(const ParameterToSetDataInfo &param);
  ParameterToSetDataInfo& operator=(ParameterToSetDataInfo &param);
  ParameterToSetDataInfo& operator=(const ParameterToSetDataInfo &param);
 };

 class SetDataInfoResponseHeaders : public sce::Np::CppWebApi::Common::ResponseHeaderBase
 {
 public:
  SetDataInfoResponseHeaders();
  ~SetDataInfoResponseHeaders();
  static void intrusive_ptr_add_ref(SetDataInfoResponseHeaders * c);
  static void intrusive_ptr_sub_ref(SetDataInfoResponseHeaders * c);

  static int32_t create(
   Common::LibContext * context,
   Common::IntrusivePtr<SetDataInfoResponseHeaders> &headersPtr,
   int64_t reqId
   );
  static void destroy(
   SetDataInfoResponseHeaders *headers
   );


  const Common::String & getXPsnAtomicOperationId() const;
  int32_t setXPsnAtomicOperationId(const Common::String& XPsnAtomicOperationId) __attribute__((warn_unused_result));
  void unsetXPsnAtomicOperationId();
  bool hasXPsnAtomicOperationId() const;

  struct SetDataInfoResponseHeadersImpl;

 private:
  struct SetDataInfoResponseHeadersImpl *m_pimpl;

  SetDataInfoResponseHeaders(SetDataInfoResponseHeaders &param);
  SetDataInfoResponseHeaders(const SetDataInfoResponseHeaders &param);
  SetDataInfoResponseHeaders& operator=(SetDataInfoResponseHeaders &param);
  SetDataInfoResponseHeaders& operator=(const SetDataInfoResponseHeaders &param);
 };

 static int32_t setDataInfo(
  int32_t npwebapiUserCtxId,
  const ParameterToSetDataInfo &param,
  Common::Transaction<Common::DefaultResponse, Common::IntrusivePtr<SetDataInfoResponseHeaders>> &transaction
  );

 class ParameterToUploadData : public Common::ParameterBase {
 public:
  ParameterToUploadData();
  ~ParameterToUploadData();

  enum class XPsnAtomicOperation {
   _NOT_SET = 0,
   kBegin,
   kEnd,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , int32_t slotId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  int32_t getslotId() const;
  void setslotId(int32_t slotId);


  XPsnAtomicOperation getxPsnAtomicOperation() const;
  void setxPsnAtomicOperation(XPsnAtomicOperation xPsnAtomicOperation);
  void unsetxPsnAtomicOperation();
  bool hasxPsnAtomicOperation() const;


  const Common::String& getxPsnAtomicOperationId() const;
  int32_t setxPsnAtomicOperationId(const char* xPsnAtomicOperationId) __attribute__((warn_unused_result));
  void unsetxPsnAtomicOperationId();
  bool hasxPsnAtomicOperationId() const;


  const Common::String& getxPsnTcsComparedLastUpdatedDateTime() const;
  int32_t setxPsnTcsComparedLastUpdatedDateTime(const char* xPsnTcsComparedLastUpdatedDateTime) __attribute__((warn_unused_result));
  void unsetxPsnTcsComparedLastUpdatedDateTime();
  bool hasxPsnTcsComparedLastUpdatedDateTime() const;


  SceNpAccountId getxPsnTcsComparedLastUpdatedUserAccountId() const;
  void setxPsnTcsComparedLastUpdatedUserAccountId(SceNpAccountId xPsnTcsComparedLastUpdatedUserAccountId);
  void unsetxPsnTcsComparedLastUpdatedUserAccountId();
  bool hasxPsnTcsComparedLastUpdatedUserAccountId() const;


  SceNpServiceLabel getxPsnNpServiceLabel() const;
  void setxPsnNpServiceLabel(SceNpServiceLabel xPsnNpServiceLabel);
  void unsetxPsnNpServiceLabel();
  bool hasxPsnNpServiceLabel() const;

  struct ParameterImplToUploadData;

 protected:
  struct ParameterImplToUploadData *m_pimpl;

  ParameterToUploadData(ParameterToUploadData &param);
  ParameterToUploadData(const ParameterToUploadData &param);
  ParameterToUploadData& operator=(ParameterToUploadData &param);
  ParameterToUploadData& operator=(const ParameterToUploadData &param);
 };

 class ParameterWithBinaryRequestBodyToUploadData : public ParameterToUploadData {
 public:
  ParameterWithBinaryRequestBodyToUploadData();
  ~ParameterWithBinaryRequestBodyToUploadData();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , int32_t slotId
   );

  int32_t terminate();

  const Common::IntrusivePtr<Common::Binary> & getRequestBody() const;
  int32_t setRequestBody(const uint8_t *requestBody, size_t requestBodySize) __attribute__((warn_unused_result));

 };

 class UploadDataResponseHeaders : public sce::Np::CppWebApi::Common::ResponseHeaderBase
 {
 public:
  UploadDataResponseHeaders();
  ~UploadDataResponseHeaders();
  static void intrusive_ptr_add_ref(UploadDataResponseHeaders * c);
  static void intrusive_ptr_sub_ref(UploadDataResponseHeaders * c);

  static int32_t create(
   Common::LibContext * context,
   Common::IntrusivePtr<UploadDataResponseHeaders> &headersPtr,
   int64_t reqId
   );
  static void destroy(
   UploadDataResponseHeaders *headers
   );


  const Common::String & getXPsnAtomicOperationId() const;
  int32_t setXPsnAtomicOperationId(const Common::String& XPsnAtomicOperationId) __attribute__((warn_unused_result));
  void unsetXPsnAtomicOperationId();
  bool hasXPsnAtomicOperationId() const;

  struct UploadDataResponseHeadersImpl;
  friend class Common::LibContextImpl;

 private:
  struct UploadDataResponseHeadersImpl *m_pimpl;

  UploadDataResponseHeaders(UploadDataResponseHeaders &param);
  UploadDataResponseHeaders(const UploadDataResponseHeaders &param);
  UploadDataResponseHeaders& operator=(UploadDataResponseHeaders &param);
  UploadDataResponseHeaders& operator=(const UploadDataResponseHeaders &param);
  static int32_t parse(Common::LibContext * context, int64_t npWebApi2ReqId, Common::IntrusivePtr<UploadDataResponseHeaders> *headersPtr);
 };

 static int32_t uploadData(
  int32_t npwebapiUserCtxId,
  const ParameterWithBinaryRequestBodyToUploadData &param,
  Common::Transaction<Common::IntrusivePtr<UploadDataResponseBody>, Common::IntrusivePtr<UploadDataResponseHeaders>> &transaction
  );

 static int32_t uploadData(
  int32_t npwebapiUserCtxId,
  const ParameterToUploadData &param,
  Common::UpStreamTransaction<Common::IntrusivePtr<UploadDataResponseBody>, Common::IntrusivePtr<UploadDataResponseHeaders>> &transaction
  );

private:
 DataApi();
 ~DataApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/title_cloud_storage.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/VariablesApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/VariablesApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/AddAndGetVariableRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/AddAndGetVariableRequestBody.h" 2 3







namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class AddAndGetVariableRequestBody : public Common::RefObject
{
public:

 bool comparedLastUpdatedDateTimeIsSet() const;
 void unsetComparedLastUpdatedDateTime();
 SceRtcTick getComparedLastUpdatedDateTime() const;
 void setComparedLastUpdatedDateTime(const SceRtcTick &comparedLastUpdatedDateTime);


 bool comparedLastUpdatedUserAccountIdIsSet() const;
 void unsetComparedLastUpdatedUserAccountId();
 const Common::String & getComparedLastUpdatedUserAccountId() const;
 int32_t setComparedLastUpdatedUserAccountId(const char* comparedLastUpdatedUserAccountId) __attribute__((warn_unused_result));


 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 SceNpServiceLabel getNpServiceLabel() const;
 void setNpServiceLabel(const SceNpServiceLabel &npServiceLabel);


 int64_t getValue() const;
 void setValue(const int64_t &value);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 AddAndGetVariableRequestBody(Common::LibContext * context);
 friend class AddAndGetVariableRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::AddAndGetVariableRequestBody>;

 ~AddAndGetVariableRequestBody();

private:
 Common::LibContext * m_context;

 SceRtcTick m_comparedLastUpdatedDateTime;
 bool m_comparedLastUpdatedDateTimeIsSet;

 Common::String m_comparedLastUpdatedUserAccountId;
 bool m_comparedLastUpdatedUserAccountIdIsSet;

 SceNpServiceLabel m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 int64_t m_value;


    AddAndGetVariableRequestBody();
};

class AddAndGetVariableRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int64_t value,
  sce::Np::CppWebApi::Common::IntrusivePtr<AddAndGetVariableRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<AddAndGetVariableRequestBody> *instancePtr);


 static void destroy(AddAndGetVariableRequestBody *instance);
};


}
}
}
}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/VariablesApi.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/GetMultiVariablesResponseBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/GetMultiVariablesResponseBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/IdempotentVariable.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/IdempotentVariable.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class IdempotentVariable : public Common::RefObject
{
public:

 bool lastUpdatedDateTimeIsSet() const;
 void unsetLastUpdatedDateTime();
 SceRtcTick getLastUpdatedDateTime() const;
 void setLastUpdatedDateTime(const SceRtcTick &lastUpdatedDateTime);


 bool lastUpdatedUserIsSet() const;
 void unsetLastUpdatedUser();
 Common::IntrusivePtr<LastUpdatedUser> getLastUpdatedUser() const;
 int32_t setLastUpdatedUser(const Common::IntrusivePtr<LastUpdatedUser> &lastUpdatedUser) __attribute__((warn_unused_result));


 bool ownerIsSet() const;
 void unsetOwner();
 Common::IntrusivePtr<Owner> getOwner() const;
 int32_t setOwner(const Common::IntrusivePtr<Owner> &owner) __attribute__((warn_unused_result));


 bool slotIdIsSet() const;
 void unsetSlotId();
 int32_t getSlotId() const;
 void setSlotId(const int32_t &slotId);


 bool valueIsSet() const;
 void unsetValue();
 int64_t getValue() const;
 void setValue(const int64_t &value);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 IdempotentVariable(Common::LibContext * context);
 friend class IdempotentVariableFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::IdempotentVariable>;

 ~IdempotentVariable();

private:
 Common::LibContext * m_context;

 SceRtcTick m_lastUpdatedDateTime;
 bool m_lastUpdatedDateTimeIsSet;

 Common::IntrusivePtr<LastUpdatedUser> m_lastUpdatedUser;
 bool m_lastUpdatedUserIsSet;

 Common::IntrusivePtr<Owner> m_owner;
 bool m_ownerIsSet;

 int32_t m_slotId;
 bool m_slotIdIsSet;

 int64_t m_value;
 bool m_valueIsSet;


    IdempotentVariable();
};

class IdempotentVariableFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<IdempotentVariable> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<IdempotentVariable> *instancePtr);


 static void destroy(IdempotentVariable *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/GetMultiVariablesResponseBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class GetMultiVariablesResponseBody : public PsnErrorObject
{
public:

 bool limitIsSet() const;
 void unsetLimit();
 int32_t getLimit() const;
 void setLimit(const int32_t &limit);


 bool offsetIsSet() const;
 void unsetOffset();
 int32_t getOffset() const;
 void setOffset(const int32_t &offset);


 bool totalVariableCountIsSet() const;
 void unsetTotalVariableCount();
 int32_t getTotalVariableCount() const;
 void setTotalVariableCount(const int32_t &totalVariableCount);


 bool variablesIsSet() const;
 void unsetVariables();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<IdempotentVariable>>> getVariables();
 int32_t setVariables(const Common::Vector<Common::IntrusivePtr<IdempotentVariable>> &variables) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetMultiVariablesResponseBody(Common::LibContext * context);
 friend class GetMultiVariablesResponseBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::GetMultiVariablesResponseBody>;

 ~GetMultiVariablesResponseBody();

private:
 Common::LibContext * m_context;

 int32_t m_limit;
 bool m_limitIsSet;

 int32_t m_offset;
 bool m_offsetIsSet;

 int32_t m_totalVariableCount;
 bool m_totalVariableCountIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<IdempotentVariable>>> m_variables;
 bool m_variablesIsSet;


    GetMultiVariablesResponseBody();
};

class GetMultiVariablesResponseBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetMultiVariablesResponseBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetMultiVariablesResponseBody> *instancePtr);


 static void destroy(GetMultiVariablesResponseBody *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/VariablesApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetMultiVariablesRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetMultiVariablesRequestBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetMultiVariablesRequestBody_variables.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetMultiVariablesRequestBody_variables.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class SetMultiVariablesRequestBody_variables : public Common::RefObject
{
public:

 bool slotIdIsSet() const;
 void unsetSlotId();
 int32_t getSlotId() const;
 void setSlotId(const int32_t &slotId);


 bool valueIsSet() const;
 void unsetValue();
 int64_t getValue() const;
 void setValue(const int64_t &value);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SetMultiVariablesRequestBody_variables(Common::LibContext * context);
 friend class SetMultiVariablesRequestBody_variablesFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::SetMultiVariablesRequestBody_variables>;

 ~SetMultiVariablesRequestBody_variables();

private:
 Common::LibContext * m_context;

 int32_t m_slotId;
 bool m_slotIdIsSet;

 int64_t m_value;
 bool m_valueIsSet;


    SetMultiVariablesRequestBody_variables();
};

class SetMultiVariablesRequestBody_variablesFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<SetMultiVariablesRequestBody_variables> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SetMultiVariablesRequestBody_variables> *instancePtr);


 static void destroy(SetMultiVariablesRequestBody_variables *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetMultiVariablesRequestBody.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class SetMultiVariablesRequestBody : public Common::RefObject
{
public:

 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 SceNpServiceLabel getNpServiceLabel() const;
 void setNpServiceLabel(const SceNpServiceLabel &npServiceLabel);


 bool variablesIsSet() const;
 void unsetVariables();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<SetMultiVariablesRequestBody_variables>>> getVariables();
 int32_t setVariables(const Common::Vector<Common::IntrusivePtr<SetMultiVariablesRequestBody_variables>> &variables) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SetMultiVariablesRequestBody(Common::LibContext * context);
 friend class SetMultiVariablesRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::SetMultiVariablesRequestBody>;

 ~SetMultiVariablesRequestBody();

private:
 Common::LibContext * m_context;

 SceNpServiceLabel m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<SetMultiVariablesRequestBody_variables>>> m_variables;
 bool m_variablesIsSet;


    SetMultiVariablesRequestBody();
};

class SetMultiVariablesRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<SetMultiVariablesRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SetMultiVariablesRequestBody> *instancePtr);


 static void destroy(SetMultiVariablesRequestBody *instance);
};


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/VariablesApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetVariableWithConditionsRequestBody.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetVariableWithConditionsRequestBody.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Condition.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Condition.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

 enum class Condition {
  _NOT_SET = 0,
  kEqual,
  kNotEqual,
  kGreater,
  kGreaterOrEqual,
  kLess,
  kLessOrEqual,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/SetVariableWithConditionsRequestBody.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class SetVariableWithConditionsRequestBody : public Common::RefObject
{
public:

 bool comparedLastUpdatedDateTimeIsSet() const;
 void unsetComparedLastUpdatedDateTime();
 SceRtcTick getComparedLastUpdatedDateTime() const;
 void setComparedLastUpdatedDateTime(const SceRtcTick &comparedLastUpdatedDateTime);


 bool comparedLastUpdatedUserAccountIdIsSet() const;
 void unsetComparedLastUpdatedUserAccountId();
 const Common::String & getComparedLastUpdatedUserAccountId() const;
 int32_t setComparedLastUpdatedUserAccountId(const char* comparedLastUpdatedUserAccountId) __attribute__((warn_unused_result));


 bool comparedValueIsSet() const;
 void unsetComparedValue();
 int64_t getComparedValue() const;
 void setComparedValue(const int64_t &comparedValue);


 Condition getCondition() const;
 void setCondition(const Condition &condition);


 bool npServiceLabelIsSet() const;
 void unsetNpServiceLabel();
 SceNpServiceLabel getNpServiceLabel() const;
 void setNpServiceLabel(const SceNpServiceLabel &npServiceLabel);


 int64_t getValue() const;
 void setValue(const int64_t &value);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 SetVariableWithConditionsRequestBody(Common::LibContext * context);
 friend class SetVariableWithConditionsRequestBodyFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::SetVariableWithConditionsRequestBody>;

 ~SetVariableWithConditionsRequestBody();

private:
 Common::LibContext * m_context;

 SceRtcTick m_comparedLastUpdatedDateTime;
 bool m_comparedLastUpdatedDateTimeIsSet;

 Common::String m_comparedLastUpdatedUserAccountId;
 bool m_comparedLastUpdatedUserAccountIdIsSet;

 int64_t m_comparedValue;
 bool m_comparedValueIsSet;

 Condition m_condition;

 SceNpServiceLabel m_npServiceLabel;
 bool m_npServiceLabelIsSet;

 int64_t m_value;


    SetVariableWithConditionsRequestBody();
};

class SetVariableWithConditionsRequestBodyFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Condition condition,
  int64_t value,
  sce::Np::CppWebApi::Common::IntrusivePtr<SetVariableWithConditionsRequestBody> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<SetVariableWithConditionsRequestBody> *instancePtr);


 static void destroy(SetVariableWithConditionsRequestBody *instance);
};


}
}
}
}
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/VariablesApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Variable.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Variable.h" 2 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/TitleCloudStorage/V1/Variable.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class Variable : public PsnErrorObject
{
public:

 bool lastUpdatedDateTimeIsSet() const;
 void unsetLastUpdatedDateTime();
 SceRtcTick getLastUpdatedDateTime() const;
 void setLastUpdatedDateTime(const SceRtcTick &lastUpdatedDateTime);


 bool lastUpdatedUserIsSet() const;
 void unsetLastUpdatedUser();
 Common::IntrusivePtr<LastUpdatedUser> getLastUpdatedUser() const;
 int32_t setLastUpdatedUser(const Common::IntrusivePtr<LastUpdatedUser> &lastUpdatedUser) __attribute__((warn_unused_result));


 bool ownerIsSet() const;
 void unsetOwner();
 Common::IntrusivePtr<Owner> getOwner() const;
 int32_t setOwner(const Common::IntrusivePtr<Owner> &owner) __attribute__((warn_unused_result));


 bool prevValueIsSet() const;
 void unsetPrevValue();
 int64_t getPrevValue() const;
 void setPrevValue(const int64_t &prevValue);


 bool slotIdIsSet() const;
 void unsetSlotId();
 int32_t getSlotId() const;
 void setSlotId(const int32_t &slotId);


 bool valueIsSet() const;
 void unsetValue();
 int64_t getValue() const;
 void setValue(const int64_t &value);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Variable(Common::LibContext * context);
 friend class VariableFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::TitleCloudStorage::V1::Variable>;

 ~Variable();

private:
 Common::LibContext * m_context;

 SceRtcTick m_lastUpdatedDateTime;
 bool m_lastUpdatedDateTimeIsSet;

 Common::IntrusivePtr<LastUpdatedUser> m_lastUpdatedUser;
 bool m_lastUpdatedUserIsSet;

 Common::IntrusivePtr<Owner> m_owner;
 bool m_ownerIsSet;

 int64_t m_prevValue;
 bool m_prevValueIsSet;

 int32_t m_slotId;
 bool m_slotIdIsSet;

 int64_t m_value;
 bool m_valueIsSet;


    Variable();
};

class VariableFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Variable> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Variable> *instancePtr);


 static void destroy(Variable *instance);
};


}
}
}
}
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/titlecloudstorage/v1/VariablesApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace TitleCloudStorage {
namespace V1 {

class VariablesApi {
public:

 class ParameterToAddAndGetVariable : public Common::ParameterBase {
 public:
  ParameterToAddAndGetVariable();
  ~ParameterToAddAndGetVariable();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , int32_t slotId
   , Common::IntrusivePtr< AddAndGetVariableRequestBody > addAndGetVariableRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  int32_t getslotId() const;
  void setslotId(int32_t slotId);


  Common::IntrusivePtr< AddAndGetVariableRequestBody > getaddAndGetVariableRequestBody() const;
  void setaddAndGetVariableRequestBody(Common::IntrusivePtr< AddAndGetVariableRequestBody > addAndGetVariableRequestBody);

  struct ParameterImplToAddAndGetVariable;

 private:
  struct ParameterImplToAddAndGetVariable *m_pimpl;

  ParameterToAddAndGetVariable(ParameterToAddAndGetVariable &param);
  ParameterToAddAndGetVariable(const ParameterToAddAndGetVariable &param);
  ParameterToAddAndGetVariable& operator=(ParameterToAddAndGetVariable &param);
  ParameterToAddAndGetVariable& operator=(const ParameterToAddAndGetVariable &param);
 };

 static int32_t addAndGetVariable(
  int32_t npwebapiUserCtxId,
  const ParameterToAddAndGetVariable &param,
  Common::Transaction<Common::IntrusivePtr<Variable>> &transaction
  );

 class ParameterToDeleteMultiVariablesByUser : public Common::ParameterBase {
 public:
  ParameterToDeleteMultiVariablesByUser();
  ~ParameterToDeleteMultiVariablesByUser();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , const char* slotIds
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  const Common::String& getslotIds() const;
  int32_t setslotIds(const char* slotIds) __attribute__((warn_unused_result));


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;

  struct ParameterImplToDeleteMultiVariablesByUser;

 private:
  struct ParameterImplToDeleteMultiVariablesByUser *m_pimpl;

  ParameterToDeleteMultiVariablesByUser(ParameterToDeleteMultiVariablesByUser &param);
  ParameterToDeleteMultiVariablesByUser(const ParameterToDeleteMultiVariablesByUser &param);
  ParameterToDeleteMultiVariablesByUser& operator=(ParameterToDeleteMultiVariablesByUser &param);
  ParameterToDeleteMultiVariablesByUser& operator=(const ParameterToDeleteMultiVariablesByUser &param);
 };

 static int32_t deleteMultiVariablesByUser(
  int32_t npwebapiUserCtxId,
  const ParameterToDeleteMultiVariablesByUser &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToGetMultiVariablesBySlot : public Common::ParameterBase {
 public:
  ParameterToGetMultiVariablesBySlot();
  ~ParameterToGetMultiVariablesBySlot();

  enum class Sort {
   _NOT_SET = 0,
   kSlotid,
   kAccountid,
   kDate,
   kValue,
  };

  enum class SortMode {
   _NOT_SET = 0,
   kAsc,
   kDesc,
  };

  enum class Group {
   _NOT_SET = 0,
   kFriends,
  };

  int32_t initialize(
   Common::LibContext * context
   , int32_t slotId
   );

  int32_t terminate();

  bool isInitialized() const;


  int32_t getslotId() const;
  void setslotId(int32_t slotId);


  const Common::String& getaccountIds() const;
  int32_t setaccountIds(const char* accountIds) __attribute__((warn_unused_result));
  void unsetaccountIds();
  bool hasaccountIds() const;


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;


  int32_t getoffset() const;
  void setoffset(int32_t offset);
  void unsetoffset();
  bool hasoffset() const;


  Sort getsort() const;
  void setsort(Sort sort);
  void unsetsort();
  bool hassort() const;


  SortMode getsortMode() const;
  void setsortMode(SortMode sortMode);
  void unsetsortMode();
  bool hassortMode() const;


  Group getgroup() const;
  void setgroup(Group group);
  void unsetgroup();
  bool hasgroup() const;


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;

  struct ParameterImplToGetMultiVariablesBySlot;

 private:
  struct ParameterImplToGetMultiVariablesBySlot *m_pimpl;

  ParameterToGetMultiVariablesBySlot(ParameterToGetMultiVariablesBySlot &param);
  ParameterToGetMultiVariablesBySlot(const ParameterToGetMultiVariablesBySlot &param);
  ParameterToGetMultiVariablesBySlot& operator=(ParameterToGetMultiVariablesBySlot &param);
  ParameterToGetMultiVariablesBySlot& operator=(const ParameterToGetMultiVariablesBySlot &param);
 };

 static int32_t getMultiVariablesBySlot(
  int32_t npwebapiUserCtxId,
  const ParameterToGetMultiVariablesBySlot &param,
  Common::Transaction<Common::IntrusivePtr<GetMultiVariablesResponseBody>> &transaction
  );

 class ParameterToGetMultiVariablesByUser : public Common::ParameterBase {
 public:
  ParameterToGetMultiVariablesByUser();
  ~ParameterToGetMultiVariablesByUser();

  enum class Sort {
   _NOT_SET = 0,
   kSlotid,
   kAccountid,
   kDate,
   kValue,
  };

  enum class SortMode {
   _NOT_SET = 0,
   kAsc,
   kDesc,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , const char* slotIds
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  const Common::String& getslotIds() const;
  int32_t setslotIds(const char* slotIds) __attribute__((warn_unused_result));


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;


  SceNpServiceLabel getnpServiceLabel() const;
  void setnpServiceLabel(SceNpServiceLabel npServiceLabel);
  void unsetnpServiceLabel();
  bool hasnpServiceLabel() const;


  int32_t getoffset() const;
  void setoffset(int32_t offset);
  void unsetoffset();
  bool hasoffset() const;


  Sort getsort() const;
  void setsort(Sort sort);
  void unsetsort();
  bool hassort() const;


  SortMode getsortMode() const;
  void setsortMode(SortMode sortMode);
  void unsetsortMode();
  bool hassortMode() const;

  struct ParameterImplToGetMultiVariablesByUser;

 private:
  struct ParameterImplToGetMultiVariablesByUser *m_pimpl;

  ParameterToGetMultiVariablesByUser(ParameterToGetMultiVariablesByUser &param);
  ParameterToGetMultiVariablesByUser(const ParameterToGetMultiVariablesByUser &param);
  ParameterToGetMultiVariablesByUser& operator=(ParameterToGetMultiVariablesByUser &param);
  ParameterToGetMultiVariablesByUser& operator=(const ParameterToGetMultiVariablesByUser &param);
 };

 static int32_t getMultiVariablesByUser(
  int32_t npwebapiUserCtxId,
  const ParameterToGetMultiVariablesByUser &param,
  Common::Transaction<Common::IntrusivePtr<GetMultiVariablesResponseBody>> &transaction
  );

 class ParameterToSetMultiVariablesByUser : public Common::ParameterBase {
 public:
  ParameterToSetMultiVariablesByUser();
  ~ParameterToSetMultiVariablesByUser();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , Common::IntrusivePtr< SetMultiVariablesRequestBody > setMultiVariablesRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  Common::IntrusivePtr< SetMultiVariablesRequestBody > getsetMultiVariablesRequestBody() const;
  void setsetMultiVariablesRequestBody(Common::IntrusivePtr< SetMultiVariablesRequestBody > setMultiVariablesRequestBody);

  struct ParameterImplToSetMultiVariablesByUser;

 private:
  struct ParameterImplToSetMultiVariablesByUser *m_pimpl;

  ParameterToSetMultiVariablesByUser(ParameterToSetMultiVariablesByUser &param);
  ParameterToSetMultiVariablesByUser(const ParameterToSetMultiVariablesByUser &param);
  ParameterToSetMultiVariablesByUser& operator=(ParameterToSetMultiVariablesByUser &param);
  ParameterToSetMultiVariablesByUser& operator=(const ParameterToSetMultiVariablesByUser &param);
 };

 static int32_t setMultiVariablesByUser(
  int32_t npwebapiUserCtxId,
  const ParameterToSetMultiVariablesByUser &param,
  Common::Transaction<Common::DefaultResponse> &transaction
  );

 class ParameterToSetVariableWithConditions : public Common::ParameterBase {
 public:
  ParameterToSetVariableWithConditions();
  ~ParameterToSetVariableWithConditions();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   , int32_t slotId
   , Common::IntrusivePtr< SetVariableWithConditionsRequestBody > setVariableWithConditionsRequestBody
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  int32_t getslotId() const;
  void setslotId(int32_t slotId);


  Common::IntrusivePtr< SetVariableWithConditionsRequestBody > getsetVariableWithConditionsRequestBody() const;
  void setsetVariableWithConditionsRequestBody(Common::IntrusivePtr< SetVariableWithConditionsRequestBody > setVariableWithConditionsRequestBody);

  struct ParameterImplToSetVariableWithConditions;

 private:
  struct ParameterImplToSetVariableWithConditions *m_pimpl;

  ParameterToSetVariableWithConditions(ParameterToSetVariableWithConditions &param);
  ParameterToSetVariableWithConditions(const ParameterToSetVariableWithConditions &param);
  ParameterToSetVariableWithConditions& operator=(ParameterToSetVariableWithConditions &param);
  ParameterToSetVariableWithConditions& operator=(const ParameterToSetVariableWithConditions &param);
 };

 static int32_t setVariableWithConditions(
  int32_t npwebapiUserCtxId,
  const ParameterToSetVariableWithConditions &param,
  Common::Transaction<Common::IntrusivePtr<Variable>> &transaction
  );

private:
 VariablesApi();
 ~VariablesApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/title_cloud_storage.h" 2 3
# 333 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/user_profile.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/BasicProfileApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/BasicProfileApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/ErrorResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/ErrorResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/Error.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/Error.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class Error : public Common::RefObject
{
public:

 int64_t getCode() const;
 void setCode(const int64_t &code);


 const Common::String & getMessage() const;
 int32_t setMessage(const char* message) __attribute__((warn_unused_result));


 const Common::String & getReferenceId() const;
 int32_t setReferenceId(const char* referenceId) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Error(Common::LibContext * context);
 friend class ErrorFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::Error>;

 ~Error();

private:
 Common::LibContext * m_context;

 int64_t m_code;

 Common::String m_message;

 Common::String m_referenceId;


    Error();
};

class ErrorFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  int64_t code,
  const char* message,
  const char* referenceId,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Error> *instancePtr);


 static void destroy(Error *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/ErrorResponse.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class ErrorResponse : public Common::RefObject
{
public:

 Common::IntrusivePtr<Error> getError() const;
 int32_t setError(const Common::IntrusivePtr<Error> &error) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 ErrorResponse(Common::LibContext * context);
 friend class ErrorResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::ErrorResponse>;

 ~ErrorResponse();

protected:
    ErrorResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Error> m_error;


};

class ErrorResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  Common::IntrusivePtr<Error> error,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<ErrorResponse> *instancePtr);


 static void destroy(ErrorResponse *instance);
};
using PsnErrorObject = ErrorResponse;
using PsnErrorObjectFactory = ErrorResponseFactory;


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/BasicProfileApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetPublicProfileResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetPublicProfileResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/PersonalDetail.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/PersonalDetail.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/Avatar.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/Avatar.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/AvatarSize.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/AvatarSize.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

 enum class AvatarSize {
  _NOT_SET = 0,
  kXl,
  kL,
  kM,
  kS,
 };


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/Avatar.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class Avatar : public Common::RefObject
{
public:

 bool sizeIsSet() const;
 void unsetSize();
 AvatarSize getSize() const;
 void setSize(const AvatarSize &size);


 bool urlIsSet() const;
 void unsetUrl();
 const Common::String & getUrl() const;
 int32_t setUrl(const char* url) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 Avatar(Common::LibContext * context);
 friend class AvatarFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::Avatar>;

 ~Avatar();

private:
 Common::LibContext * m_context;

 AvatarSize m_size;
 bool m_sizeIsSet;

 Common::String m_url;
 bool m_urlIsSet;


    Avatar();
};

class AvatarFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<Avatar> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<Avatar> *instancePtr);


 static void destroy(Avatar *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/PersonalDetail.h" 2 3




namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class PersonalDetail : public Common::RefObject
{
public:

 bool firstNameIsSet() const;
 void unsetFirstName();
 const Common::String & getFirstName() const;
 int32_t setFirstName(const char* firstName) __attribute__((warn_unused_result));


 bool middleNameIsSet() const;
 void unsetMiddleName();
 const Common::String & getMiddleName() const;
 int32_t setMiddleName(const char* middleName) __attribute__((warn_unused_result));


 bool lastNameIsSet() const;
 void unsetLastName();
 const Common::String & getLastName() const;
 int32_t setLastName(const char* lastName) __attribute__((warn_unused_result));


 bool displayNameIsSet() const;
 void unsetDisplayName();
 const Common::String & getDisplayName() const;
 int32_t setDisplayName(const char* displayName) __attribute__((warn_unused_result));


 bool profilePicturesIsSet() const;
 void unsetProfilePictures();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar>>> getProfilePictures();
 int32_t setProfilePictures(const Common::Vector<Common::IntrusivePtr<Avatar>> &profilePictures) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 PersonalDetail(Common::LibContext * context);
 friend class PersonalDetailFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::PersonalDetail>;

 ~PersonalDetail();

private:
 Common::LibContext * m_context;

 Common::String m_firstName;
 bool m_firstNameIsSet;

 Common::String m_middleName;
 bool m_middleNameIsSet;

 Common::String m_lastName;
 bool m_lastNameIsSet;

 Common::String m_displayName;
 bool m_displayNameIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar>>> m_profilePictures;
 bool m_profilePicturesIsSet;


    PersonalDetail();
};

class PersonalDetailFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<PersonalDetail> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PersonalDetail> *instancePtr);


 static void destroy(PersonalDetail *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetPublicProfileResponse.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/Relation.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/Relation.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

 enum class Relation {
  _NOT_SET = 0,
  kMe,
  kFriend,
  kRequestingFriend,
  kRequestedFriend,
  kBlocking,
  kFriendOfFriends,
  kNoRelationship,
 };


}
}
}
}
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetPublicProfileResponse.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class GetPublicProfileResponse : public PsnErrorObject
{
public:

 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 bool personalDetailIsSet() const;
 void unsetPersonalDetail();
 Common::IntrusivePtr<PersonalDetail> getPersonalDetail() const;
 int32_t setPersonalDetail(const Common::IntrusivePtr<PersonalDetail> &personalDetail) __attribute__((warn_unused_result));


 const Common::String & getAboutMe() const;
 int32_t setAboutMe(const char* aboutMe) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar>>> getAvatars();
 int32_t setAvatars(const Common::Vector<Common::IntrusivePtr<Avatar>> &avatars) __attribute__((warn_unused_result));


 Common::IntrusivePtr<Common::Vector<Common::String>> getLanguages();
 int32_t setLanguages(const Common::Vector<Common::String> &languages) __attribute__((warn_unused_result));


 bool getIsOfficiallyVerified() const;
 void setIsOfficiallyVerified(const bool &isOfficiallyVerified);


 bool accountIdIsSet() const;
 void unsetAccountId();
 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool relationIsSet() const;
 void unsetRelation();
 Relation getRelation() const;
 void setRelation(const Relation &relation);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetPublicProfileResponse(Common::LibContext * context);
 friend class GetPublicProfileResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::GetPublicProfileResponse>;

 ~GetPublicProfileResponse();

private:
 Common::LibContext * m_context;

 SceNpOnlineId m_onlineId;

 Common::IntrusivePtr<PersonalDetail> m_personalDetail;
 bool m_personalDetailIsSet;

 Common::String m_aboutMe;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar>>> m_avatars;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_languages;

 bool m_isOfficiallyVerified;

 SceNpAccountId m_accountId;
 bool m_accountIdIsSet;

 Relation m_relation;
 bool m_relationIsSet;


    GetPublicProfileResponse();
};

class GetPublicProfileResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const SceNpOnlineId &onlineId,
  const char* aboutMe,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar>>>::value_type &avatars,
  const Common::IntrusivePtr<Common::Vector<Common::String>>::value_type &languages,
  bool isOfficiallyVerified,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetPublicProfileResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetPublicProfileResponse> *instancePtr);


 static void destroy(GetPublicProfileResponse *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/BasicProfileApi.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetPublicProfilesResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetPublicProfilesResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/BasicProfile.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/BasicProfile.h" 2 3
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/BasicProfile.h" 3
namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class BasicProfile : public Common::RefObject
{
public:

 bool onlineIdIsSet() const;
 void unsetOnlineId();
 SceNpOnlineId getOnlineId() const;
 void setOnlineId(const SceNpOnlineId &onlineId);


 bool personalDetailIsSet() const;
 void unsetPersonalDetail();
 Common::IntrusivePtr<PersonalDetail> getPersonalDetail() const;
 int32_t setPersonalDetail(const Common::IntrusivePtr<PersonalDetail> &personalDetail) __attribute__((warn_unused_result));


 bool aboutMeIsSet() const;
 void unsetAboutMe();
 const Common::String & getAboutMe() const;
 int32_t setAboutMe(const char* aboutMe) __attribute__((warn_unused_result));


 bool avatarsIsSet() const;
 void unsetAvatars();
 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar>>> getAvatars();
 int32_t setAvatars(const Common::Vector<Common::IntrusivePtr<Avatar>> &avatars) __attribute__((warn_unused_result));


 bool languagesIsSet() const;
 void unsetLanguages();
 Common::IntrusivePtr<Common::Vector<Common::String>> getLanguages();
 int32_t setLanguages(const Common::Vector<Common::String> &languages) __attribute__((warn_unused_result));


 bool isOfficiallyVerifiedIsSet() const;
 void unsetIsOfficiallyVerified();
 bool getIsOfficiallyVerified() const;
 void setIsOfficiallyVerified(const bool &isOfficiallyVerified);


 bool accountIdIsSet() const;
 void unsetAccountId();
 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool relationIsSet() const;
 void unsetRelation();
 Relation getRelation() const;
 void setRelation(const Relation &relation);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 BasicProfile(Common::LibContext * context);
 friend class BasicProfileFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::BasicProfile>;

 ~BasicProfile();

private:
 Common::LibContext * m_context;

 SceNpOnlineId m_onlineId;
 bool m_onlineIdIsSet;

 Common::IntrusivePtr<PersonalDetail> m_personalDetail;
 bool m_personalDetailIsSet;

 Common::String m_aboutMe;
 bool m_aboutMeIsSet;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar>>> m_avatars;
 bool m_avatarsIsSet;

 Common::IntrusivePtr<Common::Vector<Common::String>> m_languages;
 bool m_languagesIsSet;

 bool m_isOfficiallyVerified;
 bool m_isOfficiallyVerifiedIsSet;

 SceNpAccountId m_accountId;
 bool m_accountIdIsSet;

 Relation m_relation;
 bool m_relationIsSet;


    BasicProfile();
};

class BasicProfileFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<BasicProfile> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<BasicProfile> *instancePtr);


 static void destroy(BasicProfile *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetPublicProfilesResponse.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class GetPublicProfilesResponse : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicProfile>>> getProfiles();
 int32_t setProfiles(const Common::Vector<Common::IntrusivePtr<BasicProfile>> &profiles) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetPublicProfilesResponse(Common::LibContext * context);
 friend class GetPublicProfilesResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::GetPublicProfilesResponse>;

 ~GetPublicProfilesResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicProfile>>> m_profiles;


    GetPublicProfilesResponse();
};

class GetPublicProfilesResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicProfile>>>::value_type &profiles,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetPublicProfilesResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetPublicProfilesResponse> *instancePtr);


 static void destroy(GetPublicProfilesResponse *instance);
};


}
}
}
}
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/BasicProfileApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class BasicProfileApi {
public:

 class ParameterToGetPublicProfile : public Common::ParameterBase {
 public:
  ParameterToGetPublicProfile();
  ~ParameterToGetPublicProfile();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountId
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountId() const;
  int32_t setaccountId(const char* accountId) __attribute__((warn_unused_result));


  const Common::String& getincludeFields() const;
  int32_t setincludeFields(const char* includeFields) __attribute__((warn_unused_result));
  void unsetincludeFields();
  bool hasincludeFields() const;


  const Common::String& getlanguageSet() const;
  int32_t setlanguageSet(const char* languageSet) __attribute__((warn_unused_result));
  void unsetlanguageSet();
  bool haslanguageSet() const;

  struct ParameterImplToGetPublicProfile;

 private:
  struct ParameterImplToGetPublicProfile *m_pimpl;

  ParameterToGetPublicProfile(ParameterToGetPublicProfile &param);
  ParameterToGetPublicProfile(const ParameterToGetPublicProfile &param);
  ParameterToGetPublicProfile& operator=(ParameterToGetPublicProfile &param);
  ParameterToGetPublicProfile& operator=(const ParameterToGetPublicProfile &param);
 };

 static int32_t getPublicProfile(
  int32_t npwebapiUserCtxId,
  const ParameterToGetPublicProfile &param,
  Common::Transaction<Common::IntrusivePtr<GetPublicProfileResponse>> &transaction
  );

 class ParameterToGetPublicProfiles : public Common::ParameterBase {
 public:
  ParameterToGetPublicProfiles();
  ~ParameterToGetPublicProfiles();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountIds
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountIds() const;
  int32_t setaccountIds(const char* accountIds) __attribute__((warn_unused_result));


  const Common::String& getincludeFields() const;
  int32_t setincludeFields(const char* includeFields) __attribute__((warn_unused_result));
  void unsetincludeFields();
  bool hasincludeFields() const;


  const Common::String& getlanguageSet() const;
  int32_t setlanguageSet(const char* languageSet) __attribute__((warn_unused_result));
  void unsetlanguageSet();
  bool haslanguageSet() const;

  struct ParameterImplToGetPublicProfiles;

 private:
  struct ParameterImplToGetPublicProfiles *m_pimpl;

  ParameterToGetPublicProfiles(ParameterToGetPublicProfiles &param);
  ParameterToGetPublicProfiles(const ParameterToGetPublicProfiles &param);
  ParameterToGetPublicProfiles& operator=(ParameterToGetPublicProfiles &param);
  ParameterToGetPublicProfiles& operator=(const ParameterToGetPublicProfiles &param);
 };

 static int32_t getPublicProfiles(
  int32_t npwebapiUserCtxId,
  const ParameterToGetPublicProfiles &param,
  Common::Transaction<Common::IntrusivePtr<GetPublicProfilesResponse>> &transaction
  );

private:
 BasicProfileApi();
 ~BasicProfileApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/user_profile.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/BlocksApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/BlocksApi.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetBlockingUsersResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetBlockingUsersResponse.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class GetBlockingUsersResponse : public PsnErrorObject
{
public:

 Common::IntrusivePtr< Common::Vector<SceNpAccountId> >& getBlocks();
 int32_t setBlocks(const Common::IntrusivePtr< Common::Vector<SceNpAccountId> >::value_type &blocks) __attribute__((warn_unused_result));


 bool nextOffsetIsSet() const;
 void unsetNextOffset();
 int32_t getNextOffset() const;
 void setNextOffset(const int32_t &nextOffset);


 bool previousOffsetIsSet() const;
 void unsetPreviousOffset();
 int32_t getPreviousOffset() const;
 void setPreviousOffset(const int32_t &previousOffset);


 int32_t getTotalItemCount() const;
 void setTotalItemCount(const int32_t &totalItemCount);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetBlockingUsersResponse(Common::LibContext * context);
 friend class GetBlockingUsersResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::GetBlockingUsersResponse>;

 ~GetBlockingUsersResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr< Common::Vector<SceNpAccountId> > m_blocks;

 int32_t m_nextOffset;
 bool m_nextOffsetIsSet;

 int32_t m_previousOffset;
 bool m_previousOffsetIsSet;

 int32_t m_totalItemCount;


    GetBlockingUsersResponse();
};

class GetBlockingUsersResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr< Common::Vector<SceNpAccountId> >::value_type &blocks,
  int32_t totalItemCount,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetBlockingUsersResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetBlockingUsersResponse> *instancePtr);


 static void destroy(GetBlockingUsersResponse *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/BlocksApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class BlocksApi {
public:

 class ParameterToGetBlockingUsers : public Common::ParameterBase {
 public:
  ParameterToGetBlockingUsers();
  ~ParameterToGetBlockingUsers();

  int32_t initialize(
   Common::LibContext * context
   );

  int32_t terminate();

  bool isInitialized() const;


  int32_t getoffset() const;
  void setoffset(int32_t offset);
  void unsetoffset();
  bool hasoffset() const;


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;

  struct ParameterImplToGetBlockingUsers;

 private:
  struct ParameterImplToGetBlockingUsers *m_pimpl;

  ParameterToGetBlockingUsers(ParameterToGetBlockingUsers &param);
  ParameterToGetBlockingUsers(const ParameterToGetBlockingUsers &param);
  ParameterToGetBlockingUsers& operator=(ParameterToGetBlockingUsers &param);
  ParameterToGetBlockingUsers& operator=(const ParameterToGetBlockingUsers &param);
 };

 static int32_t getBlockingUsers(
  int32_t npwebapiUserCtxId,
  const ParameterToGetBlockingUsers &param,
  Common::Transaction<Common::IntrusivePtr<GetBlockingUsersResponse>> &transaction
  );

private:
 BlocksApi();
 ~BlocksApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/user_profile.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/FriendsApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/FriendsApi.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetFriendsResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetFriendsResponse.h" 2 3








namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class GetFriendsResponse : public PsnErrorObject
{
public:

 Common::IntrusivePtr< Common::Vector<SceNpAccountId> >& getFriends();
 int32_t setFriends(const Common::IntrusivePtr< Common::Vector<SceNpAccountId> >::value_type &friends) __attribute__((warn_unused_result));


 bool totalItemCountIsSet() const;
 void unsetTotalItemCount();
 int32_t getTotalItemCount() const;
 void setTotalItemCount(const int32_t &totalItemCount);


 bool nextOffsetIsSet() const;
 void unsetNextOffset();
 int32_t getNextOffset() const;
 void setNextOffset(const int32_t &nextOffset);


 bool previousOffsetIsSet() const;
 void unsetPreviousOffset();
 int32_t getPreviousOffset() const;
 void setPreviousOffset(const int32_t &previousOffset);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetFriendsResponse(Common::LibContext * context);
 friend class GetFriendsResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::GetFriendsResponse>;

 ~GetFriendsResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr< Common::Vector<SceNpAccountId> > m_friends;

 int32_t m_totalItemCount;
 bool m_totalItemCountIsSet;

 int32_t m_nextOffset;
 bool m_nextOffsetIsSet;

 int32_t m_previousOffset;
 bool m_previousOffsetIsSet;


    GetFriendsResponse();
};

class GetFriendsResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr< Common::Vector<SceNpAccountId> >::value_type &friends,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetFriendsResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetFriendsResponse> *instancePtr);


 static void destroy(GetFriendsResponse *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/FriendsApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class FriendsApi {
public:

 class ParameterToGetFriends : public Common::ParameterBase {
 public:
  ParameterToGetFriends();
  ~ParameterToGetFriends();

  enum class Filter {
   _NOT_SET = 0,
   kOnline,
  };

  enum class Order {
   _NOT_SET = 0,
   kOnlineid,
   kOnlinestatus,
   kOnlinestatusOnlineid,
  };

  int32_t initialize(
   Common::LibContext * context
   , const char* accountIdOrMe
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountIdOrMe() const;
  int32_t setaccountIdOrMe(const char* accountIdOrMe) __attribute__((warn_unused_result));


  int32_t getoffset() const;
  void setoffset(int32_t offset);
  void unsetoffset();
  bool hasoffset() const;


  int32_t getlimit() const;
  void setlimit(int32_t limit);
  void unsetlimit();
  bool haslimit() const;


  Filter getfilter() const;
  void setfilter(Filter filter);
  void unsetfilter();
  bool hasfilter() const;


  Order getorder() const;
  void setorder(Order order);
  void unsetorder();
  bool hasorder() const;

  struct ParameterImplToGetFriends;

 private:
  struct ParameterImplToGetFriends *m_pimpl;

  ParameterToGetFriends(ParameterToGetFriends &param);
  ParameterToGetFriends(const ParameterToGetFriends &param);
  ParameterToGetFriends& operator=(ParameterToGetFriends &param);
  ParameterToGetFriends& operator=(const ParameterToGetFriends &param);
 };

 static int32_t getFriends(
  int32_t npwebapiUserCtxId,
  const ParameterToGetFriends &param,
  Common::Transaction<Common::IntrusivePtr<GetFriendsResponse>> &transaction
  );

private:
 FriendsApi();
 ~FriendsApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/user_profile.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/PresenceApi.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/PresenceApi.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetBasicPresencesResponse.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetBasicPresencesResponse.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/BasicPresence.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/BasicPresence.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/OnlineStatus.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/OnlineStatus.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

 enum class OnlineStatus {
  _NOT_SET = 0,
  kOnline,
  kOffline,
 };


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/BasicPresence.h" 2 3





namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class BasicPresence : public Common::RefObject
{
public:

 bool accountIdIsSet() const;
 void unsetAccountId();
 SceNpAccountId getAccountId() const;
 void setAccountId(const SceNpAccountId &accountId);


 bool onlineStatusIsSet() const;
 void unsetOnlineStatus();
 OnlineStatus getOnlineStatus() const;
 void setOnlineStatus(const OnlineStatus &onlineStatus);


 bool inContextIsSet() const;
 void unsetInContext();
 bool getInContext() const;
 void setInContext(const bool &inContext);


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 BasicPresence(Common::LibContext * context);
 friend class BasicPresenceFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::BasicPresence>;

 ~BasicPresence();

private:
 Common::LibContext * m_context;

 SceNpAccountId m_accountId;
 bool m_accountIdIsSet;

 OnlineStatus m_onlineStatus;
 bool m_onlineStatusIsSet;

 bool m_inContext;
 bool m_inContextIsSet;


    BasicPresence();
};

class BasicPresenceFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  sce::Np::CppWebApi::Common::IntrusivePtr<BasicPresence> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<BasicPresence> *instancePtr);


 static void destroy(BasicPresence *instance);
};


}
}
}
}
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/UserProfile/V1/GetBasicPresencesResponse.h" 2 3






namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class GetBasicPresencesResponse : public PsnErrorObject
{
public:

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicPresence>>> getBasicPresences();
 int32_t setBasicPresences(const Common::Vector<Common::IntrusivePtr<BasicPresence>> &basicPresences) __attribute__((warn_unused_result));


 int32_t fromJson(const sce::Json::Value &value);
 int32_t toJson(sce::Json::Value &value, bool callFromParent = false) const;

 GetBasicPresencesResponse(Common::LibContext * context);
 friend class GetBasicPresencesResponseFactory;
 friend class Common::IntrusivePtr<sce::Np::CppWebApi::UserProfile::V1::GetBasicPresencesResponse>;

 ~GetBasicPresencesResponse();

private:
 Common::LibContext * m_context;

 Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicPresence>>> m_basicPresences;


    GetBasicPresencesResponse();
};

class GetBasicPresencesResponseFactory
{
public:
 static int32_t create(
  Common::LibContext * context,
  const Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicPresence>>>::value_type &basicPresences,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetBasicPresencesResponse> *instancePtr);

 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<PsnErrorObject> *instancePtr);
 static int32_t create(
  Common::LibContext * context,
  const sce::Json::Value &val,
  sce::Np::CppWebApi::Common::IntrusivePtr<GetBasicPresencesResponse> *instancePtr);


 static void destroy(GetBasicPresencesResponse *instance);
};


}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/userprofile/v1/PresenceApi.h" 2 3

namespace sce {
namespace Np {
namespace CppWebApi {
namespace UserProfile {
namespace V1 {

class PresenceApi {
public:

 class ParameterToGetBasicPresences : public Common::ParameterBase {
 public:
  ParameterToGetBasicPresences();
  ~ParameterToGetBasicPresences();

  int32_t initialize(
   Common::LibContext * context
   , const char* accountIds
   );

  int32_t terminate();

  bool isInitialized() const;


  const Common::String& getaccountIds() const;
  int32_t setaccountIds(const char* accountIds) __attribute__((warn_unused_result));

  struct ParameterImplToGetBasicPresences;

 private:
  struct ParameterImplToGetBasicPresences *m_pimpl;

  ParameterToGetBasicPresences(ParameterToGetBasicPresences &param);
  ParameterToGetBasicPresences(const ParameterToGetBasicPresences &param);
  ParameterToGetBasicPresences& operator=(ParameterToGetBasicPresences &param);
  ParameterToGetBasicPresences& operator=(const ParameterToGetBasicPresences &param);
 };

 static int32_t getBasicPresences(
  int32_t npwebapiUserCtxId,
  const ParameterToGetBasicPresences &param,
  Common::Transaction<Common::IntrusivePtr<GetBasicPresencesResponse>> &transaction
  );

private:
 PresenceApi();
 ~PresenceApi();

 static const char *s_apiGroup;
};

}
}
}
}
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi/user_profile.h" 2 3
# 334 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_cppwebapi.h" 2 3
# 7 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApi.h" 2

namespace sceCppWebApi = sce::Np::CppWebApi::Common;

using namespace sceCppWebApi;
using namespace sce::Np::CppWebApi;

namespace psn
{
# 37 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApi.h"
    class WebApiAllocator
    {
    public:
        WebApiAllocator() {}
        ~WebApiAllocator() {}
        static void *allocate(size_t size, void *user_data);
        static void deallocate(void *ptr, void *user_data);
        static void notifyError(int32_t error, size_t size, void *userData);
    };




    class WebApiUserContext
    {
    public:

        WebApiUserContext(SceUserServiceUserId userId);

        int Create(int32_t webapiLibCtxId);
        int Destroy();

        int32_t GetUserCtxId() { return m_webapiUserCtxId; }

        SceUserServiceUserId m_userId;
        int32_t m_webapiUserCtxId;

        int GetAccountId(SceNpAccountId* accountId)
        {
            *accountId = (0);
            return sceNpGetAccountIdA(m_userId, accountId);
        }

        int GetAccountIdStr(char* accountIdBuf, size_t bufferSize)
        {
            SceNpAccountId accountId;
            int ret = GetAccountId(&accountId);

            if (ret < 0)
            {
                return ret;
            }

            sprintf_s(accountIdBuf, bufferSize, "%lu", accountId);

            return 0;
        }
    };

    class WebApi
    {
    public:

    private:
        bool m_isInitialised;

        int32_t m_libnetMemId;
        int32_t m_libsslCtxId;
        int32_t m_libhttp2CtxId;

    public:

        int32_t m_webapiLibCtxId;
        Common::LibContext m_cppWebapiLibCtx;

        WebApiUserContext* FindUser(SceUserServiceUserId userId);

        int32_t GetLibCtxId() { return m_webapiLibCtxId; }
        Common::LibContext* GetLibCtx() { return &m_cppWebapiLibCtx; }

        int32_t GetLibHttp2CtxId() { return m_libhttp2CtxId; }

        static WebApi* Instance() { return s_webApiInstance; }

        static int Initialise();
        static void Terminate();

        static void HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result);


    private:

        sce::Json::Initializer m_initializer;



        WebApi();

        static WebApi* s_webApiInstance;

        int Create();
        void Destroy();

        static UserMap<WebApiUserContext> s_UsersList;
    };
# 147 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApi.h"
}
# 7 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApiNotifications.h" 2

# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApiPushEvents.h" 1







namespace psn
{





    class PushFilter
    {
    public:
        PushFilter();
        ~PushFilter();

        int Create(const char* serviceName, SceNpServiceLabel npServiceLabel, const char* filterTypes[], size_t filterTypesNum);
        int Destroy();

        int32_t GetFilterId() { return m_PushFilterId; }

        bool Deserialise(BinaryReader& reader, APIResult* result);

        void IncRefCount() { m_ReferenceCount++; }
        void DecRefCount() { m_ReferenceCount--; }
        int32_t GetRefCount() { return m_ReferenceCount; }

    private:

        int Register();

        int32_t m_PushHandleId;
        int32_t m_PushFilterId;

        char m_ServiceName[255];
        SceNpServiceLabel m_npServiceLabel;

        SceNpWebApi2PushEventFilterParameter* m_FilterParams;
        size_t m_NumberFilterParams;

        int32_t m_LastError;

        int32_t m_ReferenceCount;
    };

    class PushEventBase
    {
    public:

        PushEventBase();

        void SetFilter(PushFilter* filter) { m_Filter = filter; }
        PushFilter* GetFilter() { return m_Filter; }

        int32_t GetCallbackID() { return m_PushCallbackId; }

        bool IsOrderGuaranteed() { return m_IsOrderGuaranteed; }

    protected:
        WebApiUserContext* m_UserContext;
        PushFilter* m_Filter;
        int32_t m_PushCallbackId;
        bool m_IsOrderGuaranteed;
    };

    class PushEvent : public PushEventBase
    {
    public:
        PushEvent();
        ~PushEvent();

        int Create(WebApiUserContext* userContext, PushFilter* filter, SceNpWebApi2PushEventCallback cbFunc, void* pUserArg);
        int Destroy();

        bool Deserialise(BinaryReader& reader, WebApiUserContext* userContext, PushFilter* filter, SceNpWebApi2PushEventCallback cbFunc, void* pUserArg, APIResult* result);

    private:
    };

    class OrderGuaranteedPushEvent : public PushEventBase
    {
    public:
        OrderGuaranteedPushEvent();
        ~OrderGuaranteedPushEvent();

        int Create(WebApiUserContext* userContext, PushFilter* filter, SceNpWebApi2PushEventPushContextCallback cbFunc, void* pUserArg);
        int Destroy();

        SceNpWebApi2PushEventPushContextId* GetPushContextId() { return &m_PushContextId; }
        const char* GetPushContextIdStr() { return m_PushContextId.uuid; }

        bool Deserialise(BinaryReader& reader, WebApiUserContext* userContext, PushFilter* filter, SceNpWebApi2PushEventPushContextCallback cbFunc, void* pUserArg, APIResult* result);

    private:

        SceNpWebApi2PushEventPushContextId m_PushContextId;
        bool m_PushContextIdCreated;
    };
}
# 9 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApiNotifications.h" 2

# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Utils.h" 1






namespace psn
{



    int32_t addStringToVector(Common::LibContext* snccLibContext, const char* str, Common::Vector<Common::String>& vec);

    void GetAccountIdStr(SceNpAccountId accountId, char* accountIdBuf, size_t bufferSize);

    template<size_t ArraySize>
    inline void copyString(char(&dst)[ArraySize], const char* src)
    {
        strncpy(&dst[0], src, ArraySize - 1);
        dst[ArraySize - 1] = '\0';
    }

    template<size_t ArraySize>
    inline void toRtcDateTimeStr(char(&dst)[ArraySize], const char* timeMsStr)
    {
        static_assert(ArraySize >= 27, "too short");

        const unsigned long timeMs = strtoul(timeMsStr, nullptr, 10);
        const time_t timeSec = static_cast<time_t>(timeMs / 1000);

        SceRtcDateTime rtcDateTime;
        int ret = sceRtcSetTime_t(&rtcDateTime, timeSec);
        if (ret < 0)
        {

            return;
        }
        rtcDateTime.microsecond = (timeMs - (timeSec * 1000)) * 1000;

        snprintf(dst, ArraySize, "%04d-%02d-%02d %02d:%02d:%02d.%06d",
            sceRtcGetYear(&rtcDateTime), sceRtcGetMonth(&rtcDateTime), sceRtcGetDay(&rtcDateTime),
            sceRtcGetHour(&rtcDateTime), sceRtcGetMinute(&rtcDateTime), sceRtcGetSecond(&rtcDateTime),
            sceRtcGetMicrosecond(&rtcDateTime));
    }

    template<class ObjectType>
    class IDMap
    {
        std::map<int, ObjectType*> s_ObjectList;

    public:
        void Add(int id, ObjectType* instance)
        {
            s_ObjectList.insert(std::pair<int, ObjectType*>(id, instance));
        }

        ObjectType* Find(int internalId)
        {
            auto it = s_ObjectList.find(internalId);

            if (it == s_ObjectList.end())
            {
                return __null;
            }

            return it->second;
        }

        void Remove(int internalId)
        {
            auto it = s_ObjectList.find(internalId);

            if (it == s_ObjectList.end())
            {
                return;
            }

            s_ObjectList.erase(internalId);
        }

        bool DoesExist(int internalId)
        {
            auto it = s_ObjectList.find(internalId);

            if (it == s_ObjectList.end())
            {
                return false;
            }

            return true;
        }

        typedef void(*CleanUpCallback)(ObjectType* instance);

        void Clean(CleanUpCallback callback)
        {
            auto it = s_ObjectList.begin();
            while (it != s_ObjectList.end())
            {
                callback(it->second);

                delete it->second;

                s_ObjectList.erase(it->first);

                it = s_ObjectList.begin();
            }
        }
    };

    class Utils
    {
    public:
        static uint32_t GetThisPlatformFlag();
        static const char* GetThisPlatformString();
        static const char* ToPlatformString(uint32_t platformFlag);
        static uint32_t GetPlatformFlag(const char* platform);
        static int AddPlatformStrings(uint32_t platformFlags, Vector<String>& supportedPlatforms);

        static void DeletePtr(Vector<String>* ptr);

        static int InitializeCommonDialog();
    };
}
# 11 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApiNotifications.h" 2

namespace psn
{
# 31 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/WebApiNotifications.h"
    class WebApiNotifications
    {
    public:

        enum Methods
        {
            RegisterFilter = 0x0600001u,
            UnregisterFilter = 0x0600002u,
            RegisterPushEvent = 0x0600003u,
            UnregisterPushEvent = 0x0600004u,
        };


#pragma pack(1)
        struct CallbackExtdData
        {
            const char *extdDataKey;
            int32_t extdDataKeyLen;
            const char *pData;
            int32_t dataLen;
        };
#pragma pack()


#pragma pack(1)
        struct CallbackParams
        {
            int32_t userCtxId;
            int32_t callbackId;

            bool orderGuaranteed;

            const char *pNpServiceName;
            int32_t serviceNameLen;

            SceNpServiceLabel npServiceLabel;

            bool hasToPeer;
            SceNpAccountId toAccountId;
            SceNpPlatformType toPlatform;
            const char *toOnlineId;
            int32_t toOnlineIdLen;

            bool hasFromPeer;
            SceNpAccountId fromAccountId;
            SceNpPlatformType fromPlatform;
            const char *fromOnlineId;
            int32_t fromOnlineIdLen;

            const char *pDataType;
            int32_t dataTypeLen;

            const char *pData;
            int32_t dataLen;

            CallbackExtdData *extdData;
            int32_t extdDataNum;
            int32_t extdStructSize;

            const char* pushCtxId;
            int32_t pushCtxIdLen;
            int32_t cbType;
        };
#pragma pack()

        WebApiNotifications();
        ~WebApiNotifications();

        static WebApiNotifications* Instance() { return s_Instance; }

        static void Initialise();
        static void Terminate();

        static void RegisterMethods();

        static void HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result);

        static void RegisterFilterImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UnregisterFilterImpl(UInt8* sourceData, int sourceSize, APIResult* result);

        static void RegisterPushEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UnregisterPushEventImpl(UInt8* sourceData, int sourceSize, APIResult* result);

        static PushEventBase* FindPushEvent(int pushCallbackId);
        static OrderGuaranteedPushEvent* FindOrderedPushEvent(int pushCallbackId);

    private:
        static WebApiNotifications* s_Instance;

        std::list<SceNpGameIntentInfo> m_PendingGameIntentList;


        void Create();
        void Destroy();

        PushFilter* GetOrCreateFilter(BinaryReader& reader, APIResult* result);
        PushFilter* GetFilter(BinaryReader& reader, APIResult* result);

        static void CommonEventCallback(int32_t userCtxId, int32_t callbackId, const char *pNpServiceName, SceNpServiceLabel npServiceLabel,
            const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId,
            const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen,
            const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg,
            bool isOrderGuaranteed = false, const SceNpWebApi2PushEventPushContextId *pPushCtxId = __null,
            SceNpWebApi2PushEventPushContextCallbackType cbType = SceNpWebApi2PushEventPushContextCallbackType::SCE_NP_WEBAPI2_PUSH_EVENT_PUSH_CONTEXT_CALLBACK_TYPE_UNKNOWN);

        static void PushEventCallback(int32_t userCtxId, int32_t callbackId, const char *pNpServiceName, SceNpServiceLabel npServiceLabel,
            const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId,
            const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen,
            const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg);

        static void OrderGuaranteedEventCallback(int32_t userCtxId, int32_t callbackId,
            const SceNpWebApi2PushEventPushContextId *pPushCtxId, SceNpWebApi2PushEventPushContextCallbackType cbType,
            const char *pNpServiceName, SceNpServiceLabel npServiceLabel,
            const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId,
            const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen,
            const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg);

        IDMap<PushEventBase> m_ActivePushEvents;
        IDMap<PushFilter> m_ActivePushFilters;
    };
}
# 4 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Commerce.h" 2




namespace psn
{
    class CommerceCommands
    {
    public:

        enum Methods
        {
            OpenDialog = 0x0E00001u,
            UpdateDialog = 0x0E00002u,
            CloseDialog = 0x0E00003u,
            PSStoreIcon = 0x0E00004u,
        };

        static void RegisterMethods();

        static void OpenDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UpdateDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void CloseDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void PSStoreIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void InitializeLib();
        static void TerminateLib();

    private:

        static int InitialzeDialog();
        static int TerminateDialog();

        static bool s_DialogInitialized;
    };
}
# 2 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp" 2




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 1 3
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
namespace std {







template<class _Myvec>
 class _Vector_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Myvec::value_type,
   typename _Myvec::difference_type,
   typename _Myvec::const_pointer,
   typename _Myvec::const_reference,
   _Iterator_base>
 {
public:
 typedef _Vector_const_iterator<_Myvec> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec::value_type value_type;
 typedef typename _Myvec::difference_type difference_type;
 typedef typename _Myvec::const_pointer pointer;
 typedef typename _Myvec::const_reference reference;
 typedef typename _Myvec::pointer _Tptr;

 _Vector_const_iterator()
  : _Ptr()
  {
  }

 _Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
  : _Ptr(_Parg)
  {
  this->_Adopt(_Pvector);
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = (_Tptr)_Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
# 87 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  return (*this->_Ptr);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 113 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  ++this->_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 142 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  --this->_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
# 171 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  if (this->_Getcont() != _Right._Getcont())
   _Compat(_Right);
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
# 255 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 void _Compat(const _Myiter&) const
  {
  }


 _Tptr _Ptr;
 };

template<class _Myvec> inline
 typename _Vector_const_iterator<_Myvec>::_Unchecked_type
  _Unchecked(_Vector_const_iterator<_Myvec> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Myvec> inline
 _Vector_const_iterator<_Myvec>&
  _Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
   typename _Vector_const_iterator<_Myvec>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Myvec> inline
 _Vector_const_iterator<_Myvec> operator+(
  typename _Vector_const_iterator<_Myvec>::difference_type _Off,
  _Vector_const_iterator<_Myvec> _Next)
 {
 return (_Next += _Off);
 }


template<class _Myvec>
 class _Vector_iterator
  : public _Vector_const_iterator<_Myvec>
 {
public:
 typedef _Vector_iterator<_Myvec> _Myiter;
 typedef _Vector_const_iterator<_Myvec> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec::value_type value_type;
 typedef typename _Myvec::difference_type difference_type;
 typedef typename _Myvec::pointer pointer;
 typedef typename _Myvec::reference reference;

 _Vector_iterator()
  {
  }

 _Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
  : _Mybase(_Parg, _Pvector)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Myvec> inline
 typename _Vector_iterator<_Myvec>::_Unchecked_type
  _Unchecked(_Vector_iterator<_Myvec> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Myvec> inline
 _Vector_iterator<_Myvec>&
  _Rechecked(_Vector_iterator<_Myvec>& _Iter,
   typename _Vector_iterator<_Myvec>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Myvec> inline
 _Vector_iterator<_Myvec> operator+(
  typename _Vector_iterator<_Myvec>::difference_type _Off,
  _Vector_iterator<_Myvec> _Next)
 {
 return (_Next += _Off);
 }



template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _Vec_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _Vec_base_types
 {
# 450 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 typedef _Alloc0 _Alloc;


 typedef _Vec_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _Vec_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _Vector_val
  : public _Container_base
 {
public:
 typedef _Vector_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;






 typedef _Vector_iterator<_Myt> iterator;
 typedef _Vector_const_iterator<_Myt> const_iterator;


 _Vector_val()
  {
  _Myfirst = pointer();
  _Mylast = pointer();
  _Myend = pointer();
  }

 pointer _Myfirst;
 pointer _Mylast;
 pointer _Myend;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _Vector_alloc
  : public _Vector_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alty _Alty;


 _Vector_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alval(_Al)
  {
  }

 _Vector_alloc(_Alloc0&& _Al)
  : _Alval(::std:: move(_Al))
  {
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(this->_Alval, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(this->_Alval, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(this->_Alval, _Right._Alval);
  }
# 602 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 _Alty& _Getal() noexcept
  {
  return (_Alval);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alval);
  }

 _Alty _Alval;
 };

template<class _Alloc_types>
 class _Vector_alloc<false, _Alloc_types>
  : public _Vector_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _Vector_alloc<false, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alty _Alty;


 _Vector_alloc(const _Alloc0& = _Alloc0())
  {
  }

 _Vector_alloc(_Alloc0&&)
  {
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 694 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc = allocator<_Ty> >
 class vector
  : public _Vector_alloc<!is_empty<_Alloc>::value,
   _Vec_base_types<_Ty, _Alloc> >
 {
public:
 typedef vector<_Ty, _Alloc> _Myt;
 typedef _Vector_alloc<!is_empty<_Alloc>::value,
  _Vec_base_types<_Ty, _Alloc> > _Mybase;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
# 734 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;


 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 vector()
  : _Mybase()
  {
  }

 explicit vector(const _Alloc& _Al)
  : _Mybase(_Al)
  {
  }

 explicit vector(size_type _Count)
  : _Mybase()
  {
  if (_Buy(_Count))
   {
   _Alty _Alval(this->_Getal());
   {{
   _Uninitialized_default_fill_n(this->_Myfirst, _Count,
    _Alval);
   this->_Mylast += _Count;
   } if (0) {
   _Tidy();
           ;
   }}
   }
  }


 vector(size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  resize(_Count);
  }


 vector(size_type _Count, const _Ty& _Val)
  : _Mybase()
  {
  _Construct_n(_Count, ::std:: addressof(_Val));
  }

 vector(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct_n(_Count, ::std:: addressof(_Val));
  }

 vector(const _Myt& _Right)
  : _Mybase(_Right._Getal().select_on_container_copy_construction())
  {
  if (_Buy(_Right.size()))
   {{
   this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
    this->_Myfirst);
   } if (0) {
   _Tidy();
           ;
   }}
  }

 vector(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  if (_Buy(_Right.size()))
   {{
   this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
    this->_Myfirst);
   } if (0) {
   _Tidy();
           ;
   }}
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  vector(_Iter _First, _Iter _Last)
  : _Mybase()
  {
  _Construct(_First, _Last);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct(_First, _Last);
  }

 template<class _Iter>
            void _Construct(_Iter _First, _Iter _Last)
  {
  _Construct(_First, _Last, _Iter_cat(_First));
  }

 template<class _Iter>
            void _Construct(_Iter _First, _Iter _Last,
   input_iterator_tag)
  {
  {{
  for (; _First != _Last; ++_First)
   emplace_back(*_First);
  } if (0) {
  _Tidy();
          ;
  }}
  }

 template<class _Iter>
            void _Construct(_Iter _First, _Iter _Last,
   forward_iterator_tag)
  {
  if (_Buy(::std:: distance(_First, _Last)))
   {
   {{
   this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
   } if (0) {
   _Tidy();
           ;
   }}
   }
  }

           void _Construct_n(size_type _Count, const value_type *_Pval)
  {
  if (_Buy(_Count))
   {
   {{
   this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
   } if (0) {
   _Tidy();
           ;
   }}
   }
  }




 vector(_Myt&& _Right) noexcept(is_nothrow_move_constructible<_Alloc>::value)

  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  }

 vector(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

           _Myt& operator=(_Myt&& _Right)


  {
  if (this != &_Right)
   {
   _Tidy();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());

   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

           void _Assign_rv(_Myt&& _Right, true_type)
  {
  this->_Swap_all((_Myt&)_Right);
  this->_Myfirst = _Right._Myfirst;
  this->_Mylast = _Right._Mylast;
  this->_Myend = _Right._Myend;

  _Right._Myfirst = pointer();
  _Right._Mylast = pointer();
  _Right._Myend = pointer();
  }

           void _Assign_rv(_Myt&& _Right, false_type)
  {
  if (get_allocator() == _Right.get_allocator())
   _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  else
   _Construct(::std:: make_move_iterator(_Right.begin()),
    ::std:: make_move_iterator(_Right.end()));
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right),
   typename _Alty::propagate_on_container_move_assignment());
  }

 void push_back(value_type&& _Val)
  {
  if (_Inside(::std:: addressof(_Val)))
   {
   size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst;
   if (this->_Mylast == this->_Myend)
    _Reserve(1);
   _Orphan_range(this->_Mylast, this->_Mylast);
   this->_Getal().construct(this->_Mylast,
    ::std:: forward<value_type>(this->_Myfirst[_Idx]));
   ++this->_Mylast;
   }
  else
   {
   if (this->_Mylast == this->_Myend)
    _Reserve(1);
   _Orphan_range(this->_Mylast, this->_Mylast);
   this->_Getal().construct(this->_Mylast,
    ::std:: forward<value_type>(_Val));
   ++this->_Mylast;
   }
  }

 iterator insert(const_iterator _Where, _Ty&& _Val)
  {
  return (emplace(_Where, ::std:: move(_Val)));
  }

 template<class... _Valty>
  reference
  emplace_back(_Valty&&... _Val)
  {
  if (this->_Mylast == this->_Myend)
   _Reserve(1);
  _Orphan_range(this->_Mylast, this->_Mylast);
  this->_Getal().construct(::std:: addressof(*this->_Mylast),
   ::std:: forward<_Valty>(_Val)...);
  ++this->_Mylast;
  return (back());
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst;






  emplace_back(::std:: forward<_Valty>(_Val)...);
  ::std:: rotate(begin() + _Off, end() - 1, end());
  return (begin() + _Off);
  }

 vector(::std:: initializer_list<_Ty> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  _Construct(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<value_type> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<value_type> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~vector() noexcept
  {
  _Tidy();
  }

           _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    _Tidy();
    this->_Copy_alloc(_Right._Getal());
    }

   this->_Orphan_all();

   if (_Right.empty())
    clear();
   else if (_Right.size() <= size())
    {
    pointer _Ptr = _Copy_impl(_Right._Myfirst,
     _Right._Mylast, this->_Myfirst);
    _Destroy(_Ptr, this->_Mylast);
    this->_Mylast = this->_Myfirst + _Right.size();
    }
   else if (_Right.size() <= capacity())
    {
    pointer _Ptr = _Right._Myfirst + size();
    _Copy_impl(_Right._Myfirst,
     _Ptr, this->_Myfirst);
    this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
    }
   else
    {
    if (this->_Myfirst != pointer())
     {
     _Destroy(this->_Myfirst, this->_Mylast);
     this->_Getal().deallocate(this->_Myfirst,
      this->_Myend - this->_Myfirst);
     }
    if (_Buy(_Right.size()))
     {{
     this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
      this->_Myfirst);
     } if (0) {
     _Tidy();
             ;
     }}
    }
   }
  return (*this);
  }

 void reserve(size_type _Count)
  {
  if (capacity() < _Count)
   {
   if (max_size() < _Count)
    _Xlen();
   _Reallocate(_Count);
   }
  }

 size_type capacity() const noexcept
  {
  return (this->_Myend - this->_Myfirst);
  }

 size_type _Unused_capacity() const noexcept
  {
  return (this->_Myend - this->_Mylast);
  }

 size_type _Has_unused_capacity() const noexcept
  {
  return (this->_Myend != this->_Mylast);
  }
# 1125 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 iterator begin() noexcept
  {
  return (iterator(this->_Myfirst, this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Myfirst, this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Mylast, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Mylast, this));
  }

 iterator _Make_iter(const_iterator _Where) const
  {
  return (iterator(_Where._Ptr, this));
  }


 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if (_Has_unused_capacity())
   {
   if (empty())
    _Tidy();
   else
    _Reallocate(size());
   }
  }

           void resize(size_type _Newsize)
  {
  if (_Newsize < size())

   _Pop_back_n(size() - _Newsize);



  else if (size() < _Newsize)
   {
   _Alty _Alval(this->_Getal());
   _Reserve(_Newsize - size());
   {{
   _Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
    _Alval);
   } if (0) {
   _Tidy();
           ;
   }}
   this->_Mylast += _Newsize - size();
   }
  }

           void resize(size_type _Newsize, const value_type& _Val)
  {

  if (_Newsize < size())
   _Pop_back_n(size() - _Newsize);
  else if (size() < _Newsize)
   {
   const value_type *_Ptr = ::std:: addressof(_Val);

   if (_Inside(_Ptr))
    {
    const difference_type _Idx = _Ptr
     - ::std:: addressof(*this->_Myfirst);
    _Reserve(_Newsize - size());
    _Ptr = ::std:: addressof(*this->_Myfirst) + _Idx;
    }
   else
    _Reserve(_Newsize - size());

   {{
   _Ufill(this->_Mylast, _Newsize - size(), _Ptr);
   } if (0) {
   _Tidy();
           ;
   }}
   this->_Mylast += _Newsize - size();
   }






  }

 size_type size() const noexcept
  {
  return ((size_type)(this->_Mylast - this->_Myfirst));
  }

 size_type max_size() const noexcept
  {
  return (this->_Getal().max_size());
  }

 bool empty() const noexcept
  {
  return (this->_Myfirst == this->_Mylast);
  }

 _Alloc get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 const_reference at(size_type _Pos) const
  {
  if (size() <= _Pos)
   _Xran();
  return (*(this->_Myfirst + _Pos));
  }

 reference at(size_type _Pos)
  {
  if (size() <= _Pos)
   _Xran();
  return (*(this->_Myfirst + _Pos));
  }

 const_reference operator[](size_type _Pos) const
  {
# 1307 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  return (*(this->_Myfirst + _Pos));
  }

 reference operator[](size_type _Pos)
  {
# 1323 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  return (*(this->_Myfirst + _Pos));
  }

 _Ty *data() noexcept
  {
  return (this->_Myfirst);
  }

 const _Ty *data() const noexcept
  {
  return (this->_Myfirst);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

           void push_back(const value_type& _Val)
  {
  if (_Inside(::std:: addressof(_Val)))
   {
   size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst;
   if (this->_Mylast == this->_Myend)
    _Reserve(1);
   _Orphan_range(this->_Mylast, this->_Mylast);
   this->_Getal().construct(this->_Mylast,
    this->_Myfirst[_Idx]);
   ++this->_Mylast;
   }
  else
   {
   if (this->_Mylast == this->_Myend)
    _Reserve(1);
   _Orphan_range(this->_Mylast, this->_Mylast);
   this->_Getal().construct(this->_Mylast,
    _Val);
   ++this->_Mylast;
   }
  }
# 1393 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
           void pop_back()
  {
  if (!empty())
   {
   this->_Getal().destroy(this->_Mylast - 1);
   --this->_Mylast;
   }
  }


 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  void assign(_Iter _First, _Iter _Last)
  {
  clear();
  _Assign(_First, _Last, _Iter_cat(_First));
  }

 template<class _Iter>
            void _Assign(_Iter _First, _Iter _Last,
   input_iterator_tag)
  {
  for (; _First != _Last; ++_First)
   emplace_back(*_First);
  }

 template<class _Iter>
            void _Assign(_Iter _First, _Iter _Last,
   forward_iterator_tag)
  {
  size_type _Newsize = ::std:: distance(_First, _Last);

  if (capacity() < _Newsize)
   {
   size_type _Newcapacity = _Grow_to(_Newsize);
   _Tidy();
   _Buy(_Newcapacity);
   }

  this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
  }

 void assign(size_type _Count, const value_type& _Val)
  {
  clear();
  insert(begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const _Ty& _Val)
  {
  return (_Insert_n(_Where, (size_type)1, _Val));
  }

 iterator insert(const_iterator _Where, size_type _Count,
  const _Ty& _Val)
  {
  return (_Insert_n(_Where, _Count, _Val));
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst;
  _Insert(_Where, _First, _Last, _Iter_cat(_First));
  return (begin() + _Off);
  }

 template<class _Iter>
            void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
    input_iterator_tag)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst;






  if (_First != _Last)
   {
   size_type _Oldsize = size();

   {{
   for (; _First != _Last; ++_First)
    push_back(*_First);

   } if (0) {
   erase(begin() + _Oldsize, end());
           ;
   }}

   ::std:: rotate(begin() + _Off, begin() + _Oldsize, end());
   }
  }

 template<class _Iter>
            void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
    forward_iterator_tag)
  {
# 1505 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  size_type _Count = 0;
  _Distance(_First, _Last, _Count);

  if (_Count == 0)
   ;
  else if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();

   size_type _Capacity = _Grow_to(size() + _Count);
   pointer _Newvec = this->_Getal().allocate(_Capacity);
   pointer _Ptr = _Newvec;

   {{
   _Ptr = _Umove(this->_Myfirst, (_Where)._Ptr,
    _Newvec);
   _Ptr = _Ucopy(_First, _Last, _Ptr);
   _Umove((_Where)._Ptr, this->_Mylast,
    _Ptr);
   } if (0) {
   _Destroy(_Newvec, _Ptr);
   this->_Getal().deallocate(_Newvec, _Capacity);
           ;
   }}

   _Count += size();
   if (this->_Myfirst != pointer())
    {
    _Destroy(this->_Myfirst, this->_Mylast);
    this->_Getal().deallocate(this->_Myfirst,
     this->_Myend - this->_Myfirst);
    }

   this->_Orphan_all();
   this->_Myend = _Newvec + _Capacity;
   this->_Mylast = _Newvec + _Count;
   this->_Myfirst = _Newvec;
   }
  else
   {
   _Ucopy(_First, _Last, this->_Mylast);
   ::std:: rotate((_Where)._Ptr, this->_Mylast,
    this->_Mylast + _Count);
   this->_Mylast += _Count;
   _Orphan_range((_Where)._Ptr, this->_Mylast);
   }
  }
# 1569 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
           iterator erase(const_iterator _Where)
  {
  _Move((_Where)._Ptr + 1, this->_Mylast,
   (_Where)._Ptr);
  _Destroy(this->_Mylast - 1, this->_Mylast);
  --this->_Mylast;
  return (_Make_iter(_Where));
  }


           iterator erase(const_iterator _First_arg,
  const_iterator _Last_arg)
  {
  if (_First_arg == begin() && _Last_arg == end())
   clear();
  else if (_First_arg != _Last_arg)
   {
   iterator _First = _Make_iter(_First_arg);
   iterator _Last = _Make_iter(_Last_arg);

   if (_First != _Last)
    {
# 1601 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
    pointer _Ptr = _Move((_Last)._Ptr, this->_Mylast,
     (_First)._Ptr);


    _Destroy(_Ptr, this->_Mylast);
    this->_Mylast = _Ptr;
    }
   }
  return (_Make_iter(_First_arg));
  }


 void _Pop_back_n(size_type _Count)
  {
  pointer _Ptr = this->_Mylast - _Count;





  _Destroy(_Ptr, this->_Mylast);
  this->_Mylast = _Ptr;
  }


 void clear() noexcept
  {
  this->_Orphan_all();
  _Destroy(this->_Myfirst, this->_Mylast);
  this->_Mylast = this->_Myfirst;
  }

           void swap(_Myt& _Right)


  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_adl(this->_Myfirst, _Right._Myfirst);
   _Swap_adl(this->_Mylast, _Right._Mylast);
   _Swap_adl(this->_Myend, _Right._Myend);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   _Swap_adl(this->_Myfirst, _Right._Myfirst);
   _Swap_adl(this->_Mylast, _Right._Mylast);
   _Swap_adl(this->_Myend, _Right._Myend);
   }
  else
   {




   ::std:: terminate();

   }
  }

protected:
           bool _Buy(size_type _Capacity)
  {
  this->_Myfirst = pointer();
  this->_Mylast = pointer();
  this->_Myend = pointer();

  if (_Capacity == 0)
   return (false);
  else if (max_size() < _Capacity)
   _Xlen();
  else
   {
   this->_Myfirst = this->_Getal().allocate(_Capacity);
   this->_Mylast = this->_Myfirst;
   this->_Myend = this->_Myfirst + _Capacity;
   }
  return (true);
  }

 void _Destroy(pointer _First, pointer _Last)
  {
  _Alty _Alval(this->_Getal());
  _Destroy_range(_First, _Last, _Alval);
  }

 size_type _Grow_to(size_type _Count) const
  {
  size_type _Capacity = capacity();

  _Capacity = max_size() - _Capacity / 2 < _Capacity
   ? 0 : _Capacity + _Capacity / 2;
  if (_Capacity < _Count)
   _Capacity = _Count;
  return (_Capacity);
  }

 bool _Inside(const value_type *_Ptr) const
  {
  return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
  }

           void _Reallocate(size_type _Count)
  {
  pointer _Ptr = this->_Getal().allocate(_Count);

  {{
  _Umove(this->_Myfirst, this->_Mylast, _Ptr);
  } if (0) {
  this->_Getal().deallocate(_Ptr, _Count);
          ;
  }}

  size_type _Size = size();
  if (this->_Myfirst != pointer())
   {
   _Destroy(this->_Myfirst, this->_Mylast);
   this->_Getal().deallocate(this->_Myfirst,
    this->_Myend - this->_Myfirst);
   }

  this->_Orphan_all();
  this->_Myend = _Ptr + _Count;
  this->_Mylast = _Ptr + _Size;
  this->_Myfirst = _Ptr;
  }

           void _Reserve(size_type _Count)
  {
  if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();
   _Reallocate(_Grow_to(size() + _Count));
   }
  }

           void _Tidy()
  {
  if (this->_Myfirst != pointer())
   {
   this->_Orphan_all();
   _Destroy(this->_Myfirst, this->_Mylast);
   this->_Getal().deallocate(this->_Myfirst,
    (size_type)(this->_Myend - this->_Myfirst));
   this->_Myfirst = pointer();
   this->_Mylast = pointer();
   this->_Myend = pointer();
   }
  }

 template<class _Iter>
  pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
  {
  _Alty _Alval(this->_Getal());
  return (_Uninitialized_copy(_First, _Last,
   _Ptr, _Alval));
  }

 template<class _Iter>
  pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
  {
  _Alty _Alval(this->_Getal());
  return (_Uninitialized_move(_First, _Last,
   _Ptr, _Alval));
  }

           iterator _Insert_n(const_iterator _Where,
  size_type _Count, const value_type& _Val)
  {







  size_type _Off = (_Where)._Ptr - this->_Myfirst;
  if (_Count == 0)
   ;
  else if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();

   size_type _Capacity = _Grow_to(size() + _Count);
   pointer _Newvec = this->_Getal().allocate(_Capacity);
   size_type _Whereoff = (_Where)._Ptr - this->_Myfirst;
   int _Ncopied = 0;

   {{
   _Ufill(_Newvec + _Whereoff, _Count,
    ::std:: addressof(_Val));
   ++_Ncopied;
   _Umove(this->_Myfirst, (_Where)._Ptr,
    _Newvec);
   ++_Ncopied;
   _Umove((_Where)._Ptr, this->_Mylast,
    _Newvec + (_Whereoff + _Count));
   } if (0) {
   if (1 < _Ncopied)
    _Destroy(_Newvec, _Newvec + _Whereoff);
   if (0 < _Ncopied)
    _Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
   this->_Getal().deallocate(_Newvec, _Capacity);
           ;
   }}

   _Count += size();
   if (this->_Myfirst != pointer())
    {
    _Destroy(this->_Myfirst, this->_Mylast);
    this->_Getal().deallocate(this->_Myfirst,
     this->_Myend - this->_Myfirst);
    }

   this->_Orphan_all();
   this->_Myend = _Newvec + _Capacity;
   this->_Mylast = _Newvec + _Count;
   this->_Myfirst = _Newvec;
   }
  else if ((size_type)(this->_Mylast - (_Where)._Ptr)
   < _Count)
   {
   value_type _Tmp = _Val;

   _Umove((_Where)._Ptr, this->_Mylast,
    (_Where)._Ptr + _Count);

   {{
   _Ufill(this->_Mylast,
    _Count - (this->_Mylast - (_Where)._Ptr),
    ::std:: addressof(_Tmp));
   } if (0) {
   _Destroy((_Where)._Ptr + _Count,
    this->_Mylast + _Count);
           ;
   }}

   this->_Mylast += _Count;
   _Orphan_range((_Where)._Ptr, this->_Mylast);
   ::std:: fill((_Where)._Ptr, this->_Mylast - _Count,
    _Tmp);
   }
  else
   {
   value_type _Tmp = _Val;

   pointer _Oldend = this->_Mylast;
   this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
    this->_Mylast);

   _Orphan_range((_Where)._Ptr, this->_Mylast);
   _Move_backward((_Where)._Ptr, _Oldend - _Count,
    _Oldend);
   ::std:: fill((_Where)._Ptr,
    (_Where)._Ptr + _Count, _Tmp);
   }
  return (begin() + _Off);
  }

 pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
  {
  _Alty _Alval(this->_Getal());
  _Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
  return (_Ptr + _Count);
  }

 void _Xlen() const
  {
  _Xlength_error("vector<T> too long");
  }

 void _Xran() const
  {
  _Xout_of_range("invalid vector<T> subscript");
  }
# 1901 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 void _Orphan_range(pointer, pointer) const
  {
  }

 };
# 1915 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
template<class _Ty,
 class _Alloc> inline
 void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator==(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator!=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }




typedef unsigned int _Vbase;
const int _VBITS = 8 * sizeof (_Vbase);


template<class _Alloc>
 class _Vb_iter_base
  : public _Iterator012<random_access_iterator_tag,
   bool,
   typename _Alloc::difference_type,
   bool *,
   bool,
   _Iterator_base>
 {
public:
 typedef typename _Alloc::size_type _Sizet;
 typedef vector<bool, _Alloc> _Mycont;

 _Vb_iter_base()
  : _Myptr(0), _Myoff(0)
  {
  }

 _Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
  const _Container_base *_Mypvbool)
  : _Myptr(_Ptr), _Myoff(_Off)
  {
  this->_Adopt(_Mypvbool);
  }

 void _Advance(_Sizet _Off)
  {
  _Myoff += _Off;
  _Myptr += _Myoff / _VBITS;
  _Myoff %= _VBITS;
  }

 int _Valid(_Sizet _Inc) const
  {
# 2024 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  return (-1);

  }

 const _Vbase *_Myptr;
 _Sizet _Myoff;
 };


template<class _Alloc>
 class _Vb_reference
  : public _Vb_iter_base<_Alloc>
 {
 typedef _Vb_iter_base<_Alloc> _Mybase;
 typedef _Vb_reference<_Alloc> _Mytype;

 _Vb_reference() noexcept
  {
  }

public:
 _Vb_reference(const _Mybase& _Right)
  : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
  {
  }

 _Mytype& operator=(const _Mytype& _Right) noexcept
  {
  return (*this = bool(_Right));
  }

 _Mytype& operator=(bool _Val) noexcept
  {
  if (_Val)
   *(_Vbase *)_Getptr() |= _Mask();
  else
   *(_Vbase *)_Getptr() &= (~_Mask());
  return (*this);
  }

 void flip() noexcept
  {
  *(_Vbase *)_Getptr() ^= _Mask();
  }

 operator bool() const noexcept
  {
  return ((*_Getptr() & _Mask()) != 0);
  }

 const _Vbase *_Getptr() const
  {
# 2090 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  return (this->_Myptr);
  }

protected:
 _Vbase _Mask() const
  {
  return ((_Vbase)(1) << this->_Myoff);
  }
 };

template<class _Alloc> inline
 void swap(_Vb_reference<_Alloc> _Left,
  _Vb_reference<_Alloc> _Right)
 {
 bool _Val = _Left;
 _Left = _Right;
 _Right = _Val;
 }


template<class _Alloc>
 class _Vb_const_iterator
  : public _Vb_iter_base<_Alloc>
 {
public:
 typedef _Vb_iter_base<_Alloc> _Mybase;
 typedef _Vb_const_iterator<_Alloc> _Mytype;

 typedef _Vb_reference<_Alloc> _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef bool value_type;
 typedef typename _Alloc::size_type size_type;
 typedef typename _Alloc::difference_type difference_type;
 typedef const_reference *pointer;
 typedef const_reference reference;

 _Vb_const_iterator()
  {
  }

 _Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
  : _Mybase(_Ptr, 0, _Mypvbool)
  {
  }

 const_reference operator*() const
  {
  return (_Reft(*this));
  }

 _Mytype& operator++()
  {
  _Inc();
  return (*this);
  }

 _Mytype operator++(int)
  {
  _Mytype _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Mytype& operator--()
  {
  _Dec();
  return (*this);
  }

 _Mytype operator--(int)
  {
  _Mytype _Tmp = *this;
  --*this;
  return (_Tmp);
  }

           _Mytype& operator+=(difference_type _Off)
  {
  if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
   {
   this->_Myoff += _Off;
   this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
   this->_Myoff %= _VBITS;
   }
  else
   {
   this->_Myoff += _Off;
   this->_Myptr += this->_Myoff / _VBITS;
   this->_Myoff %= _VBITS;
   }
  return (*this);
  }

 _Mytype operator+(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Mytype& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Mytype operator-(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(
  const _Mytype& _Right) const
  {
  _Compat(_Right);
  return (_VBITS * (this->_Myptr - _Right._Myptr)
   + (difference_type)this->_Myoff
   - (difference_type)_Right._Myoff);
  }

 const_reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Mytype& _Right) const
  {
  if (this->_Getcont() != _Right._Getcont())
   _Compat(_Right);
  return (this->_Myptr == _Right._Myptr
   && this->_Myoff == _Right._Myoff);
  }

 bool operator!=(const _Mytype& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Mytype& _Right) const
  {
  _Compat(_Right);
  return (this->_Myptr < _Right._Myptr
   || (this->_Myptr == _Right._Myptr
    && this->_Myoff < _Right._Myoff));
  }

 bool operator>(const _Mytype& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Mytype& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Mytype& _Right) const
  {
  return (!(*this < _Right));
  }
# 2268 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 void _Compat(const _Mytype&) const
  {
  }


           void _Dec()
  {
  if (this->_Myoff != 0)
   --this->_Myoff;
  else
   {
# 2291 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
   this->_Myoff = _VBITS - 1;
   --this->_Myptr;
   }
  }

           void _Inc()
  {
  if (this->_Myoff < _VBITS - 1)
   ++this->_Myoff;
  else
   {
# 2314 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
   this->_Myoff = 0;
   ++this->_Myptr;
   }
  }
 };

template<class _Alloc> inline
 _Vb_const_iterator<_Alloc> operator+(
  typename _Alloc::difference_type _Off,
  _Vb_const_iterator<_Alloc> _Right)
  {
  return (_Right += _Off);
  }

template<class _Alloc>
 struct _Is_checked_helper<_Vb_const_iterator<_Alloc> >
  : public true_type
 {
 };


template<class _Alloc>
 class _Vb_iterator
  : public _Vb_const_iterator<_Alloc>
 {
public:
 typedef _Vb_const_iterator<_Alloc> _Mybase;
 typedef _Vb_iterator<_Alloc> _Mytype;

 typedef _Vb_reference<_Alloc> _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef bool value_type;
 typedef typename _Alloc::size_type size_type;
 typedef typename _Alloc::difference_type difference_type;
 typedef _Reft *pointer;
 typedef _Reft reference;

 _Vb_iterator()
  {
  }

 _Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
  : _Mybase(_Ptr, _Mypvbool)
  {
  }

 reference operator*() const
  {
  return (_Reft(*this));
  }

 _Mytype& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Mytype operator++(int)
  {
  _Mytype _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Mytype& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Mytype operator--(int)
  {
  _Mytype _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Mytype& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Mytype operator+(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Mytype& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Mytype operator-(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Alloc> inline
 _Vb_iterator<_Alloc> operator+(typename _Alloc::difference_type _Off,
  _Vb_iterator<_Alloc> _Right)
  {
  return (_Right += _Off);
  }

template<class _Alloc>
 struct _Is_checked_helper<_Vb_iterator<_Alloc> >
  : public true_type
 {
 };


template<class _Alloc>
 class _Vb_val
  : public _Container_base
 {
public:
 typedef vector<_Vbase, _Alloc> _Vectype;
 typedef typename _Vectype::_Alty _Alty;
 typedef typename _Alty::size_type size_type;

 _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
  : _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
  {
  _Alloc_proxy();
  _Mysize = 0;
  }

 _Vb_val(const _Vb_val& _Right)
  : _Myvec(_Right._Myvec),
   _Mysize(_Right._Mysize)
  {
  _Alloc_proxy();
  }

 _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
  : _Myvec(_Right._Myvec, _Al),
   _Mysize(_Right._Mysize)
  {
  _Alloc_proxy();
  }

 _Vb_val(_Vb_val&& _Right)
  : _Myvec(::std:: forward<_Vectype>(_Right._Myvec)),
   _Mysize(_Right._Mysize)
  {
  _Right._Mysize = 0;
  _Alloc_proxy();
  }

 _Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
  : _Myvec(::std:: forward<_Vectype>(_Right._Myvec), _Al),
   _Mysize(_Right._Mysize)
  {
  _Right._Mysize = 0;
  _Alloc_proxy();
  }

 ~_Vb_val() noexcept
  {
  _Free_proxy();
  }


 void _Swap_alloc(_Vb_val&)
  {
  }

 void _Alloc_proxy()
  {
  }

 void _Free_proxy()
  {
  }
# 2531 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 static size_type _Nw(size_type _Count)
  {
  return ((_Count + _VBITS - 1) / _VBITS);
  }

 _Vectype _Myvec;
 typename _Alty::size_type _Mysize;
 };


template<class _Alloc>
 class vector<bool, _Alloc>
  : public _Vb_val<_Alloc>
 {
public:
 typedef vector<bool, _Alloc> _Myt;
 typedef _Vb_val<_Alloc> _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Vectype _Vectype;

 typedef typename _Alty::size_type size_type;
 typedef typename _Alty::difference_type difference_type;
 typedef bool _Ty;
 typedef _Alloc allocator_type;

 typedef _Vb_reference<_Alty> reference;
 typedef bool const_reference;
 typedef bool value_type;

 typedef reference _Reft;
 typedef _Vb_const_iterator<_Alty> const_iterator;
 typedef _Vb_iterator<_Alty> iterator;

 typedef iterator pointer;
 typedef const_iterator const_pointer;
 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 static const int _VBITS = ::std:: _VBITS;

 vector()
  : _Mybase(0, false)
  {
  }

 explicit vector(const _Alloc& _Al)
  : _Mybase(0, false, _Al)
  {
  }

 explicit vector(size_type _Count, const _Alloc& _Al = _Alloc())
  : _Mybase(_Count, false, _Al)
  {
  _Trim(_Count);
  }

 vector(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
  : _Mybase(_Count, _Val, _Al)
  {
  _Trim(_Count);
  }

 vector(const _Myt& _Right)
  : _Mybase(_Right)
  {
  }

 vector(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
  : _Mybase(0, false, _Al)
  {
  _BConstruct(_First, _Last);
  }

 template<class _Iter>
  void _BConstruct(_Iter _First, _Iter _Last)
  {
  insert(begin(), _First, _Last);
  }

 vector(_Myt&& _Right)
  : _Mybase(::std:: forward<_Myt>(_Right))
  {
  }

 vector(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(::std:: forward<_Myt>(_Right), _Al)
  {
  }

           _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   clear();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->get_allocator() != _Right.get_allocator())
    {
    this->_Free_proxy();
    this->_Myvec = ::std:: move(_Right._Myvec);
    this->_Alloc_proxy();
    }
   else
    this->_Myvec = ::std:: move(_Right._Myvec);

   this->_Mysize = _Right._Mysize;
   _Right._Mysize = 0;
   }
  return (*this);
  }


 template<class... _Valty>
  reference
  emplace_back(_Valty&&... _Val)
  {
  bool _Tmp(::std:: forward<_Valty>(_Val)...);
  push_back(_Tmp);
  return (back());
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {
  bool _Tmp(::std:: forward<_Valty>(_Val)...);
  return (insert(_Where, _Tmp));
  }


 vector(::std:: initializer_list<bool> _Ilist,
   const _Alloc& _Al = allocator_type())
  : _Mybase(0, false, _Al)
  {
  insert(begin(), _Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<bool> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<bool> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
   ::std:: initializer_list<bool> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~vector() noexcept
  {
  }

 _Myt& operator=(const _Myt& _Right)
  {
  this->_Mysize = _Right._Mysize;
  this->_Myvec = _Right._Myvec;
  return (*this);
  }

 void reserve(size_type _Count)
  {
  this->_Myvec.reserve(this->_Nw(_Count));
  }

 size_type capacity() const noexcept
  {
  return (this->_Myvec.capacity() * _VBITS);
  }

           iterator begin() noexcept
  {
  return (iterator((_Vbase *)this->_Myvec._Myfirst, this));
  }

           const_iterator begin() const noexcept
  {
  return (const_iterator((_Vbase *)this->_Myvec._Myfirst, this));
  }

           iterator end() noexcept
  {
  iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += this->_Mysize;
  return (_Tmp);
  }

           const_iterator end() const noexcept
  {
  const_iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += this->_Mysize;
  return (_Tmp);
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if (this->_Myvec._Has_unused_capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 iterator _Make_iter(const_iterator _Where)
  {
  iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += _Where - begin();
  return (_Tmp);
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

           void resize(size_type _Newsize, bool _Val = false)
  {
  if (size() < _Newsize)
   _Insert_n(end(), _Newsize - size(), _Val);
  else if (_Newsize < size())
   erase(begin() + _Newsize, end());
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  const size_type _Maxsize = this->_Myvec.max_size();
  return (_Maxsize < (size_type)(-1) / _VBITS
   ? _Maxsize * _VBITS : (size_type)(-1));
  }

 bool empty() const noexcept
  {
  return (size() == 0);
  }

 _Alloc get_allocator() const noexcept
  {
  return (this->_Myvec.get_allocator());
  }

 const_reference at(size_type _Off) const
  {
  if (size() <= _Off)
   _Xran();
  return ((*this)[_Off]);
  }

 reference at(size_type _Off)
  {
  if (size() <= _Off)
   _Xran();
  return ((*this)[_Off]);
  }

 const_reference operator[](size_type _Off) const
  {
  const_iterator _It = begin();
  _It._Advance(_Off);
  return (*_It);
  }

 reference operator[](size_type _Off)
  {
  iterator _It = begin();
  _It._Advance(_Off);
  return (*_It);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 void push_back(const bool& _Val)
  {
  insert(end(), _Val);
  }

 void pop_back()
  {
  if (!empty())
   erase(end() - 1);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  void assign(_Iter _First, _Iter _Last)
  {
  erase(begin(), end());
  insert(begin(), _First, _Last);
  }

 void assign(size_type _Count, const bool& _Val)
  {
  erase(begin(), end());
  _Insert_n(begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const bool& _Val)
  {
  return (_Insert_n(_Where, (size_type)1, _Val));
  }

 iterator insert(const_iterator _Where, size_type _Count,
  const bool& _Val)
  {
  return (_Insert_n(_Where, _Count, _Val));
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = _Where - begin();
  _Insert(_Where, _First, _Last, _Iter_cat(_First));
  return (begin() + _Off);
  }

 template<class _Iter>
            void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
    input_iterator_tag)
  {
  size_type _Off = _Where - begin();

  for (; _First != _Last; ++_First, (void)++_Off)
   insert(begin() + _Off, *_First);
  }

 template<class _Iter>
            void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
   forward_iterator_tag)
  {
                             ;
  size_type _Count = 0;
  _Distance(_First, _Last, _Count);

  size_type _Off = _Insert_x(_Where, _Count);
  ::std:: copy(_First, _Last, begin() + _Off);
  }

           iterator erase(const_iterator _Where_arg)
  {
  iterator _Where = _Make_iter(_Where_arg);
  size_type _Off = _Where - begin();
# 2956 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
  ::std:: copy(_Where + 1, end(), _Where);


  _Trim(this->_Mysize - 1);
  return (begin() + _Off);
  }

           iterator erase(const_iterator _First_arg,
  const_iterator _Last_arg)
  {
  iterator _First = _Make_iter(_First_arg);
  iterator _Last = _Make_iter(_Last_arg);
  size_type _Off = _First - begin();

  if (_First != _Last)
   {
# 2981 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
   iterator _Next = ::std:: copy(_Last, end(), _First);
   _Trim(_Next - begin());

   }
  return (begin() + _Off);
  }

 void clear() noexcept
  {
  erase(begin(), end());
  }

           void flip() noexcept
  {
  for (typename _Vectype::iterator _Next = this->_Myvec.begin();
   _Next != this->_Myvec.end(); ++_Next)
   *_Next = (_Vbase)~*_Next;
  _Trim(this->_Mysize);
  }

           void swap(_Myt& _Right)
  {
  if (this == &_Right)
   ;
  else if (this->get_allocator() == _Right.get_allocator())
   {
   this->_Swap_all(_Right);
   this->_Myvec.swap(_Right._Myvec);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   this->_Myvec.swap(_Right._Myvec);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else
   {




   ::std:: terminate();

   }
  }

 static void swap(reference _Left, reference _Right) noexcept
  {
  bool _Val = _Left;

  _Left = _Right;
  _Right = _Val;
  }

 size_t hash() const
  {
  return (_Hash_seq((const unsigned char *)this->_Myvec.data(),
   this->_Myvec.size() * sizeof (_Vbase)));
  }
# 3076 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 iterator _Insert_n(const_iterator _Where,
  size_type _Count, const bool& _Val)
  {
  size_type _Off = _Insert_x(_Where, _Count);
  ::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
  return (begin() + _Off);
  }

           size_type _Insert_x(const_iterator _Where, size_type _Count)
  {
  size_type _Off = _Where - begin();







  if (_Count == 0)
   ;
  else if (max_size() - size() < _Count)
   _Xlen();
  else
   {
   this->_Myvec.resize(this->_Nw(size() + _Count), 0);
   if (empty())
    this->_Mysize += _Count;
   else
    {
    iterator _Oldend = end();
    this->_Mysize += _Count;
    ::std:: copy_backward(begin() + _Off, _Oldend, end());
    }




   }
  return (_Off);
  }
# 3142 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
 void _Orphan_range(size_type, size_type) const
  {
  }


           void _Trim(size_type _Size)
  {
  if (max_size() < _Size)
   _Xlen();
  size_type _Words = this->_Nw(_Size);

  if (_Words < this->_Myvec.size())
   this->_Myvec.erase(this->_Myvec.begin() + _Words,
    this->_Myvec.end());
  this->_Mysize = _Size;
  _Size %= _VBITS;
  if (0 < _Size)
   this->_Myvec[_Words - 1] &= ((_Vbase)(1) << _Size) - 1;
  }

 void _Xlen() const
  {
  _Xlength_error("vector<bool> too long");
  }

 void _Xran() const
  {
  _Xout_of_range("invalid vector<bool> subscript");
  }
 };
# 3181 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
typedef vector<bool, allocator<bool> > _Bvector;

typedef _Bvector bit_vector;



template<class _Alloc> inline
 bool operator==(const vector<bool, _Alloc>& _Left,
  const vector<bool, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left._Myvec.begin(), _Left._Myvec.end(),
   _Right._Myvec.begin()));
 }

template<class _Alloc> inline
 bool operator!=(const vector<bool, _Alloc>& _Left,
  const vector<bool, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }
}
namespace std {

template<class _Alloc>
 struct hash<vector<bool, _Alloc> >
 {
 typedef vector<bool, _Alloc> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Keyval.hash());
  }
 };
}
namespace std {
# 3238 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\vector" 3
}
# 7 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp" 2
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_commerce_dialog.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_commerce_dialog.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/error.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/types.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/types.h" 3
typedef enum SceCommonDialogStatus {
 SCE_COMMON_DIALOG_STATUS_NONE = 0,
 SCE_COMMON_DIALOG_STATUS_INITIALIZED = 1,
 SCE_COMMON_DIALOG_STATUS_RUNNING = 2,
 SCE_COMMON_DIALOG_STATUS_FINISHED = 3
} SceCommonDialogStatus;

typedef enum SceCommonDialogResult {
 SCE_COMMON_DIALOG_RESULT_OK = 0,
 SCE_COMMON_DIALOG_RESULT_USER_CANCELED = 1,
} SceCommonDialogResult;

typedef struct SceCommonDialogBaseParam {
 size_t size;
 uint8_t reserved[36];
 uint32_t magic;
} SceCommonDialogBaseParam __attribute__ ((__aligned__(8)));
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/common_api.h" 1 3
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/common_api.h" 3
extern "C" {


int32_t sceCommonDialogInitialize();
bool sceCommonDialogIsUsed();

static inline
void _sceCommonDialogSetMagicNumber( uint32_t* magic, const SceCommonDialogBaseParam* param )
{
 *magic = (uint32_t)( 0xC0D1A109 + (uint64_t)param );
}

static inline
void _sceCommonDialogBaseParamInit(SceCommonDialogBaseParam *param)
{
 memset(param, 0x0, sizeof(SceCommonDialogBaseParam));
 param->size = (uint32_t)sizeof(SceCommonDialogBaseParam);
 _sceCommonDialogSetMagicNumber( &(param->magic), param );
}


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog.h" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_commerce_dialog.h" 2 3






extern "C" {
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_commerce_dialog.h" 3
typedef int32_t SceNpCommerceDialogMode;
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np_commerce_dialog.h" 3
typedef int32_t SceNpCommerceServiceName;





typedef int32_t SceNpCommerceDialogMode;




typedef struct SceNpCommerceDialogParam {
    SceCommonDialogBaseParam baseParam;
    int32_t size;

    SceUserServiceUserId userId;
    SceNpCommerceDialogMode mode;
    SceNpServiceLabel serviceLabel;

    const char * const *targets;
    uint32_t numTargets;
 int : 32;
    uint64_t features;

    void *userData;
    uint8_t reserved[32];
} SceNpCommerceDialogParam;



typedef struct SceNpCommereDialogParam2 {
    SceCommonDialogBaseParam baseParam;
    int32_t size;

    SceUserServiceUserId userId;
    SceNpCommerceDialogMode mode;
    SceNpServiceLabel serviceLabel;
    SceNpCommerceServiceName serviceName;

    const char* const* targets;
    uint32_t numTargets;
    int : 32;
    uint64_t features;

    void* userData;
    uint8_t reserved[32];
} SceNpCommerceDialogParam2;



typedef struct SceNpCommerceDialogResult {
    int32_t result;
    bool authorized;
 char : 8;
 short : 16;
    void *userData;
    uint8_t reserved[32];
} SceNpCommerceDialogResult;




static inline void sceNpCommerceDialogParamInitialize( SceNpCommerceDialogParam *param )
{
 memset( param, 0x0, sizeof(SceNpCommerceDialogParam) );

 _sceCommonDialogBaseParamInit( &param->baseParam );
 param->size = sizeof(SceNpCommerceDialogParam);
}



static inline void sceNpCommerceDialogParamInitialize2( SceNpCommerceDialogParam2 *param )
{
    memset(param, 0x0, sizeof(SceNpCommerceDialogParam2));

    _sceCommonDialogBaseParamInit(&param->baseParam);
    param->size = sizeof(SceNpCommerceDialogParam2);
}



int32_t sceNpCommerceDialogInitialize();



int32_t sceNpCommerceDialogOpen(const SceNpCommerceDialogParam *param);



int32_t sceNpCommerceDialogOpen2(const SceNpCommerceDialogParam2* param);



SceCommonDialogStatus sceNpCommerceDialogUpdateStatus(void);



SceCommonDialogStatus sceNpCommerceDialogGetStatus(void);



int32_t sceNpCommerceDialogGetResult(SceNpCommerceDialogResult* result);



int32_t sceNpCommerceDialogClose(void);



int32_t sceNpCommerceDialogTerminate( void );


}
# 8 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp" 2

#pragma comment(lib,"libSceNpCommerce_stub_weak.a")


namespace psn
{
    void CommerceCommands::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::OpenDialog, CommerceCommands::OpenDialogImpl);
        MsgHandler::AddMethod(Methods::UpdateDialog, CommerceCommands::UpdateDialogImpl);
        MsgHandler::AddMethod(Methods::CloseDialog, CommerceCommands::CloseDialogImpl);
        MsgHandler::AddMethod(Methods::PSStoreIcon, CommerceCommands::PSStoreIconImpl);
    }

    void CommerceCommands::InitializeLib()
    {
    }

    void CommerceCommands::TerminateLib()
    {
    }

    bool CommerceCommands::s_DialogInitialized = false;

    void CommerceCommands::OpenDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        ret = InitialzeDialog();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp", 42));
            return;
        }

        BinaryReader reader(sourceData, sourceSize);
        Int32 mode = reader.ReadInt32();
        Int32 userId = reader.ReadInt32();
        UInt32 serviceLabel = reader.ReadUInt32();
        Int32 numTargets = reader.ReadInt32();

        const char** targets = __null;

        if (numTargets > 0)
        {
            targets = (const char**)__builtin_alloca(sizeof(void*) * numTargets);
            for (int i = 0; i < numTargets; i++)
                targets[i] = reader.ReadStringPtr();
        }

        SceNpCommerceDialogParam param;
        sceNpCommerceDialogParamInitialize(&param);

        param.userId = userId;
        param.serviceLabel = serviceLabel;
        param.mode = mode;
        param.numTargets = numTargets;
        param.targets = targets;
        param.features = (0x1);

        ret = sceNpCommerceDialogOpen(&param);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp", 75));
            TerminateDialog();
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void CommerceCommands::UpdateDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        SceCommonDialogStatus status = sceNpCommerceDialogUpdateStatus();
        SceNpCommerceDialogResult dialogResult;
        bool hasFinished = false;

        if (status == SCE_COMMON_DIALOG_STATUS_FINISHED)
        {
            ret = sceNpCommerceDialogGetResult(&dialogResult);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp", 103));
                TerminateDialog();
                return;
            }

            hasFinished = true;
            TerminateDialog();
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(status);
        writer.WriteBool(hasFinished);
        if (hasFinished == true)
        {
            writer.WriteInt32(dialogResult.result);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void CommerceCommands::CloseDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        ret = TerminateDialog();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp", 136));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int CommerceCommands::InitialzeDialog()
    {
        if (s_DialogInitialized == true) return 0;

        int ret = Utils::InitializeCommonDialog();

        if (ret < 0)
        {
            return ret;
        }

        ret = sceNpCommerceDialogInitialize();

        if (ret < 0)
        {
            return ret;
        }

        s_DialogInitialized = true;

        return ret;
    }

    int CommerceCommands::TerminateDialog()
    {
        if (s_DialogInitialized == false) return 0;

        int ret = sceNpCommerceDialogTerminate();

        if (ret < 0)
        {
            return ret;
        }

        s_DialogInitialized = false;

        return ret;
    }

    void CommerceCommands::PSStoreIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 mode = reader.ReadInt32();
        SceNpCommercePsStoreIconPos pos = (SceNpCommercePsStoreIconPos)reader.ReadInt32();
        SceNpCommercePsStoreIconLayout layout = (SceNpCommercePsStoreIconLayout)reader.ReadInt32();

        ret = sceNpCommerceSetPsStoreIconLayout(layout);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp", 201));
            return;
        }

        if (mode == 0)
        {
            ret = sceNpCommerceShowPsStoreIcon(pos);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp", 210));
                return;
            }
        }
        else if (mode == 1)
        {
            ret = sceNpCommerceHidePsStoreIcon();
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Commerce.cpp", 219));
                return;
            }
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 10 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 1


# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/CoreMain.h" 1





namespace psn
{
    struct InitResult
    {
    public:
        bool initialized;
        UInt32 sceSDKVersion;

        InitResult()
        {
            initialized = false;
        }
    };

    class Main
    {
    public:

    private:

        static bool s_Initialised;

    public:

        static void Initialize(InitResult& initResult, APIResult* result);
        static void Update();
        static void Shutdown(APIResult* result);

        static int LoadModules(APIResult* result);
        static int UnloadModules(APIResult* result);




        static PrxPluginInterface s_PrxInterface;

    private:

        static SceKernelModule s_CoreHandle;
    };
}
# 4 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 2 3



extern "C" {
# 187 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 3
int sceSysmoduleLoadModule(uint16_t id);
int sceSysmoduleUnloadModule(uint16_t id);
int sceSysmoduleIsLoaded(uint16_t id);


}
# 7 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2







# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Users.h" 1





using namespace sce::Np::CppWebApi::UserProfile::V1;
using namespace sce::Np::CppWebApi;

namespace psn
{
    class UserSystem
    {
    public:

        enum Methods
        {
            AddUser = 0x0100001u,
            RemoveUser = 0x0100002u,
            GetFriends = 0x0100003u,
            GetProfiles = 0x0100004u,
            GetBasicPresences = 0x0100005u,
            GetBlockingUsers = 0x0100006u,

            StartSignedStateCallback = 0x0100007u,
            StopSignedStateCallback = 0x0100008u,
            FetchSignedStateEvent = 0x0100009u,

            StartReachabilityStateCallback = 0x0100010u,
            StopReachabilityStateCallback = 0x0100011u,
            FetchReachabilityStateEvent = 0x0100012u,
        };

        class UserIds
        {
        public:

            UserIds(SceUserServiceUserId userId);

            int Create();
            int Destroy();

            SceUserServiceUserId m_userId;
            SceNpAccountId m_accountId;
        };

        static void RegisterMethods();

        static void AddUserImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void RemoveUserImpl(UInt8* sourceData, int sourceSize, APIResult* result);

        static void GetFriendsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result);

        static int GetFriendsInternal(SceNpAccountId accountId, WebApiUserContext* user, UInt32 offset, UInt32 limit,
            FriendsApi::ParameterToGetFriends::Filter filter,
            FriendsApi::ParameterToGetFriends::Order order,
            Common::IntrusivePtr<Common::Vector<SceNpAccountId> > &accountIdPtr, Int32& nextOffset, Int32& previousOffset);

        static void GetProfilesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static int GetProfilesInternal(std::string accountIds, WebApiUserContext* user,
            Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicProfile> > > &profilesPtr);

        static void GetBasicPresencesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static int GetBasicPresencesInternal(std::string accountIds, WebApiUserContext* user,
            Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicPresence> > > &presencesPtr);

        static void GetBlockingUsersImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static int GetBlockingUsersInternal(WebApiUserContext* user, UInt32 offset, UInt32 limit, BinaryWriter& writer);


        static void WriteAvatarList(BinaryWriter& writer, Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar> > > avatarsPtr);


        static void SignedStateCallback(SceUserServiceUserId userId, SceNpState state, void *userData);

        static void StartSignedStateCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void StopSignedStateCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void FetchSignedStateEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        struct SigninStateEvent
        {
            SceUserServiceUserId userId;
            SceNpState state;
        };

        static int s_SignInCallbackId;
        static std::list<SigninStateEvent> s_PendingSigninStateList;

        static void ReachabilityStateCallback(SceUserServiceUserId userId, SceNpReachabilityState state, void *userData);

        static void StartReachabilityStateCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void StopReachabilityStateCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void FetchReachabilityStateEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        struct ReachabilityStateEvent
        {
            SceUserServiceUserId userId;
            SceNpReachabilityState state;
        };

        static std::list<ReachabilityStateEvent> s_PendingReachabilityStateList;


        static UserMap<UserIds> s_UsersList;
    };
}
# 15 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/UniversalDataSystem.h" 1




namespace psn
{
    enum PropertyType
    {
        kInvalid = 0,
        kInt32,
        kUInt32,
        kInt64,
        kUInt64,
        kString,
        kFloat,
        kFloat64,
        kBool,
        kBinary,
        kProperties,
        kArray
    };

    class UniversalDataSystem
    {
    public:

        enum Methods
        {
            StartSystem = 0x0200001u,
            StopSystem = 0x0200002u,
            GetMemoryStats = 0x0200003u,
            PostEvent = 0x0200006u,
            EventToString = 0x0200007u,
            UnlockTrophy = 0x0200010u,
            UnlockTrophyProgress = 0x0200011u,
        };

        class UserContext
        {
        public:

            UserContext(SceUserServiceUserId userId);

            int Create();
            int Destroy();

            SceUserServiceUserId m_userId;

            SceNpUniversalDataSystemContext m_context;
            SceNpUniversalDataSystemHandle m_handle;

        };


        static void InitializeLib();
        static void TerminateLib();

        static void RegisterMethods();

        static void HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result);

        static void StartSystemImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void StopSystemImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void GetMemoryStatsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void PostEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void EventToStringImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void UnlockTrophyImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void UnlockTrophyProgressImpl(UInt8* sourceData, int sourceSize, APIResult* result);


        static SceNpUniversalDataSystemEvent* ReadEvent(BinaryReader& reader, APIResult* result);
        static SceNpUniversalDataSystemEventPropertyObject* ReadProperties(BinaryReader& reader, APIResult* result);
        static SceNpUniversalDataSystemEventPropertyArray* ReadPropertiesArray(BinaryReader& reader, APIResult* result);

        static bool ReadArrayValue(BinaryReader& reader, PropertyType arrayType, SceNpUniversalDataSystemEventPropertyArray* propertiesArray, APIResult* result);
        static bool ReadProperty(BinaryReader& reader, SceNpUniversalDataSystemEventPropertyObject* properties, APIResult* result);

        static UserMap<UserContext> s_UsersList;
    };
}
# 16 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/GameIntent.h" 1




namespace psn
{
    class GameIntent
    {
    public:

        enum Methods
        {
            FetchGameIntent = 0x0400001u,
        };

        static void InitializeLib();
        static void TerminateLib();
        static void RegisterMethods();

        static void FetchGameIntentImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void HandleSystemEvent(SceSystemServiceEvent& sevent);

        static void WriteIntentProperty(SceNpGameIntentData& intentData, const char* key, int maxValueLength, BinaryWriter& writer);

        static std::list<SceNpGameIntentInfo> s_PendingGameIntentList;
    };
}
# 17 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/TrophyService.h" 1




namespace psn
{
    class TrophyService
    {
    public:
        enum Methods
        {
            StartService = 0x0300001u,
            StopService = 0x0300002u,
            GetGameInfo = 0x0300003u,
            GetGroupInfo = 0x0300004u,
            GetTrophyInfo = 0x0300005u,
            GetGameIcon = 0x0300006u,
            GeGroupIcon = 0x0300007u,
            GetTrophyIcon = 0x0300008u,
            GetRewardIcon = 0x0300009u,
            ShowTrophyList = 0x030000Au,
            FetchUnlockEvent = 0x030000Bu,
        };

        class UserTrophies
        {
        public:

            UserTrophies(SceUserServiceUserId userId);

            int Create();
            int Destroy();

            SceUserServiceUserId m_userId;

            SceNpTrophy2Context m_context;
            SceNpTrophy2Handle m_handle;
        };

        static void RegisterMethods();

        static void StartServiceImpl(APIResult* result);
        static void StopServiceImpl(APIResult* result);

        static void HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result);

        static void GetGameInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetGroupInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetTrophyInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetGameIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GeGroupIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetTrophyIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetRewardIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void ShowTrophyListImpl(UInt8* sourceData, int sourceSize, APIResult* result);

        static void Update();

        static UserMap<UserTrophies> s_UsersList;
        static std::list<Int32> s_PendingUnlockEventsList;

        static void UnlockCallback(SceNpTrophy2Context context, SceNpTrophy2Id trophyId, void *userdata);
        static void FetchUnlockEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
    };
}
# 18 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/FeatureGating.h" 1






namespace psn
{
    class FeatureGating
    {
    public:

        enum Methods
        {
            CheckPremium = 0x0700001u,
            NotifyPremiumFeature = 0x0700002u,
            StartPremiumEventCallback = 0x0700003u,
            StopPremiumEventCallback = 0x0700004u,
            FetchPremiumEvent = 0x0700005u,
        };

        static void RegisterMethods();

        static void CheckPremiumImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void NotifyPremiumFeatureImpl(UInt8* sourceData, int sourceSize, APIResult* result);

        static void StartPremiumEventCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void StopPremiumEventCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result);
        static void FetchPremiumEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void PremiumEventCallback(SceUserServiceUserId userId, SceNpPremiumEventType eventType, void *userData);

        struct PremiumEvent
        {
            SceUserServiceUserId userId;
            SceNpPremiumEventType eventType;
        };

        static std::list<PremiumEvent> s_PendingPremiumEventsList;
    };
}
# 19 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/GameUpdate.h" 1






namespace psn
{
    class GameUpdate
    {
    public:

        enum Methods
        {
            GameUpdateCheck = 0x1500001u,
            GameUpdateGetAddcontLatestVersion = 0x1500002u,
        };

        static void RegisterMethods();

        static void InitializeLib();
        static void TerminateLib();

        static void GameUpdateCheckImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GameUpdateGetAddcontLatestVersionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static bool s_ModuleLoaded;
    };
}
# 20 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/OnlineSafety.h" 1




namespace psn
{
    class OnlineSafety
    {
    public:

        enum Methods
        {
            GetCRS = 0x0800001u,
            FilterProfanity = 0x0800002u,
            TestProfanity = 0x0800003u,
        };

        static void RegisterMethods();

        static void GetCRSImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void FilterProfanityImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void TestProfanityImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
    };
}
# 21 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2

# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/SessionsManager.h" 1






# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/PlayerSession.h" 1






# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/SessionMap.h" 1



namespace psn
{
    template<class SessionType>
    class SessionMap
    {
        std::map<int, SessionType*> s_SessionsList;

    public:
        void AddSession(int id, SessionType* instance)
        {
            s_SessionsList.insert(std::pair<int, SessionType*>(id, instance));
        }

        SessionType* FindSession(int internalId)
        {
            auto it = s_SessionsList.find(internalId);

            if (it == s_SessionsList.end())
            {
                return __null;
            }

            return it->second;
        }

        SessionType* FindSession(const char* sessionId)
        {


            for (auto it = s_SessionsList.begin(); it != s_SessionsList.end(); it++)
            {
                const char* itSessionId = it->second->GetSessionId();

                if (strcmp(itSessionId, sessionId) == 0)
                {
                    return it->second;
                }
            }

            return __null;
        }

        void DeleteSession(int internalId)
        {
            auto it = s_SessionsList.find(internalId);

            if (it == s_SessionsList.end())
            {
                return;
            }

            delete it->second;

            s_SessionsList.erase(internalId);
        }

        bool DoesSessionExist(int internalId)
        {
            auto it = s_SessionsList.find(internalId);

            if (it == s_SessionsList.end())
            {
                return false;
            }

            return true;
        }

        typedef void(*CleanUpCallback)(SessionType* instance);

        void Clean(CleanUpCallback callback)
        {
            auto it = s_SessionsList.begin();
            while (it != s_SessionsList.end())
            {
                callback(it->second);

                delete it->second;

                s_SessionsList.erase(it->first);

                it = s_SessionsList.begin();
            }
        }
    };
}
# 8 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/PlayerSession.h" 2

namespace sceCppWebApi = sce::Np::CppWebApi::Common;
namespace sceSessionManager = sce::Np::CppWebApi::SessionManager::V1;

using namespace sceCppWebApi;
using namespace sceSessionManager;

namespace psn
{
    class PlayerSessionCommands
    {
    public:

        enum Methods
        {
            CreatePlayerSession = 0x0A00001u,
            LeavePlayerSession = 0x0A00002u,
            JoinPlayerSession = 0x0A00003u,
            GetPlayerSessions = 0x0A00004u,
            SendPlayerSessionsInvitation = 0x0A00005u,
            GetPlayerSessionInvitations = 0x0A00006u,
            SetPlayerSessionProperties = 0x0A00007u,
            ChangePlayerSessionLeader = 0x0A00008u,
            AddPlayerSessionJoinableSpecifiedUsers = 0x0A00009u,
            DeletePlayerSessionJoinableSpecifiedUsers = 0x0A0000Au,
            SetPlayerSessionMemberSystemProperties = 0x0A0000Bu,
            SendPlayerSessionMessage = 0x0A0000Cu,
            GetJoinedPlayerSessionsByUser = 0x0A0000Du,
        };




        struct LocalisedStrings
        {
            IntrusivePtr<LocalizedString> m_LocalizedStringPtr;

            int Deserialise(BinaryReader& reader);
        };

        class InitializationParams
        {
        public:
            InitializationParams();
            ~InitializationParams();

            int m_UserId;
            uint32_t m_MaxPlayers;
            uint32_t m_MaxSpectators;
            bool m_SwapSupported;
            bool m_JoinDisabled;

            sceSessionManager::JoinableUserType m_JoinableUserType;
            sceSessionManager::InvitableUserType m_InvitableUserType;

            uint32_t m_PlatformFlags;

            LocalisedStrings m_SessionName;

            Vector<String> *m_LeaderPrivileges;
            Vector<String> *m_ExclusiveLeaderPrivileges;
            Vector<String> *m_DisableSystemUiMenu;

            int m_CustomDataSize1;
            void* m_CustomData1;

            int m_CustomDataSize2;
            void* m_CustomData2;

            void Deserialise(BinaryReader& reader);
        };


        static void RegisterMethods();

        static void CreatePlayerSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void LeavePlayerSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void JoinPlayerSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetPlayerSessionsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SendPlayerSessionsInvitationImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void GetPlayerSessionInvitationsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SetPlayerSessionPropertiesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void ChangePlayerSessionLeaderImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void AddPlayerSessionJoinableSpecifiedUsersImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void DeletePlayerSessionJoinableSpecifiedUsersImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SetPlayerSessionMemberSystemPropertiesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SendPlayerSessionMessageImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetJoinedPlayerSessionsByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void SerialiseSessionInfo(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<PlayerSessionForRead> > > playerSessionsPtr);





        static int Create(Int32 pushCallbackId, void* creatorCustomData1, int creatorDataSize1, InitializationParams& params, BinaryWriter& writer);
        static int Leave(SceUserServiceUserId userId, const char* sessionId);
        static int JoinAsPlayer(SceUserServiceUserId userId, Int32 pushCallbackId, const char* sessionId, bool swapping, BinaryWriter& writer);
        static int JoinAsSpectator(SceUserServiceUserId userId, Int32 pushCallbackId, const char* sessionId, bool swapping, BinaryWriter& writer);

        static int SetPlayerSessionProps(WebApiUserContext* userCtx, const char* sessionId, BinaryReader& reader);

        static int DeserialiseLeaderPrivileges(BinaryReader& reader, Vector<String> *strings);


    };
}
# 8 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/SessionsManager.h" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/GameSession.h" 1






namespace sceCppWebApi = sce::Np::CppWebApi::Common;
namespace sceSessionManager = sce::Np::CppWebApi::SessionManager::V1;

using namespace sceCppWebApi;
using namespace sceSessionManager;

namespace psn
{
    const int kNumSearchAttributes = 10;

    class GameSessionCommands
    {
    public:

        enum Methods
        {
            CreateGameSession = 0x0B00001u,
            LeaveGameSession = 0x0B00002u,
            JoinGameSession = 0x0B00003u,
            GetGameSessions = 0x0B00004u,
            SetGameSessionProperties = 0x0B00005u,
            SetGameSessionMemberSystemProperties = 0x0B00006u,
            SendGameSessionMessage = 0x0B00007u,
            GetJoinedGameSessionsByUser = 0x0B00008u,
            DeleteGameSession = 0x0B00009u,
            GameSessionsSearch = 0x0B0000Au,
        };

        struct GSMember
        {
            int m_UserId;
            int m_PushCallbackId;
            SceNpAccountId m_AccountId;
            SceNpPlatformType m_Platform;
            InitialJoinState m_JoinState;
            int m_NatType;

            int m_CustomDataSize1;
            void* m_CustomData1;

            void Deserialise(BinaryReader& reader);
        };

        class InitializationParams
        {
        public:
            InitializationParams();
            ~InitializationParams();

            uint32_t m_MaxPlayers;
            uint32_t m_MaxSpectators;
            uint32_t m_PlatformFlags;
            bool m_JoinDisabled;
            bool m_UsePlayerSession;
            int32_t m_ReservationTimeoutSeconds;

            uint32_t m_NumberMembers;
            GSMember* m_Members;

            int m_CustomDataSize1;
            void* m_CustomData1;

            int m_CustomDataSize2;
            void* m_CustomData2;

            bool m_Searchable;
            const char *m_SearchIndex;

            unsigned int m_StringsSetBits, m_IntsSetBits, m_BoolsSetBits;
            int m_Ints[kNumSearchAttributes];
            bool m_Bools[kNumSearchAttributes];
            char *m_Strings[kNumSearchAttributes];

            void Deserialise(BinaryReader& reader);
        };

        static void RegisterMethods();

        static void CreateGameSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void LeaveGameSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void JoinGameSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetGameSessionsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SetGameSessionPropertiesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SetGameSessionMemberSystemPropertiesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SendGameSessionMessageImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetJoinedGameSessionsByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void DeleteGameSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GameSessionsSearchImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void SerialiseSessionInfo(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<GameSessionForRead> > > gameSessionsPtr);
        static int SetGameSessionProps(WebApiUserContext* userCtx, const char* sessionId, BinaryReader& reader);

        static int AddUser(GSMember& member, Vector<IntrusivePtr<RequestGameSessionPlayer> >& requestGameSessionPlayers);

        static int Create(GSMember& creator, InitializationParams& params, BinaryWriter& writer);
        static int Leave(SceUserServiceUserId userId, const char* sessionId);
        static int JoinAsPlayer(SceUserServiceUserId userId, Int32 pushCallbackId, const char* sessionId, bool swapping, BinaryWriter& writer);
        static int JoinAsSpectator(SceUserServiceUserId userId, Int32 pushCallbackId, const char* sessionId, bool swapping, BinaryWriter& writer);
    };
}
# 9 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/SessionsManager.h" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Matches.h" 1







namespace sceCppWebApi = sce::Np::CppWebApi::Common;
namespace sceMatches = sce::Np::CppWebApi::Matches::V1;

using namespace sceCppWebApi;
using namespace sceMatches;

namespace psn
{
    class MatchesCommands
    {
    public:

        enum Methods
        {
            CreateMatch = 0x0C00001u,
            GetMatchDetails = 0x0C00002u,
            UpdateMatchStatus = 0x0C00003u,
            JoinMatch = 0x0C00004u,
            LeaveMatch = 0x0C00005u,
            ReportResults = 0x0C00006u,
            UpdateDetails = 0x0C00007u,
        };

        struct MatchPlayer
        {
            char* m_PlayerId;
            char* m_PlayerName;
            SceNpAccountId m_AccountId;
            PlayerType m_PlayerType;
            void Deserialise(BinaryReader& reader);
        };

        struct MatchTeamMember
        {
            char* m_PlayerId;
            void Deserialise(BinaryReader& reader);
        };

        struct MatchTeam
        {
            char* m_TeamId;
            char* m_TeamName;
            std::vector<MatchTeamMember> m_Members;

            void Deserialise(BinaryReader& reader);
        };

        class InitializationParams
        {
        public:
            InitializationParams();
            ~InitializationParams();

            char* m_ActivityId;

            int32_t m_ServiceLabel;

            char* m_ZoneId;

            std::vector<MatchPlayer> m_Players;
            std::vector<MatchTeam> m_Teams;

            void Deserialise(BinaryReader& reader);
        };

        static void RegisterMethods();

        static void InitializeLib();
        static void TerminateLib();

        static void CreateMatchImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetMatchDetailsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UpdateMatchStatusImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void JoinMatchImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void LeaveMatchImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void ReportResultsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UpdateDetailsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void SerialiseMatchDetail(BinaryWriter& writer, IntrusivePtr<GetMatchDetailResponse> matchDetail);

        static void SerialiseGameRoster(BinaryWriter& writer, IntrusivePtr<ResponseInGameRoster> roster);
        static void SerialiseMatchResults(BinaryWriter& writer, IntrusivePtr<ResponseMatchResults> matchResults);
        static void SerialiseMatchStats(BinaryWriter& writer, IntrusivePtr<ResponseMatchStatistics> matchStats);

        static void SerialisePlayers(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponseMatchPlayer> > > players);
        static void SerialiseTeams(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponseMatchTeam> > > teams);
        static void SerialisePlayerResults(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponsePlayerResults> > > playerResults);

        static void SerialiseTeamResults(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponseTeamResults> > > teamResults);
        static void SerialiseTeamMemberResults(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponseTeamMemberResult> > > teamMemberResults);

        static void SerialiseAdditionalStats(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<AdditionalStatistic> > > additionalStats);

        static int Create(Int32 userId, InitializationParams& initParams, BinaryWriter& writer);

        static int DeserialiseMatchResults(Common::LibContext* libContextPtr, BinaryReader &reader, CompetitionType competition, GroupingType groupType, ResultType resultType, Common::IntrusivePtr<RequestMatchResults> &requestMatchResults);
        static int DeserialiseTemporaryMatchResults(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, Common::IntrusivePtr<RequestTemporaryMatchResults> &requestMatchResults);

        static int DeserialiseCompetitiveResults(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestCompetitiveResult> &requestCompetitiveResult);
        static int DeserialiseTemporaryCompetitiveResults(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestTemporaryCompetitiveResult> &requestCompetitiveResult);

        static int DeserialiseMatchStats(Common::LibContext* libContextPtr, BinaryReader &reader, CompetitionType competition, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestMatchStatistics> &requestMatchStatistics);

        static int DeserialisePlayerStats(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestMatchStatistics> &requestMatchStatistics);
        static int DeserialiseTeamStats(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestMatchStatistics> &requestMatchStatistics);
        static int DeserialiseTeamMemberStats(Common::LibContext* libContextPtr, BinaryReader &reader, IntrusivePtr<RequestTeamStatistic>& requestTeamStatistic);

        static int DeserialiseAdditionalStats(Common::LibContext* libContextPtr, BinaryReader &reader, Vector<IntrusivePtr<AdditionalStatistic> >& stats);
    };
}
# 10 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/SessionsManager.h" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/MatchMaking.h" 1






namespace sceCppWebApi = sce::Np::CppWebApi::Common;
namespace matchmaking = sce::Np::CppWebApi::Matchmaking::V1;

using namespace sceCppWebApi;
using namespace sce::Np::CppWebApi;
using namespace matchmaking;

namespace psn
{
    class MatchMakingSystem
    {
    public:

        enum Methods
        {
            SubmitTicket = 0x0D00001u,
            GetTicket = 0x0D00002u,
            CancelTicket = 0x0D00003u,
            GetOffer = 0x0D00004u,
            ListUserTickets = 0x0D00005u,
        };

        static void RegisterMethods();

        static void Initialize();

        static void SubmitTicketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetTicketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void CancelTicketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetOfferImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void ListUserTicketsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static Platform GetPlatformType(SceNpPlatformType platformType);
        static SceNpPlatformType GetPlatformType(Platform platform);

        static int ReadAttributes(BinaryReader &reader, Common::Vector<Common::IntrusivePtr<Attribute> >& attributes, int numAttributes);

        static int WriteTicketResponse(BinaryWriter& writer, sce::Np::CppWebApi::Matchmaking::V1::SubmitTicketResponseBody* body);
        static int WriteTicketResponse(BinaryWriter& writer, sce::Np::CppWebApi::Matchmaking::V1::GetTicketResponseBody* body);
        static int WriteOfferResponse(BinaryWriter& writer, sce::Np::CppWebApi::Matchmaking::V1::GetOfferResponseBody* body);

        static int WriteAttributes(BinaryWriter& writer, Common::Vector<Common::IntrusivePtr<Attribute> >* attributes);
        static int WritePlayers(BinaryWriter& writer, Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate> >* players);
        static int WritePlayersForRead(BinaryWriter& writer, Common::Vector<Common::IntrusivePtr<PlayerForRead> >* players);
        static int WritePlayersForOfferRead(BinaryWriter& writer, Common::Vector<Common::IntrusivePtr<PlayerForOfferRead> >* players);

        static int WriteLocation(BinaryWriter& writer, Location* location);
        static int WriteSubmitter(BinaryWriter& writer, Submitter* submitter);
    };
}
# 11 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/SessionsManager.h" 2

namespace sceSessionManager = sce::Np::CppWebApi::SessionManager::V1;
using namespace sceSessionManager;

namespace psn
{
    class SessionsManager
    {
    public:

        enum Methods
        {

        };

        static void RegisterMethods();



        static void InitializeLib();
        static void TerminateLib();

    private:


    };
}
# 23 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Entitlements.h" 1




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_entitlement_access.h" 1 3
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_entitlement_access.h" 3
extern "C" {
# 238 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_entitlement_access.h" 3
typedef uint32_t SceNpEntitlementAccessSkuFlag;



typedef uint32_t SceNpEntitlementAccessPackageType;



typedef uint32_t SceNpEntitlementAccessDownloadStatus;



typedef uint32_t SceNpEntitlementAccessEntitlementType;



typedef uint32_t SceNpEntitlementAccessSortType;



typedef uint32_t SceNpEntitlementAccessDirectionType;



typedef uint32_t SceNpEntitlementAccessGameTrialsFlag;
# 371 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\np/np_entitlement_access.h" 3
typedef struct SceNpEntitlementAccessInitParam {

 char reserved[32];

} SceNpEntitlementAccessInitParam;



typedef struct SceNpEntitlementAccessBootParam {

 char reserved[32];

} SceNpEntitlementAccessBootParam;



typedef struct SceNpEntitlementAccessAddcontEntitlementInfo {

 SceNpUnifiedEntitlementLabel entitlementLabel;

 SceNpEntitlementAccessPackageType packageType;

 SceNpEntitlementAccessDownloadStatus downloadStatus;

} SceNpEntitlementAccessAddcontEntitlementInfo;



typedef struct SceNpEntitlementAccessEntitlementKey {

 char data[(16)];

} SceNpEntitlementAccessEntitlementKey;



typedef struct SceNpEntitlementAccessTransactionId {

 char transactionId[(65)];

 char padding[7];

} SceNpEntitlementAccessTransactionId;



typedef struct SceNpEntitlementAccessUnifiedEntitlementInfo {

 SceNpUnifiedEntitlementLabel entitlementLabel;

 SceRtcTick activeDate;

 SceRtcTick inactiveDate;

 SceNpEntitlementAccessEntitlementType entitlementType;

 int32_t useCount;

 int32_t useLimit;

 SceNpEntitlementAccessPackageType packageType;

 bool activeFlag;

 int8_t reserved[3];

} SceNpEntitlementAccessUnifiedEntitlementInfo;



typedef struct SceNpEntitlementAccessRequestEntitlementInfoListParam {
 size_t size;

 SceNpEntitlementAccessEntitlementType entitlementType;

 int32_t offset;

 int32_t limit;

 SceNpEntitlementAccessSortType sort;

 SceNpEntitlementAccessDirectionType direction;

 SceNpEntitlementAccessPackageType packageType;

} SceNpEntitlementAccessRequestEntitlementInfoListParam;



typedef struct SceNpEntitlementAccessServiceEntitlementInfo {

 SceNpServiceEntitlementLabel entitlementLabel;

 SceRtcTick activeDate;

 SceRtcTick inactiveDate;

 SceNpEntitlementAccessEntitlementType entitlementType;

 int32_t useCount;

 int32_t useLimit;

 uint32_t reserved1;

 bool activeFlag;

 bool isConsumable;

 int8_t reserved2[2];

} SceNpEntitlementAccessServiceEntitlementInfo;







int32_t sceNpEntitlementAccessInitialize(

  const SceNpEntitlementAccessInitParam *initParam,

  SceNpEntitlementAccessBootParam *bootParam

);



int32_t sceNpEntitlementAccessGetSkuFlag(

  SceNpEntitlementAccessSkuFlag *skuFlag

);



int32_t sceNpEntitlementAccessGetAddcontEntitlementInfoList(

  SceNpServiceLabel serviceLabel,

  SceNpEntitlementAccessAddcontEntitlementInfo *list,

  uint32_t listNum,

  uint32_t *hitNum

);



int32_t sceNpEntitlementAccessGetAddcontEntitlementInfo(

  SceNpServiceLabel serviceLabel,

  const SceNpUnifiedEntitlementLabel *entitlementLabel,

  SceNpEntitlementAccessAddcontEntitlementInfo *info

);



int32_t sceNpEntitlementAccessGetEntitlementKey(

  SceNpServiceLabel serviceLabel,

  const SceNpUnifiedEntitlementLabel *entitlementLabel,

  SceNpEntitlementAccessEntitlementKey *key

);



int32_t sceNpEntitlementAccessGenerateTransactionId(

 SceNpEntitlementAccessTransactionId *transactionId

);



int32_t sceNpEntitlementAccessRequestConsumeUnifiedEntitlement(

 SceUserServiceUserId userId,

 SceNpServiceLabel serviceLabel,

 const SceNpUnifiedEntitlementLabel *entitlementLabel,

 const SceNpEntitlementAccessTransactionId *transactionId,

 int32_t useCount,

 int64_t *requestId

);



int32_t sceNpEntitlementAccessRequestConsumeServiceEntitlement(

 SceUserServiceUserId userId,

 SceNpServiceLabel serviceLabel,

 const SceNpServiceEntitlementLabel *entitlementLabel,

 const SceNpEntitlementAccessTransactionId *transactionId,

 int32_t useCount,

 int64_t *requestId

);



int32_t sceNpEntitlementAccessPollConsumeEntitlement(
 int64_t requestId,

 int32_t *pResult,

 int32_t *useLimit

);



int32_t sceNpEntitlementAccessRequestUnifiedEntitlementInfo(

 SceUserServiceUserId userId,

 SceNpServiceLabel serviceLabel,

 const SceNpUnifiedEntitlementLabel *entitlementLabel,

 int64_t *requestId

);



int32_t sceNpEntitlementAccessPollUnifiedEntitlementInfo(

 int64_t requestId,

 int32_t *pResult,

 SceNpEntitlementAccessUnifiedEntitlementInfo *info

);



int32_t sceNpEntitlementAccessRequestUnifiedEntitlementInfoList(

 SceUserServiceUserId userId,

 SceNpServiceLabel serviceLabel,

 const SceNpUnifiedEntitlementLabel *list,

 uint32_t listNum,

 const SceNpEntitlementAccessRequestEntitlementInfoListParam *param,

 int64_t *requestId

);



int32_t sceNpEntitlementAccessPollUnifiedEntitlementInfoList(

 int64_t requestId,

 int32_t *pResult,

 SceNpEntitlementAccessUnifiedEntitlementInfo *list,

 uint32_t listNum,

 uint32_t *hitNum,

 int32_t *nextOffset,

 int32_t *previousOffset

);



int32_t sceNpEntitlementAccessRequestServiceEntitlementInfo(

 SceUserServiceUserId userId,

 SceNpServiceLabel serviceLabel,

 const SceNpServiceEntitlementLabel *entitlementLabel,

 int64_t *requestId

);



int32_t sceNpEntitlementAccessPollServiceEntitlementInfo(

 int64_t requestId,

 int32_t *pResult,

 SceNpEntitlementAccessServiceEntitlementInfo *info

);



int32_t sceNpEntitlementAccessRequestServiceEntitlementInfoList(

 SceUserServiceUserId userId,

 SceNpServiceLabel serviceLabel,

 const SceNpServiceEntitlementLabel *list,

 uint32_t listNum,

 const SceNpEntitlementAccessRequestEntitlementInfoListParam *param,

 int64_t *requestId

);



int32_t sceNpEntitlementAccessPollServiceEntitlementInfoList(

 int64_t requestId,

 int32_t *pResult,

 SceNpEntitlementAccessServiceEntitlementInfo *list,

 uint32_t listNum,

 uint32_t *hitNum,

 int32_t *nextOffset,

 int32_t *previousOffset

);



int32_t sceNpEntitlementAccessDeleteRequest(

 int64_t requestId

);



int32_t sceNpEntitlementAccessAbortRequest(

 int64_t requestId

);



int32_t sceNpEntitlementAccessGetGameTrialsFlag(

 SceNpEntitlementAccessGameTrialsFlag* gameTrialsFlag

);


}
# 6 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Entitlements.h" 2

namespace psn
{

    class EntitlementsSystem
    {
    public:

        enum Methods
        {
            GetAdditionalContentEntitlementInfoList = 0xFA00001u,
            GetSkuFlag = 0xFA00002u,
            GetAdditionalContentEntitlementInfo = 0xFA00003u,
            GetEntitlementKey = 0xFA00004u,

            AbortRequest = 0xFA00005u,
            DeleteRequest = 0xFA00006u,
            GenerateTransactionId = 0xFA00007u,
            PollUnifiedEntitlementInfo = 0xFA00008u,
            PollUnifiedEntitlementInfoList = 0xFA00009u,
            PollServiceEntitlementInfo = 0xFA00010u,
            PollServiceEntitlementInfoList = 0xFA00011u,
            PollConsumeEntitlement = 0xFA00012u,
            RequestUnifiedEntitlementInfo = 0xFA00013u,
            RequestUnifiedEntitlementInfoList = 0xFA00014u,
            RequestServiceEntitlementInfo = 0xFA00015u,
            RequestServiceEntitlementInfoList = 0xFA00016u,
            RequestConsumeUnifiedEntitlement = 0xFA00017u,
            RequestConsumeServiceEntitlement = 0xFA00018u,
        };

        static void RegisterMethods();

        static void Initialize();

        static void GetAdditionalContentEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetSkuFlagImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetAdditionalContentEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetEntitlementKeyImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void AbortRequestImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void DeleteRequestImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GenerateTransactionIdImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void PollUnifiedEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void PollUnifiedEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void PollServiceEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void PollServiceEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void PollConsumeEntitlementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void RequestUnifiedEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void RequestUnifiedEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void RequestServiceEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void RequestServiceEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void RequestConsumeUnifiedEntitlementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void RequestConsumeServiceEntitlementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void Write(BinaryWriter& writer, SceNpEntitlementAccessUnifiedEntitlementInfo& unifiedInfo);
        static void Write(BinaryWriter& writer, SceNpEntitlementAccessServiceEntitlementInfo& serviceInfo);
    };

}
# 24 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2

# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/PlayerReviewDialog.h" 1






namespace psn
{
    class PlayerReviewDialog
    {
    public:

        enum Methods
        {
            OpenDialog = 0x0F00001u,
            UpdateDialog = 0x0F00002u,
            CloseDialog = 0x0F00003u,
        };

        static void RegisterMethods();

        static void OpenDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UpdateDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void CloseDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void InitializeLib();
        static void TerminateLib();

    private:

        static int InitialzeDialog();
        static int TerminateDialog();

        static bool s_DialogInitialized;
    };
}
# 26 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/PlayerInvitationDialog.h" 1






namespace psn
{
    class PlayerInvitationDialog
    {
    public:

        enum Methods
        {
            OpenDialog = 0x1600001u,
            UpdateDialog = 0x1600002u,
            CloseDialog = 0x1600003u,
        };

        static void RegisterMethods();

        static void OpenDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UpdateDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void CloseDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void InitializeLib();
        static void TerminateLib();

    private:

        static int InitializeDialog();
        static int TerminateDialog();

        static bool s_DialogInitialized;
    };
}
# 27 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/MsgDialog.h" 1






# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\message_dialog.h" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\message_dialog.h" 3
extern "C" {
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\message_dialog.h" 3
typedef int32_t SceMsgDialogMode;







typedef int32_t SceMsgDialogSystemMessageType;
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\message_dialog.h" 3
typedef int32_t SceMsgDialogButtonType;
# 60 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\message_dialog.h" 3
typedef int32_t SceMsgDialogButtonId;
# 70 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\message_dialog.h" 3
typedef int32_t SceMsgDialogProgressBarType;





typedef int32_t SceMsgDialogProgressBarTarget;
# 88 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\message_dialog.h" 3
typedef struct SceMsgDialogButtonsParam {
 const char *msg1;

 const char *msg2;

 char reserved[32];

} SceMsgDialogButtonsParam;



typedef struct SceMsgDialogUserMessageParam {
 SceMsgDialogButtonType buttonType;

 int :32;

 const char *msg;

 SceMsgDialogButtonsParam *buttonsParam;

 char reserved[24];

} SceMsgDialogUserMessageParam;



typedef struct SceMsgDialogSystemMessageParam {
 SceMsgDialogSystemMessageType sysMsgType;

 char reserved[32];

} SceMsgDialogSystemMessageParam;



typedef struct SceMsgDialogProgressBarParam {
 SceMsgDialogProgressBarType barType;

 int :32;

 const char *msg;

 char reserved[64];

} SceMsgDialogProgressBarParam;



typedef struct SceMsgDialogParam {
 SceCommonDialogBaseParam baseParam;

 size_t size;

 SceMsgDialogMode mode;

 int :32;

 SceMsgDialogUserMessageParam *userMsgParam;

 SceMsgDialogProgressBarParam *progBarParam;

 SceMsgDialogSystemMessageParam *sysMsgParam;

 SceUserServiceUserId userId;

 char reserved[40];

 int :32;

} SceMsgDialogParam;



typedef struct SceMsgDialogResult {
 SceMsgDialogMode mode;

 int32_t result;

 SceMsgDialogButtonId buttonId;

 char reserved[32];

} SceMsgDialogResult;






static inline
void sceMsgDialogParamInitialize(SceMsgDialogParam *param)
{
 memset( param, 0x0, sizeof(SceMsgDialogParam) );

 _sceCommonDialogBaseParamInit( &param->baseParam );
 param->size = sizeof(SceMsgDialogParam);
}



int32_t sceMsgDialogInitialize(void);



int32_t sceMsgDialogOpen(const SceMsgDialogParam *param);



SceCommonDialogStatus sceMsgDialogUpdateStatus(void);



SceCommonDialogStatus sceMsgDialogGetStatus(void);



int32_t sceMsgDialogGetResult(SceMsgDialogResult *result);



int32_t sceMsgDialogTerminate(void);



int32_t sceMsgDialogClose(void);



int32_t sceMsgDialogProgressBarInc(
  SceMsgDialogProgressBarTarget target,

  uint32_t delta

 );



int32_t sceMsgDialogProgressBarSetValue(
  SceMsgDialogProgressBarTarget target,

  uint32_t rate

 );




int32_t sceMsgDialogProgressBarSetMsg(
  SceMsgDialogProgressBarTarget target,

  const char *barMsg

 );
# 250 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\message_dialog.h" 3
}
# 8 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/MsgDialog.h" 2

namespace psn
{
    class MsgDialog
    {
    public:

        enum Methods
        {
            OpenDialog = 0x1000001u,
            UpdateDialog = 0x1000002u,
            CloseDialog = 0x1000003u,
        };

        static void RegisterMethods();

        static void OpenDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UpdateDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void CloseDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static int UpdateProgressBar(BinaryReader& reader, SceCommonDialogStatus status);

        static void InitializeLib();
        static void TerminateLib();

    private:

        static int InitialzeDialog();
        static int TerminateDialog();

        static bool s_DialogInitialized;
        static bool s_ModuleLoaded;
    };
}
# 28 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Leaderboards.h" 1






namespace sceCppWebApi = sce::Np::CppWebApi::Common;
namespace PsnLeaderboards = sce::Np::CppWebApi::Leaderboards::V1;

using namespace sceCppWebApi;
using namespace sce::Np::CppWebApi;
using namespace PsnLeaderboards;

namespace psn
{
    class Leaderboards
    {
    public:

        enum Methods
        {
            GetBoardDefinition = 0x1100001u,
            RecordScore = 0x1100002u,
            GetRanking = 0x1100003u,
            GetLargeDateByObjectId = 0x1100004u,
        };

        static void RegisterMethods();

        static void Initialize();

        static void GetBoardDefinitionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void RecordScoreImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetRankingImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetLargeDataByObjectIdImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        struct ScoreData
        {
            Int32 userId;
            WebApiUserContext* userCtx;
            int boardId;
            int64_t score;
            bool waitsForData;
            bool needsTmpRank;
            int32_t pcId;
            SceNpServiceLabel serviceLabel;
            int64_t smallDataSize;
            void* smallDataPtr;
            char* objectId;
            char* comment;
            SceRtcTick comparedDateTime;

            Int32 largeDataSize;
            void* largeData;

            bool isServiceLabelSet;
            bool isObjectIdSet;
            bool isPcIdSet;
            bool isSmallDataSet;
            bool isCommentSet;
            bool isComparedDateTimeSet;

            bool tempRanksSet;
            Int32 tmpRankResult;
            Int32 tmpSerialRankResult;

            char operationId[40];
        };

        static int RecordLeaderboardScore(ScoreData& scoreData);
        static int RecordLargeData(ScoreData& scoreData);
    };
}
# 29 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/SessionSignalling.h" 1
# 10 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/SessionSignalling.h"
namespace psn
{
    class SessionSignalling
    {
    public:

        enum Methods
        {
            FetchSignallingEvent = 0x1200001u,
            UserToUserSignalling = 0x1200002u,
            ActivateUser = 0x1200003u,
            Deactivate = 0x1200004u,
            GetLocalNetInfo = 0x1200005u,
            GetConnectionStatus = 0x1200006u,
            GetConnectionInfo = 0x1200007u,
            CreateUserContext = 0x1200008u,
            DestroyUserContext = 0x1200009u,
            GetNatRouterInfo = 0x120000au,
            ActivateSession = 0x1200010u,
        };

        class ActiveContext
        {
        public:
            SceNpSessionSignalingContextId m_ctxId;
            SceUserServiceUserId m_userId;
        };

        static std::map<SceNpSessionSignalingContextId, ActiveContext*> s_ActiveCtxList;

        static void AddContext(ActiveContext* ctx);
        static void RemoveContext(ActiveContext* ctx);
        static ActiveContext* FindContext(SceNpSessionSignalingContextId ctxId);
        static ActiveContext* FindContext(Int32 userId);

        static int InitializeLib(int32_t libhttp2CtxId);
        static int TerminateLib();

        static void RegisterMethods();



        static void FetchSignallingEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void CreateUserContextImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void DestroyUserContextImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void UserToUserSignallingImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void ActivateUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void ActivateSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void DeactivateImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetLocalNetInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetNatRouterInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetConnectionStatusImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetConnectionInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void RequestCallback(SceNpSessionSignalingContextId ctxId, SceNpSessionSignalingRequestId reqId, SceNpSessionSignalingRequestEvent event, const void* eventData, int errorCode, void* arg);
        static void GroupCallback(SceNpSessionSignalingContextId ctxId, SceNpSessionSignalingGroupId grpId, SceNpSessionSignalingGroupEvent event, const void* eventData, int errorCode, void* arg);


        static void ConnectionCallback(SceNpSessionSignalingContextId ctxId, SceNpSessionSignalingGroupId grpId, SceNpSessionSignalingConnectionId connId, SceNpSessionSignalingConnectionEvent event, int errorCode, void* arg);




        struct SignallingEvent
        {
        public:

            enum EventType
            {
                Request = 0,
                Group = 1,
                Connection = 2
            };

            EventType type;

            SceUserServiceUserId userId;
            SceNpSessionSignalingContextId ctxId;
            int errorCode;

            UInt32 id;
            Int32 eventDesc;

            SceNpPeerAddressA peerActivatedData;
            SceNpSessionSignalingGroupId grpIdForConnectionEvent;

            void Init();
        };

        static std::list<SignallingEvent> s_PendingSignallingEventsList;
    };
}
# 30 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/Sockets.h" 1





namespace psn
{
    class Sockets
    {
    public:

        enum Methods
        {
            SetupUdpP2PSocket = 0x1300001u,
            TerminateSocket = 0x1300002u,
            SendTo = 0x1300003u,
            RecvThreadUpdate = 0x1300004u,
        };

        static void RegisterMethods();

        static void SetupUdpP2PSocketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void TerminateSocketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SendToImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void RecvThreadUpdateImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
    };
}
# 31 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source/TitleCloudStorage.h" 1






namespace TCS = sce::Np::CppWebApi::TitleCloudStorage::V1;

namespace psn
{
    class TitleCloudStorage
    {
    public:

        enum Methods
        {
            AddAndGetVariable = 0x1400001u,
            SetVariableWithConditions = 0x1400002u,
            GetMultiVariablesBySlot = 0x1400003u,

            SetMultiVariablesByUser = 0x1400004u,
            GetMultiVariablesByUser = 0x1400005u,
            DeleteMultiVariablesByUser = 0x1400006u,

            UploadData = 0x1400007u,
            DownloadData = 0x1400008u,
            DeleteMultiDataBySlot = 0x140009u,
            DeleteMultiDataByUser = 0x140010u,
            GetMultiDataStatusesBySlot = 0x140011u,
            GetMultiDataStatusesByUser = 0x140012u,
        };

        static void RegisterMethods();

        static void AddAndGetVariableImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void SetVariableWithConditionsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetMultiVariablesBySlotImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void SetMultiVariablesByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetMultiVariablesByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void DeleteMultiVariablesByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        static void UploadDataImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void DownloadDataImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void DeleteMultiDataBySlotImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void DeleteMultiDataByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetMultiDataStatusesBySlotImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);
        static void GetMultiDataStatusesByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result);

        struct UploadParams
        {
            WebApiUserContext* userWebCtx;
            const char* accountId;
            Int32 slotId;

            Int32 dataSize;
            void* data;

            size_t infoSize;
            void* info;

            bool isServiceLabelSet;
            Int32 serviceLabel;

            bool isComparedLastUpdatedDateTimeSet;
            SceRtcTick compareTick;

            bool isComparedLastUpdatedUserAccountId;
            char* compareAccountIdStr;
        };

        static int UploadDataAndSetInfo(UploadParams* uploadParams);

        static void WriteVariable(BinaryWriter& writer, const TCS::Variable* variable);
        static void WriteVariable(BinaryWriter& writer, const TCS::IdempotentVariable* variable);

        static void WriteDataStatus(BinaryWriter& writer, const TCS::DataStatus* dataStatus);
    };
}
# 32 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp" 2




#pragma comment(lib,"libSceNpCppWebApi_stub_weak.a")
#pragma comment(lib,"libSceNpWebApi2_stub_weak.a")
#pragma comment(lib,"libSceJson2_stub_weak.a")


extern size_t g_args;
extern const void *g_argp;

namespace psn
{
    extern "C" __declspec (dllexport) void PSN_PrxInitialize (InitResult* initResult, APIResult* result)
    {
        Main::Initialize(*initResult, result);
    }

    extern "C" __declspec (dllexport) void PSN_PrxUpdate ()
    {
        Main::Update();
    }

    extern "C" __declspec (dllexport) void PSN_PrxShutDown (APIResult* result)
    {
        Main::Shutdown(result);
    }

    extern "C" __declspec (dllexport) void PSN_PrxProcessMsg (void* sourceData, int sourceSize, void* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        MsgHandler::ProcessMsg((UInt8*)sourceData, sourceSize, (UInt8*)resultsData, resultsMaxSize, resultsSize, result);
    }




    bool Main::s_Initialised = false;
    PrxPluginInterface Main::s_PrxInterface;
    SceKernelModule Main::s_CoreHandle;


    void Main::Initialize(InitResult& initResult, APIResult* result)
    {
        if (s_Initialised)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "PSNCore Plugin already initialised", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 78));
            return;
        }

        int ret = 0;




        if (g_args != -1)
            Main::s_PrxInterface.InitialisePrxPluginArgs(g_args, g_argp, "PSN");


        ret = LoadModules(result);
        if (ret < 0)
        {
            return;
        }

        s_PrxInterface.SetupRuntimeInterfaces();


        MsgHandler::InitialiseSystemEventManager(s_PrxInterface.m_IEventQueue);


        s_Initialised = true;

        initResult.initialized = true;



        initResult.sceSDKVersion = (0x08000045u);


        ret = WebApi::Initialise();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 115));
            return;
        }

        WebApiNotifications::Initialise();

        UserSystem::RegisterMethods();


        UniversalDataSystem::InitializeLib();
        UniversalDataSystem::RegisterMethods();


        GameIntent::InitializeLib();
        GameIntent::RegisterMethods();

        WebApiNotifications::RegisterMethods();


        TrophyService::RegisterMethods();
        FeatureGating::RegisterMethods();

        GameUpdate::InitializeLib();
        GameUpdate::RegisterMethods();

        Bandwidth::RegisterMethods();

        OnlineSafety::RegisterMethods();
        Authentication::RegisterMethods();

        SessionsManager::InitializeLib();
        SessionsManager::RegisterMethods();

        Leaderboards::RegisterMethods();

        TitleCloudStorage::RegisterMethods();


        EntitlementsSystem::Initialize();
        EntitlementsSystem::RegisterMethods();

        CommerceCommands::RegisterMethods();
        PlayerReviewDialog::RegisterMethods();
        PlayerInvitationDialog::RegisterMethods();


        SessionSignalling::InitializeLib(WebApi::Instance()->GetLibHttp2CtxId());
        SessionSignalling::RegisterMethods();
        Sockets::RegisterMethods();

        MsgDialog::RegisterMethods();
        MsgDialog::InitializeLib();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Main::Update()
    {
        if (s_Initialised == false)
        {
            return;
        }

        int ret = sceNpCheckCallback();

        if (ret != 0)
        {
        }
    }

    void Main::Shutdown(APIResult* result)
    {

        MsgHandler::ShutdownSystemEventManager();


        PRXHelphers::UnloadPRX(s_CoreHandle);

        MsgDialog::TerminateLib();
        UniversalDataSystem::TerminateLib();
        GameUpdate::TerminateLib();

        GameIntent::TerminateLib();

        SessionsManager::TerminateLib();

        WebApiNotifications::Terminate();
        WebApi::Terminate();

        int ret = UnloadModules(__null);
        if (ret < 0)
        {
            return;
        }

        s_Initialised = false;
    }

    int Main::LoadModules(APIResult* result)
    {
        int ret = 0;


        ret = sceSysmoduleLoadModule(0x0105);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error loading SCE_SYSMODULE_NP_UNIVERSAL_DATA_SYSTEM", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 223));
            return ret;
        }

        ret = sceSysmoduleLoadModule(0x0110);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error loading SCE_SYSMODULE_NP_TROPHY2", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 232));
            return ret;
        }

        ret = sceSysmoduleLoadModule(0x0113);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error loading SCE_SYSMODULE_NP_ENTITLEMENT_ACCESS", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 241));
            return ret;
        }


        ret = sceSysmoduleLoadModule(0x0019);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error loading SCE_SYSMODULE_NP_UTILITY", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 251));
            return ret;
        }

        ret = sceSysmoduleLoadModule(0x0115);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error loading SCE_SYSMODULE_NP_CPP_WEB_API", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 260));
            return ret;
        }

        ret = sceSysmoduleLoadModule(0x009d);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error loading SCE_SYSMODULE_NP_AUTH", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 269));
            return ret;
        }


        ret = sceSysmoduleLoadModule(0x00a8);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error loading SCE_SYSMODULE_NP_COMMERCE", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 279));
            return ret;
        }
# 294 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp"
        ret = sceSysmoduleLoadModule(0x0112);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error loading SCE_SYSMODULE_NP_SESSION_SIGNALING", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 299));
            return ret;
        }

        return 0;
    }

    int Main::UnloadModules(APIResult* result)
    {
        int ret;


        ret = sceSysmoduleUnloadModule(0x0112);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error unloading SCE_SYSMODULE_NP_SESSION_SIGNALING", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 316));
            return ret;
        }
# 329 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp"
        ret = sceSysmoduleUnloadModule(0x00a8);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error unloading SCE_SYSMODULE_NP_COMMERCE", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 334));
            return ret;
        }


        ret = sceSysmoduleUnloadModule(0x0115);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error unloading SCE_SYSMODULE_NP_CPP_WEB_API", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 344));
            return ret;
        }

        ret = sceSysmoduleUnloadModule(0x009d);
        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error unloading SCE_SYSMODULE_NP_AUTH", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 352));
            return ret;
        }


        ret = sceSysmoduleUnloadModule(0x0105);
        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error unloading SCE_SYSMODULE_NP_UNIVERSAL_DATA_SYSTEM", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 361));
            return ret;
        }
# 373 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp"
        ret = sceSysmoduleUnloadModule(0x0113);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error unloading SCE_SYSMODULE_NP_ENTITLEMENT_ACCESS", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 378));
            return ret;
        }


        ret = sceSysmoduleUnloadModule(0x0019);

        if (ret < 0)
        {

            (psn::APIResult::SetSceResultMessage(result, psn::APIResultTypes::Error, ret, "Error unloading SCE_SYSMODULE_NP_UTILITY", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp", 388));
            return ret;
        }

        return 0;
    }
# 406 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\CoreMain.cpp"
}
# 11 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp" 1





#pragma comment(lib,"libSceNpEntitlementAccess_stub_weak.a")


namespace psn
{
    void EntitlementsSystem::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::GetAdditionalContentEntitlementInfoList, EntitlementsSystem::GetAdditionalContentEntitlementInfoListImpl);
        MsgHandler::AddMethod(Methods::GetSkuFlag, EntitlementsSystem::GetSkuFlagImpl);
        MsgHandler::AddMethod(Methods::GetAdditionalContentEntitlementInfo, EntitlementsSystem::GetAdditionalContentEntitlementInfoImpl);
        MsgHandler::AddMethod(Methods::GetEntitlementKey, EntitlementsSystem::GetEntitlementKeyImpl);

        MsgHandler::AddMethod(Methods::AbortRequest, EntitlementsSystem::AbortRequestImpl);
        MsgHandler::AddMethod(Methods::DeleteRequest, EntitlementsSystem::DeleteRequestImpl);
        MsgHandler::AddMethod(Methods::GenerateTransactionId, EntitlementsSystem::GenerateTransactionIdImpl);
        MsgHandler::AddMethod(Methods::PollUnifiedEntitlementInfo, EntitlementsSystem::PollUnifiedEntitlementInfoImpl);
        MsgHandler::AddMethod(Methods::PollUnifiedEntitlementInfoList, EntitlementsSystem::PollUnifiedEntitlementInfoListImpl);
        MsgHandler::AddMethod(Methods::PollServiceEntitlementInfo, EntitlementsSystem::PollServiceEntitlementInfoImpl);
        MsgHandler::AddMethod(Methods::PollServiceEntitlementInfoList, EntitlementsSystem::PollServiceEntitlementInfoListImpl);
        MsgHandler::AddMethod(Methods::PollConsumeEntitlement, EntitlementsSystem::PollConsumeEntitlementImpl);
        MsgHandler::AddMethod(Methods::RequestUnifiedEntitlementInfo, EntitlementsSystem::RequestUnifiedEntitlementInfoImpl);
        MsgHandler::AddMethod(Methods::RequestUnifiedEntitlementInfoList, EntitlementsSystem::RequestUnifiedEntitlementInfoListImpl);
        MsgHandler::AddMethod(Methods::RequestServiceEntitlementInfo, EntitlementsSystem::RequestServiceEntitlementInfoImpl);
        MsgHandler::AddMethod(Methods::RequestServiceEntitlementInfoList, EntitlementsSystem::RequestServiceEntitlementInfoListImpl);
        MsgHandler::AddMethod(Methods::RequestConsumeUnifiedEntitlement, EntitlementsSystem::RequestConsumeUnifiedEntitlementImpl);
        MsgHandler::AddMethod(Methods::RequestConsumeServiceEntitlement, EntitlementsSystem::RequestConsumeServiceEntitlementImpl);
    }

    void EntitlementsSystem::Initialize()
    {
        SceNpEntitlementAccessInitParam initParam;
        SceNpEntitlementAccessBootParam bootParam;


        memset(&initParam, 0, sizeof(SceNpEntitlementAccessInitParam));
        memset(&bootParam, 0, sizeof(SceNpEntitlementAccessBootParam));


        sceNpEntitlementAccessInitialize(&initParam, &bootParam);
    }

    void EntitlementsSystem::GetSkuFlagImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        SceNpEntitlementAccessSkuFlag skuflag;

        int ret = sceNpEntitlementAccessGetSkuFlag(&skuflag);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 54));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(skuflag);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void EntitlementsSystem::GetAdditionalContentEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        SceNpEntitlementAccessAddcontEntitlementInfo *list = __null;
        uint32_t listNum = 0;
        uint32_t hitNum;
        int ret = sceNpEntitlementAccessGetAddcontEntitlementInfoList(serviceLabel, list, listNum, &hitNum);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 82));
            return;
        }


        if (hitNum > 0)
        {
            list = (SceNpEntitlementAccessAddcontEntitlementInfo *)malloc(sizeof(SceNpEntitlementAccessAddcontEntitlementInfo) * hitNum);
            listNum = hitNum;


            ret = sceNpEntitlementAccessGetAddcontEntitlementInfoList(serviceLabel, list, listNum, &hitNum);
            if (ret < 0)
            {
                free(list);
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 97));
                return;
            }
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(hitNum);

        for (int i = 0; i < hitNum; i++)
        {
            writer.WriteString(list[i].entitlementLabel.data);
            writer.WriteUInt32(list[i].packageType);
            writer.WriteUInt32(list[i].downloadStatus);
        }

        *resultsSize = writer.GetWrittenLength();

        if (list != __null) free(list);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::GetAdditionalContentEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        char* label = reader.ReadStringPtr();

        SceNpUnifiedEntitlementLabel entitlementLabel;
        SceNpEntitlementAccessAddcontEntitlementInfo info;

        memset(&entitlementLabel, 0, sizeof(SceNpUnifiedEntitlementLabel));
        memset(&info, 0, sizeof(SceNpEntitlementAccessAddcontEntitlementInfo));

        strncpy(entitlementLabel.data, label, (17));

        int ret = sceNpEntitlementAccessGetAddcontEntitlementInfo(serviceLabel, &entitlementLabel, &info);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 141));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteString(info.entitlementLabel.data);
        writer.WriteUInt32(info.packageType);
        writer.WriteUInt32(info.downloadStatus);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::GetEntitlementKeyImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        char* label = reader.ReadStringPtr();

        SceNpUnifiedEntitlementLabel entitlementLabel;
        SceNpEntitlementAccessEntitlementKey key;

        memset(&entitlementLabel, 0, sizeof(SceNpUnifiedEntitlementLabel));
        memset(&key, 0, sizeof(SceNpEntitlementAccessEntitlementKey));

        strncpy(entitlementLabel.data, label, (17));

        int ret = sceNpEntitlementAccessGetEntitlementKey(serviceLabel, &entitlementLabel, &key);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 177));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteString(key.data, (16));

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void EntitlementsSystem::AbortRequestImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int64 requestId = reader.ReadInt64();

        int ret = sceNpEntitlementAccessAbortRequest(requestId);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 204));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::DeleteRequestImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int64 requestId = reader.ReadInt64();

        int ret = sceNpEntitlementAccessDeleteRequest(requestId);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 223));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void EntitlementsSystem::GenerateTransactionIdImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        SceNpEntitlementAccessTransactionId transactionId;
        memset(&transactionId, 0, sizeof(SceNpEntitlementAccessTransactionId));

        int ret = sceNpEntitlementAccessGenerateTransactionId(&transactionId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 241));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteString(transactionId.transactionId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void EntitlementsSystem::RequestUnifiedEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        char* label = reader.ReadStringPtr();

        SceNpUnifiedEntitlementLabel entitlementLabel;

        memset(&entitlementLabel, 0, sizeof(SceNpUnifiedEntitlementLabel));

        if (label != __null)
        {
            strncpy(entitlementLabel.data, label, (17));
        }

        Int64 requestId;
        int ret = sceNpEntitlementAccessRequestUnifiedEntitlementInfo(userId, serviceLabel, &entitlementLabel, &requestId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 280));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt64(requestId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::PollUnifiedEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int64 requestId = reader.ReadInt64();

        SceNpEntitlementAccessUnifiedEntitlementInfo info;

        int requestResult = 0;

        int ret = sceNpEntitlementAccessPollUnifiedEntitlementInfo(requestId, &requestResult, &info);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 309));
            return;
        }

        if (requestResult < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, requestResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 315));
            return;
        }


        bool isFinished = ret == (0);


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(isFinished);

        if (isFinished == true)
        {
            Write(writer, info);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void EntitlementsSystem::RequestUnifiedEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        Int32 offset = reader.ReadInt32();
        uint32_t maxNum = reader.ReadUInt32();
        maxNum = maxNum < (100) ? maxNum : (100);

        SceNpEntitlementAccessPackageType packageType = (SceNpEntitlementAccessPackageType)reader.ReadInt32();

        SceNpEntitlementAccessSortType sort = (SceNpEntitlementAccessSortType)reader.ReadInt32();
        SceNpEntitlementAccessDirectionType direction = (SceNpEntitlementAccessDirectionType)reader.ReadInt32();

        SceNpEntitlementAccessRequestEntitlementInfoListParam param;

        param.size = sizeof(param);
        param.entitlementType = (2);
        param.offset = offset;
        param.limit = maxNum;
        param.sort = sort;
        param.direction = direction;
        param.packageType = packageType;

        Int64 requestId;
        int ret = sceNpEntitlementAccessRequestUnifiedEntitlementInfoList(userId, serviceLabel, __null, 0, &param, &requestId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 371));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt64(requestId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::PollUnifiedEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int64 requestId = reader.ReadInt64();
        uint32_t maxNum = reader.ReadUInt32();

        uint32_t hitNum = 0;
        int32_t nextOffset = 0;
        int32_t previousOffset = 0;

        SceNpEntitlementAccessUnifiedEntitlementInfo* list = (SceNpEntitlementAccessUnifiedEntitlementInfo*)malloc(sizeof(SceNpEntitlementAccessUnifiedEntitlementInfo) * (100));
        uint32_t listNum = maxNum < (100) ? maxNum : (100);

        int requestResult = 0;

        int ret = sceNpEntitlementAccessPollUnifiedEntitlementInfoList(requestId, &requestResult, list, listNum, &hitNum, &nextOffset, &previousOffset);
        if (ret < 0)
        {
            if (list != __null) free(list);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 407));
            return;
        }

        if (requestResult < 0)
        {
            if (list != __null) free(list);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, requestResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 414));
            return;
        }


        bool isFinished = ret == (0);


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(isFinished);

        if (isFinished == true)
        {

            writer.WriteInt32(nextOffset);
            writer.WriteInt32(previousOffset);

            writer.WriteInt32(hitNum);

            for (int i = 0; i < hitNum; i++)
            {
                Write(writer, list[i]);
            }
        }

        *resultsSize = writer.GetWrittenLength();

        if (list != __null) free(list);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void EntitlementsSystem::RequestServiceEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        char* label = reader.ReadStringPtr();

        SceNpServiceEntitlementLabel entitlementLabel;

        memset(&entitlementLabel, 0, sizeof(SceNpServiceEntitlementLabel));
        strncpy(entitlementLabel.data, label, (7));

        Int64 requestId;
        int ret = sceNpEntitlementAccessRequestServiceEntitlementInfo(userId, serviceLabel, &entitlementLabel, &requestId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 469));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt64(requestId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::PollServiceEntitlementInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int64 requestId = reader.ReadInt64();

        SceNpEntitlementAccessServiceEntitlementInfo info;

        int requestResult = 0;

        int ret = sceNpEntitlementAccessPollServiceEntitlementInfo(requestId, &requestResult, &info);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 498));
            return;
        }

        if (requestResult < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, requestResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 504));
            return;
        }


        bool isFinished = ret == (0);


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(isFinished);

        if (isFinished == true)
        {
            Write(writer, info);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void EntitlementsSystem::RequestServiceEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        Int32 offset = reader.ReadInt32();
        uint32_t maxNum = reader.ReadUInt32();
        maxNum = maxNum < (100) ? maxNum : (100);

        SceNpEntitlementAccessSortType sort = (SceNpEntitlementAccessSortType)reader.ReadInt32();
        SceNpEntitlementAccessDirectionType direction = (SceNpEntitlementAccessDirectionType)reader.ReadInt32();

        SceNpEntitlementAccessRequestEntitlementInfoListParam param;

        param.size = sizeof(param);
        param.entitlementType = (1);
        param.offset = offset;
        param.limit = maxNum;
        param.sort = sort;
        param.direction = direction;
        param.packageType = (0);

        Int64 requestId;
        int ret = sceNpEntitlementAccessRequestServiceEntitlementInfoList(userId, serviceLabel, __null, 0, &param, &requestId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 558));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt64(requestId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::PollServiceEntitlementInfoListImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int64 requestId = reader.ReadInt64();
        uint32_t maxNum = reader.ReadUInt32();

        uint32_t hitNum = 0;
        int32_t nextOffset = 0;
        int32_t previousOffset = 0;

        SceNpEntitlementAccessServiceEntitlementInfo* list = (SceNpEntitlementAccessServiceEntitlementInfo*)malloc(sizeof(SceNpEntitlementAccessServiceEntitlementInfo) * (100));
        uint32_t listNum = maxNum < (100) ? maxNum : (100);

        int requestResult = 0;

        int ret = sceNpEntitlementAccessPollServiceEntitlementInfoList(requestId, &requestResult, list, listNum, &hitNum, &nextOffset, &previousOffset);
        if (ret < 0)
        {
            if (list != __null) free(list);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 594));
            return;
        }

        if (requestResult < 0)
        {
            if (list != __null) free(list);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, requestResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 601));
            return;
        }


        bool isFinished = ret == (0);


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(isFinished);

        if (isFinished == true)
        {

            writer.WriteInt32(nextOffset);
            writer.WriteInt32(previousOffset);

            writer.WriteInt32(hitNum);

            for (int i = 0; i < hitNum; i++)
            {
                Write(writer, list[i]);
            }
        }

        *resultsSize = writer.GetWrittenLength();

        if (list != __null) free(list);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void EntitlementsSystem::RequestConsumeUnifiedEntitlementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        Int32 useCount = reader.ReadInt32();

        char* label = reader.ReadStringPtr();

        char* transactionIdStr = reader.ReadStringPtr();

        SceNpUnifiedEntitlementLabel entitlementLabel;

        memset(&entitlementLabel, 0, sizeof(SceNpUnifiedEntitlementLabel));
        strncpy(entitlementLabel.data, label, (17));

        SceNpEntitlementAccessTransactionId transactionId;
        memset(&transactionId, 0, sizeof(SceNpEntitlementAccessTransactionId));
        strncpy(transactionId.transactionId, transactionIdStr, (65));

        Int64 requestId;
        int ret = sceNpEntitlementAccessRequestConsumeUnifiedEntitlement(userId, serviceLabel, &entitlementLabel, &transactionId, useCount, &requestId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 664));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt64(requestId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::RequestConsumeServiceEntitlementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        Int32 useCount = reader.ReadInt32();

        char* label = reader.ReadStringPtr();

        char* transactionIdStr = reader.ReadStringPtr();

        SceNpServiceEntitlementLabel entitlementLabel;

        memset(&entitlementLabel, 0, sizeof(SceNpServiceEntitlementLabel));
        strncpy(entitlementLabel.data, label, (7));

        SceNpEntitlementAccessTransactionId transactionId;
        memset(&transactionId, 0, sizeof(SceNpEntitlementAccessTransactionId));
        strncpy(transactionId.transactionId, transactionIdStr, (65));

        Int64 requestId;
        int ret = sceNpEntitlementAccessRequestConsumeServiceEntitlement(userId, serviceLabel, &entitlementLabel, &transactionId, useCount, &requestId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 707));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt64(requestId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void EntitlementsSystem::PollConsumeEntitlementImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int64 requestId = reader.ReadInt64();

        Int32 useLimit = 0;

        int requestResult = 0;

        int ret = sceNpEntitlementAccessPollConsumeEntitlement(requestId, &requestResult, &useLimit);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 736));
            return;
        }

        if (requestResult < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, requestResult, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Entitlements.cpp", 742));
            return;
        }


        bool isFinished = ret == (0);


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(isFinished);

        if (isFinished == true)
        {
            writer.WriteInt32(useLimit);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }



    void EntitlementsSystem::Write(BinaryWriter& writer, SceNpEntitlementAccessUnifiedEntitlementInfo& unifiedInfo)
    {
        if (unifiedInfo.inactiveDate.tick != (0xffffffffffffffffUL))
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(unifiedInfo.inactiveDate);
        }
        else
        {
            writer.WriteBool(false);
        }

        if (unifiedInfo.activeDate.tick != (0xffffffffffffffffUL))
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(unifiedInfo.activeDate);
        }
        else
        {
            writer.WriteBool(false);
        }

        writer.WriteString(unifiedInfo.entitlementLabel.data);
        writer.WriteInt32(unifiedInfo.entitlementType);
        writer.WriteInt32(unifiedInfo.useCount);
        writer.WriteInt32(unifiedInfo.useLimit);
        writer.WriteUInt32(unifiedInfo.packageType);
        writer.WriteBool(unifiedInfo.activeFlag);
    }

    void EntitlementsSystem::Write(BinaryWriter& writer, SceNpEntitlementAccessServiceEntitlementInfo& serviceInfo)
    {
        if (serviceInfo.inactiveDate.tick != (0xffffffffffffffffUL))
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(serviceInfo.inactiveDate);
        }
        else
        {
            writer.WriteBool(false);
        }

        if (serviceInfo.activeDate.tick != (0xffffffffffffffffUL))
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(serviceInfo.activeDate);
        }
        else
        {
            writer.WriteBool(false);
        }

        writer.WriteString(serviceInfo.entitlementLabel.data);
        writer.WriteInt32(serviceInfo.entitlementType);
        writer.WriteInt32(serviceInfo.useCount);
        writer.WriteInt32(serviceInfo.useLimit);
        writer.WriteBool(serviceInfo.activeFlag);
        writer.WriteBool(serviceInfo.isConsumable);
    }
}
# 12 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\FeatureGating.cpp" 1




#pragma comment(lib,"libSceNpManager_stub_weak.a")


namespace psn
{
    std::list<FeatureGating::PremiumEvent> FeatureGating::s_PendingPremiumEventsList;

    void FeatureGating::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::CheckPremium, FeatureGating::CheckPremiumImpl);
        MsgHandler::AddMethod(Methods::NotifyPremiumFeature, FeatureGating::NotifyPremiumFeatureImpl);

        MsgHandler::AddMethod(Methods::StartPremiumEventCallback, FeatureGating::StartPremiumEventCallbackImpl);
        MsgHandler::AddMethod(Methods::StopPremiumEventCallback, FeatureGating::StopPremiumEventCallbackImpl);
        MsgHandler::AddMethod(Methods::FetchPremiumEvent, FeatureGating::FetchPremiumEventImpl);
    }

    void FeatureGating::CheckPremiumImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        SceNpCheckPremiumResult checkResult;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        UInt64 features = reader.ReadUInt64();

        int ret = sceNpCreateRequest();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\FeatureGating.cpp", 36));
            return;
        }

        int requestId = ret;

        SceNpCheckPremiumParameter checkParam;
        memset(&checkParam, 0, sizeof(checkParam));
        checkParam.size = sizeof(checkParam);
        checkParam.features = features;
        checkParam.userId = userId;
        ret = sceNpCheckPremium(requestId, &checkParam, &checkResult);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\FeatureGating.cpp", 50));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(checkResult.authorized);

        *resultsSize = writer.GetWrittenLength();

        sceNpDeleteRequest(requestId);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void FeatureGating::NotifyPremiumFeatureImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        UInt64 features = reader.ReadUInt64();
        UInt64 properties = reader.ReadUInt64();

        SceNpNotifyPremiumFeatureParameter param;
        memset(&param, 0x0, sizeof(param));

        param.size = sizeof(param);
        param.userId = userId;
        param.features = features;
        param.properties = properties;

        int ret = sceNpNotifyPremiumFeature(&param);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\FeatureGating.cpp", 84));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void FeatureGating::PremiumEventCallback(SceUserServiceUserId userId, SceNpPremiumEventType eventType, void *userData)
    {
        PremiumEvent event;

        event.userId = userId;
        event.eventType = eventType;

        s_PendingPremiumEventsList.push_back(event);
    }

    void FeatureGating::StartPremiumEventCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        int ret = sceNpRegisterPremiumEventCallback(PremiumEventCallback, __null);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\FeatureGating.cpp", 106));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void FeatureGating::StopPremiumEventCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        int ret = sceNpUnregisterPremiumEventCallback();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\FeatureGating.cpp", 118));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void FeatureGating::FetchPremiumEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        if (s_PendingPremiumEventsList.empty() == true)
        {
            *resultsSize = 0;
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
            return;
        }


        PremiumEvent event = s_PendingPremiumEventsList.front();
        s_PendingPremiumEventsList.pop_front();


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(event.userId);
        writer.WriteInt32(event.eventType);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 13 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameIntent.cpp" 1



#pragma comment(lib,"libSceNpGameIntent_stub_weak.a")

namespace psn
{






    std::list<SceNpGameIntentInfo> GameIntent::s_PendingGameIntentList;

    void GameIntent::InitializeLib()
    {
        SceNpGameIntentInitParam initParam;
        sceNpGameIntentInitParamInit(&initParam);
        int ret = sceNpGameIntentInitialize(&initParam);

        if (ret < 0)
        {
            printf("Error initialising GameIntent, 0x%x\n", ret);
        }
    }

    void GameIntent::TerminateLib()
    {
        sceNpGameIntentTerminate();
    }

    void GameIntent::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::FetchGameIntent, GameIntent::FetchGameIntentImpl);

        MsgHandler::RegisterSystemEventCallback(HandleSystemEvent);
    }

    void GameIntent::FetchGameIntentImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        if (s_PendingGameIntentList.empty() == true)
        {
            *resultsSize = 0;
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
            return;
        }


        SceNpGameIntentInfo intentInfo = s_PendingGameIntentList.front();
        s_PendingGameIntentList.pop_front();


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteString(intentInfo.intentType);

        writer.WriteUInt32(intentInfo.userId);

        if (strncmp(intentInfo.intentType, "joinSession", sizeof(intentInfo.intentType)) == 0)
        {
            WriteIntentProperty(intentInfo.intentData, "playerSessionId", (37), writer);
            WriteIntentProperty(intentInfo.intentData, "memberType", (17), writer);
        }
        else if (strncmp(intentInfo.intentType, "launchActivity", sizeof(intentInfo.intentType)) == 0)
        {
            WriteIntentProperty(intentInfo.intentData, "activityId", (33), writer);
        }
        else if (strncmp(intentInfo.intentType, "launchMultiplayerActivity", sizeof(intentInfo.intentType)) == 0)
        {
            WriteIntentProperty(intentInfo.intentData, "activityId", (33), writer);
            WriteIntentProperty(intentInfo.intentData, "playerSessionId", (37), writer);
        }



        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void GameIntent::WriteIntentProperty(SceNpGameIntentData& intentData, const char* key, int maxValueLength, BinaryWriter& writer)
    {
        char value[(50)];
        sceNpGameIntentGetPropertyValueString(&intentData, key, value, sizeof(value));
        writer.WriteString(value);
    }

    void GameIntent::HandleSystemEvent(SceSystemServiceEvent& sevent)
    {
        if (sevent.eventType == SCE_SYSTEM_SERVICE_EVENT_GAME_INTENT)
        {
            SceNpGameIntentInfo intentInfo;
            sceNpGameIntentInfoInit(&intentInfo);
            int ret = sceNpGameIntentReceiveIntent(&intentInfo);
            if (ret == 0)
            {
                s_PendingGameIntentList.push_back(intentInfo);
            }
        }
    }
}
# 14 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp" 1







namespace psn
{
    void GameSessionCommands::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::CreateGameSession, GameSessionCommands::CreateGameSessionImpl);
        MsgHandler::AddMethod(Methods::LeaveGameSession, GameSessionCommands::LeaveGameSessionImpl);
        MsgHandler::AddMethod(Methods::JoinGameSession, GameSessionCommands::JoinGameSessionImpl);
        MsgHandler::AddMethod(Methods::GetGameSessions, GameSessionCommands::GetGameSessionsImpl);
        MsgHandler::AddMethod(Methods::SetGameSessionProperties, GameSessionCommands::SetGameSessionPropertiesImpl);
        MsgHandler::AddMethod(Methods::SetGameSessionMemberSystemProperties, GameSessionCommands::SetGameSessionMemberSystemPropertiesImpl);
        MsgHandler::AddMethod(Methods::SendGameSessionMessage, GameSessionCommands::SendGameSessionMessageImpl);
        MsgHandler::AddMethod(Methods::GetJoinedGameSessionsByUser, GameSessionCommands::GetJoinedGameSessionsByUserImpl);
        MsgHandler::AddMethod(Methods::DeleteGameSession, GameSessionCommands::DeleteGameSessionImpl);
        MsgHandler::AddMethod(Methods::GameSessionsSearch, GameSessionCommands::GameSessionsSearchImpl);
    }


    void GameSessionCommands::GSMember::Deserialise(BinaryReader& reader)
    {
        m_UserId = reader.ReadInt32();
        m_PushCallbackId = reader.ReadInt32();
        m_AccountId = reader.ReadUInt64();
        m_Platform = reader.ReadInt32();
        m_JoinState = (InitialJoinState)reader.ReadInt32();
        m_NatType = reader.ReadInt32();

        m_CustomDataSize1 = reader.ReadInt32();
        m_CustomData1 = __null;

        if (m_CustomDataSize1 > 0)
        {
            m_CustomData1 = reader.ReadDataPtr(m_CustomDataSize1);
        }
    }

    GameSessionCommands::InitializationParams::InitializationParams() :
        m_MaxPlayers(0),
        m_MaxSpectators(0),
        m_PlatformFlags(0),
        m_JoinDisabled(false),
        m_UsePlayerSession(false),
        m_ReservationTimeoutSeconds(0),
        m_NumberMembers(0),
        m_Members(__null),
        m_CustomDataSize1(0),
        m_CustomData1(__null),
        m_CustomDataSize2(0),
        m_CustomData2(__null),
        m_Searchable(true)
    {
    }

    GameSessionCommands::InitializationParams::~InitializationParams()
    {
        if (m_Members != __null) delete[] m_Members;
    }

    void GameSessionCommands::InitializationParams::Deserialise(BinaryReader& reader)
    {
        m_MaxPlayers = reader.ReadUInt32();
        m_MaxSpectators = reader.ReadUInt32();
        m_PlatformFlags = reader.ReadUInt32();

        m_JoinDisabled = reader.ReadBool();
        m_UsePlayerSession = reader.ReadBool();
        m_ReservationTimeoutSeconds = reader.ReadInt32();

        m_NumberMembers = reader.ReadUInt32();
        if (m_NumberMembers > 0)
        {
            m_Members = new GSMember[m_NumberMembers];

            for (int i = 0; i < m_NumberMembers; i++)
            {
                m_Members[i].Deserialise(reader);
            }
        }

        m_CustomDataSize1 = reader.ReadInt32();
        if (m_CustomDataSize1 > 0)
        {
            m_CustomData1 = reader.ReadDataPtr(m_CustomDataSize1);
        }

        m_CustomDataSize2 = reader.ReadInt32();
        if (m_CustomDataSize2 > 0)
        {
            m_CustomData2 = reader.ReadDataPtr(m_CustomDataSize2);
        }
        m_Searchable = reader.ReadBool();

        m_SearchIndex = reader.ReadStringPtr();


        m_StringsSetBits = reader.ReadUInt32();
        m_IntsSetBits = reader.ReadUInt32();
        m_BoolsSetBits = reader.ReadUInt32();
        for (int i = 0; i < kNumSearchAttributes; i++)
        {
            m_Strings[i] = reader.ReadStringPtr();
            m_Ints[i] = reader.ReadInt32();
            m_Bools[i] = reader.ReadBool();
        }
    }


    void GameSessionCommands::CreateGameSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        GSMember creator;
        creator.Deserialise(reader);

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(creator.m_UserId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 129));
            return;
        }

        ret = userCtx->GetAccountId(&creator.m_AccountId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 136));
            return;
        }

        creator.m_Platform = Utils::GetThisPlatformFlag();

        InitializationParams params;
        params.Deserialise(reader);

        BinaryWriter writer(resultsData, resultsMaxSize);

        ret = Create(creator, params, writer);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 151));
            return;
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int GameSessionCommands::AddUser(GSMember& member, Vector<IntrusivePtr<RequestGameSessionPlayer> >& requestGameSessionPlayers)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        int ret = 0;


        IntrusivePtr<RequestGameSessionPlayer> requestGameSessionPlayerPtr;

        char accountId[32] = { 0 };
        snprintf(accountId, sizeof(accountId) - 1, "%lu", member.m_AccountId);
        ret = RequestGameSessionPlayerFactory::create(libContextPtr, accountId, Utils::ToPlatformString(member.m_Platform), &requestGameSessionPlayerPtr);
        if (ret < 0)
        {
            return ret;
        }

        if (member.m_JoinState != InitialJoinState::_NOT_SET)
        {

            requestGameSessionPlayerPtr->setJoinState(member.m_JoinState);
        }

        if (member.m_NatType != 0)
        {
            requestGameSessionPlayerPtr->setNatType(member.m_NatType);
        }

        int pushCallbackId = member.m_PushCallbackId;

        if (pushCallbackId != 0)
        {
            OrderGuaranteedPushEvent* pushEvent = WebApiNotifications::FindOrderedPushEvent(pushCallbackId);

            if (pushEvent == __null)
            {
                return -1;
            }


            IntrusivePtr<GameSessionPushContext> gameSessionPushContextPtr;
            ret = GameSessionPushContextFactory::create(libContextPtr, pushEvent->GetPushContextIdStr(), &gameSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }

            Vector<IntrusivePtr<GameSessionPushContext> > gameSessionPushContexts(libContextPtr);
            ret = gameSessionPushContexts.pushBack(gameSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }

            ret = requestGameSessionPlayerPtr->setPushContexts(gameSessionPushContexts);
            if (ret < 0)
            {
                return ret;
            }
        }

        if (member.m_CustomDataSize1 > 0)
        {
            ret = requestGameSessionPlayerPtr->setCustomData1(member.m_CustomData1, member.m_CustomDataSize1);
            if (ret < 0)
            {
                return ret;
            }
        }


        ret = requestGameSessionPlayers.pushBack(requestGameSessionPlayerPtr);
        if (ret < 0)
        {
            return ret;
        }

        return 0;
    }

    void GameSessionCommands::LeaveGameSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();
        const char* sessionId = reader.ReadStringPtr();

        int ret = Leave(userId, sessionId);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 252));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        SceNpAccountId accountId = (0);
        sceNpGetAccountIdA(userId, &accountId);

        writer.WriteUInt64(accountId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void GameSessionCommands::JoinGameSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();
        Int32 pushCallbackId = reader.ReadInt32();
        bool joinAsSpector = reader.ReadBool();
        bool swapping = reader.ReadBool();
        const char* sessionId = reader.ReadStringPtr();


        BinaryWriter writer(resultsData, resultsMaxSize);

        if (joinAsSpector == false)
        {
            int ret = JoinAsPlayer(userId, pushCallbackId, sessionId, swapping, writer);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 288));
                return;
            }
        }
        else
        {
            int ret = JoinAsSpectator(userId, pushCallbackId, sessionId, swapping, writer);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 298));
                return;
            }
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int GameSessionCommands::Create(GSMember& creator, InitializationParams& initParams, BinaryWriter& writer)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        OrderGuaranteedPushEvent* pushEvent = WebApiNotifications::FindOrderedPushEvent(creator.m_PushCallbackId);

        if (pushEvent == __null)
        {
            return -1;
        }

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(creator.m_UserId);

        if (userCtx == __null)
        {
            return -1;
        }

        int ret = 0;


        Vector<IntrusivePtr<RequestGameSessionPlayer> > requestGameSessionPlayers(libContextPtr);

        AddUser(creator, requestGameSessionPlayers);


        for (int i = 0; i < initParams.m_NumberMembers; i++)
        {
            AddUser(initParams.m_Members[i], requestGameSessionPlayers);
        }


        IntrusivePtr<RequestGameSessionMemberPlayer> requestGameSessionMemberPlayer;
        ret = RequestGameSessionMemberPlayerFactory::create(libContextPtr, requestGameSessionPlayers, &requestGameSessionMemberPlayer);
        if (ret < 0)
        {
            return ret;
        }

        Vector<String> gameSessionSupportedPlatforms(libContextPtr);
        ret = Utils::AddPlatformStrings(initParams.m_PlatformFlags, gameSessionSupportedPlatforms);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<RequestGameSession> requestGameSessionPtr;
        ret = RequestGameSessionFactory::create(libContextPtr, initParams.m_MaxPlayers, requestGameSessionMemberPlayer, gameSessionSupportedPlatforms, &requestGameSessionPtr);
        if (ret < 0)
        {
            return ret;
        }


        requestGameSessionPtr->setMaxSpectators(initParams.m_MaxSpectators);

        requestGameSessionPtr->setJoinDisabled(initParams.m_JoinDisabled);

        requestGameSessionPtr->setUsePlayerSession(initParams.m_UsePlayerSession);

        requestGameSessionPtr->setReservationTimeoutSeconds(initParams.m_ReservationTimeoutSeconds);

        if (initParams.m_SearchIndex != __null)
        {
            ret = requestGameSessionPtr->setSearchIndex(initParams.m_SearchIndex);
            if (ret < 0)
            {
                return ret;
            }
        }

        if (initParams.m_StringsSetBits | initParams.m_IntsSetBits | initParams.m_BoolsSetBits)
        {

            IntrusivePtr<SearchAttributes> searchAttributes;
            ret = SearchAttributesFactory::create(libContextPtr, &searchAttributes);
            if (ret < 0)
            {
                return ret;
            }

            for (int i = 0; i < 10; i++)
            {
                if (initParams.m_StringsSetBits & (1 << i))
                {
                    switch (i)
                    {
                        case 0: ret = searchAttributes->setString1(initParams.m_Strings[i]); break;
                        case 1: ret = searchAttributes->setString2(initParams.m_Strings[i]); break;
                        case 2: ret = searchAttributes->setString3(initParams.m_Strings[i]); break;
                        case 3: ret = searchAttributes->setString4(initParams.m_Strings[i]); break;
                        case 4: ret = searchAttributes->setString5(initParams.m_Strings[i]); break;
                        case 5: ret = searchAttributes->setString6(initParams.m_Strings[i]); break;
                        case 6: ret = searchAttributes->setString7(initParams.m_Strings[i]); break;
                        case 7: ret = searchAttributes->setString8(initParams.m_Strings[i]); break;
                        case 8: ret = searchAttributes->setString9(initParams.m_Strings[i]); break;
                        case 9: ret = searchAttributes->setString10(initParams.m_Strings[i]); break;
                    }
                    if (ret < 0)
                    {
                        return ret;
                    }
                }
                if (initParams.m_IntsSetBits & (1 << i))
                {
                    switch (i)
                    {
                        case 0: searchAttributes->setInteger1(initParams.m_Ints[i]); break;
                        case 1: searchAttributes->setInteger2(initParams.m_Ints[i]); break;
                        case 2: searchAttributes->setInteger3(initParams.m_Ints[i]); break;
                        case 3: searchAttributes->setInteger4(initParams.m_Ints[i]); break;
                        case 4: searchAttributes->setInteger5(initParams.m_Ints[i]); break;
                        case 5: searchAttributes->setInteger6(initParams.m_Ints[i]); break;
                        case 6: searchAttributes->setInteger7(initParams.m_Ints[i]); break;
                        case 7: searchAttributes->setInteger8(initParams.m_Ints[i]); break;
                        case 8: searchAttributes->setInteger9(initParams.m_Ints[i]); break;
                        case 9: searchAttributes->setInteger10(initParams.m_Ints[i]); break;
                    }
                }
                if (initParams.m_BoolsSetBits & (1 << i))
                {
                    switch (i)
                    {
                        case 0: searchAttributes->setBoolean1(initParams.m_Bools[i]); break;
                        case 1: searchAttributes->setBoolean2(initParams.m_Bools[i]); break;
                        case 2: searchAttributes->setBoolean3(initParams.m_Bools[i]); break;
                        case 3: searchAttributes->setBoolean4(initParams.m_Bools[i]); break;
                        case 4: searchAttributes->setBoolean5(initParams.m_Bools[i]); break;
                        case 5: searchAttributes->setBoolean6(initParams.m_Bools[i]); break;
                        case 6: searchAttributes->setBoolean7(initParams.m_Bools[i]); break;
                        case 7: searchAttributes->setBoolean8(initParams.m_Bools[i]); break;
                        case 8: searchAttributes->setBoolean9(initParams.m_Bools[i]); break;
                        case 9: searchAttributes->setBoolean10(initParams.m_Bools[i]); break;
                    }
                }
            }
            ret = requestGameSessionPtr->setSearchAttributes(searchAttributes);
            if (ret < 0)
            {
                return ret;
            }
        }

        requestGameSessionPtr->setSearchable(initParams.m_Searchable);

        if (initParams.m_CustomDataSize1 > 0)
        {
            ret = requestGameSessionPtr->setCustomData1(initParams.m_CustomData1, initParams.m_CustomDataSize1);
            if (ret < 0)
            {
                return ret;
            }
        }

        if (initParams.m_CustomDataSize2 > 0)
        {
            ret = requestGameSessionPtr->setCustomData2(initParams.m_CustomData2, initParams.m_CustomDataSize2);
            if (ret < 0)
            {
                return ret;
            }
        }


        Vector<IntrusivePtr<RequestGameSession> > requestGameSessions(libContextPtr);
        ret = requestGameSessions.pushBack(requestGameSessionPtr);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<PostGameSessionsRequestBody> postGameSessionsRequestBody;
        ret = PostGameSessionsRequestBodyFactory::create(libContextPtr, requestGameSessions, &postGameSessionsRequestBody);
        if (ret < 0)
        {
            return ret;
        }


        GameSessionsApi::ParameterToCreateGameSessions param;
        ret = param.initialize(libContextPtr, postGameSessionsRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        typedef Common::IntrusivePtr<PostGameSessionsResponseBody> PostGameSessionsResponseType;
        PostGameSessionsResponseType response;

        Common::Transaction<PostGameSessionsResponseType> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::createGameSessions(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        if (!(response)) return -1;

        IntrusivePtr<Vector<IntrusivePtr<GameSession> > > gameSessionsPtr = response->getGameSessions();

        if (!(gameSessionsPtr)) return -1;

        if (gameSessionsPtr->empty()) return -1;

        IntrusivePtr<GameSession>& gameSessionPtr = (*gameSessionsPtr)[0];

        if (!(gameSessionPtr)) return -1;

        writer.WriteString(gameSessionPtr->getSessionId().c_str());

        Common::IntrusivePtr<ResponseGameSessionMemberPlayer> member = gameSessionPtr->getMember();
        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer> > > players = member->getPlayers();

        writer.WriteInt32(players->size());

        for (auto& it : *players)
        {
            writer.WriteUInt64(it->getAccountId());
            writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
        }


        writer.WriteUInt64(creator.m_AccountId);

        param.terminate();
        transaction.finish();

        return ret;
    }

    int GameSessionCommands::Leave(SceUserServiceUserId userId, const char* sessionId)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            return -1;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            return ret;
        }


        GameSessionsApi::ParameterToLeaveGameSession param;
        ret = param.initialize(libContextPtr, sessionId, accountIdBuf);
        if (ret < 0)
        {
            return ret;
        }

        Common::Transaction<Common::DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = GameSessionsApi::leaveGameSession(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        Common::DefaultResponse response;
        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        param.terminate();

        transaction.finish();

        return 0;
    }

    int GameSessionCommands::JoinAsPlayer(SceUserServiceUserId userId, Int32 pushCallbackId, const char* sessionId, bool swapping, BinaryWriter& writer)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        OrderGuaranteedPushEvent* pushEvent = __null;

        if (swapping == false)
        {
            pushEvent = WebApiNotifications::FindOrderedPushEvent(pushCallbackId);

            if (pushEvent == __null)
            {
                return -1;
            }
        }

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            return -1;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            return ret;
        }



        IntrusivePtr<RequestJoinGameSessionPlayer> requestJoinGameSessionPlayerPtr;
        ret = RequestJoinGameSessionPlayerFactory::create(libContextPtr, accountIdBuf, Utils::GetThisPlatformString(), &requestJoinGameSessionPlayerPtr);

        if (ret < 0)
        {
            return ret;
        }


        if (swapping == false)
        {

            IntrusivePtr<GameSessionPushContext> gameSessionPushContextPtr;
            ret = GameSessionPushContextFactory::create(libContextPtr, pushEvent->GetPushContextIdStr(), &gameSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }


            Vector<IntrusivePtr<GameSessionPushContext> > gameSessionPushContexts(libContextPtr);
            ret = gameSessionPushContexts.pushBack(gameSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }


            ret = requestJoinGameSessionPlayerPtr->setPushContexts(gameSessionPushContexts);
            if (ret < 0)
            {
                return ret;
            }
        }


        Vector<IntrusivePtr<RequestJoinGameSessionPlayer> > requestJoinGameSessionPlayers(libContextPtr);
        ret = requestJoinGameSessionPlayers.pushBack(requestJoinGameSessionPlayerPtr);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<PostGameSessionsSessionIdMemberPlayersRequestBody> postGameSessionsSessionIdMemberPlayersRequestBody;
        ret = PostGameSessionsSessionIdMemberPlayersRequestBodyFactory::create(libContextPtr, requestJoinGameSessionPlayers, &postGameSessionsSessionIdMemberPlayersRequestBody);
        if (ret < 0)
        {
            return ret;
        }


        GameSessionsApi::ParameterToJoinGameSessionAsPlayer param;
        ret = param.initialize(libContextPtr, sessionId, postGameSessionsSessionIdMemberPlayersRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        typedef Common::IntrusivePtr<PostGameSessionsSessionIdMemberPlayersResponseBody> PostGameSessionsSessionIdMemberPlayersResponseBody;
        PostGameSessionsSessionIdMemberPlayersResponseBody response;

        Common::Transaction<PostGameSessionsSessionIdMemberPlayersResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::joinGameSessionAsPlayer(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionPlayer> > > players = response->getPlayers();

        writer.WriteInt32(players->size());

        for (auto& it : *players)
        {
            writer.WriteUInt64(it->getAccountId());
            writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
        }

        SceNpAccountId accountId = (0);
        sceNpGetAccountIdA(userId, &accountId);

        writer.WriteUInt64(accountId);

        param.terminate();
        transaction.finish();

        return ret;
    }

    int GameSessionCommands::JoinAsSpectator(SceUserServiceUserId userId, Int32 pushCallbackId, const char* sessionId, bool swapping, BinaryWriter& writer)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        OrderGuaranteedPushEvent* pushEvent = __null;

        if (swapping == false)
        {
            pushEvent = WebApiNotifications::FindOrderedPushEvent(pushCallbackId);

            if (pushEvent == __null)
            {
                return -1;
            }
        }

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            return -1;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            return ret;
        }



        IntrusivePtr<RequestGameSessionSpectator> requestGameSessionSpectatorPtr;
        ret = RequestGameSessionSpectatorFactory::create(libContextPtr, accountIdBuf, Utils::GetThisPlatformString(), &requestGameSessionSpectatorPtr);
        if (ret < 0)
        {
            return ret;
        }


        if (swapping == false)
        {

            IntrusivePtr<GameSessionPushContext> gameSessionPushContextPtr;
            ret = GameSessionPushContextFactory::create(libContextPtr, pushEvent->GetPushContextIdStr(), &gameSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }


            Vector<IntrusivePtr<GameSessionPushContext> > gameSessionPushContexts(libContextPtr);
            ret = gameSessionPushContexts.pushBack(gameSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }


            ret = requestGameSessionSpectatorPtr->setPushContexts(gameSessionPushContexts);
            if (ret < 0)
            {
                return ret;
            }
        }


        Vector<IntrusivePtr<RequestGameSessionSpectator> > requestGameSessionSpectators(libContextPtr);
        ret = requestGameSessionSpectators.pushBack(requestGameSessionSpectatorPtr);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<PostGameSessionsSessionIdMemberSpectatorsRequestBody> postGameSessionsSessionIdMemberSpectatorsRequestBody;
        ret = PostGameSessionsSessionIdMemberSpectatorsRequestBodyFactory::create(libContextPtr, requestGameSessionSpectators, &postGameSessionsSessionIdMemberSpectatorsRequestBody);
        if (ret < 0)
        {
            return ret;
        }


        GameSessionsApi::ParameterToJoinGameSessionAsSpectator param;
        ret = param.initialize(libContextPtr, sessionId, postGameSessionsSessionIdMemberSpectatorsRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        typedef Common::IntrusivePtr<PostGameSessionsSessionIdMemberSpectatorsResponseBody> PostGameSessionsSessionIdMemberSpectatorsResponseBody;
        PostGameSessionsSessionIdMemberSpectatorsResponseBody response;

        Common::Transaction<PostGameSessionsSessionIdMemberSpectatorsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::joinGameSessionAsSpectator(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponseGameSessionSpectator> > > spectators = response->getSpectators();

        writer.WriteInt32(spectators->size());

        for (auto& it : *spectators)
        {
            writer.WriteUInt64(it->getAccountId());
            writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
        }

        SceNpAccountId accountId = (0);
        sceNpGetAccountIdA(userId, &accountId);

        writer.WriteUInt64(accountId);

        param.terminate();
        transaction.finish();

        return ret;
    }

    void GameSessionCommands::GetGameSessionsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 908));
            return;
        }

        const char* sessionIds = reader.ReadStringPtr();
        UInt32 numFields = reader.ReadUInt32();

        Vector<String>* fields = new Vector<String>(libContextPtr);

        for (int i = 0; i < numFields; i++)
        {
            const char* str = reader.ReadStringPtr();
            ret = addStringToVector(libContextPtr, str, *fields);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 923));
                return;
            }
        }

        IntrusivePtr<Vector<String> > fieldsPtr(fields, Utils::DeletePtr, libContextPtr);

        GameSessionsApi::ParameterToGetGameSessions param;
        ret = param.initialize(libContextPtr, sessionIds);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 934));
            return;
        }

        param.setfields(fieldsPtr);

        typedef Common::IntrusivePtr<GetGameSessionsResponseBody> GetGameSessionsResponseBody;
        GetGameSessionsResponseBody response;

        Common::Transaction<GetGameSessionsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::getGameSessions(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 952));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 962));
            return;
        }

        IntrusivePtr<Vector<IntrusivePtr<GameSessionForRead> > > gameSessionsPtr = response->getGameSessions();


        BinaryWriter writer(resultsData, resultsMaxSize);

        SerialiseSessionInfo(writer, gameSessionsPtr);

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void GameSessionCommands::SerialiseSessionInfo(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<GameSessionForRead> > > gameSessionsPtr)
    {
        if (!(gameSessionsPtr)) return;

        if (gameSessionsPtr->empty())
        {

            writer.WriteBool(false);
            return;
        }

        writer.WriteBool(true);

        int numSessions = gameSessionsPtr->size();

        writer.WriteInt32(numSessions);

        for (int session = 0; session < numSessions; session++)
        {
            IntrusivePtr<GameSessionForRead>& gameSessionPtr = (*gameSessionsPtr)[session];

            if (!(gameSessionPtr))
            {
                writer.WriteBool(false);
                return;
            }
            writer.WriteBool(true);

            if (gameSessionPtr->sessionIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(gameSessionPtr->getSessionId().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->createdTimestampIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(gameSessionPtr->getCreatedTimestamp().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->maxPlayersIsSet())
            {
                writer.WriteBool(true);
                writer.WriteUInt32(gameSessionPtr->getMaxPlayers());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->maxSpectatorsIsSet())
            {
                writer.WriteBool(true);
                writer.WriteUInt32(gameSessionPtr->getMaxSpectators());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->memberIsSet())
            {
                IntrusivePtr<GameSessionMemberForRead> member = gameSessionPtr->getMember();
                writer.WriteBool(true);

                if (member->playersIsSet())
                {
                    writer.WriteBool(true);

                    IntrusivePtr<Vector<IntrusivePtr<GameSessionPlayer> > > players = member->getPlayers();

                    writer.WriteInt32(players->size());

                    for (auto& it : *players)
                    {
                        writer.WriteBool(false);
                        writer.WriteUInt64(it->getAccountId());
                        writer.WriteString(it->getOnlineId().data);
                        writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
                        writer.WriteString(it->getJoinTimestamp().c_str());

                        if (it->joinStateIsSet())
                        {
                            writer.WriteBool(true);

                            writer.WriteInt32((Int32)it->getJoinState());
                        }
                        else
                        {
                            writer.WriteBool(false);
                        }

                        if (it->customData1IsSet())
                        {
                            writer.WriteBool(true);
                            Binary* binary = it->getCustomData1().get();
                            writer.WriteData((char*)binary->getBinary(), binary->size());
                        }
                        else
                        {
                            writer.WriteBool(false);
                        }
                    }
                }
                else
                {
                    writer.WriteBool(false);
                }

                if (member->spectatorsIsSet())
                {
                    writer.WriteBool(true);

                    IntrusivePtr<Vector<IntrusivePtr<GameSessionSpectator> > > spectators = member->getSpectators();

                    writer.WriteInt32(spectators->size());

                    for (auto& it : *spectators)
                    {
                        writer.WriteBool(true);
                        writer.WriteUInt64(it->getAccountId());
                        writer.WriteString(it->getOnlineId().data);
                        writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
                        writer.WriteString(it->getJoinTimestamp().c_str());

                        if (it->joinStateIsSet())
                        {
                            writer.WriteBool(true);

                            writer.WriteInt32((Int32)it->getJoinState());
                        }
                        else
                        {
                            writer.WriteBool(false);
                        }

                        if (it->customData1IsSet())
                        {
                            writer.WriteBool(true);
                            Binary* binary = it->getCustomData1().get();
                            writer.WriteData((char*)binary->getBinary(), binary->size());
                        }
                        else
                        {
                            writer.WriteBool(false);
                        }
                    }
                }
                else
                {
                    writer.WriteBool(false);
                }
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->joinDisabledIsSet())
            {
                writer.WriteBool(true);
                writer.WriteBool(gameSessionPtr->getJoinDisabled());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->supportedPlatformsIsSet())
            {
                writer.WriteBool(true);

                uint32_t platformFlags = 0;

                IntrusivePtr<Vector<String> > platforms = gameSessionPtr->getSupportedPlatforms();

                for (auto& it : *platforms)
                {
                    platformFlags |= Utils::GetPlatformFlag(it.c_str());
                }

                writer.WriteUInt32(platformFlags);
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->representativeIsSet())
            {
                writer.WriteBool(true);

                writer.WriteUInt64(gameSessionPtr->getRepresentative()->getAccountId());
                writer.WriteString(gameSessionPtr->getRepresentative()->getOnlineId().data);
                writer.WriteUInt32(Utils::GetPlatformFlag(gameSessionPtr->getRepresentative()->getPlatform().c_str()));
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->customData1IsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Binary> customData1 = gameSessionPtr->getCustomData1();

                writer.WriteData((const char*)customData1->getBinary(), customData1->size());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->customData2IsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Binary> customData2 = gameSessionPtr->getCustomData2();

                writer.WriteData((const char*)customData2->getBinary(), customData2->size());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->usePlayerSessionIsSet())
            {
                writer.WriteBool(true);
                writer.WriteBool(gameSessionPtr->getUsePlayerSession());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->matchmakingIsSet())
            {
                writer.WriteBool(true);

                MatchmakingForRead* matchMakingPtr = gameSessionPtr->getMatchmaking().get();

                writer.WriteString(matchMakingPtr->getOfferId().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (gameSessionPtr->reservationTimeoutSecondsIsSet())
            {
                writer.WriteBool(true);
                writer.WriteInt32(gameSessionPtr->getReservationTimeoutSeconds());
            }
            else
            {
                writer.WriteBool(false);
            }
        }
    }

    void GameSessionCommands::SetGameSessionPropertiesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1265));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        ret = SetGameSessionProps(userCtx, sessionId, reader);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1275));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int GameSessionCommands::SetGameSessionProps(WebApiUserContext* userCtx, const char* sessionId, BinaryReader& reader)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        IntrusivePtr<PatchGameSessionsSessionIdRequestBody> patchGameSessionsSessionIdRequestBody;
        ret = PatchGameSessionsSessionIdRequestBodyFactory::create(libContextPtr, &patchGameSessionsSessionIdRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        bool isSetMaxPlayers = reader.ReadBool();
        if (isSetMaxPlayers)
        {
            UInt32 maxPlayers = reader.ReadUInt32();
            patchGameSessionsSessionIdRequestBody->setMaxPlayers(maxPlayers);
        }

        bool isSetMaxSpectators = reader.ReadBool();
        if (isSetMaxSpectators)
        {
            UInt32 maxSpectators = reader.ReadUInt32();
            patchGameSessionsSessionIdRequestBody->setMaxSpectators(maxSpectators);
        }

        bool isSetJoinDisabled = reader.ReadBool();
        if (isSetJoinDisabled)
        {
            bool joinDisabled = reader.ReadBool();
            patchGameSessionsSessionIdRequestBody->setJoinDisabled(joinDisabled);
        }

        bool isSetCustomData1 = reader.ReadBool();
        if (isSetCustomData1)
        {
            int dataSize = reader.ReadInt32();
            void* data = reader.ReadDataPtr(dataSize);

            int ret = patchGameSessionsSessionIdRequestBody->setCustomData1(data, dataSize);
            if (ret < 0)
            {
                return ret;
            }
        }

        bool isSetCustomData2 = reader.ReadBool();
        if (isSetCustomData2)
        {
            int dataSize = reader.ReadInt32();
            void* data = reader.ReadDataPtr(dataSize);

            int ret = patchGameSessionsSessionIdRequestBody->setCustomData2(data, dataSize);
            if (ret < 0)
            {
                return ret;
            }
        }

        bool isSetSearchable = reader.ReadBool();
        if (isSetSearchable)
        {
            bool searchable = reader.ReadBool();
            patchGameSessionsSessionIdRequestBody->setSearchable(searchable);
        }

        GameSessionsApi::ParameterToSetGameSessionProperties param;
        ret = param.initialize(libContextPtr, sessionId, patchGameSessionsSessionIdRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::setGameSessionProperties(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        param.terminate();
        transaction.finish();

        return 0;
    }

    void GameSessionCommands::SetGameSessionMemberSystemPropertiesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1401));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        int dataSize = reader.ReadInt32();
        void* data = reader.ReadDataPtr(dataSize);


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1416));
            return;
        }

        Common::IntrusivePtr<PatchGameSessionsSessionIdMembersAccountIdRequestBody> patchGameSessionsSessionIdMembersAccountIdRequestBody;
        ret = PatchGameSessionsSessionIdMembersAccountIdRequestBodyFactory::create(libContextPtr, &patchGameSessionsSessionIdMembersAccountIdRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1424));
            return;
        }

        ret = patchGameSessionsSessionIdMembersAccountIdRequestBody->setCustomData1(data, dataSize);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1431));
            return;
        }

        GameSessionsApi::ParameterToSetGameSessionMemberSystemProperties param;
        ret = param.initialize(libContextPtr, sessionId, accountIdBuf, patchGameSessionsSessionIdMembersAccountIdRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1439));
            return;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);

        ret = GameSessionsApi::setGameSessionMemberSystemProperties(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1453));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1463));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void GameSessionCommands::SendGameSessionMessageImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1489));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        const char* payload = reader.ReadStringPtr();

        int count = reader.ReadInt32();

        Vector<IntrusivePtr<MemberWithMultiPlatform> > to(libContextPtr);

        for (int i = 0; i < count; i++)
        {
            SceNpAccountId accountId = reader.ReadUInt64();
            uint32_t platformFlag = reader.ReadUInt32();
            const char * platformStr = Utils::ToPlatformString(platformFlag);
            ((platformStr) ? (void)0 : :: _Assert("C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp" "(" "1506" ") : Assertion Failed (" "platformStr" ")", __func__));

            IntrusivePtr<MemberWithMultiPlatform> mp;
            ret = MemberWithMultiPlatformFactory::create(libContextPtr, accountId, platformStr, &mp);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1512));
                return;
            }


            ret = to.pushBack(mp);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1520));
                return;
            }
        }

        Common::IntrusivePtr<PostGameSessionsSessionIdSessionMessageRequestBody> postGameSessionsSessionIdSessionMessageRequestBody;
        ret = PostGameSessionsSessionIdSessionMessageRequestBodyFactory::create(libContextPtr, to, payload, &postGameSessionsSessionIdSessionMessageRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1529));
            return;
        }

        GameSessionsApi::ParameterToSendGameSessionMessage param;
        ret = param.initialize(libContextPtr, sessionId, postGameSessionsSessionIdSessionMessageRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1537));
            return;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::sendGameSessionMessage(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1552));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1562));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void GameSessionCommands::GetJoinedGameSessionsByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1588));
            return;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        GameSessionsApi::ParameterToGetJoinedGameSessionsByUser param;
        ret = param.initialize(libContextPtr, accountIdBuf);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1600));
            return;
        }

        ret = param.setmemberFilter("player,spectator");
        if (ret < 0)
        {
            param.terminate();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1608));
            return;
        }

        ret = param.setplatformFilter("PS4,PS5");
        if (ret < 0)
        {
            param.terminate();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1616));
            return;
        }

        typedef Common::IntrusivePtr<GetUsersAccountIdGameSessionsResponseBody> GetUsersAccountIdGameSessionsResponseBody;
        GetUsersAccountIdGameSessionsResponseBody response;

        Common::Transaction<GetUsersAccountIdGameSessionsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::getJoinedGameSessionsByUser(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1632));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1642));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        IntrusivePtr<Vector<IntrusivePtr<JoinedGameSessionWithPlatform> > > gameSessions = response->getGameSessions();

        writer.WriteInt32(gameSessions.get()->size());

        for (auto& it : *gameSessions)
        {
            writer.WriteString(it->getSessionId().c_str());

            writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));


        }

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void GameSessionCommands::DeleteGameSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1686));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        GameSessionsApi::ParameterToDeleteGameSession param;
        ret = param.initialize(libContextPtr, sessionId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1696));
            return;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::deleteGameSession(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1711));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1721));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }



    void GameSessionCommands::GameSessionsSearchImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1749));
            return;
        }

        const char* searchIndex = reader.ReadStringPtr();

        int numConditions = reader.ReadInt32();
        Common::Vector<Common::IntrusivePtr<SearchCondition> > searchConditions(libContextPtr);
        if (numConditions > 0)
        {
            for (int cond = 0; cond < numConditions; cond++)
            {
                SearchAttribute attribute = (SearchAttribute)reader.ReadInt32();
                SearchOperator op = (SearchOperator)reader.ReadInt32();

                Common::IntrusivePtr<SearchCondition> searchCondition;
                ret = SearchConditionFactory::create(libContextPtr, attribute, op, &searchCondition);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1768));
                    return;
                }

                const char* value = reader.ReadStringPtr();
                int numvalues = reader.ReadInt32();

                if (op != SearchOperator::kIn)
                {
                    ret = searchCondition->setValue(value);
                    if (ret < 0)
                    {
                        (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1780));
                        return;
                    }
                    if (numvalues != 0)
                    {
                        (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Unexpected values in SearchCondition", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1785));
                        return;
                    }
                }
                else
                {
                    Common::Vector<Common::String>* values = new Common::Vector<Common::String>(libContextPtr);
                    for (int val = 0; val < numvalues; val++)
                    {
                        const char* value = reader.ReadStringPtr();
                        ret = addStringToVector(libContextPtr, value, *values);
                        if (ret < 0)
                        {
                            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1798));
                            return;
                        }
                    }
                    ret = searchCondition->setValues(*values);
                    if (ret < 0)
                    {
                        (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1805));
                        return;
                    }
                }
                ret = searchConditions.pushBack(searchCondition);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1812));
                    return;
                }
            }
        }


        Common::IntrusivePtr<PostGameSessionsSearchRequestBody> postGameSessionsSearchRequestBody;
        ret = PostGameSessionsSearchRequestBodyFactory::create(libContextPtr, searchConditions, &postGameSessionsSearchRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1823));
            return;
        }

        GameSessionsApi::ParameterToPostGameSessionsSearch param;
        ret = param.initialize(libContextPtr, searchIndex, postGameSessionsSearchRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1831));
            return;
        }

        typedef Common::IntrusivePtr<PostGameSessionsSearchResponseBody> PostGameSessionsSearchResponseType;
        PostGameSessionsSearchResponseType response;

        Common::Transaction<PostGameSessionsSearchResponseType> transaction;
        transaction.start(libContextPtr);


        ret = GameSessionsApi::postGameSessionsSearch(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1847));
            return;
        }
        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameSession.cpp", 1855));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        IntrusivePtr<Vector<IntrusivePtr<SearchGameSession> > > gameSessionsPtr = response->getGameSessions();

        int sessionCount = gameSessionsPtr->size();
        writer.WriteInt32(sessionCount);
        for (int session = 0; session < sessionCount; session++)
        {
            IntrusivePtr<SearchGameSession>& gameSessionPtr = (*gameSessionsPtr)[session];
            writer.WriteString(gameSessionPtr->getSessionId().c_str());
        }


        param.terminate();
        transaction.finish();

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 15 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameUpdate.cpp" 1



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libgameupdate.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libgameupdate.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libgameupdate.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libgameupdate_error.h" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libgameupdate.h" 2 3



typedef struct SceGameUpdateCheckParam {
 size_t size;
 uint32_t option;
 uint32_t reserved[9];
} SceGameUpdateCheckParam;

typedef struct SceGameUpdateCheckResult {
 size_t size;
 bool found;
 bool addcontFound;
 char padding[2];
 char contentVersion[(11)];
 char padding2[1];
 uint32_t reserved[6];
} SceGameUpdateCheckResult;

typedef struct SceGameUpdateAddcontVersionInfo {
 size_t size;
 bool found;
 char contentVersion[(11)];
 uint32_t reserved[6];
} SceGameUpdateAddcontVersionInfo;


extern "C" {


int sceGameUpdateInitialize(void);
int sceGameUpdateTerminate(void);

int sceGameUpdateCreateRequest(void);
int sceGameUpdateCheck(int requestId, const SceGameUpdateCheckParam* param, SceGameUpdateCheckResult* result);
int sceGameUpdateAbortRequest(int requestId);
int sceGameUpdateDeleteRequest(int requestId);
int sceGameUpdateGetAddcontLatestVersion(SceNpServiceLabel serviceLabel, const SceNpUnifiedEntitlementLabel* entitlementLabel, SceGameUpdateAddcontVersionInfo* info);



}
# 5 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameUpdate.cpp" 2


#pragma comment(lib,"libSceGameUpdate_stub_weak.a")

namespace psn
{
    bool GameUpdate::s_ModuleLoaded = false;


    void GameUpdate::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::GameUpdateCheck, GameUpdate::GameUpdateCheckImpl);
        MsgHandler::AddMethod(Methods::GameUpdateGetAddcontLatestVersion, GameUpdate::GameUpdateGetAddcontLatestVersionImpl);
    }

    void GameUpdate::InitializeLib()
    {
        int res = sceSysmoduleIsLoaded(0x00cc);
        if (res != 0)
        {
            res = sceSysmoduleLoadModule(0x00cc);

            if (res < 0)
            {
                printf("Error loading SCE_SYSMODULE_GAME_UPDATE, 0x%x\n", res);
            }
            s_ModuleLoaded = true;
        }
        res = sceGameUpdateInitialize();
        if (res < 0)
        {
            printf("Error calling sceGameUpdateInitialize(), 0x%x\n", res);
        }
    }

    void GameUpdate::TerminateLib()
    {
        int res = sceGameUpdateTerminate();
        if (res < 0)
        {
            printf("Error calling sceGameUpdateTerminate(), 0x%x\n", res);
        }
        if (s_ModuleLoaded == true)
        {
            res = sceSysmoduleUnloadModule(0x00cc);

            if (res < 0)
            {
                printf("Error unloading SCE_SYSMODULE_GAME_UPDATE, 0x%x\n", res);
            }
        }
    }

    void GameUpdate::GameUpdateCheckImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        SceGameUpdateCheckResult checkResult;

        BinaryReader reader(sourceData, sourceSize);

        UInt32 option = reader.ReadInt32();

        int ret = sceGameUpdateCreateRequest();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameUpdate.cpp", 71));
            return;
        }

        int requestId = ret;

        SceGameUpdateCheckParam checkParam;
        memset(&checkParam, 0, sizeof(checkParam));
        checkParam.size = sizeof(checkParam);
        checkParam.option = option;

        memset(&checkResult, 0, sizeof(checkResult));
        checkResult.size = sizeof(checkResult);

        ret = sceGameUpdateCheck(requestId, &checkParam, &checkResult);
        if (ret < 0)
        {
            if (ret == -2143213559)
            {
                printf("sceGameUpdateCheck() returned SCE_GAME_UPDATE_ERROR_INTERNAL. Check Debug Settings \"Update Test\"\n");
            }
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameUpdate.cpp", 92));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(checkResult.found);
        writer.WriteBool(checkResult.addcontFound);
        writer.WriteString(checkResult.contentVersion);

        *resultsSize = writer.GetWrittenLength();

        sceGameUpdateDeleteRequest(requestId);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void GameUpdate::GameUpdateGetAddcontLatestVersionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        SceGameUpdateAddcontVersionInfo info;

        BinaryReader reader(sourceData, sourceSize);

        SceNpServiceLabel serviceLabel = reader.ReadUInt32();
        SceNpUnifiedEntitlementLabel entitlementLabel;
        char *entitlementLabelData = reader.ReadStringPtr();
        memset(&entitlementLabel, 0, sizeof(entitlementLabel));
        strcpy_s(entitlementLabel.data, (17) , entitlementLabelData);

        memset(&info, 0, sizeof(info));
        info.size = sizeof(info);

        int ret = sceGameUpdateGetAddcontLatestVersion(serviceLabel, &entitlementLabel, &info);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\GameUpdate.cpp", 129));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(info.found);
        writer.WriteString(info.contentVersion);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 16 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp" 1





namespace PsnLeaderboards = sce::Np::CppWebApi::Leaderboards::V1;

namespace psn
{
    void Leaderboards::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::GetBoardDefinition, Leaderboards::GetBoardDefinitionImpl);
        MsgHandler::AddMethod(Methods::RecordScore, Leaderboards::RecordScoreImpl);
        MsgHandler::AddMethod(Methods::GetRanking, Leaderboards::GetRankingImpl);
        MsgHandler::AddMethod(Methods::GetLargeDateByObjectId, Leaderboards::GetLargeDataByObjectIdImpl);
    }

    void Leaderboards::Initialize()
    {
    }

    void Leaderboards::GetBoardDefinitionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        char* fields = __null;
        SceNpServiceLabel serviceLabel = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 40));
            return;
        }

        int boardId = reader.ReadInt32();

        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet == true)
        {
            serviceLabel = reader.ReadUInt32();
        }

        bool isFieldsSet = reader.ReadBool();
        if (isFieldsSet == true)
        {
            fields = reader.ReadStringPtr();
        }

        BoardsApi::ParameterToGetBoardDefinition param;
        ret = param.initialize(libContextPtr, boardId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 62));
            return;
        }

        if (isServiceLabelSet == true)
        {
            param.setnpServiceLabel(serviceLabel);
        }

        if (isFieldsSet == true)
        {
            ret = param.setfields(fields);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 76));
                return;
            }
        }

        typedef Common::IntrusivePtr<GetBoardDefinitionResponseBody> GetBoardDefinitionResponseBody;
        GetBoardDefinitionResponseBody response;

        Common::Transaction<GetBoardDefinitionResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = BoardsApi::getBoardDefinition(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 93));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 103));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        if (response->entryLimitIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32(response->getEntryLimit());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (response->largeDataNumLimitIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32(response->getLargeDataNumLimit());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (response->largeDataSizeLimitIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt64(response->getLargeDataSizeLimit());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (response->maxScoreLimitIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt64(response->getMaxScoreLimit());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (response->minScoreLimitIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt64(response->getMinScoreLimit());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (response->sortModeIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32((Int32)response->getSortMode());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (response->updateModeIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32((Int32)response->getUpdateMode());
        }
        else
        {
            writer.WriteBool(false);
        }

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Leaderboards::GetRankingImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 202));
            return;
        }

        int boardId = reader.ReadInt32();

        SceNpServiceLabel serviceLabel = 0;

        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet == true)
        {
            serviceLabel = reader.ReadUInt32();
        }

        int offset = reader.ReadInt32();
        int limit = reader.ReadInt32();
        int startSerialRank = reader.ReadInt32();

        Group group = (Group)reader.ReadInt32();

        Common::IntrusivePtr<User> aroundUser;
        int hasCenteredAroundUser = reader.ReadBool();
        if (hasCenteredAroundUser)
        {
            UserFactory::create(libContextPtr, &aroundUser);

            SceNpAccountId accountId = reader.ReadUInt64();
            Int32 pcId = reader.ReadInt32();

            aroundUser->setAccountId(accountId);
            aroundUser->setPcId(pcId);
        }

        int hasEdgeLimit = reader.ReadBool();
        Int32 edgeLimit = 0;
        if (hasEdgeLimit)
        {
            edgeLimit = reader.ReadInt32();
        }

        Common::Vector<Common::IntrusivePtr<User> > users(libContextPtr);
        int numUsers = reader.ReadInt32();

        if (numUsers > 0)
        {
            Common::IntrusivePtr<User> user;
            UserFactory::create(libContextPtr, &user);

            SceNpAccountId accountId = reader.ReadUInt64();
            Int32 pcId = reader.ReadInt32();

            user->setAccountId(accountId);
            user->setPcId(pcId);

            ret = users.pushBack(user);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 259));
                return;
            }
        }

        Common::IntrusivePtr<GetRankingRequestBody> requestBody;
        ret = GetRankingRequestBodyFactory::create(libContextPtr, &requestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 268));
            return;
        }

        if (isServiceLabelSet)
        {
            requestBody->setNpServiceLabel(serviceLabel);
        }

        requestBody->setOffset(offset);
        requestBody->setLimit(limit);
        requestBody->setStartSerialRank(startSerialRank);

        requestBody->setGroup(group);

        if (hasCenteredAroundUser)
        {
            ret = requestBody->setUserCenteredAround(aroundUser);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 288));
                return;
            }
        }

        if (hasEdgeLimit && edgeLimit > 0)
        {
            requestBody->setCenterToEdgeLimit(edgeLimit);
        }

        if (numUsers > 0)
        {
            ret = requestBody->setUsers(users);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 303));
                return;
            }
        }

        ViewApi::ParameterToGetRanking param;
        ret = param.initialize(libContextPtr, boardId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 312));
            return;
        }

        param.setgetRankingRequestBody(requestBody);

        typedef Common::IntrusivePtr<GetRankingResponseBody> GetRankingResponseBody;
        GetRankingResponseBody response;

        Common::Transaction<GetRankingResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = ViewApi::getRanking(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 330));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 340));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        if (response->entriesIsSet())
        {
            Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Entry> > > entries = response->getEntries();

            writer.WriteInt32(entries->size());

            for (const auto &entry : *entries)
            {
                writer.WriteUInt64(entry->getAccountId());

                writer.WriteBool(entry->pcIdIsSet());

                if (entry->pcIdIsSet())
                {
                    writer.WriteInt32(entry->getPcId());
                }

                writer.WriteInt32(entry->getSerialRank());
                writer.WriteInt32(entry->getHighestSerialRank());

                writer.WriteInt32(entry->getRank());
                writer.WriteInt32(entry->getHighestRank());
                writer.WriteInt64(entry->getScore());

                writer.WriteBool(entry->smallDataIsSet());
                if (entry->smallDataIsSet())
                {
                    Common::IntrusivePtr<Common::Binary> smallData = entry->getSmallData();
                    writer.WriteData((char*)smallData->getBinary(), smallData->size());
                }

                writer.WriteBool(entry->objectIdIsSet());
                if (entry->objectIdIsSet())
                {
                    writer.WriteString(entry->getObjectId().c_str());
                }

                writer.WriteBool(entry->commentIsSet());
                if (entry->commentIsSet())
                {
                    writer.WriteString(entry->getComment().c_str());
                }

                writer.WriteString(entry->getOnlineId().data);
            }
        }
        else
        {
            writer.WriteInt32(0);
        }

        writer.WriteRtcTick(response->getLastUpdatedDateTime());
        writer.WriteInt32(response->getTotalEntryCount());

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Leaderboards::GetLargeDataByObjectIdImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 423));
            return;
        }

        char* objectId = reader.ReadStringPtr();

        ViewApi::ParameterToGetLargeDataByObjectId param;
        ret = param.initialize(libContextPtr, objectId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 433));
            return;
        }

        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet == true)
        {
            SceNpServiceLabel serviceLabel = reader.ReadUInt32();
            param.setnpServiceLabel(serviceLabel);
        }

        bool isRangeSet = reader.ReadBool();
        if (isRangeSet == true)
        {
            char* rangeStr = reader.ReadStringPtr();
            ret = param.setrange(rangeStr);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 451));
                return;
            }
        }

        bool isIfMatchSet = reader.ReadBool();
        if (isIfMatchSet == true)
        {
            char* matchStr = reader.ReadStringPtr();
            ret = param.setifMatch(matchStr);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 463));
                return;
            }
        }

        Common::DownStreamTransaction<Common::IntrusivePtr<ViewApi::GetLargeDataByObjectIdResponseHeaders> > transaction;
        transaction.start(libContextPtr);


        ret = ViewApi::getLargeDataByObjectId(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 477));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);


        UInt32* posForSize = writer.ReservePlaceholderUInt32();

        Int64 totalSize = 0;
        bool done = false;

        while (done == false)
        {
            size_t readDataSize = 0;
            char dataBuf[1024] = { 0 };
            readDataSize = transaction.readData(dataBuf, sizeof(dataBuf) - 1);

            if (readDataSize <= 0)
            {
                done = true;
            }
            else
            {


                if ((writer.GetWrittenLength() + readDataSize) >= resultsMaxSize)
                {
                    if (ret < 0)
                    {
                        param.terminate();
                        transaction.finish();
                        (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Not enough space in Results buffer for Leaderboard large data", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 509));
                        return;
                    }
                }



                writer.WriteDataBlock(dataBuf, readDataSize);

                totalSize += readDataSize;
            }
        }

        *posForSize = totalSize;

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Leaderboards::RecordScoreImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;
        int ret = 0;

        ScoreData scoreData;

        BinaryReader reader(sourceData, sourceSize);
        scoreData.userId = reader.ReadInt32();

        scoreData.userCtx = WebApi::Instance()->FindUser(scoreData.userId);

        if (scoreData.userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 546));
            return;
        }

        scoreData.boardId = reader.ReadInt32();
        scoreData.score = reader.ReadUInt64();

        scoreData.largeDataSize = reader.ReadInt32();
        scoreData.largeData = __null;

        if (scoreData.largeDataSize > 0)
        {
            scoreData.largeData = reader.ReadDataPtr(scoreData.largeDataSize);
        }

        scoreData.waitsForData = false;
        scoreData.needsTmpRank = false;
        scoreData.pcId = 0;
        scoreData.serviceLabel = 0;
        scoreData.smallDataSize = 0;
        scoreData.smallDataPtr = __null;
        scoreData.objectId = __null;
        scoreData.comment = __null;
        scoreData.comparedDateTime.tick = 0;
        scoreData.tempRanksSet = false;

        scoreData.waitsForData = reader.ReadBool();
        scoreData.needsTmpRank = reader.ReadBool();

        scoreData.isServiceLabelSet = reader.ReadBool();
        if (scoreData.isServiceLabelSet == true)
        {
            scoreData.serviceLabel = reader.ReadUInt32();
        }

        scoreData.isObjectIdSet = reader.ReadBool();
        if (scoreData.isObjectIdSet == true)
        {
            scoreData.objectId = reader.ReadStringPtr();
        }

        scoreData.isPcIdSet = reader.ReadBool();
        if (scoreData.isPcIdSet == true)
        {
            scoreData.pcId = reader.ReadInt32();
        }

        scoreData.isSmallDataSet = reader.ReadBool();
        if (scoreData.isSmallDataSet == true)
        {
            scoreData.smallDataSize = reader.ReadUInt64();
            scoreData.smallDataPtr = reader.ReadDataPtr(scoreData.smallDataSize);
        }

        scoreData.isCommentSet = reader.ReadBool();
        if (scoreData.isCommentSet == true)
        {
            scoreData.comment = reader.ReadStringPtr();
        }

        scoreData.isComparedDateTimeSet = reader.ReadBool();
        if (scoreData.isComparedDateTimeSet == true)
        {
            scoreData.comparedDateTime.tick = reader.ReadUInt64();
        }





        ret = RecordLeaderboardScore(scoreData);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 619));
            return;
        }

        if (scoreData.largeDataSize > 0 && scoreData.largeData != __null)
        {
            ret = RecordLargeData(scoreData);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp", 628));
                return;
            }
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        if (scoreData.tempRanksSet)
        {
            writer.WriteBool(true);
            writer.WriteInt32(scoreData.tmpRankResult);
            writer.WriteInt32(scoreData.tmpSerialRankResult);
        }
        else
        {
            writer.WriteBool(false);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int Leaderboards::RecordLeaderboardScore(ScoreData& scoreData)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        Common::IntrusivePtr<RecordScoreRequestBody> requestBody;

        ret = RecordScoreRequestBodyFactory::create(libContextPtr, scoreData.score, &requestBody);
        if (ret < 0)
        {
            return ret;
        }

        bool hasLargeData = scoreData.largeDataSize > 0 && scoreData.largeData != __null;


        requestBody->setWaitsForData(hasLargeData);
        requestBody->setNeedsTmpRank(scoreData.needsTmpRank);

        if (scoreData.isServiceLabelSet == true)
        {
            requestBody->setNpServiceLabel(scoreData.serviceLabel);
        }
# 685 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp"
        if (scoreData.isPcIdSet == true)
        {
            requestBody->setPcId(scoreData.pcId);
        }

        if (scoreData.isSmallDataSet == true)
        {
            ret = requestBody->setSmallData(scoreData.smallDataPtr, scoreData.smallDataSize);
            if (ret < 0)
            {
                return ret;
            }
        }

        if (scoreData.isCommentSet == true)
        {
            ret = requestBody->setComment(scoreData.comment);
            if (ret < 0)
            {
                return ret;
            }
        }

        if (scoreData.isComparedDateTimeSet == true)
        {
            requestBody->setComparedDateTime(scoreData.comparedDateTime);
        }

        RecordApi::ParameterToRecordScore param;
        ret = param.initialize(libContextPtr, scoreData.boardId, requestBody);
        if (ret < 0)
        {
            return ret;
        }

        typedef Common::IntrusivePtr<RecordScoreResponseBody> RecordScoreResponseBody;
        RecordScoreResponseBody response;

        Common::Transaction<RecordScoreResponseBody, Common::IntrusivePtr<RecordApi::RecordScoreResponseHeaders> > transaction;
        transaction.start(libContextPtr);

        if (hasLargeData)
        {

            param.setxPsnAtomicOperation(RecordApi::ParameterToRecordScore::XPsnAtomicOperation::kBegin);



        }


        ret = RecordApi::recordScore(scoreData.userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        if (requestBody->getNeedsTmpRank())
        {
            scoreData.tempRanksSet = true;
            scoreData.tmpRankResult = response->getTmpRank();
            scoreData.tmpSerialRankResult = response->getTmpSerialRank();
        }
        else
        {
            scoreData.tempRanksSet = false;
        }

        if (hasLargeData)
        {
            Common::IntrusivePtr<RecordApi::RecordScoreResponseHeaders> responseHeaderOfScore;
            ret = transaction.getResponseHeaders(responseHeaderOfScore);
            if (ret < 0)
            {
                param.terminate();
                transaction.finish();
                return ret;
            }

            if (!responseHeaderOfScore->hasXPsnAtomicOperationId())
            {
                param.terminate();
                transaction.finish();
                return -1;
            }

            strcpy_s(scoreData.operationId, sizeof(scoreData.operationId), responseHeaderOfScore->getXPsnAtomicOperationId().c_str());
        }

        param.terminate();
        transaction.finish();

        return 0;
    }

    int Leaderboards::RecordLargeData(ScoreData& scoreData)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        RecordApi::ParameterToRecordLargeData param;

        param.initialize(libContextPtr, scoreData.boardId, PsnLeaderboards::RecordApi::ParameterToRecordLargeData::XPsnAtomicOperation::kEnd, scoreData.operationId);
# 809 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Leaderboards.cpp"
        if (ret < 0)
        {
            return ret;
        }


        Common::UpStreamTransaction<Common::IntrusivePtr<RecordLargeDataResponseBody>> transaction;



        transaction.start(libContextPtr, scoreData.largeDataSize);


        ret = RecordApi::recordLargeData(scoreData.userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        ret = transaction.sendData(scoreData.largeData, scoreData.largeDataSize);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        param.terminate();
        transaction.finish();

        return 0;
    }
}
# 17 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp" 1







namespace psn
{
    void MatchesCommands::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::CreateMatch, MatchesCommands::CreateMatchImpl);
        MsgHandler::AddMethod(Methods::GetMatchDetails, MatchesCommands::GetMatchDetailsImpl);
        MsgHandler::AddMethod(Methods::UpdateMatchStatus, MatchesCommands::UpdateMatchStatusImpl);
        MsgHandler::AddMethod(Methods::JoinMatch, MatchesCommands::JoinMatchImpl);
        MsgHandler::AddMethod(Methods::LeaveMatch, MatchesCommands::LeaveMatchImpl);
        MsgHandler::AddMethod(Methods::ReportResults, MatchesCommands::ReportResultsImpl);
        MsgHandler::AddMethod(Methods::UpdateDetails, MatchesCommands::UpdateDetailsImpl);
    }

    void MatchesCommands::InitializeLib()
    {
    }

    void MatchesCommands::TerminateLib()
    {
    }

    void MatchesCommands::MatchPlayer::Deserialise(BinaryReader& reader)
    {
        m_PlayerId = reader.ReadStringPtr();
        m_PlayerType = (PlayerType)reader.ReadInt32();
        m_PlayerName = reader.ReadStringPtr();
        m_AccountId = reader.ReadUInt64();
    }

    void MatchesCommands::MatchTeamMember::Deserialise(BinaryReader& reader)
    {
        m_PlayerId = reader.ReadStringPtr();
    }

    void MatchesCommands::MatchTeam::Deserialise(BinaryReader& reader)
    {
        m_TeamId = reader.ReadStringPtr();
        m_TeamName = reader.ReadStringPtr();

        int32_t numPlayers = reader.ReadInt32();

        for (int i = 0; i < numPlayers; i++)
        {
            MatchTeamMember member;
            member.Deserialise(reader);

            m_Members.push_back(member);
        }
    }

    MatchesCommands::InitializationParams::InitializationParams()
    {
    }

    MatchesCommands::InitializationParams::~InitializationParams()
    {
    }

    void MatchesCommands::InitializationParams::Deserialise(BinaryReader& reader)
    {
        m_ActivityId = reader.ReadStringPtr();

        m_ServiceLabel = reader.ReadInt32();

        m_ZoneId = reader.ReadStringPtr();

        int32_t numPlayers = reader.ReadInt32();

        for (int i = 0; i < numPlayers; i++)
        {
            MatchPlayer player;
            player.Deserialise(reader);

            m_Players.push_back(player);
        }

        int32_t numTeams = reader.ReadInt32();

        for (int i = 0; i < numTeams; i++)
        {
            MatchTeam team;
            team.Deserialise(reader);

            m_Teams.push_back(team);
        }
    }

    void MatchesCommands::CreateMatchImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        InitializationParams params;
        params.Deserialise(reader);

        BinaryWriter writer(resultsData, resultsMaxSize);

        ret = Create(userId, params, writer);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 114));
            return;
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchesCommands::GetMatchDetailsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        char* matchId = reader.ReadStringPtr();
        Int32 serviceLabel = reader.ReadInt32();

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 141));
            return;
        }


        MatchApi::ParameterToGetMatchDetail param;
        ret = param.initialize(libContextPtr, matchId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 150));
            return;
        }

        param.setnpServiceLabel(serviceLabel);

        typedef Common::IntrusivePtr<GetMatchDetailResponse> GetMatchDetailResponseType;
        GetMatchDetailResponseType response;

        Common::Transaction<GetMatchDetailResponseType> transaction;
        transaction.start(libContextPtr);


        ret = MatchApi::getMatchDetail(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 166));
            param.terminate();
            transaction.finish();
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 176));
            param.terminate();
            transaction.finish();
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        SerialiseMatchDetail(writer, response);

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchesCommands::UpdateMatchStatusImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        char* matchId = reader.ReadStringPtr();
        UpdateStatus status = (UpdateStatus)reader.ReadInt32();

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 212));
            return;
        }

        IntrusivePtr<UpdateMatchStatusRequest> updateMatchStatusRequest;
        ret = UpdateMatchStatusRequestFactory::create(libContextPtr, status, &updateMatchStatusRequest);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 220));
            return;
        }

        MatchApi::ParameterToUpdateMatchStatus param;
        ret = param.initialize(libContextPtr, matchId, updateMatchStatusRequest);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 228));
            return;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = MatchApi::updateMatchStatus(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 244));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 254));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchesCommands::JoinMatchImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        char* matchId = reader.ReadStringPtr();

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 281));
            return;
        }

        Vector<IntrusivePtr<AddedPlayer> > addedPlayers(libContextPtr);

        int32_t numPlayers = reader.ReadInt32();

        for (int i = 0; i < numPlayers; i++)
        {
            char* playerId = reader.ReadStringPtr();
            PlayerType playerType = (PlayerType)reader.ReadInt32();


            IntrusivePtr<AddedPlayer> addedPlayer;
            ret = AddedPlayerFactory::create(libContextPtr, playerId, playerType, &addedPlayer);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 299));
                return;
            }


            bool isPlayerNameSet = reader.ReadBool();
            if (isPlayerNameSet == true)
            {
                char* playerName = reader.ReadStringPtr();
                ret = addedPlayer->setPlayerName(playerName);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 311));
                    return;
                }
            }

            bool isAccountIdSet = reader.ReadBool();
            if (isAccountIdSet == true)
            {
                SceNpAccountId accountId = reader.ReadUInt64();

                char accountIdBuf[21];
                GetAccountIdStr(accountId, accountIdBuf, sizeof(accountIdBuf));
                ret = addedPlayer->setAccountId(accountIdBuf);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 326));
                    return;
                }
            }

            bool isTeamIdSet = reader.ReadBool();
            if (isTeamIdSet == true)
            {
                char* teamId = reader.ReadStringPtr();
                ret = addedPlayer->setTeamId(teamId);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 338));
                    return;
                }
            }


            ret = addedPlayers.pushBack(addedPlayer);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 347));
                return;
            }
        }


        IntrusivePtr<JoinMatchRequest> joinMatchRequest;
        ret = JoinMatchRequestFactory::create(libContextPtr, addedPlayers, &joinMatchRequest);

        MatchApi::ParameterToJoinMatch param;
        ret = param.initialize(libContextPtr, matchId, joinMatchRequest);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 360));
            return;
        }

        DefaultResponse response;
        Common::Transaction<DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = MatchApi::joinMatch(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 375));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 385));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchesCommands::LeaveMatchImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        char* matchId = reader.ReadStringPtr();

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 412));
            return;
        }

        Vector<IntrusivePtr<RemovedPlayer> > removedPlayers(libContextPtr);

        int32_t numPlayers = reader.ReadInt32();

        for (int i = 0; i < numPlayers; i++)
        {
            char* playerId = reader.ReadStringPtr();

            LeaveReason reason = (LeaveReason)reader.ReadInt32();


            IntrusivePtr<RemovedPlayer> removedPlayer;
            ret = RemovedPlayerFactory::create(libContextPtr, playerId, &removedPlayer);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 431));
                return;
            }

            if (reason != LeaveReason::_NOT_SET)
            {
                removedPlayer->setReason(reason);
            }


            ret = removedPlayers.pushBack(removedPlayer);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 444));
                return;
            }
        }

        IntrusivePtr<LeaveMatchRequest> leaveMatchRequest;
        ret = LeaveMatchRequestFactory::create(libContextPtr, removedPlayers, &leaveMatchRequest);

        MatchApi::ParameterToLeaveMatch param;
        ret = param.initialize(libContextPtr, matchId, leaveMatchRequest);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 456));
            return;
        }

        DefaultResponse response;
        Common::Transaction<DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = MatchApi::leaveMatch(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 471));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 481));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int MatchesCommands::DeserialiseMatchResults(Common::LibContext* libContextPtr, BinaryReader &reader, CompetitionType competition, GroupingType groupType, ResultType resultType, Common::IntrusivePtr<RequestMatchResults> &requestMatchResults)
    {
        int ret = 0;

        Int32 version = reader.ReadInt32();


        ret = RequestMatchResultsFactory::create(libContextPtr, (ResultsVersion)version, &requestMatchResults);
        if (ret < 0)
        {
            return ret;
        }

        if (competition == CompetitionType::kCooperative)



        {
            RequestCooperativeResult coopResult = (RequestCooperativeResult)reader.ReadInt32();
            requestMatchResults->setCooperativeResult(coopResult);
        }
        else
        {

            IntrusivePtr<RequestCompetitiveResult> requestCompetitiveResult;

            ret = DeserialiseCompetitiveResults(libContextPtr, reader, groupType, resultType, requestCompetitiveResult);
            if (ret < 0)
            {
                return ret;
            }


            ret = requestMatchResults->setCompetitiveResult(requestCompetitiveResult);
            if (ret < 0)
            {
                return ret;
            }
        }

        return 0;
    }

    int MatchesCommands::DeserialiseTemporaryMatchResults(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, Common::IntrusivePtr<RequestTemporaryMatchResults> &requestMatchResults)
    {
        int ret = 0;

        Int32 version = reader.ReadInt32();


        IntrusivePtr<RequestTemporaryCompetitiveResult> requestCompetitiveResult;
        ret = DeserialiseTemporaryCompetitiveResults(libContextPtr, reader, groupType, resultType, requestCompetitiveResult);
        if (ret < 0)
        {
            return ret;
        }


        ret = RequestTemporaryMatchResultsFactory::create(libContextPtr, (ResultsVersion)version, requestCompetitiveResult, &requestMatchResults);
        if (ret < 0)
        {
            return ret;
        }

        return 0;
    }

    int MatchesCommands::DeserialiseTemporaryCompetitiveResults(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestTemporaryCompetitiveResult> &requestCompetitiveResult)
    {
        int ret = 0;

        ret = RequestTemporaryCompetitiveResultFactory::create(libContextPtr, &requestCompetitiveResult);
        if (ret < 0)
        {
            return ret;
        }

        if (groupType == GroupingType::kNonTeamMatch)



        {


            int32_t numPlayerResults = reader.ReadInt32();

            if (numPlayerResults > 0)
            {
                Vector<IntrusivePtr<RequestPlayerResults> > requestPlayerResults(libContextPtr);

                for (int i = 0; i < numPlayerResults; i++)
                {
                    char* playerId = reader.ReadStringPtr();
                    int32_t rank = reader.ReadInt32();
                    bool isScoreSet = reader.ReadBool();
                    double playerScore = 0;

                    if (isScoreSet == true)
                    {
                        playerScore = reader.ReadDouble();
                    }

                    IntrusivePtr<RequestPlayerResults> requestPlayerResult;
                    ret = RequestPlayerResultsFactory::create(libContextPtr, playerId, rank, &requestPlayerResult);
                    if (ret < 0)
                    {
                        return ret;
                    }


                    if (isScoreSet == true)
                    {
                        requestPlayerResult->setScore(playerScore);
                    }


                    ret = requestPlayerResults.pushBack(requestPlayerResult);
                    if (ret < 0)
                    {
                        return ret;
                    }
                }

                ret = requestCompetitiveResult->setPlayerResults(requestPlayerResults);
                if (ret < 0)
                {
                    return ret;
                }
            }
        }

        else if (groupType == GroupingType::kTeamMatch)



        {

            int32_t numTeamResults = reader.ReadInt32();

            if (numTeamResults > 0)
            {
                Vector<IntrusivePtr<RequestTemporaryTeamResults> > requestTeamResults(libContextPtr);

                for (int i = 0; i < numTeamResults; i++)
                {
                    char* teamId = reader.ReadStringPtr();
                    int32_t rank = reader.ReadInt32();
                    bool isScoreSet = reader.ReadBool();
                    double teamScore = 0;

                    if (isScoreSet == true)
                    {
                        teamScore = reader.ReadDouble();
                    }

                    int32_t numMemberResults = reader.ReadInt32();

                    IntrusivePtr<RequestTemporaryTeamResults> requestTeamResult;
                    ret = RequestTemporaryTeamResultsFactory::create(libContextPtr, teamId, rank, &requestTeamResult);
                    if (ret < 0)
                    {
                        return ret;
                    }


                    if (isScoreSet == true)
                    {
                        requestTeamResult->setScore(teamScore);
                    }

                    if (numMemberResults > 0)
                    {
                        Vector<IntrusivePtr<RequestTeamMemberResult> > requestTeamMemberResults(libContextPtr);

                        for (int j = 0; j < numMemberResults; j++)
                        {
                            char* playerId = reader.ReadStringPtr();
                            double playerScore = reader.ReadDouble();


                            IntrusivePtr<RequestTeamMemberResult> requestTeamMemberResult;
                            ret = RequestTeamMemberResultFactory::create(libContextPtr, playerId, playerScore, &requestTeamMemberResult);
                            if (ret < 0)
                            {
                                return ret;
                            }


                            ret = requestTeamMemberResults.pushBack(requestTeamMemberResult);
                            if (ret < 0)
                            {
                                return ret;
                            }
                        }

                        ret = requestTeamResult->setTeamMemberResults(requestTeamMemberResults);
                        if (ret < 0)
                        {
                            return ret;
                        }
                    }


                    ret = requestTeamResults.pushBack(requestTeamResult);
                    if (ret < 0)
                    {
                        return ret;
                    }
                }


                ret = requestCompetitiveResult->setTeamResults(requestTeamResults);
                if (ret < 0)
                {
                    return ret;
                }
            }
        }

        return ret;
    }

    int MatchesCommands::DeserialiseCompetitiveResults(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestCompetitiveResult> &requestCompetitiveResult)
    {
        int ret = 0;

        ret = RequestCompetitiveResultFactory::create(libContextPtr, &requestCompetitiveResult);
        if (ret < 0)
        {
            return ret;
        }

        if (groupType == GroupingType::kNonTeamMatch)



        {


            int32_t numPlayerResults = reader.ReadInt32();

            if (numPlayerResults > 0)
            {
                Vector<IntrusivePtr<RequestPlayerResults> > requestPlayerResults(libContextPtr);

                for (int i = 0; i < numPlayerResults; i++)
                {
                    char* playerId = reader.ReadStringPtr();
                    int32_t rank = reader.ReadInt32();
                    bool isScoreSet = reader.ReadBool();
                    double playerScore = 0;

                    if (isScoreSet == true)
                    {
                        playerScore = reader.ReadDouble();
                    }

                    IntrusivePtr<RequestPlayerResults> requestPlayerResult;
                    ret = RequestPlayerResultsFactory::create(libContextPtr, playerId, rank, &requestPlayerResult);
                    if (ret < 0)
                    {
                        return ret;
                    }


                    if (isScoreSet == true)
                    {
                        requestPlayerResult->setScore(playerScore);
                    }


                    ret = requestPlayerResults.pushBack(requestPlayerResult);
                    if (ret < 0)
                    {
                        return ret;
                    }
                }

                ret = requestCompetitiveResult->setPlayerResults(requestPlayerResults);
                if (ret < 0)
                {
                    return ret;
                }
            }
        }

        else if (groupType == GroupingType::kTeamMatch)



        {

            int32_t numTeamResults = reader.ReadInt32();

            if (numTeamResults > 0)
            {
                Vector<IntrusivePtr<RequestTeamResults> > requestTeamResults(libContextPtr);

                for (int i = 0; i < numTeamResults; i++)
                {
                    char* teamId = reader.ReadStringPtr();
                    int32_t rank = reader.ReadInt32();
                    bool isScoreSet = reader.ReadBool();
                    double teamScore = 0;

                    if (isScoreSet == true)
                    {
                        teamScore = reader.ReadDouble();
                    }

                    int32_t numMemberResults = reader.ReadInt32();

                    IntrusivePtr<RequestTeamResults> requestTeamResult;
                    ret = RequestTeamResultsFactory::create(libContextPtr, teamId, rank, &requestTeamResult);
                    if (ret < 0)
                    {
                        return ret;
                    }


                    if (isScoreSet == true)
                    {
                        requestTeamResult->setScore(teamScore);
                    }

                    if (numMemberResults > 0)
                    {
                        Vector<IntrusivePtr<RequestTeamMemberResult> > requestTeamMemberResults(libContextPtr);

                        for (int j = 0; j < numMemberResults; j++)
                        {
                            char* playerId = reader.ReadStringPtr();
                            double playerScore = reader.ReadDouble();


                            IntrusivePtr<RequestTeamMemberResult> requestTeamMemberResult;
                            ret = RequestTeamMemberResultFactory::create(libContextPtr, playerId, playerScore, &requestTeamMemberResult);
                            if (ret < 0)
                            {
                                return ret;
                            }


                            ret = requestTeamMemberResults.pushBack(requestTeamMemberResult);
                            if (ret < 0)
                            {
                                return ret;
                            }
                        }

                        ret = requestTeamResult->setTeamMemberResults(requestTeamMemberResults);
                        if (ret < 0)
                        {
                            return ret;
                        }
                    }


                    ret = requestTeamResults.pushBack(requestTeamResult);
                    if (ret < 0)
                    {
                        return ret;
                    }
                }


                ret = requestCompetitiveResult->setTeamResults(requestTeamResults);
                if (ret < 0)
                {
                    return ret;
                }
            }
        }

        return ret;
    }

    int MatchesCommands::DeserialiseMatchStats(Common::LibContext* libContextPtr, BinaryReader &reader, CompetitionType competition, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestMatchStatistics> &requestMatchStatistics)
    {
        int ret = 0;


        ret = RequestMatchStatisticsFactory::create(libContextPtr, &requestMatchStatistics);
        if (ret < 0)
        {
            return ret;
        }


        if (competition == CompetitionType::kCooperative || (competition == CompetitionType::kCompetitive && groupType == GroupingType::kNonTeamMatch))
        {
            ret = DeserialisePlayerStats(libContextPtr, reader, groupType, resultType, requestMatchStatistics);
            if (ret < 0)
            {
                return ret;
            }
        }
        else if (competition == CompetitionType::kCompetitive && groupType == GroupingType::kTeamMatch)
        {
            ret = DeserialiseTeamStats(libContextPtr, reader, groupType, resultType, requestMatchStatistics);
            if (ret < 0)
            {
                return ret;
            }
        }
# 916 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp"
        return ret;
    }

    int MatchesCommands::DeserialiseAdditionalStats(Common::LibContext* libContextPtr, BinaryReader &reader, Vector<IntrusivePtr<AdditionalStatistic> >& stats)
    {
        int ret = 0;

        int32_t numStats = reader.ReadInt32();

        for (int i = 0; i < numStats; i++)
        {
            char* statsKey = reader.ReadStringPtr();
            char* statsValue = reader.ReadStringPtr();

            IntrusivePtr<AdditionalStatistic> stat;
            ret = AdditionalStatisticFactory::create(libContextPtr, statsKey, statsValue, &stat);
            if (ret < 0)
            {
                return ret;
            }

            ret = stats.pushBack(stat);
            if (ret < 0)
            {
                return ret;
            }
        }

        return 0;
    }

    int MatchesCommands::DeserialisePlayerStats(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestMatchStatistics> &requestMatchStatistics)
    {
        int ret = 0;

        int32_t numPlayerStats = reader.ReadInt32();

        if (numPlayerStats == 0)
        {
            return 0;
        }

        Vector<IntrusivePtr<RequestPlayerStatistic> > requestPlayerStatistics(libContextPtr);

        for (int i = 0; i < numPlayerStats; i++)
        {
            char* playerId = reader.ReadStringPtr();

            Vector<IntrusivePtr<AdditionalStatistic> > playerStats(libContextPtr);

            ret = DeserialiseAdditionalStats(libContextPtr, reader, playerStats);
            if (ret < 0)
            {
                return ret;
            }


            IntrusivePtr<RequestPlayerStatistic> requestPlayerStatistic;
            ret = RequestPlayerStatisticFactory::create(libContextPtr, playerId, playerStats, &requestPlayerStatistic);
            if (ret < 0)
            {
                return ret;
            }


            ret = requestPlayerStatistics.pushBack(requestPlayerStatistic);
            if (ret < 0)
            {
                return ret;
            }
        }


        ret = requestMatchStatistics->setPlayerStatistics(requestPlayerStatistics);
        if (ret < 0)
        {
            return ret;
        }

        return 0;
    }

    int MatchesCommands::DeserialiseTeamMemberStats(Common::LibContext* libContextPtr, BinaryReader &reader, IntrusivePtr<RequestTeamStatistic> &requestTeamStatistic)
    {
        int ret = 0;

        int32_t numMemberStats = reader.ReadInt32();

        if (numMemberStats == 0)
        {
            return 0;
        }

        Vector<IntrusivePtr<RequestTeamMemberStatistic> > requestTeamMemberStatistics(libContextPtr);

        for (int i = 0; i < numMemberStats; i++)
        {
            char* playerId = reader.ReadStringPtr();


            Vector<IntrusivePtr<AdditionalStatistic> > teamMemberStats(libContextPtr);
            ret = DeserialiseAdditionalStats(libContextPtr, reader, teamMemberStats);
            if (ret < 0)
            {
                return ret;
            }

            IntrusivePtr<RequestTeamMemberStatistic> requestTeamMemberStatistic;
            ret = RequestTeamMemberStatisticFactory::create(libContextPtr, playerId, teamMemberStats, &requestTeamMemberStatistic);
            if (ret < 0)
            {
                return ret;
            }


            ret = requestTeamMemberStatistics.pushBack(requestTeamMemberStatistic);
            if (ret < 0)
            {
                return ret;
            }
        }


        ret = requestTeamStatistic->setTeamMemberStatistics(requestTeamMemberStatistics);
        if (ret < 0)
        {
            return ret;
        }

        return 0;
    }

    int MatchesCommands::DeserialiseTeamStats(Common::LibContext* libContextPtr, BinaryReader &reader, GroupingType groupType, ResultType resultType, IntrusivePtr<RequestMatchStatistics> &requestMatchStatistics)
    {
        int ret = 0;

        int32_t numTeamStats = reader.ReadInt32();

        if (numTeamStats == 0)
        {
            return 0;
        }

        Vector<IntrusivePtr<RequestTeamStatistic> > requestTeamStatistics(libContextPtr);

        for (int i = 0; i < numTeamStats; i++)
        {
            char* teamId = reader.ReadStringPtr();


            IntrusivePtr<RequestTeamStatistic> requestTeamStatistic;
            ret = RequestTeamStatisticFactory::create(libContextPtr, teamId, &requestTeamStatistic);
            if (ret < 0)
            {
                return ret;
            }


            Vector<IntrusivePtr<AdditionalStatistic> > teamStats(libContextPtr);
            ret = DeserialiseAdditionalStats(libContextPtr, reader, teamStats);
            if (ret < 0)
            {
                return ret;
            }

            ret = requestTeamStatistic->setStats(teamStats);
            if (ret < 0)
            {
                return ret;
            }

            ret = DeserialiseTeamMemberStats(libContextPtr, reader, requestTeamStatistic);
            if (ret < 0)
            {
                return ret;
            }

            ret = requestTeamStatistics.pushBack(requestTeamStatistic);
            if (ret < 0)
            {
                return ret;
            }
        }


        ret = requestMatchStatistics->setTeamStatistics(requestTeamStatistics);
        if (ret < 0)
        {
            return ret;
        }

        return 0;
    }

    void MatchesCommands::ReportResultsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        char* matchId = reader.ReadStringPtr();
        CompetitionType competition = (CompetitionType)reader.ReadInt32();
        GroupingType groupType = (GroupingType)reader.ReadInt32();
        ResultType resultType = (ResultType)reader.ReadInt32();



        reader.ReadInt32();




        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1137));
            return;
        }

        Common::IntrusivePtr<RequestMatchResults> requestMatchResults;
        DeserialiseMatchResults(libContextPtr, reader, competition, groupType, resultType, requestMatchResults);

        IntrusivePtr<RequestMatchStatistics> requestMatchStatistics;
        DeserialiseMatchStats(libContextPtr, reader, competition, groupType, resultType, requestMatchStatistics);


        IntrusivePtr<ReportResultsRequest> reportResultsRequest;
        ret = ReportResultsRequestFactory::create(libContextPtr, requestMatchResults, &reportResultsRequest);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1152));
            return;
        }





        ret = reportResultsRequest->setMatchStatistics(requestMatchStatistics);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1163));
            return;
        }


        MatchApi::ParameterToReportResults param;
        ret = param.initialize(libContextPtr, matchId, reportResultsRequest);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1172));
            return;
        }

        DefaultResponse response;
        Common::Transaction<DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = MatchApi::reportResults(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1187));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1197));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchesCommands::UpdateDetailsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        char* matchId = reader.ReadStringPtr();

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1224));
            return;
        }

        Common::IntrusivePtr<UpdateMatchDetailRequest> updateMatchDetailRequest;
        ret = UpdateMatchDetailRequestFactory::create(libContextPtr, &updateMatchDetailRequest);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1232));
            return;
        }

        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet)
        {
            Int32 npServiceLabel = reader.ReadInt32();
            updateMatchDetailRequest->setNpServiceLabel(npServiceLabel);
        }

        bool isZoneIdSet = reader.ReadBool();
        if (isZoneIdSet)
        {
            char* zoneId = reader.ReadStringPtr();
            ret = updateMatchDetailRequest->setZoneId(zoneId);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1250));
                return;
            }
        }

        bool isExpirationTimeSet = reader.ReadBool();
        if (isExpirationTimeSet)
        {
            Int32 expirationTime = reader.ReadInt32();
            updateMatchDetailRequest->setExpirationTime(expirationTime);
        }

        IntrusivePtr<RequestInGameRoster> requestInGameRoster;
        ret = RequestInGameRosterFactory::create(libContextPtr, &requestInGameRoster);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1266));
            return;
        }


        Vector<IntrusivePtr<RequestMatchPlayer> > requestMatchPlayers(libContextPtr);

        bool isPlayersSet = reader.ReadBool();
        if (isPlayersSet)
        {
            int32_t numPlayers = reader.ReadInt32();

            for (int i = 0; i < numPlayers; i++)
            {
                IntrusivePtr<RequestMatchPlayer> requestMatchPlayer;

                char* playerId = reader.ReadStringPtr();
                PlayerType playerType = (PlayerType)reader.ReadInt32();

                ret = RequestMatchPlayerFactory::create(libContextPtr, playerId, playerType, &requestMatchPlayer);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1288));
                    return;
                }

                bool isPlayerNameSet = reader.ReadBool();
                if (isPlayerNameSet == true)
                {
                    char* playerName = reader.ReadStringPtr();
                    ret = requestMatchPlayer->setPlayerName(playerName);
                    if (ret < 0)
                    {
                        (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1299));
                        return;
                    }
                }

                bool isAccountIdSet = reader.ReadBool();
                if (isAccountIdSet == true)
                {
                    UInt64 accountId = reader.ReadUInt64();
                    char accountIdBuf[21];
                    GetAccountIdStr(accountId, accountIdBuf, sizeof(accountIdBuf));
                    ret = requestMatchPlayer->setAccountId(accountIdBuf);
                    if (ret < 0)
                    {
                        (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1313));
                        return;
                    }
                }

                ret = requestMatchPlayers.pushBack(requestMatchPlayer);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1321));
                    return;
                }
            }

            ret = requestInGameRoster->setPlayers(requestMatchPlayers);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1329));
                return;
            }
        }

        bool isTeamsSet = reader.ReadBool();
        if (isTeamsSet)
        {
            int32_t numTeams = reader.ReadInt32();

            Vector<IntrusivePtr<RequestMatchTeam> > requestMatchTeams(libContextPtr);
            for (int i = 0; i < numTeams; i++)
            {
                IntrusivePtr<RequestMatchTeam> requestMatchTeam;

                char* teamId = reader.ReadStringPtr();

                ret = RequestMatchTeamFactory::create(libContextPtr, teamId, &requestMatchTeam);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1349));
                    return;
                }

                bool isTeamNameSet = reader.ReadBool();
                if (isTeamNameSet == true)
                {
                    char* teamName = reader.ReadStringPtr();
                    ret = requestMatchTeam->setTeamName(teamName);
                    if (ret < 0)
                    {
                        (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1360));
                        return;
                    }
                }

                int32_t numMembers = reader.ReadInt32();

                if (numMembers > 0)
                {
                    Vector<IntrusivePtr<RequestMember> > requestMembers(libContextPtr);

                    for (int j = 0; j < numMembers; j++)
                    {

                        IntrusivePtr<RequestMember> requestMember;

                        char* playerId = reader.ReadStringPtr();

                        ret = RequestMemberFactory::create(libContextPtr, playerId, &requestMember);
                        if (ret < 0)
                        {
                            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1381));
                            return;
                        }


                        ret = requestMembers.pushBack(requestMember);
                        if (ret < 0)
                        {
                            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1389));
                            return;
                        }
                    }
                    ret = requestMatchTeam->setMembers(requestMembers);
                    if (ret < 0)
                    {
                        (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1396));
                        return;
                    }
                }

                ret = requestMatchTeams.pushBack(requestMatchTeam);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1404));
                    return;
                }
            }


            ret = requestInGameRoster->setTeams(requestMatchTeams);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1413));
                return;
            }
        }

        if (isPlayersSet || isTeamsSet)
        {

            ret = updateMatchDetailRequest->setInGameRoster(requestInGameRoster);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1424));
                return;
            }
        }

        GroupingType groupType = (GroupingType)reader.ReadInt32();
        ResultType resultType = (ResultType)reader.ReadInt32();

        bool isResultsSet = reader.ReadBool();
        if (isResultsSet)
        {
            Common::IntrusivePtr<RequestTemporaryMatchResults> matchResults;
            DeserialiseTemporaryMatchResults(libContextPtr, reader, groupType, resultType, matchResults);

            ret = updateMatchDetailRequest->setMatchResults(matchResults);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1441));
                return;
            }
        }

        bool isStatsSet = reader.ReadBool();
        if (isStatsSet)
        {
            IntrusivePtr<RequestMatchStatistics> requestMatchStatistics;

            DeserialiseMatchStats(libContextPtr, reader, CompetitionType::kCompetitive, groupType, resultType, requestMatchStatistics);




            ret = updateMatchDetailRequest->setMatchStatistics(requestMatchStatistics);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1459));
                return;
            }
        }

        MatchApi::ParameterToUpdateMatchDetail param;
        ret = param.initialize(libContextPtr, matchId, updateMatchDetailRequest);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1468));
            return;
        }

        DefaultResponse response;
        Common::Transaction<DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = MatchApi::updateMatchDetail(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1483));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Matches.cpp", 1493));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchesCommands::SerialiseMatchDetail(BinaryWriter& writer, IntrusivePtr<GetMatchDetailResponse> matchDetail)
    {
        writer.WriteString(matchDetail->getMatchId().c_str());

        writer.WriteInt32((Int32)matchDetail->getStatus());

        writer.WriteString(matchDetail->getActivityId().c_str());

        writer.WriteInt32((Int32)matchDetail->getGroupingType());
        writer.WriteInt32((Int32)matchDetail->getCompetitionType());
        writer.WriteInt32((Int32)matchDetail->getResultType());

        if (matchDetail->zoneIdIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(matchDetail->getZoneId().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        writer.WriteInt32(matchDetail->getExpirationTime());

        if (matchDetail->matchStartTimestampIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(matchDetail->getMatchStartTimestamp().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (matchDetail->matchEndTimestampIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(matchDetail->getMatchEndTimestamp().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (matchDetail->lastPausedTimestampIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(matchDetail->getLastPausedTimestamp().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (matchDetail->inGameRosterIsSet())
        {
            IntrusivePtr<ResponseInGameRoster> roster = matchDetail->getInGameRoster();
            writer.WriteBool(true);

            SerialiseGameRoster(writer, roster);
        }
        else
        {
            writer.WriteBool(false);
        }

        if (matchDetail->matchResultsIsSet())
        {
            IntrusivePtr<ResponseMatchResults> matchResults = matchDetail->getMatchResults();
            writer.WriteBool(true);

            SerialiseMatchResults(writer, matchResults);
        }
        else
        {
            writer.WriteBool(false);
        }

        if (matchDetail->matchStatisticsIsSet())
        {
            IntrusivePtr<ResponseMatchStatistics> matchStats = matchDetail->getMatchStatistics();
            writer.WriteBool(true);

            SerialiseMatchStats(writer, matchStats);
        }
        else
        {
            writer.WriteBool(false);
        }
    }

    void MatchesCommands::SerialisePlayers(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponseMatchPlayer> > > players)
    {
        writer.WriteInt32(players->size());

        for (auto& it : *players)
        {
            writer.WriteString(it->getPlayerId().c_str());

            writer.WriteInt32((Int32)it->getPlayerType());

            if (it->playerNameIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getPlayerName().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->accountIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getAccountId().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->onlineIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getOnlineId().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            writer.WriteBool(it->getJoinFlag());
        }
    }

    void MatchesCommands::SerialiseTeams(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponseMatchTeam> > > teams)
    {
        writer.WriteInt32(teams->size());

        for (auto& it : *teams)
        {
            writer.WriteString(it->getTeamId().c_str());

            if (it->teamNameIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getTeamName().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->membersIsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Vector<IntrusivePtr<ResponseMember> > > members = it->getMembers();

                writer.WriteInt32(members->size());

                for (auto& member : *members)
                {
                    writer.WriteString(member->getPlayerId().c_str());
                    writer.WriteBool(member->getJoinFlag());
                }
            }
            else
            {
                writer.WriteBool(false);
            }
        }
    }

    void MatchesCommands::SerialiseGameRoster(BinaryWriter& writer, IntrusivePtr<ResponseInGameRoster> roster)
    {
        if (roster->playersIsSet())
        {
            writer.WriteBool(true);

            SerialisePlayers(writer, roster->getPlayers());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (roster->teamsIsSet())
        {
            writer.WriteBool(true);

            SerialiseTeams(writer, roster->getTeams());
        }
        else
        {
            writer.WriteBool(false);
        }
    }

    void MatchesCommands::SerialiseMatchResults(BinaryWriter& writer, IntrusivePtr<ResponseMatchResults> matchResults)
    {
        writer.WriteInt32((Int32)matchResults->getVersion());

        if (matchResults->cooperativeResultIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32((Int32)matchResults->getCooperativeResult());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (matchResults->competitiveResultIsSet())
        {
            writer.WriteBool(true);

            IntrusivePtr<ResponseCompetitiveResult> competitiveResult = matchResults->getCompetitiveResult();

            if (competitiveResult->playerResultsIsSet())
            {
                writer.WriteBool(true);

                SerialisePlayerResults(writer, competitiveResult->getPlayerResults());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (competitiveResult->teamResultsIsSet())
            {
                writer.WriteBool(true);

                SerialiseTeamResults(writer, competitiveResult->getTeamResults());
            }
            else
            {
                writer.WriteBool(false);
            }
        }
        else
        {
            writer.WriteBool(false);
        }
    }

    void MatchesCommands::SerialiseTeamResults(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponseTeamResults> > > teamResults)
    {
        writer.WriteInt32(teamResults->size());

        for (auto& it : *teamResults)
        {
            writer.WriteString(it->getTeamId().c_str());

            writer.WriteInt32(it->getRank());

            if (it->scoreIsSet())
            {
                writer.WriteBool(true);
                writer.WriteDouble(it->getScore());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->teamMemberResultsIsSet())
            {
                writer.WriteBool(true);

                SerialiseTeamMemberResults(writer, it->getTeamMemberResults());
            }
            else
            {
                writer.WriteBool(false);
            }
        }
    }

    void MatchesCommands::SerialiseTeamMemberResults(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponseTeamMemberResult> > > teamMemberResults)
    {
        writer.WriteInt32(teamMemberResults->size());

        for (auto& teamMemberResult : *teamMemberResults)
        {
            writer.WriteString(teamMemberResult->getPlayerId().c_str());

            writer.WriteDouble(teamMemberResult->getScore());
        }
    }

    void MatchesCommands::SerialisePlayerResults(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<ResponsePlayerResults> > > playerResults)
    {
        writer.WriteInt32(playerResults->size());

        for (auto& it : *playerResults)
        {
            writer.WriteString(it->getPlayerId().c_str());

            writer.WriteInt32(it->getRank());

            if (it->scoreIsSet())
            {
                writer.WriteBool(true);
                writer.WriteDouble(it->getScore());
            }
            else
            {
                writer.WriteBool(false);
            }
        }
    }

    void MatchesCommands::SerialiseAdditionalStats(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<AdditionalStatistic> > > additionalStats)
    {
        writer.WriteInt32(additionalStats->size());

        for (auto& aStats : *additionalStats)
        {
            writer.WriteString(aStats->getStatsKey().c_str());
            writer.WriteString(aStats->getStatsValue().c_str());
        }
    }

    void MatchesCommands::SerialiseMatchStats(BinaryWriter& writer, IntrusivePtr<ResponseMatchStatistics> matchStats)
    {
        if (matchStats->playerStatisticsIsSet())
        {
            writer.WriteBool(true);

            IntrusivePtr<Vector<IntrusivePtr<ResponsePlayerStatistic> > > playerStats = matchStats->getPlayerStatistics();

            writer.WriteInt32(playerStats->size());

            for (auto& it : *playerStats)
            {
                writer.WriteString(it->getPlayerId().c_str());

                SerialiseAdditionalStats(writer, it->getStats());
            }
        }
        else
        {
            writer.WriteBool(false);
        }

        if (matchStats->teamStatisticsIsSet())
        {
            writer.WriteBool(true);

            IntrusivePtr<Vector<IntrusivePtr<ResponseTeamStatistic> > > teamStats = matchStats->getTeamStatistics();

            writer.WriteInt32(teamStats->size());

            for (auto& it : *teamStats)
            {
                writer.WriteString(it->getTeamId().c_str());

                SerialiseAdditionalStats(writer, it->getStats());

                IntrusivePtr<Vector<IntrusivePtr<ResponseTeamMemberStatistic> > > teamMemberStats = it->getTeamMemberStatistics();

                writer.WriteInt32(teamMemberStats->size());

                for (auto& teamMemberState : *teamMemberStats)
                {
                    writer.WriteString(teamMemberState->getPlayerId().c_str());
                    SerialiseAdditionalStats(writer, teamMemberState->getStats());
                }
            }
        }
        else
        {
            writer.WriteBool(false);
        }
    }

    int MatchesCommands::Create(Int32 userId, InitializationParams& initParams, BinaryWriter& writer)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            return -1;
        }

        int ret = 0;

        IntrusivePtr<RequestInGameRoster> requestInGameRoster;
        ret = RequestInGameRosterFactory::create(libContextPtr, &requestInGameRoster);
        if (ret < 0)
        {
            return ret;
        }


        Vector<IntrusivePtr<RequestMatchPlayer> > requestMatchPlayers(libContextPtr);
        for (auto& player : initParams.m_Players)
        {
            IntrusivePtr<RequestMatchPlayer> requestMatchPlayer;

            ret = RequestMatchPlayerFactory::create(libContextPtr, player.m_PlayerId, player.m_PlayerType, &requestMatchPlayer);
            if (ret < 0)
            {
                return ret;
            }

            if (player.m_PlayerName != __null && strlen(player.m_PlayerName) > 0)
            {
                ret = requestMatchPlayer->setPlayerName(player.m_PlayerName);
                if (ret < 0)
                {
                    return ret;
                }
            }

            if (player.m_PlayerType == PlayerType::kPsnPlayer)



            {
                char accountIdBuf[21];
                GetAccountIdStr(player.m_AccountId, accountIdBuf, sizeof(accountIdBuf));
                ret = requestMatchPlayer->setAccountId(accountIdBuf);
                if (ret < 0)
                {
                    return ret;
                }
            }

            ret = requestMatchPlayers.pushBack(requestMatchPlayer);
            if (ret < 0)
            {
                return ret;
            }
        }

        ret = requestInGameRoster->setPlayers(requestMatchPlayers);
        if (ret < 0)
        {
            return ret;
        }

        if (initParams.m_Teams.size() > 0)
        {
            Vector<IntrusivePtr<RequestMatchTeam> > requestMatchTeams(libContextPtr);
            for (auto& team : initParams.m_Teams)
            {
                IntrusivePtr<RequestMatchTeam> requestMatchTeam;

                ret = RequestMatchTeamFactory::create(libContextPtr, team.m_TeamId, &requestMatchTeam);
                if (ret < 0)
                {
                    return ret;
                }

                if (team.m_TeamName != __null && strlen(team.m_TeamName) > 0)
                {
                    ret = requestMatchTeam->setTeamName(team.m_TeamName);
                    if (ret < 0)
                    {
                        return ret;
                    }
                }

                if (team.m_Members.size())
                {
                    Vector<IntrusivePtr<RequestMember> > requestMembers(libContextPtr);

                    for (auto& member : team.m_Members)
                    {

                        IntrusivePtr<RequestMember> requestMember;
                        ret = RequestMemberFactory::create(libContextPtr, member.m_PlayerId, &requestMember);
                        if (ret < 0)
                        {
                            return ret;
                        }


                        ret = requestMembers.pushBack(requestMember);
                        if (ret < 0)
                        {
                            return ret;
                        }
                    }
                    ret = requestMatchTeam->setMembers(requestMembers);
                    if (ret < 0)
                    {
                        return ret;
                    }
                }

                ret = requestMatchTeams.pushBack(requestMatchTeam);
                if (ret < 0)
                {
                    return ret;
                }
            }


            ret = requestInGameRoster->setTeams(requestMatchTeams);
            if (ret < 0)
            {
                return ret;
            }
        }

        IntrusivePtr<CreateMatchRequest> createMatchRequest;
        ret = CreateMatchRequestFactory::create(libContextPtr, initParams.m_ActivityId, &createMatchRequest);
        if (ret < 0)
        {
            return ret;
        }


        ret = createMatchRequest->setInGameRoster(requestInGameRoster);
        if (ret < 0)
        {
            return ret;
        }

        createMatchRequest->setNpServiceLabel(initParams.m_ServiceLabel);
        if (ret < 0)
        {
            return ret;
        }

        if (initParams.m_ZoneId != __null && strlen(initParams.m_ZoneId) > 0)
        {
            ret = createMatchRequest->setZoneId(initParams.m_ZoneId);
            if (ret < 0)
            {
                return ret;
            }
        }

        MatchApi::ParameterToCreateMatch param;
        ret = param.initialize(libContextPtr, createMatchRequest);
        if (ret < 0)
        {
            return ret;
        }

        typedef Common::IntrusivePtr<CreateMatchResponse> CreateMatchResponseType;
        CreateMatchResponseType response;

        Common::Transaction<CreateMatchResponseType> transaction;
        transaction.start(libContextPtr);


        ret = MatchApi::createMatch(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        if (!(response))
        {
            param.terminate();
            transaction.finish();
            return -1;
        }

        writer.WriteString(response->getMatchId().c_str());

        param.terminate();
        transaction.finish();

        return ret;
    }
}
# 18 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp" 1



namespace psn
{
    void MatchMakingSystem::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::SubmitTicket, MatchMakingSystem::SubmitTicketImpl);
        MsgHandler::AddMethod(Methods::GetTicket, MatchMakingSystem::GetTicketImpl);
        MsgHandler::AddMethod(Methods::CancelTicket, MatchMakingSystem::CancelTicketImpl);
        MsgHandler::AddMethod(Methods::GetOffer, MatchMakingSystem::GetOfferImpl);
        MsgHandler::AddMethod(Methods::ListUserTickets, MatchMakingSystem::ListUserTicketsImpl);
    }

    void MatchMakingSystem::Initialize()
    {
    }

    void MatchMakingSystem::SubmitTicketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 34));
            return;
        }

        char* rulesetName = reader.ReadStringPtr();



        Vector<IntrusivePtr<PlayerForTicketCreate> > playersForTicketCreate(libContextPtr);


        int numPlayers = reader.ReadInt32();

        for (int i = 0; i < numPlayers; i++)
        {
            SceNpAccountId accountId = reader.ReadUInt64();
            SceNpPlatformType platformType = reader.ReadInt32();

            IntrusivePtr<PlayerForTicketCreate> playerForTicketCreate;
            Platform platform = GetPlatformType(platformType);

            ret = PlayerForTicketCreateFactory::create(libContextPtr, accountId, platform, &playerForTicketCreate);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 58));
                return;
            }

            bool isNameSet = reader.ReadBool();

            if (isNameSet == true)
            {
                char* teamName = reader.ReadStringPtr();

                ret = playerForTicketCreate->setTeamName(teamName);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 71));
                    return;
                }
            }

            bool isNatTypeSet = reader.ReadBool();
            if (isNatTypeSet)
            {

                Int32 natType = reader.ReadInt32();
                playerForTicketCreate->setNatType(natType);
            }


            Int32 numAttributes = reader.ReadInt32();

            if (numAttributes > 0)
            {
                Vector<IntrusivePtr<Attribute> > playerAttributes(libContextPtr);

                ret = ReadAttributes(reader, playerAttributes, numAttributes);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 94));
                    return;
                }

                ret = playerForTicketCreate->setPlayerAttributes(playerAttributes);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 101));
                    return;
                }
            }


            ret = playersForTicketCreate.pushBack(playerForTicketCreate);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 110));
                return;
            }
        }

        IntrusivePtr<SubmitTicketRequestBody> submitTicketRequestBody;
        ret = SubmitTicketRequestBodyFactory::create(libContextPtr, rulesetName, playersForTicketCreate, &submitTicketRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 119));
            return;
        }

        Int32 numTicketAttributes = reader.ReadInt32();

        if (numTicketAttributes > 0)
        {
            Common::Vector<Common::IntrusivePtr<Attribute> > ticketAttributes(libContextPtr);

            ret = ReadAttributes(reader, ticketAttributes, numTicketAttributes);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 132));
                return;
            }

            ret = submitTicketRequestBody->setTicketAttributes(ticketAttributes);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 139));
                return;
            }
        }


        bool isGameSessionIdSet = reader.ReadBool();

        if (isGameSessionIdSet)
        {
            char* gameSessionId = reader.ReadStringPtr();

            IntrusivePtr<Location> location;
            ret = LocationFactory::create(libContextPtr, &location);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 155));
                return;
            }

            ret = location->setGameSessionId(gameSessionId);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 162));
                return;
            }
            ret = submitTicketRequestBody->setLocation(location);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 168));
                return;
            }
        }

        Api::ParameterToSubmitTicket param;
        ret = param.initialize(libContextPtr, submitTicketRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 177));
            return;
        }

        typedef Common::IntrusivePtr<SubmitTicketResponseBody> SubmitTicketResponseBody;
        SubmitTicketResponseBody response;

        Common::Transaction<SubmitTicketResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = Api::submitTicket(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 193));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 203));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        sce::Np::CppWebApi::Matchmaking::V1::SubmitTicketResponseBody* body = response.get();

        WriteTicketResponse(writer, body);

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchMakingSystem::GetTicketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 236));
            return;
        }

        char* ticketId = reader.ReadStringPtr();

        Api::ParameterToGetTicket param;
        ret = param.initialize(libContextPtr, ticketId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 246));
            return;
        }

        char* view = reader.ReadStringPtr();

        ret = param.setview(view);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 255));
            return;
        }

        typedef Common::IntrusivePtr<GetTicketResponseBody> GetTicketResponseBody;
        GetTicketResponseBody response;

        Common::Transaction<GetTicketResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = Api::getTicket(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 271));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 281));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        sce::Np::CppWebApi::Matchmaking::V1::GetTicketResponseBody* body = response.get();

        WriteTicketResponse(writer, body);

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchMakingSystem::CancelTicketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 314));
            return;
        }

        char* ticketId = reader.ReadStringPtr();

        Api::ParameterToCancelTicket param;
        ret = param.initialize(libContextPtr, ticketId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 324));
            return;
        }

        DefaultResponse response;
        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);


        ret = Api::cancelTicket(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 338));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 348));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchMakingSystem::GetOfferImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 373));
            return;
        }

        char* offerId = reader.ReadStringPtr();

        if (offerId == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "OfferId is null", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 381));
            return;
        }

        Api::ParameterToGetOffer param;
        ret = param.initialize(libContextPtr, offerId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 389));
            return;
        }

        typedef Common::IntrusivePtr<GetOfferResponseBody> GetOfferResponseBody;
        GetOfferResponseBody response;

        Common::Transaction<GetOfferResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = Api::getOffer(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 405));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 415));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        sce::Np::CppWebApi::Matchmaking::V1::GetOfferResponseBody* body = response.get();

        WriteOfferResponse(writer, body);

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MatchMakingSystem::ListUserTicketsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 448));
            return;
        }

        Api::ParameterToListUserTickets param;
        ret = param.initialize(libContextPtr, "me");
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 456));
            return;
        }

        bool isPlatformFilterSet = reader.ReadBool();
        if (isPlatformFilterSet)
        {
            char* platformFilter = reader.ReadStringPtr();
            ret = param.setplatformFilter(platformFilter);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 467));
                return;
            }
        }

        bool isRulesetFilterSet = reader.ReadBool();
        if (isRulesetFilterSet)
        {
            char* rulesetFilter = reader.ReadStringPtr();
            ret = param.setrulesetFilter(rulesetFilter);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 479));
                return;
            }
        }

        typedef Common::IntrusivePtr<ListUserTicketsResponseBody> ListUserTicketsResponseBody;
        ListUserTicketsResponseBody response;

        Common::Transaction<ListUserTicketsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = Api::listUserTickets(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 496));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp", 506));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        sce::Np::CppWebApi::Matchmaking::V1::ListUserTicketsResponseBody* body = response.get();

        if (body != __null)
        {
            Common::Vector<Common::IntrusivePtr<UserTicket> >* userTickets = body->getTickets().get();

            if (userTickets != __null)
            {
                writer.WriteInt32(userTickets->size());

                for (auto& it : *userTickets)
                {
                    if (it->ticketIdIsSet())
                    {
                        writer.WriteBool(true);
                        writer.WriteString(it->getTicketId().c_str());
                    }
                    else
                    {
                        writer.WriteBool(false);
                    }

                    if (it->statusIsSet())
                    {
                        writer.WriteBool(true);
                        writer.WriteInt32((Int32)it->getStatus());
                    }
                    else
                    {
                        writer.WriteBool(false);
                    }

                    if (it->rulesetNameIsSet())
                    {
                        writer.WriteBool(true);
                        writer.WriteString(it->getRulesetName().c_str());
                    }
                    else
                    {
                        writer.WriteBool(false);
                    }

                    if (it->platformIsSet())
                    {
                        writer.WriteBool(true);
                        writer.WriteInt32((Int32)GetPlatformType(it->getPlatform()));
                    }
                    else
                    {
                        writer.WriteBool(false);
                    }
                }
            }
            else
            {
                writer.WriteInt32(0);
            }
        }
        else
        {
            writer.WriteInt32(0);
        }

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int MatchMakingSystem::WriteTicketResponse(BinaryWriter& writer, sce::Np::CppWebApi::Matchmaking::V1::SubmitTicketResponseBody* body)
    {
        if (body->ticketIdIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(body->getTicketId().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->rulesetNameIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(body->getRulesetName().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->ticketAttributesIsSet())
        {
            WriteAttributes(writer, body->getTicketAttributes().get());
        }
        else
        {
            WriteAttributes(writer, __null);
        }

        if (body->playersIsSet())
        {
            WritePlayers(writer, body->getPlayers().get());
        }
        else
        {
            WritePlayers(writer, __null);
        }

        if (body->statusIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32((Int32)body->getStatus());
        }
        else
        {
            writer.WriteBool(false);
        }

        writer.WriteBool(false);

        if (body->submitterIsSet())
        {
            writer.WriteBool(true);
            WriteSubmitter(writer, body->getSubmitter().get());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->createdDateTimeIsSet())
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(body->getCreatedDateTime());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->updatedDateTimeIsSet())
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(body->getUpdatedDateTime());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->locationIsSet())
        {
            writer.WriteBool(true);
            WriteLocation(writer, body->getLocation().get());
        }
        else
        {
            writer.WriteBool(false);
        }

        return 0;
    }

    int MatchMakingSystem::WriteTicketResponse(BinaryWriter& writer, sce::Np::CppWebApi::Matchmaking::V1::GetTicketResponseBody* body)
    {
        if (body->ticketIdIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(body->getTicketId().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->rulesetNameIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(body->getRulesetName().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->ticketAttributesIsSet())
        {
            WriteAttributes(writer, body->getTicketAttributes().get());
        }
        else
        {
            WriteAttributes(writer, __null);
        }

        if (body->playersIsSet())
        {
            WritePlayersForRead(writer, body->getPlayers().get());
        }
        else
        {
            WritePlayersForRead(writer, __null);
        }

        if (body->statusIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32((Int32)body->getStatus());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->offerIdIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(body->getOfferId().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->submitterIsSet())
        {
            writer.WriteBool(true);
            WriteSubmitter(writer, body->getSubmitter().get());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->createdDateTimeIsSet())
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(body->getCreatedDateTime());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->updatedDateTimeIsSet())
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(body->getUpdatedDateTime());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->locationIsSet())
        {
            writer.WriteBool(true);
            WriteLocation(writer, body->getLocation().get());
        }
        else
        {
            writer.WriteBool(false);
        }

        return 0;
    }

    int MatchMakingSystem::WriteOfferResponse(BinaryWriter& writer, sce::Np::CppWebApi::Matchmaking::V1::GetOfferResponseBody* body)
    {
        if (body->offerIdIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(body->getOfferId().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->rulesetNameIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(body->getRulesetName().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->playersIsSet())
        {
            WritePlayersForOfferRead(writer, body->getPlayers().get());
        }
        else
        {
            WritePlayersForOfferRead(writer, __null);
        }

        if (body->statusIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32((Int32)body->getStatus());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->locationIsSet())
        {
            writer.WriteBool(true);
            WriteLocation(writer, body->getLocation().get());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->createdDateTimeIsSet())
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(body->getCreatedDateTime());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (body->updatedDateTimeIsSet())
        {
            writer.WriteBool(true);
            writer.WriteRtcTick(body->getUpdatedDateTime());
        }
        else
        {
            writer.WriteBool(false);
        }

        return 0;
    }

    Platform MatchMakingSystem::GetPlatformType(SceNpPlatformType platformType)
    {

        if (platformType == (3))
        {
            return Platform::kPs4;
        }

        if (platformType == (5))
        {
            return Platform::kPs5;
        }
# 879 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp"
        return Platform::_NOT_SET;
    }

    SceNpPlatformType MatchMakingSystem::GetPlatformType(Platform platform)
    {

        if (platform == Platform::kPs4)
        {
            return (3);
        }

        if (platform == Platform::kPs5 || platform == Platform::kProspero)
        {
            return (5);
        }
# 905 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MatchMaking.cpp"
        return (0);
    }

    int MatchMakingSystem::ReadAttributes(BinaryReader &reader, Common::Vector<Common::IntrusivePtr<Attribute> >& attributes, int numAttributes)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        for (int a = 0; a < numAttributes; a++)
        {
            char* name = reader.ReadStringPtr();
            Int32 attributeType = reader.ReadInt32();
            char* value = reader.ReadStringPtr();

            IntrusivePtr<Attribute> attr;
            int ret = AttributeFactory::create(libContextPtr, name, static_cast<AttributeType>(attributeType), value, &attr);
            if (ret < 0)
            {
                return ret;
            }

            ret = attributes.pushBack(attr);
            if (ret < 0)
            {
                return ret;
            }
        }

        return 0;
    }

    int MatchMakingSystem::WriteAttributes(BinaryWriter& writer, Common::Vector<Common::IntrusivePtr<Attribute> >* attributes)
    {
        if (attributes == __null)
        {
            writer.WriteInt32(0);
            return 0;
        }

        writer.WriteInt32(attributes->size());

        for (auto& it : *attributes)
        {
            writer.WriteString(it->getName().c_str());
            writer.WriteInt32((Int32)it->getType());
            writer.WriteString(it->getValue().c_str());
        }

        return 0;
    }


    int MatchMakingSystem::WritePlayers(BinaryWriter& writer, Common::Vector<Common::IntrusivePtr<PlayerForTicketCreate> >* players)
    {
        if (players == __null)
        {
            writer.WriteInt32(0);
            return 0;
        }

        writer.WriteInt32(players->size());

        for (auto& it : *players)
        {
            writer.WriteBool(true);
            writer.WriteUInt64(it->getAccountId());

            writer.WriteBool(false);

            writer.WriteBool(true);
            writer.WriteInt32((Int32)GetPlatformType(it->getPlatform()));

            if (it->teamNameIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getTeamName().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->natTypeIsSet())
            {
                writer.WriteBool(true);
                writer.WriteInt32(it->getNatType());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->playerAttributesIsSet())
            {
                WriteAttributes(writer, it->getPlayerAttributes().get());
            }
            else
            {
                WriteAttributes(writer, __null);
            }
        }

        return 0;
    }


    int MatchMakingSystem::WritePlayersForRead(BinaryWriter& writer, Common::Vector<Common::IntrusivePtr<PlayerForRead> >* players)
    {
        if (players == __null)
        {
            writer.WriteInt32(0);
            return 0;
        }

        writer.WriteInt32(players->size());

        for (auto& it : *players)
        {
            if (it->accountIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteUInt64(it->getAccountId());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->onlineIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getOnlineId().data);
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->platformIsSet())
            {
                writer.WriteBool(true);
                writer.WriteInt32((Int32)GetPlatformType(it->getPlatform()));
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->teamNameIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getTeamName().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->natTypeIsSet())
            {
                writer.WriteBool(true);
                writer.WriteInt32(it->getNatType());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->playerAttributesIsSet())
            {
                WriteAttributes(writer, it->getPlayerAttributes().get());
            }
            else
            {
                WriteAttributes(writer, __null);
            }
        }

        return 0;
    }

    int MatchMakingSystem::WritePlayersForOfferRead(BinaryWriter& writer, Common::Vector<Common::IntrusivePtr<PlayerForOfferRead> >* players)
    {
        if (players == __null)
        {
            writer.WriteInt32(0);
            return 0;
        }

        writer.WriteInt32(players->size());

        for (auto& it : *players)
        {
            if (it->accountIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteUInt64(it->getAccountId());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->onlineIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getOnlineId().data);
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->platformIsSet())
            {
                writer.WriteBool(true);
                writer.WriteInt32((Int32)GetPlatformType(it->getPlatform()));
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->teamNameIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getTeamName().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (it->ticketIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(it->getTicketId().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }
        }

        return 0;
    }

    int MatchMakingSystem::WriteSubmitter(BinaryWriter& writer, Submitter* submitter)
    {
        if (submitter->accountIdIsSet())
        {
            writer.WriteBool(true);
            writer.WriteUInt64(submitter->getAccountId());
        }
        else
        {
            writer.WriteBool(false);
        }

        if (submitter->platformIsSet())
        {
            writer.WriteBool(true);
            writer.WriteInt32((Int32)GetPlatformType(submitter->getPlatform()));
        }
        else
        {
            writer.WriteBool(false);
        }

        return 0;
    }

    int MatchMakingSystem::WriteLocation(BinaryWriter& writer, Location* location)
    {
        if (location->gameSessionIdIsSet())
        {
            writer.WriteBool(true);
            writer.WriteString(location->getGameSessionId().c_str());
        }
        else
        {
            writer.WriteBool(false);
        }

        return 0;
    }
}
# 19 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MsgDialog.cpp" 1
# 11 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MsgDialog.cpp"
#pragma comment(lib,"libSceMsgDialog_stub_weak.a")

namespace psn
{
    void MsgDialog::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::OpenDialog, MsgDialog::OpenDialogImpl);
        MsgHandler::AddMethod(Methods::UpdateDialog, MsgDialog::UpdateDialogImpl);
        MsgHandler::AddMethod(Methods::CloseDialog, MsgDialog::CloseDialogImpl);
    }

    void MsgDialog::InitializeLib()
    {
        int res = sceSysmoduleIsLoaded(0x00a4);
        if (res != 0)
        {
            res = sceSysmoduleLoadModule(0x00a4);

            if (res < 0)
            {
                printf("Error loading SCE_SYSMODULE_MESSAGE_DIALOG, 0x%x\n", res);
            }
            s_ModuleLoaded = true;
        }
    }

    void MsgDialog::TerminateLib()
    {
        if (s_ModuleLoaded == true)
        {
            int res = sceSysmoduleUnloadModule(0x00a4);

            if (res < 0)
            {
                printf("Error unloading SCE_SYSMODULE_MESSAGE_DIALOG, 0x%x\n", res);
            }
        }
    }

    bool MsgDialog::s_DialogInitialized = false;
    bool MsgDialog::s_ModuleLoaded = false;

    void MsgDialog::OpenDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        ret = InitialzeDialog();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MsgDialog.cpp", 63));
            return;
        }

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        SceMsgDialogMode mode = (SceMsgDialogMode)reader.ReadInt32();

        SceMsgDialogParam param;
        sceMsgDialogParamInitialize(&param);

        param.userId = userId;
        param.mode = mode;

        SceMsgDialogUserMessageParam userMsgParam;
        memset(&userMsgParam, 0, sizeof(userMsgParam));

        SceMsgDialogButtonsParam buttonParam;
        memset(&buttonParam, 0, sizeof(buttonParam));

        SceMsgDialogProgressBarParam progressParam;
        memset(&progressParam, 0, sizeof(progressParam));

        SceMsgDialogSystemMessageParam sysMsgParam;
        memset(&sysMsgParam, 0, sizeof(sysMsgParam));

        if (mode == (1))
        {
            userMsgParam.buttonType = (SceMsgDialogButtonType)reader.ReadInt32();
            userMsgParam.msg = reader.ReadStringPtr();

            if (userMsgParam.buttonType == (9))
            {
                buttonParam.msg1 = reader.ReadStringPtr();
                buttonParam.msg2 = reader.ReadStringPtr();

                userMsgParam.buttonsParam = &buttonParam;
            }

            param.userMsgParam = &userMsgParam;
        }
        else if (mode == (2))
        {
            progressParam.barType = (SceMsgDialogProgressBarType)reader.ReadInt32();
            progressParam.msg = reader.ReadStringPtr();

            param.progBarParam = &progressParam;
        }
        else if (mode == (3))
        {
            sysMsgParam.sysMsgType = (SceMsgDialogSystemMessageType)reader.ReadInt32();

            param.sysMsgParam = &sysMsgParam;
        }

        ret = sceMsgDialogOpen(&param);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MsgDialog.cpp", 123));
            TerminateDialog();
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MsgDialog::UpdateDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        SceCommonDialogStatus status = sceMsgDialogUpdateStatus();

        BinaryReader reader(sourceData, sourceSize);
        UpdateProgressBar(reader, status);

        SceMsgDialogResult dialogResult;
        memset(&dialogResult, 0, sizeof(dialogResult));

        bool hasFinished = false;

        if (status == SCE_COMMON_DIALOG_STATUS_FINISHED)
        {
            ret = sceMsgDialogGetResult(&dialogResult);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MsgDialog.cpp", 157));
                TerminateDialog();
                return;
            }

            hasFinished = true;
            TerminateDialog();
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(status);
        writer.WriteBool(hasFinished);
        if (hasFinished == true)
        {
            writer.WriteInt32(dialogResult.result);
            writer.WriteInt32(dialogResult.buttonId);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void MsgDialog::CloseDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        ret = TerminateDialog();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\MsgDialog.cpp", 191));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int MsgDialog::UpdateProgressBar(BinaryReader& reader, SceCommonDialogStatus status)
    {
        int ret = 0;

        Int32 updateType = reader.ReadInt32();

        if ((updateType & 1) != 0)
        {

            UInt32 delta = reader.ReadUInt32();

            if (status == SCE_COMMON_DIALOG_STATUS_RUNNING)
            {
                ret = sceMsgDialogProgressBarInc((0), delta);
                if (ret < 0)
                {
                    return ret;
                }
            }
        }
        else if ((updateType & 2) != 0)
        {

            UInt32 rate = reader.ReadUInt32();

            if (status == SCE_COMMON_DIALOG_STATUS_RUNNING)
            {
                ret = sceMsgDialogProgressBarSetValue((0), rate);
                if (ret < 0)
                {
                    return ret;
                }
            }
        }

        if ((updateType & 4) != 0)
        {

            char* msg = reader.ReadStringPtr();

            if (status == SCE_COMMON_DIALOG_STATUS_RUNNING)
            {
                ret = sceMsgDialogProgressBarSetMsg((0), msg);
                if (ret < 0)
                {
                    return ret;
                }
            }
        }

        return ret;
    }

    int MsgDialog::InitialzeDialog()
    {
        if (s_DialogInitialized == true) return 0;

        int ret = Utils::InitializeCommonDialog();

        if (ret < 0)
        {
            return ret;
        }

        ret = sceMsgDialogInitialize();

        if (ret < 0)
        {
            return ret;
        }

        s_DialogInitialized = true;

        return ret;
    }

    int MsgDialog::TerminateDialog()
    {
        if (s_DialogInitialized == false) return 0;

        int ret = sceMsgDialogTerminate();

        if (ret < 0)
        {
            return ret;
        }

        s_DialogInitialized = false;

        return ret;
    }
}
# 20 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp" 1






namespace CppWebApi = sce::Np::CppWebApi;
namespace CRS = sce::Np::CppWebApi::CommunicationRestrictionStatus::V3;

namespace Profanity = sce::Np::CppWebApi::ProfanityFilter::V2;

namespace psn
{
    void OnlineSafety::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::GetCRS, OnlineSafety::GetCRSImpl);
        MsgHandler::AddMethod(Methods::FilterProfanity, OnlineSafety::FilterProfanityImpl);
        MsgHandler::AddMethod(Methods::TestProfanity, OnlineSafety::TestProfanityImpl);
    }

    enum CRStatus
    {
        NOT_CHECKED = 0,
        CHECK_FAILED = 1,
        NOT_SIGNED_UP = 2,
        USER_NOT_FOUND = 3,
        SIGNED_OUT = 4,
        RESTRICTED = 5,
        UNRESTRICTED = 6,
        SIGNED_IN_NOT_REGISTERED = 7
    };

    void OnlineSafety::GetCRSImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        CRStatus status = CHECK_FAILED;

        bool signedup = false;
        int ret = sceNpHasSignedUp(userId, &signedup);

        if (ret < 0)
        {
            if (ret == -2141913081)
            {
                status = USER_NOT_FOUND;
            }
            else
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 53));
                return;
            }
        }
        else
        {
            if (signedup == false)
            {
                status = NOT_SIGNED_UP;
            }
            else
            {
                SceNpAccountId accountId = (0);

                ret = sceNpGetAccountIdA(userId, &accountId);

                if (ret < 0)
                {
                    if (ret == -2141913082) status = SIGNED_OUT;
                    else if (ret == -2141913078) status = NOT_SIGNED_UP;
                    else if (ret == -2141913081) status = USER_NOT_FOUND;
                    else
                    {
                        (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 76));
                        return;
                    }
                }
                else
                {
                    WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

                    if (userWebCtx == __null)
                    {
                        status = SIGNED_IN_NOT_REGISTERED;
                    }
                    else
                    {
                        CRS::CommunicationRestrictionStatusApi::ParameterToGetCommunicationRestrictionStatus param;
                        CppWebApi::Common::IntrusivePtr<CRS::CommunicationRestrictionStatusResponse> response;

                        CppWebApi::Common::Transaction<
                            CppWebApi::Common::IntrusivePtr<CRS::CommunicationRestrictionStatusResponse> > trans;

                        Common::LibContext* libContextPtr = &WebApi::Instance()->m_cppWebapiLibCtx;

                        ret = trans.start(libContextPtr);
                        if (ret < 0)
                        {
                            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 101));
                            return;
                        }

                        ret = param.initialize(libContextPtr, accountId);
                        if (ret < 0)
                        {
                            trans.finish();
                            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 109));
                            return;
                        }

                        ret = CRS::CommunicationRestrictionStatusApi::getCommunicationRestrictionStatus(userWebCtx->m_webapiUserCtxId, param, trans);
                        if (ret < 0)
                        {
                            param.terminate();
                            trans.finish();
                            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 118));
                            return;
                        }

                        ret = trans.getResponse(response);
                        if (ret < 0)
                        {
                            param.terminate();
                            trans.finish();
                            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 127));
                            return;
                        }

                        if (response->getRestricted())
                        {
                            status = RESTRICTED;
                        }
                        else
                        {
                            status = UNRESTRICTED;
                        }

                        trans.finish();
                        param.terminate();
                    }
                }
            }
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteUInt32(status);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void OnlineSafety::FilterProfanityImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();
        char* locale = reader.ReadStringPtr();
        char* textToFilter = reader.ReadStringPtr();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 170));
            return;
        }

        Common::Transaction<Common::IntrusivePtr<Profanity::FilterProfanityResponse> > transaction;

        Common::LibContext* libContextPtr = &WebApi::Instance()->m_cppWebapiLibCtx;


        int ret = transaction.start(libContextPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 182));
            return;
        }

        Common::IntrusivePtr<Profanity::WebApiFilterRequest> pFilterRequest;
        ret = Profanity::WebApiFilterRequestFactory::create(libContextPtr, textToFilter, &pFilterRequest);
        if (ret < 0)
        {
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 191));
            return;
        }

        Profanity::ProfanityApi::ParameterToFilterProfanity param;
        ret = param.initialize(libContextPtr, locale, "0", pFilterRequest);
        if (ret < 0)
        {
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 200));
            return;
        }


        ret = Profanity::ProfanityApi::filterProfanity(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 210));
            return;
        }

        Common::IntrusivePtr<Profanity::FilterProfanityResponse> respPtr;
        ret = transaction.getResponse(respPtr);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 220));
            return;
        }

        const char* outputStr = respPtr->getMessage().c_str();

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteString(outputStr);

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void OnlineSafety::TestProfanityImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();
        char* locale = reader.ReadStringPtr();
        char* textToFilter = reader.ReadStringPtr();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 251));
            return;
        }

        Common::Transaction<Common::IntrusivePtr<Profanity::TestForProfanityResponse> > transaction;

        Common::LibContext* libContextPtr = &WebApi::Instance()->m_cppWebapiLibCtx;


        int ret = transaction.start(libContextPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 263));
            return;
        }

        Common::IntrusivePtr<Profanity::WebApiFilterRequest> pFilterRequest;
        ret = Profanity::WebApiFilterRequestFactory::create(libContextPtr, textToFilter, &pFilterRequest);
        if (ret < 0)
        {
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 272));
            return;
        }

        Profanity::ProfanityApi::ParameterToTestForProfanity param;
        ret = param.initialize(libContextPtr, locale, "0", pFilterRequest);
        if (ret < 0)
        {
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 281));
            return;
        }


        ret = Profanity::ProfanityApi::testForProfanity(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 291));
            return;
        }

        Common::IntrusivePtr<Profanity::TestForProfanityResponse> respPtr;
        ret = transaction.getResponse(respPtr);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\OnlineSafety.cpp", 301));
            return;
        }

        const char* outputStr = respPtr->getMessage().c_str();

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteString(outputStr);

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 21 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerInvitationDialog.cpp" 1
# 10 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerInvitationDialog.cpp"
#pragma comment(lib,"libScePlayerInvitationDialog_stub_weak.a")

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\player_invitation_dialog.h" 1 3
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\player_invitation_dialog.h" 3
extern "C" {
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\player_invitation_dialog.h" 3
typedef enum ScePlayerInvitationDialogMode {
 SCE_PLAYER_INVITATION_DIALOG_MODE_INVALID = 0,

 SCE_PLAYER_INVITATION_DIALOG_MODE_SEND = 1,

} ScePlayerInvitationDialogMode;
# 42 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\player_invitation_dialog.h" 3
typedef struct {
 const char* sessionId;

 uint8_t reserved[64];

} ScePlayerInvitationDialogSendParam;



typedef struct ScePlayerInvitationDialogParam {
 SceCommonDialogBaseParam baseParam;

 uint32_t size;

 SceUserServiceUserId userId;

 ScePlayerInvitationDialogMode mode;

 union {
  const ScePlayerInvitationDialogSendParam* sendParam;

 };
 uint8_t reserved[64];

} ScePlayerInvitationDialogParam;



typedef struct ScePlayerInvitationDialogResult {
 int32_t errorCode;

 SceCommonDialogResult result;

 uint8_t reserved[32];

} ScePlayerInvitationDialogResult;







static inline
 void scePlayerInvitationDialogParamInitialize(ScePlayerInvitationDialogParam *param)
{
 memset(param, 0x0, sizeof(ScePlayerInvitationDialogParam));

 _sceCommonDialogBaseParamInit(&param->baseParam);

 param->userId = (-1);
 param->mode = SCE_PLAYER_INVITATION_DIALOG_MODE_INVALID;
 param->size = sizeof(ScePlayerInvitationDialogParam);
}




int32_t scePlayerInvitationDialogInitialize();



int32_t scePlayerInvitationDialogOpen(const ScePlayerInvitationDialogParam *param);



SceCommonDialogStatus scePlayerInvitationDialogUpdateStatus(void);



SceCommonDialogStatus scePlayerInvitationDialogGetStatus(void);



int32_t scePlayerInvitationDialogGetResult(ScePlayerInvitationDialogResult *result);



int32_t scePlayerInvitationDialogTerminate(void);



int32_t scePlayerInvitationDialogClose(void);



}
# 13 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerInvitationDialog.cpp" 2




namespace psn
{
    void PlayerInvitationDialog::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::OpenDialog, PlayerInvitationDialog::OpenDialogImpl);
        MsgHandler::AddMethod(Methods::UpdateDialog, PlayerInvitationDialog::UpdateDialogImpl);
        MsgHandler::AddMethod(Methods::CloseDialog, PlayerInvitationDialog::CloseDialogImpl);
    }

    void PlayerInvitationDialog::InitializeLib()
    {
    }

    void PlayerInvitationDialog::TerminateLib()
    {
    }

    bool PlayerInvitationDialog::s_DialogInitialized = false;

    void PlayerInvitationDialog::OpenDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        ret = InitializeDialog();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerInvitationDialog.cpp", 46));
            return;
        }

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        char* sessionId = reader.ReadStringPtr();
        ScePlayerInvitationDialogMode mode = (ScePlayerInvitationDialogMode)reader.ReadInt32();

        ScePlayerInvitationDialogParam param;
        scePlayerInvitationDialogParamInitialize(&param);

        ScePlayerInvitationDialogSendParam sendParam;
        memset(&sendParam, 0, sizeof(sendParam));
        sendParam.sessionId = sessionId;

        param.userId = userId;
        param.mode = mode;
        param.sendParam = &sendParam;

        ret = scePlayerInvitationDialogOpen(&param);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerInvitationDialog.cpp", 71));
            TerminateDialog();
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerInvitationDialog::UpdateDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        SceCommonDialogStatus status = scePlayerInvitationDialogUpdateStatus();
        ScePlayerInvitationDialogResult dialogResult;
        memset(&dialogResult, 0, sizeof(dialogResult));

        bool hasFinished = false;

        if (status == SCE_COMMON_DIALOG_STATUS_FINISHED)
        {
            ret = scePlayerInvitationDialogGetResult(&dialogResult);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerInvitationDialog.cpp", 101));
                TerminateDialog();
                return;
            }

            hasFinished = true;
            TerminateDialog();
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(status);
        writer.WriteBool(hasFinished);
        if (hasFinished == true)
        {
            writer.WriteInt32(dialogResult.result);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerInvitationDialog::CloseDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        ret = TerminateDialog();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerInvitationDialog.cpp", 134));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int PlayerInvitationDialog::InitializeDialog()
    {
        if (s_DialogInitialized == true) return 0;

        int ret = Utils::InitializeCommonDialog();

        if (ret < 0)
        {
            return ret;
        }

        ret = sceSysmoduleIsLoaded(0x010d);
        if (ret != 0)
        {
            if (ret == -2141581311)
            {
                ret = sceSysmoduleLoadModule(0x010d);
            }

            if (ret != 0)
            {
                return ret;
            }
        }

        ret = scePlayerInvitationDialogInitialize();

        if (ret < 0)
        {
            return ret;
        }

        s_DialogInitialized = true;

        return ret;
    }

    int PlayerInvitationDialog::TerminateDialog()
    {
        if (s_DialogInitialized == false) return 0;

        int ret = scePlayerInvitationDialogTerminate();

        if (ret < 0)
        {
            return ret;
        }

        s_DialogInitialized = false;

        return ret;
    }
}
# 22 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp" 1
# 14 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp"
namespace psn
{
    void PlayerReviewDialog::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::OpenDialog, PlayerReviewDialog::OpenDialogImpl);
        MsgHandler::AddMethod(Methods::UpdateDialog, PlayerReviewDialog::UpdateDialogImpl);
        MsgHandler::AddMethod(Methods::CloseDialog, PlayerReviewDialog::CloseDialogImpl);
    }

    void PlayerReviewDialog::InitializeLib()
    {
    }

    void PlayerReviewDialog::TerminateLib()
    {
    }

    bool PlayerReviewDialog::s_DialogInitialized = false;

    void PlayerReviewDialog::OpenDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
# 76 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp"
  *resultsSize = 0;
  (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, -2147352557, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp", 77));
  return;

    }

    void PlayerReviewDialog::UpdateDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
# 123 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp"
  *resultsSize = 0;
  (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, -2147352557, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp", 124));
  return;

    }

    void PlayerReviewDialog::CloseDialogImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
# 150 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp"
  *resultsSize = 0;
  (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, -2147352557, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp", 151));
  return;

    }

    int PlayerReviewDialog::InitialzeDialog()
    {
# 179 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp"
  return -2147352557;

    }

    int PlayerReviewDialog::TerminateDialog()
    {
# 199 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerReviewDialog.cpp"
  return -2147352557;

    }
}
# 23 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp" 1







namespace psn
{


    void PlayerSessionCommands::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::CreatePlayerSession, PlayerSessionCommands::CreatePlayerSessionImpl);
        MsgHandler::AddMethod(Methods::LeavePlayerSession, PlayerSessionCommands::LeavePlayerSessionImpl);
        MsgHandler::AddMethod(Methods::JoinPlayerSession, PlayerSessionCommands::JoinPlayerSessionImpl);
        MsgHandler::AddMethod(Methods::GetPlayerSessions, PlayerSessionCommands::GetPlayerSessionsImpl);
        MsgHandler::AddMethod(Methods::SendPlayerSessionsInvitation, PlayerSessionCommands::SendPlayerSessionsInvitationImpl);

        MsgHandler::AddMethod(Methods::GetPlayerSessionInvitations, PlayerSessionCommands::GetPlayerSessionInvitationsImpl);
        MsgHandler::AddMethod(Methods::SetPlayerSessionProperties, PlayerSessionCommands::SetPlayerSessionPropertiesImpl);
        MsgHandler::AddMethod(Methods::ChangePlayerSessionLeader, PlayerSessionCommands::ChangePlayerSessionLeaderImpl);
        MsgHandler::AddMethod(Methods::AddPlayerSessionJoinableSpecifiedUsers, PlayerSessionCommands::AddPlayerSessionJoinableSpecifiedUsersImpl);
        MsgHandler::AddMethod(Methods::DeletePlayerSessionJoinableSpecifiedUsers, PlayerSessionCommands::DeletePlayerSessionJoinableSpecifiedUsersImpl);
        MsgHandler::AddMethod(Methods::SetPlayerSessionMemberSystemProperties, PlayerSessionCommands::SetPlayerSessionMemberSystemPropertiesImpl);
        MsgHandler::AddMethod(Methods::SendPlayerSessionMessage, PlayerSessionCommands::SendPlayerSessionMessageImpl);
        MsgHandler::AddMethod(Methods::GetJoinedPlayerSessionsByUser, PlayerSessionCommands::GetJoinedPlayerSessionsByUserImpl);
    }
# 60 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp"
    int PlayerSessionCommands::LocalisedStrings::Deserialise(BinaryReader& reader)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        const char* defaultStr = reader.ReadStringPtr();

        int strCount = reader.ReadInt32();

        sce::Json::Object localizedText;

        for (int i = 0; i < strCount; i++)
        {
            const char* localeStr = reader.ReadStringPtr();
            const char* textStr = reader.ReadStringPtr();

            localizedText[localeStr] = sce::Json::String(textStr);
        }



        int ret = LocalizedStringFactory::create(libContextPtr, defaultStr, localizedText, &m_LocalizedStringPtr);

        return ret;
    }

    PlayerSessionCommands::InitializationParams::InitializationParams() :
        m_MaxPlayers(0),
        m_MaxSpectators(0),
        m_SwapSupported(false),
        m_JoinDisabled(false),

        m_JoinableUserType(JoinableUserType::kNoOne),
        m_InvitableUserType(InvitableUserType::kNoOne),




        m_PlatformFlags(0),
        m_LeaderPrivileges(__null),
        m_ExclusiveLeaderPrivileges(__null),
        m_DisableSystemUiMenu(__null),
        m_CustomDataSize1(0),
        m_CustomData1(__null),
        m_CustomDataSize2(0),
        m_CustomData2(__null)
    {
    }

    PlayerSessionCommands::InitializationParams::~InitializationParams()
    {
        if (m_LeaderPrivileges != __null) delete m_LeaderPrivileges;
        if (m_ExclusiveLeaderPrivileges != __null) delete m_ExclusiveLeaderPrivileges;
        if (m_DisableSystemUiMenu != __null) delete m_DisableSystemUiMenu;
    }

    void PlayerSessionCommands::InitializationParams::Deserialise(BinaryReader& reader)
    {
        m_UserId = reader.ReadInt32();
        m_MaxPlayers = reader.ReadUInt32();
        m_MaxSpectators = reader.ReadUInt32();
        m_SwapSupported = reader.ReadBool();
        m_JoinDisabled = reader.ReadBool();
        m_JoinableUserType = (sceSessionManager::JoinableUserType)reader.ReadUInt32();
        m_InvitableUserType = (sceSessionManager::InvitableUserType)reader.ReadUInt32();
        m_PlatformFlags = reader.ReadUInt32();

        m_SessionName.Deserialise(reader);

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        m_LeaderPrivileges = new Vector<String>(libContextPtr);
        m_ExclusiveLeaderPrivileges = new Vector<String>(libContextPtr);
        m_DisableSystemUiMenu = new Vector<String>(libContextPtr);

        PlayerSessionCommands::DeserialiseLeaderPrivileges(reader, m_LeaderPrivileges);
        PlayerSessionCommands::DeserialiseLeaderPrivileges(reader, m_ExclusiveLeaderPrivileges);
        PlayerSessionCommands::DeserialiseLeaderPrivileges(reader, m_DisableSystemUiMenu);

        m_CustomDataSize1 = reader.ReadInt32();
        if (m_CustomDataSize1 > 0)
        {
            m_CustomData1 = reader.ReadDataPtr(m_CustomDataSize1);
        }

        m_CustomDataSize2 = reader.ReadInt32();
        if (m_CustomDataSize2 > 0)
        {
            m_CustomData2 = reader.ReadDataPtr(m_CustomDataSize2);
        }
    }

    int PlayerSessionCommands::DeserialiseLeaderPrivileges(BinaryReader& reader, Vector<String> *strings)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        int ret = 0;

        int count = reader.ReadInt32();

        for (int i = 0; i < count; i++)
        {
            const char* str = reader.ReadStringPtr();

            int ret = addStringToVector(libContextPtr, str, *strings);
            if (ret < 0)
            {
                return ret;
            }
        }

        return ret;
    }

    void PlayerSessionCommands::CreatePlayerSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 pushCallbackId = reader.ReadInt32();

        InitializationParams params;
        params.Deserialise(reader);

        int creatorDataSize1 = reader.ReadInt32();
        void* creatorCustomData1 = __null;
        if (creatorDataSize1 > 0)
        {
            creatorCustomData1 = reader.ReadDataPtr(creatorDataSize1);
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        int ret = Create(pushCallbackId, creatorCustomData1, creatorDataSize1, params, writer);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 196));
            return;
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::LeavePlayerSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();
        const char* sessionId = reader.ReadStringPtr();

        int ret = Leave(userId, sessionId);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 217));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        SceNpAccountId accountId = (0);
        sceNpGetAccountIdA(userId, &accountId);

        writer.WriteUInt64(accountId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::JoinPlayerSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();
        Int32 pushCallbackId = reader.ReadInt32();
        bool joinAsSpector = reader.ReadBool();
        bool swapping = reader.ReadBool();
        const char* sessionId = reader.ReadStringPtr();


        BinaryWriter writer(resultsData, resultsMaxSize);

        if (joinAsSpector == false)
        {
            int ret = JoinAsPlayer(userId, pushCallbackId, sessionId, swapping, writer);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 253));
                return;
            }
        }
        else
        {
            int ret = JoinAsSpectator(userId, pushCallbackId, sessionId, swapping, writer);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 263));
                return;
            }
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void DeletePtr(Vector<String>* ptr)
    {
        delete ptr;
    }

    void PlayerSessionCommands::GetPlayerSessionsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 293));
            return;
        }

        const char* sessionIds = reader.ReadStringPtr();
        UInt32 numFields = reader.ReadUInt32();

        Vector<String>* fields = new Vector<String>(libContextPtr);

        for (int i = 0; i < numFields; i++)
        {
            const char* str = reader.ReadStringPtr();

            ret = addStringToVector(libContextPtr, str, *fields);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 309));
                return;
            }
        }

        IntrusivePtr<Vector<String> > fieldsPtr(fields, DeletePtr, libContextPtr);

        PlayerSessionsApi::ParameterToGetPlayerSessions param;
        ret = param.initialize(libContextPtr, sessionIds);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 320));
            return;
        }

        param.setfields(fieldsPtr);

        typedef Common::IntrusivePtr<GetPlayerSessionsResponseBody> GetPlayerSessionsResponseBody;
        GetPlayerSessionsResponseBody response;

        Common::Transaction<GetPlayerSessionsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::getPlayerSessions(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 338));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 348));
            return;
        }

        IntrusivePtr<Vector<IntrusivePtr<PlayerSessionForRead> > > playerSessionsPtr = response->getPlayerSessions();


        BinaryWriter writer(resultsData, resultsMaxSize);

        SerialiseSessionInfo(writer, playerSessionsPtr);

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::SendPlayerSessionsInvitationImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();
        const char* sessionId = reader.ReadStringPtr();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 383));
            return;
        }

        Int32 numAccountIds = reader.ReadInt32();

        Vector<IntrusivePtr<RequestPlayerSessionInvitation> > invitations(libContextPtr);

        for (int i = 0; i < numAccountIds; i++)
        {
            UInt64 accountId = reader.ReadUInt64();
            IntrusivePtr<To> to;
            ret = ToFactory::create(libContextPtr, accountId, &to);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 398));
                return;
            }

            IntrusivePtr<RequestPlayerSessionInvitation> requestPlayerSessionInvitation;
            ret = RequestPlayerSessionInvitationFactory::create(libContextPtr, to, &requestPlayerSessionInvitation);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 406));
                return;
            }

            ret = invitations.pushBack(requestPlayerSessionInvitation);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 413));
                return;
            }
        }

        IntrusivePtr<PostPlayerSessionsSessionIdInvitationsRequestBody> postPlayerSessionsSessionIdInvitationsRequestBody;
        ret = PostPlayerSessionsSessionIdInvitationsRequestBodyFactory::create(libContextPtr, &postPlayerSessionsSessionIdInvitationsRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 422));
            return;
        }

        ret = postPlayerSessionsSessionIdInvitationsRequestBody->setInvitations(invitations);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 429));
            return;
        }

        PlayerSessionsApi::ParameterToSendPlayerSessionInvitations param;
        ret = param.initialize(libContextPtr, sessionId, postPlayerSessionsSessionIdInvitationsRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 437));
            return;
        }

        typedef Common::IntrusivePtr<PostPlayerSessionsSessionIdInvitationsResponseBody> PostPlayerSessionsSessionIdInvitationsResponseBody;
        PostPlayerSessionsSessionIdInvitationsResponseBody response;

        Common::Transaction<PostPlayerSessionsSessionIdInvitationsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::sendPlayerSessionInvitations(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 453));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 463));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        IntrusivePtr<Vector<IntrusivePtr<ResponsePlayerSessionInvitation> > > invitationsPtr = response->getInvitations();

        if (!(invitationsPtr))
        {
            writer.WriteInt32(0);
        }
        else
        {
            writer.WriteInt32(invitationsPtr->size());

            for (auto& it : *invitationsPtr)
            {
                writer.WriteString(it->getInvitationId().c_str());
            }
        }

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }







    void PlayerSessionCommands::GetPlayerSessionInvitationsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 516));
            return;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 526));
            return;
        }

        UInt32 numFields = reader.ReadUInt32();

        Vector<String>* fields = new Vector<String>(libContextPtr);

        for (int i = 0; i < numFields; i++)
        {
            const char* str = reader.ReadStringPtr();

            ret = addStringToVector(libContextPtr, str, *fields);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 541));
                return;
            }
        }

        Int32 filter = reader.ReadInt32();

        const char * invitationInvalidFilter = __null;

        if (filter == 0)
        {
            invitationInvalidFilter = "false";
        }
        else if (filter == 1)
        {
            invitationInvalidFilter = "true";
        }
        else if (filter == 2)
        {
            invitationInvalidFilter = "true,false\0";
        }

        IntrusivePtr<Vector<String> > fieldsPtr(fields, DeletePtr, libContextPtr);

        PlayerSessionsApi::ParameterToGetPlayerSessionInvitations param;
        ret = param.initialize(libContextPtr, accountIdBuf);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 569));
            return;
        }

        ret = param.setinvitationInvalidFilter(invitationInvalidFilter);
        if (ret < 0)
        {
            param.terminate();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 577));
            return;
        }

        param.setfields(fieldsPtr);

        typedef Common::IntrusivePtr<GetUsersAccountIdPlayerSessionsInvitationsResponseBody> GetUsersAccountIdPlayerSessionsInvitationsResponseBody;
        GetUsersAccountIdPlayerSessionsInvitationsResponseBody response;

        Common::Transaction<GetUsersAccountIdPlayerSessionsInvitationsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::getPlayerSessionInvitations(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 595));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 605));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        if (!(response->invitationsIsSet()))
        {

            writer.WriteBool(false);
        }
        else
        {
            writer.WriteBool(true);

            IntrusivePtr<Vector<IntrusivePtr<UsersPlayerSessionsInvitationForRead> > > invitations = response->getInvitations();

            writer.WriteInt32(invitations.get()->size());

            for (auto& it : *invitations)
            {

                if (it->invitationIdIsSet())
                {
                    writer.WriteBool(true);
                    writer.WriteString(it->getInvitationId().c_str());
                }
                else
                {
                    writer.WriteBool(false);
                }


                if (it->fromIsSet())
                {
                    writer.WriteBool(true);
                    IntrusivePtr<FromMember> fromMemberPtr = it->getFrom();
                    writer.WriteUInt64(fromMemberPtr->getAccountId());
                    writer.WriteString(fromMemberPtr->getOnlineId().data);
                    writer.WriteUInt32(Utils::GetPlatformFlag(fromMemberPtr->getPlatform().c_str()));
                }
                else
                {
                    writer.WriteBool(false);
                }


                if (it->sessionIdIsSet())
                {
                    writer.WriteBool(true);
                    writer.WriteString(it->getSessionId().c_str());
                }
                else
                {
                    writer.WriteBool(false);
                }


                if (it->supportedPlatformsIsSet())
                {
                    writer.WriteBool(true);

                    uint32_t platformFlags = 0;

                    IntrusivePtr<Vector<String> > platforms = it->getSupportedPlatforms();

                    for (auto& it : *platforms)
                    {
                        platformFlags |= Utils::GetPlatformFlag(it.c_str());
                    }

                    writer.WriteUInt32(platformFlags);
                }
                else
                {
                    writer.WriteBool(false);
                }


                if (it->receivedTimestampIsSet())
                {
                    writer.WriteBool(true);
                    writer.WriteString(it->getReceivedTimestamp().c_str());
                }
                else
                {
                    writer.WriteBool(false);
                }


                if (it->invitationInvalidIsSet())
                {
                    writer.WriteBool(true);
                    writer.WriteBool(it->getInvitationInvalid());
                }
                else
                {
                    writer.WriteBool(false);
                }
            }
        }

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::SetPlayerSessionPropertiesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 730));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        ret = SetPlayerSessionProps(userCtx, sessionId, reader);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 740));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::ChangePlayerSessionLeaderImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 763));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        SceNpAccountId accountId = reader.ReadUInt64();

        const char* platform = reader.ReadStringPtr();

        IntrusivePtr<PutPlayerSessionsSessionIdLeaderRequestBody> putPlayerSessionsSessionIdLeaderRequestBodyPtr;
        ret = PutPlayerSessionsSessionIdLeaderRequestBodyFactory::create(libContextPtr, accountId, platform, &putPlayerSessionsSessionIdLeaderRequestBodyPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 777));
            return;
        }

        PlayerSessionsApi::ParameterToChangePlayerSessionLeader param;
        ret = param.initialize(libContextPtr, sessionId, putPlayerSessionsSessionIdLeaderRequestBodyPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 785));
            return;
        }

        ret = param.setsessionId(sessionId);
        if (ret < 0)
        {
            param.terminate();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 793));
            return;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);

        ret = PlayerSessionsApi::changePlayerSessionLeader(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 807));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 817));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::AddPlayerSessionJoinableSpecifiedUsersImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 843));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        int count = reader.ReadInt32();

        Vector<IntrusivePtr<JoinableUser> > joinableSpecifiedUsers(libContextPtr);

        for (int i = 0; i < count; i++)
        {
            SceNpAccountId accountId = reader.ReadUInt64();

            IntrusivePtr<JoinableUser> joinableUserPtr;
            ret = JoinableUserFactory::create(libContextPtr, accountId, &joinableUserPtr);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 861));
                return;
            }


            ret = joinableSpecifiedUsers.pushBack(joinableUserPtr);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 869));
                return;
            }
        }

        Common::IntrusivePtr<PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody> postPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody;
        ret = PostPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBodyFactory::create(libContextPtr, joinableSpecifiedUsers, &postPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 878));
            return;
        }

        PlayerSessionsApi::ParameterToAddPlayerSessionJoinableSpecifiedUsers param;
        ret = param.initialize(libContextPtr, sessionId, postPlayerSessionsSessionIdJoinableSpecifiedUsersRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 886));
            return;
        }

        typedef Common::IntrusivePtr<PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody> PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody;
        PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody response;

        Common::Transaction<PostPlayerSessionsSessionIdJoinableSpecifiedUsersResponseBody> transaction;
        transaction.start(libContextPtr);

        ret = PlayerSessionsApi::addPlayerSessionJoinableSpecifiedUsers(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 901));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 911));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        IntrusivePtr<Vector<IntrusivePtr<JoinableUser> > > joinableUsers = response->getJoinableSpecifiedUsers();

        writer.WriteInt32(joinableUsers.get()->size());

        for (auto& it : *joinableUsers)
        {
            writer.WriteUInt64(it->getAccountId());
        }

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::DeletePlayerSessionJoinableSpecifiedUsersImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 951));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        const char* accountIds = reader.ReadStringPtr();

        PlayerSessionsApi::ParameterToDeletePlayerSessionJoinableSpecifiedUsers param;
        ret = param.initialize(libContextPtr, sessionId, accountIds);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 963));
            return;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);

        ret = PlayerSessionsApi::deletePlayerSessionJoinableSpecifiedUsers(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 977));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 987));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::SetPlayerSessionMemberSystemPropertiesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1013));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        int dataSize = reader.ReadInt32();
        void* data = reader.ReadDataPtr(dataSize);


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1028));
            return;
        }

        Common::IntrusivePtr<PatchPlayerSessionsSessionIdMembersAccountIdRequestBody> patchPlayerSessionsSessionIdMembersAccountIdRequestBody;
        ret = PatchPlayerSessionsSessionIdMembersAccountIdRequestBodyFactory::create(libContextPtr, &patchPlayerSessionsSessionIdMembersAccountIdRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1036));
            return;
        }

        ret = patchPlayerSessionsSessionIdMembersAccountIdRequestBody->setCustomData1(data, dataSize);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1043));
            return;
        }

        PlayerSessionsApi::ParameterToSetPlayerSessionMemberSystemProperties param;
        ret = param.initialize(libContextPtr, sessionId, accountIdBuf, patchPlayerSessionsSessionIdMembersAccountIdRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1051));
            return;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);

        ret = PlayerSessionsApi::setPlayerSessionMemberSystemProperties(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1065));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1075));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::SendPlayerSessionMessageImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1101));
            return;
        }

        const char* sessionId = reader.ReadStringPtr();

        const char* payload = reader.ReadStringPtr();

        int count = reader.ReadInt32();

        Vector<IntrusivePtr<MemberWithMultiPlatform> > to(libContextPtr);

        for (int i = 0; i < count; i++)
        {
            SceNpAccountId accountId = reader.ReadUInt64();
            uint32_t platformFlag = reader.ReadUInt32();
            const char * platformStr = Utils::ToPlatformString(platformFlag);
            ((platformStr) ? (void)0 : :: _Assert("C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp" "(" "1118" ") : Assertion Failed (" "platformStr" ")", __func__));


            IntrusivePtr<MemberWithMultiPlatform> mp;
            ret = MemberWithMultiPlatformFactory::create(libContextPtr, accountId, platformStr, &mp);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1125));
                return;
            }


            ret = to.pushBack(mp);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1133));
                return;
            }
        }

        Common::IntrusivePtr<PostPlayerSessionsSessionIdSessionMessageRequestBody> postPlayerSessionsSessionIdSessionMessageRequestBody;
        ret = PostPlayerSessionsSessionIdSessionMessageRequestBodyFactory::create(libContextPtr, to, payload, &postPlayerSessionsSessionIdSessionMessageRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1142));
            return;
        }

        PlayerSessionsApi::ParameterToSendPlayerSessionMessage param;
        ret = param.initialize(libContextPtr, sessionId, postPlayerSessionsSessionIdSessionMessageRequestBody);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1150));
            return;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::sendPlayerSessionMessage(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1165));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1175));
            return;
        }

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::GetJoinedPlayerSessionsByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Can't find user context id", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1201));
            return;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        PlayerSessionsApi::ParameterToGetJoinedPlayerSessionsByUser param;
        ret = param.initialize(libContextPtr, accountIdBuf);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1213));
            return;
        }

        ret = param.setmemberFilter("player,spectator");
        if (ret < 0)
        {
            param.terminate();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1221));
            return;
        }

        ret = param.setplatformFilter("PS4,PS5");
        if (ret < 0)
        {
            param.terminate();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1229));
            return;
        }

        typedef Common::IntrusivePtr<GetUsersAccountIdPlayerSessionsResponseBody> GetUsersAccountIdPlayerSessionsResponseBody;
        GetUsersAccountIdPlayerSessionsResponseBody response;

        Common::Transaction<GetUsersAccountIdPlayerSessionsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::getJoinedPlayerSessionsByUser(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1245));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp", 1255));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        IntrusivePtr<Vector<IntrusivePtr<JoinedPlayerSessionWithPlatform> > > playerSessions = response->getPlayerSessions();

        writer.WriteInt32(playerSessions.get()->size());

        for (auto& it : *playerSessions)
        {
            writer.WriteString(it->getSessionId().c_str());

            writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
        }

        *resultsSize = writer.GetWrittenLength();

        param.terminate();
        transaction.finish();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void PlayerSessionCommands::SerialiseSessionInfo(BinaryWriter& writer, IntrusivePtr<Vector<IntrusivePtr<PlayerSessionForRead> > > playerSessionsPtr)
    {
        if (!(playerSessionsPtr)) return;

        if (playerSessionsPtr->empty())
        {

            writer.WriteBool(false);
            return;
        }

        writer.WriteBool(true);

        int numSessions = playerSessionsPtr->size();

        writer.WriteInt32(numSessions);

        for (int session = 0; session < numSessions; session++)
        {
            IntrusivePtr<PlayerSessionForRead>& playerSessionPtr = (*playerSessionsPtr)[session];
            if (!(playerSessionPtr))
            {
                writer.WriteBool(false);
                return;
            }
            writer.WriteBool(true);

            if (playerSessionPtr->sessionIdIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(playerSessionPtr->getSessionId().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->createdTimestampIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(playerSessionPtr->getCreatedTimestamp().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->maxPlayersIsSet())
            {
                writer.WriteBool(true);
                writer.WriteUInt32(playerSessionPtr->getMaxPlayers());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->maxSpectatorsIsSet())
            {
                writer.WriteBool(true);
                writer.WriteUInt32(playerSessionPtr->getMaxSpectators());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->memberIsSet())
            {
                IntrusivePtr<PlayerSessionMemberForRead> member = playerSessionPtr->getMember();
                writer.WriteBool(true);

                if (member->playersIsSet())
                {
                    writer.WriteBool(true);

                    IntrusivePtr<Vector<IntrusivePtr<PlayerSessionPlayer> > > players = member->getPlayers();

                    writer.WriteInt32(players->size());

                    for (auto& it : *players)
                    {
                        writer.WriteBool(false);
                        writer.WriteUInt64(it->getAccountId());
                        writer.WriteString(it->getOnlineId().data);
                        writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
                        writer.WriteString(it->getJoinTimestamp().c_str());

                        if (it->customData1IsSet())
                        {
                            writer.WriteBool(true);
                            Binary* binary = it->getCustomData1().get();
                            writer.WriteData((char*)binary->getBinary(), binary->size());
                        }
                        else
                        {
                            writer.WriteBool(false);
                        }
                    }
                }
                else
                {
                    writer.WriteBool(false);
                }

                if (member->spectatorsIsSet())
                {
                    writer.WriteBool(true);

                    IntrusivePtr<Vector<IntrusivePtr<PlayerSessionSpectator> > > spectators = member->getSpectators();

                    writer.WriteInt32(spectators->size());

                    for (auto& it : *spectators)
                    {
                        writer.WriteBool(true);
                        writer.WriteUInt64(it->getAccountId());
                        writer.WriteString(it->getOnlineId().data);
                        writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
                        writer.WriteString(it->getJoinTimestamp().c_str());

                        if (it->customData1IsSet())
                        {
                            writer.WriteBool(true);
                            Binary* binary = it->getCustomData1().get();
                            writer.WriteData((char*)binary->getBinary(), binary->size());
                        }
                        else
                        {
                            writer.WriteBool(false);
                        }
                    }
                }
                else
                {
                    writer.WriteBool(false);
                }
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->joinDisabledIsSet())
            {
                writer.WriteBool(true);
                writer.WriteBool(playerSessionPtr->getJoinDisabled());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->supportedPlatformsIsSet())
            {
                writer.WriteBool(true);

                uint32_t platformFlags = 0;

                IntrusivePtr<Vector<String> > platforms = playerSessionPtr->getSupportedPlatforms();

                for (auto& it : *platforms)
                {
                    platformFlags |= Utils::GetPlatformFlag(it.c_str());
                }

                writer.WriteUInt32(platformFlags);
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->sessionNameIsSet())
            {
                writer.WriteBool(true);
                writer.WriteString(playerSessionPtr->getSessionName().c_str());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->localizedSessionNameIsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<LocalizedString> localizedName = playerSessionPtr->getLocalizedSessionName();

                LocalizedString* ptr = localizedName.get();

                writer.WriteString(ptr->getDefaultLanguage().c_str());

                writer.WriteUInt32(ptr->getLocalizedText().size());

                for (auto& it : ptr->getLocalizedText())
                {
                    const char* locale = it.first.c_str();
                    auto str = it.second.getString();
                    const char* text = str.c_str();

                    writer.WriteString(locale);
                    writer.WriteString(text);
                }
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->leaderIsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<LeaderWithOnlineId> leader = playerSessionPtr->getLeader();
                writer.WriteUInt64(leader->getAccountId());
                writer.WriteUInt32(Utils::GetPlatformFlag(leader->getPlatform().c_str()));
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->joinableUserTypeIsSet())
            {
                writer.WriteBool(true);
                writer.WriteUInt32((UInt32)playerSessionPtr->getJoinableUserType());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->joinableSpecifiedUsersIsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Vector<IntrusivePtr<JoinableUser> > > specifiedUsers = playerSessionPtr->getJoinableSpecifiedUsers();

                writer.WriteUInt32(specifiedUsers.get()->size());

                for (auto& it : *specifiedUsers)
                {
                    writer.WriteUInt64(it.get()->getAccountId());
                }
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->invitableUserTypeIsSet())
            {
                writer.WriteBool(true);
                writer.WriteUInt32((UInt32)playerSessionPtr->getInvitableUserType());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->leaderPrivilegesIsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Vector<String> > privileges = playerSessionPtr->getLeaderPrivileges();

                writer.WriteUInt32(privileges.get()->size());

                for (auto& it : *privileges)
                {
                    writer.WriteString(it.c_str());
                }
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->exclusiveLeaderPrivilegesIsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Vector<String> > excPrivileges = playerSessionPtr->getExclusiveLeaderPrivileges();

                writer.WriteUInt32(excPrivileges.get()->size());

                for (auto& it : *excPrivileges)
                {
                    writer.WriteString(it.c_str());
                }
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->disableSystemUiMenuIsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Vector<String> > disableSystemUI = playerSessionPtr->getDisableSystemUiMenu();

                writer.WriteUInt32(disableSystemUI.get()->size());

                for (auto& it : *disableSystemUI)
                {
                    writer.WriteString(it.c_str());
                }
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->customData1IsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Binary> customData1 = playerSessionPtr->getCustomData1();

                writer.WriteData((const char*)customData1->getBinary(), customData1->size());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->customData2IsSet())
            {
                writer.WriteBool(true);

                IntrusivePtr<Binary> customData2 = playerSessionPtr->getCustomData2();

                writer.WriteData((const char*)customData2->getBinary(), customData2->size());
            }
            else
            {
                writer.WriteBool(false);
            }

            if (playerSessionPtr->swapSupportedIsSet())
            {
                writer.WriteBool(true);
                writer.WriteBool(playerSessionPtr->getSwapSupported());
            }
            else
            {
                writer.WriteBool(false);
            }
        }
    }

    int PlayerSessionCommands::Create(Int32 pushCallbackId, void* creatorCustomData1, int creatorDataSize1, InitializationParams& initParams, BinaryWriter& writer)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        OrderGuaranteedPushEvent* pushEvent = WebApiNotifications::FindOrderedPushEvent(pushCallbackId);

        if (pushEvent == __null)
        {
            return -1;
        }

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(initParams.m_UserId);

        if (userCtx == __null)
        {
            return -1;
        }


        char accountIdBuf[21];
        int ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<PlayerSessionPushContext> playerSessionPushContextPtr;
        ret = PlayerSessionPushContextFactory::create(libContextPtr, pushEvent->GetPushContextIdStr(), &playerSessionPushContextPtr);
        if (ret < 0)
        {
            return ret;
        }

        Vector<IntrusivePtr<PlayerSessionPushContext> > playerSessionPushContexts(libContextPtr);
        ret = playerSessionPushContexts.pushBack(playerSessionPushContextPtr);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<RequestCreatePlayerSessionPlayer> requestCreatePlayerSessionPlayerPtr;
        ret = RequestCreatePlayerSessionPlayerFactory::create(libContextPtr, accountIdBuf, Utils::GetThisPlatformString(), playerSessionPushContexts, &requestCreatePlayerSessionPlayerPtr);
        if (ret < 0)
        {
            return ret;
        }

        if (creatorDataSize1 > 0 && creatorCustomData1 != __null)
        {
            ret = requestCreatePlayerSessionPlayerPtr->setCustomData1(creatorCustomData1, creatorDataSize1);
            if (ret < 0)
            {
                return ret;
            }
        }


        Vector<IntrusivePtr<RequestCreatePlayerSessionPlayer> > requestCreatePlayerSessionPlayers(libContextPtr);
        ret = requestCreatePlayerSessionPlayers.pushBack(requestCreatePlayerSessionPlayerPtr);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<RequestPlayerSessionMemberPlayer> requestPlayerSessionMemberPlayerPtr;
        ret = RequestPlayerSessionMemberPlayerFactory::create(libContextPtr, requestCreatePlayerSessionPlayers, &requestPlayerSessionMemberPlayerPtr);
        if (ret < 0)
        {
            return ret;
        }

        Vector<String> playerSessionSupportedPlatforms(libContextPtr);
        ret = Utils::AddPlatformStrings(initParams.m_PlatformFlags, playerSessionSupportedPlatforms);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<RequestPlayerSession> requestPlayerSessionPtr;
        ret = RequestPlayerSessionFactory::create(libContextPtr, initParams.m_MaxPlayers, requestPlayerSessionMemberPlayerPtr, playerSessionSupportedPlatforms, initParams.m_SessionName.m_LocalizedStringPtr, &requestPlayerSessionPtr);
        if (ret < 0)
        {
            return ret;
        }


        requestPlayerSessionPtr->setMaxSpectators(initParams.m_MaxSpectators);
        requestPlayerSessionPtr->setJoinableUserType(initParams.m_JoinableUserType);
        requestPlayerSessionPtr->setInvitableUserType(initParams.m_InvitableUserType);

        if (initParams.m_LeaderPrivileges != __null && initParams.m_LeaderPrivileges->size() > 0)
        {
            ret = requestPlayerSessionPtr->setLeaderPrivileges(*initParams.m_LeaderPrivileges);
            if (ret < 0)
            {
                return ret;
            }
        }


        if (initParams.m_ExclusiveLeaderPrivileges != __null && initParams.m_ExclusiveLeaderPrivileges->size() > 0)
        {
            ret = requestPlayerSessionPtr->setExclusiveLeaderPrivileges(*initParams.m_ExclusiveLeaderPrivileges);
            if (ret < 0)
            {
                return ret;
            }
        }


        if (initParams.m_DisableSystemUiMenu != __null && initParams.m_DisableSystemUiMenu->size() > 0)
        {
            ret = requestPlayerSessionPtr->setDisableSystemUiMenu(*initParams.m_DisableSystemUiMenu);
            if (ret < 0)
            {
                return ret;
            }
        }


        requestPlayerSessionPtr->setSwapSupported(initParams.m_SwapSupported);
        requestPlayerSessionPtr->setJoinDisabled(initParams.m_JoinDisabled);

        if (initParams.m_CustomDataSize1 > 0)
        {
            ret = requestPlayerSessionPtr->setCustomData1(initParams.m_CustomData1, initParams.m_CustomDataSize1);
            if (ret < 0)
            {
                return ret;
            }
        }

        if (initParams.m_CustomDataSize2 > 0)
        {
            ret = requestPlayerSessionPtr->setCustomData2(initParams.m_CustomData2, initParams.m_CustomDataSize2);
            if (ret < 0)
            {
                return ret;
            }
        }


        Vector<IntrusivePtr<RequestPlayerSession> > requestPlayerSessions(libContextPtr);
        ret = requestPlayerSessions.pushBack(requestPlayerSessionPtr);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<PostPlayerSessionsRequestBody> postPlayerSessionsRequestBodyPtr;
        ret = PostPlayerSessionsRequestBodyFactory::create(libContextPtr, requestPlayerSessions, &postPlayerSessionsRequestBodyPtr);
        if (ret < 0)
        {
            return ret;
        }


        PlayerSessionsApi::ParameterToCreatePlayerSessions param;
        ret = param.initialize(libContextPtr, postPlayerSessionsRequestBodyPtr);
        if (ret < 0)
        {
            return ret;
        }

        typedef Common::IntrusivePtr<PostPlayerSessionsResponseBody> PostPlayerSessionsResponseType;
        PostPlayerSessionsResponseType response;

        Common::Transaction<PostPlayerSessionsResponseType> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::createPlayerSessions(userCtx->GetUserCtxId(), param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        IntrusivePtr<Vector<IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSession> > > playerSessionsPtr = response->getPlayerSessions();

        IntrusivePtr<sce::Np::CppWebApi::SessionManager::V1::PlayerSession>& playerSessionPtr = (*playerSessionsPtr)[0];

        writer.WriteString(playerSessionPtr->getSessionId().c_str());

        Common::IntrusivePtr<ResponsePlayerSessionMemberPlayer> member = playerSessionPtr->getMember();
        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer> > > players = member->getPlayers();

        writer.WriteInt32(players->size());

        for (auto& it : *players)
        {
            writer.WriteUInt64(it->getAccountId());
            writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
        }


        SceNpAccountId accountId = (0);
        sceNpGetAccountIdA(initParams.m_UserId, &accountId);

        writer.WriteUInt64(accountId);

        param.terminate();

        transaction.finish();

        return ret;
    }

    int PlayerSessionCommands::Leave(SceUserServiceUserId userId, const char* sessionId)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            return -1;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            return ret;
        }


        PlayerSessionsApi::ParameterToLeavePlayerSession param;
        ret = param.initialize(libContextPtr, sessionId, accountIdBuf);
        if (ret < 0)
        {
            return ret;
        }

        Common::Transaction<Common::DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::leavePlayerSession(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        Common::DefaultResponse response;
        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        param.terminate();

        transaction.finish();

        return 0;
    }

    int PlayerSessionCommands::JoinAsPlayer(SceUserServiceUserId userId, Int32 pushCallbackId, const char* sessionId, bool swapping, BinaryWriter& writer)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        OrderGuaranteedPushEvent* pushEvent = __null;

        if (swapping == false)
        {
            pushEvent = WebApiNotifications::FindOrderedPushEvent(pushCallbackId);

            if (pushEvent == __null)
            {
                return -1;
            }
        }

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            return -1;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            return ret;
        }



        IntrusivePtr<RequestPlayerSessionPlayer> requestPlayerSessionPlayerPtr;
        ret = RequestPlayerSessionPlayerFactory::create(libContextPtr, accountIdBuf, Utils::GetThisPlatformString(), &requestPlayerSessionPlayerPtr);

        if (ret < 0)
        {
            return ret;
        }


        if (swapping == false)
        {

            IntrusivePtr<PlayerSessionPushContext> playerSessionPushContextPtr;
            ret = PlayerSessionPushContextFactory::create(libContextPtr, pushEvent->GetPushContextIdStr(), &playerSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }


            Vector<IntrusivePtr<PlayerSessionPushContext> > playerSessionPushContexts(libContextPtr);
            ret = playerSessionPushContexts.pushBack(playerSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }


            ret = requestPlayerSessionPlayerPtr->setPushContexts(playerSessionPushContexts);
            if (ret < 0)
            {
                return ret;
            }
        }


        Vector<IntrusivePtr<RequestPlayerSessionPlayer> > requestPlayerSessionPlayers(libContextPtr);
        ret = requestPlayerSessionPlayers.pushBack(requestPlayerSessionPlayerPtr);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<PostPlayerSessionsSessionIdMemberPlayersRequestBody> postPlayerSessionsSessionIdMemberPlayersRequestBody;
        ret = PostPlayerSessionsSessionIdMemberPlayersRequestBodyFactory::create(libContextPtr, requestPlayerSessionPlayers, &postPlayerSessionsSessionIdMemberPlayersRequestBody);
        if (ret < 0)
        {
            return ret;
        }


        PlayerSessionsApi::ParameterToJoinPlayerSessionAsPlayer param;
        ret = param.initialize(libContextPtr, sessionId, postPlayerSessionsSessionIdMemberPlayersRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        typedef Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberPlayersResponseBody> PostPlayerSessionsSessionIdMemberPlayersResponseBody;
        PostPlayerSessionsSessionIdMemberPlayersResponseBody response;

        Common::Transaction<PostPlayerSessionsSessionIdMemberPlayersResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::joinPlayerSessionAsPlayer(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionPlayer> > > players = response->getPlayers();

        writer.WriteInt32(players->size());

        for (auto& it : *players)
        {
            writer.WriteUInt64(it->getAccountId());
            writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
        }

        SceNpAccountId accountId = (0);
        sceNpGetAccountIdA(userId, &accountId);

        writer.WriteUInt64(accountId);

        param.terminate();
        transaction.finish();

        return ret;
    }

    int PlayerSessionCommands::JoinAsSpectator(SceUserServiceUserId userId, Int32 pushCallbackId, const char* sessionId, bool swapping, BinaryWriter& writer)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        OrderGuaranteedPushEvent* pushEvent = __null;

        if (swapping == false)
        {
            pushEvent = WebApiNotifications::FindOrderedPushEvent(pushCallbackId);

            if (pushEvent == __null)
            {
                return -1;
            }
        }

        WebApiUserContext* userCtx = WebApi::Instance()->FindUser(userId);

        if (userCtx == __null)
        {
            return -1;
        }


        char accountIdBuf[21];
        ret = userCtx->GetAccountIdStr(accountIdBuf, sizeof(accountIdBuf));

        if (ret < 0)
        {
            return ret;
        }



        IntrusivePtr<RequestPlayerSessionSpectator> requestPlayerSessionSpectatorPtr;
        ret = RequestPlayerSessionSpectatorFactory::create(libContextPtr, accountIdBuf, Utils::GetThisPlatformString(), &requestPlayerSessionSpectatorPtr);
        if (ret < 0)
        {
            return ret;
        }


        if (swapping == false)
        {

            IntrusivePtr<PlayerSessionPushContext> playerSessionPushContextPtr;
            ret = PlayerSessionPushContextFactory::create(libContextPtr, pushEvent->GetPushContextIdStr(), &playerSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }


            Vector<IntrusivePtr<PlayerSessionPushContext> > playerSessionPushContexts(libContextPtr);
            ret = playerSessionPushContexts.pushBack(playerSessionPushContextPtr);
            if (ret < 0)
            {
                return ret;
            }


            ret = requestPlayerSessionSpectatorPtr->setPushContexts(playerSessionPushContexts);
            if (ret < 0)
            {
                return ret;
            }
        }


        Vector<IntrusivePtr<RequestPlayerSessionSpectator> > requestPlayerSessionSpectators(libContextPtr);
        ret = requestPlayerSessionSpectators.pushBack(requestPlayerSessionSpectatorPtr);
        if (ret < 0)
        {
            return ret;
        }


        IntrusivePtr<PostPlayerSessionsSessionIdMemberSpectatorsRequestBody> postPlayerSessionsSessionIdMemberSpectatorsRequestBody;
        ret = PostPlayerSessionsSessionIdMemberSpectatorsRequestBodyFactory::create(libContextPtr, requestPlayerSessionSpectators, &postPlayerSessionsSessionIdMemberSpectatorsRequestBody);
        if (ret < 0)
        {
            return ret;
        }


        PlayerSessionsApi::ParameterToJoinPlayerSessionAsSpectator param;
        ret = param.initialize(libContextPtr, sessionId, postPlayerSessionsSessionIdMemberSpectatorsRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        typedef Common::IntrusivePtr<PostPlayerSessionsSessionIdMemberSpectatorsResponseBody> PostPlayerSessionsSessionIdMemberSpectatorsResponseBody;
        PostPlayerSessionsSessionIdMemberSpectatorsResponseBody response;

        Common::Transaction<PostPlayerSessionsSessionIdMemberSpectatorsResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::joinPlayerSessionAsSpectator(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<ResponsePlayerSessionSpectator> > > spectators = response->getSpectators();

        writer.WriteInt32(spectators->size());

        for (auto& it : *spectators)
        {
            writer.WriteUInt64(it->getAccountId());
            writer.WriteUInt32(Utils::GetPlatformFlag(it->getPlatform().c_str()));
        }

        SceNpAccountId accountId = (0);
        sceNpGetAccountIdA(userId, &accountId);

        writer.WriteUInt64(accountId);

        param.terminate();
        transaction.finish();

        return ret;
    }

    int PlayerSessionCommands::SetPlayerSessionProps(WebApiUserContext* userCtx, const char* sessionId, BinaryReader& reader)
    {
        int ret = 0;

        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        IntrusivePtr<PatchPlayerSessionsSessionIdRequestBody> patchPlayerSessionsSessionIdRequestBody;
        ret = PatchPlayerSessionsSessionIdRequestBodyFactory::create(libContextPtr, &patchPlayerSessionsSessionIdRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        bool isSetMaxPlayers = reader.ReadBool();
        if (isSetMaxPlayers)
        {
            UInt32 maxPlayers = reader.ReadUInt32();
            patchPlayerSessionsSessionIdRequestBody->setMaxPlayers(maxPlayers);
        }

        bool isSetMaxSpectators = reader.ReadBool();
        if (isSetMaxSpectators)
        {
            UInt32 maxSpectators = reader.ReadUInt32();
            patchPlayerSessionsSessionIdRequestBody->setMaxSpectators(maxSpectators);
        }

        bool isSetJoinDisabled = reader.ReadBool();
        if (isSetJoinDisabled)
        {
            bool joinDisabled = reader.ReadBool();
            patchPlayerSessionsSessionIdRequestBody->setJoinDisabled(joinDisabled);
        }

        bool isSetJoinableUserType = reader.ReadBool();
        if (isSetJoinableUserType)
        {
# 2252 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\PlayerSession.cpp"
            CustomJoinableUserType jut = (CustomJoinableUserType)reader.ReadUInt32();
            patchPlayerSessionsSessionIdRequestBody->setJoinableUserType(jut);
        }

        bool isSetInvitableUserType = reader.ReadBool();
        if (isSetInvitableUserType)
        {
            CustomInvitableUserType iut = (CustomInvitableUserType)reader.ReadUInt32();
            patchPlayerSessionsSessionIdRequestBody->setInvitableUserType(iut);
        }

        bool isSetLocalizedSessionName = reader.ReadBool();
        if (isSetLocalizedSessionName)
        {
            LocalisedStrings sessionName;
            ret = sessionName.Deserialise(reader);
            if (ret < 0)
            {
                return ret;
            }

            ret = patchPlayerSessionsSessionIdRequestBody->setLocalizedSessionName(sessionName.m_LocalizedStringPtr);
            if (ret < 0)
            {
                return ret;
            }
        }

        bool isSetLeaderPrivileges = reader.ReadBool();
        if (isSetLeaderPrivileges)
        {
            Vector<String> leaderPrivileges(libContextPtr);
            ret = PlayerSessionCommands::DeserialiseLeaderPrivileges(reader, &leaderPrivileges);
            if (ret < 0)
            {
                return ret;
            }

            ret = patchPlayerSessionsSessionIdRequestBody->setLeaderPrivileges(leaderPrivileges);
            if (ret < 0)
            {
                return ret;
            }
        }

        bool isSetExclusiveLeaderPrivileges = reader.ReadBool();
        if (isSetExclusiveLeaderPrivileges)
        {
            Vector<String> exclusiveLeaderPrivileges(libContextPtr);
            ret = PlayerSessionCommands::DeserialiseLeaderPrivileges(reader, &exclusiveLeaderPrivileges);

            if (ret < 0)
            {
                return ret;
            }

            ret = patchPlayerSessionsSessionIdRequestBody->setExclusiveLeaderPrivileges(exclusiveLeaderPrivileges);
            if (ret < 0)
            {
                return ret;
            }
        }


        bool isSetDisableSystemUiMenu = reader.ReadBool();

        if (isSetDisableSystemUiMenu)
        {
            Vector<String> disableSystemUiMenu(libContextPtr);
            ret = PlayerSessionCommands::DeserialiseLeaderPrivileges(reader, &disableSystemUiMenu);

            if (ret < 0)
            {
                return ret;
            }

            ret = patchPlayerSessionsSessionIdRequestBody->setDisableSystemUiMenu(disableSystemUiMenu);
            if (ret < 0)
            {
                return ret;
            }
        }

        bool isSetCustomData1 = reader.ReadBool();
        if (isSetCustomData1)
        {
            int dataSize = reader.ReadInt32();
            void* data = reader.ReadDataPtr(dataSize);

            int ret = patchPlayerSessionsSessionIdRequestBody->setCustomData1(data, dataSize);
            if (ret < 0)
            {
                return ret;
            }
        }

        bool isSetCustomData2 = reader.ReadBool();
        if (isSetCustomData2)
        {
            int dataSize = reader.ReadInt32();
            void* data = reader.ReadDataPtr(dataSize);

            int ret = patchPlayerSessionsSessionIdRequestBody->setCustomData2(data, dataSize);
            if (ret < 0)
            {
                return ret;
            }
        }

        bool isSetSwapSupported = reader.ReadBool();
        if (isSetSwapSupported)
        {
            bool swapSupported = reader.ReadBool();
            patchPlayerSessionsSessionIdRequestBody->setSwapSupported(swapSupported);
        }

        PlayerSessionsApi::ParameterToSetPlayerSessionProperties param;
        ret = param.initialize(libContextPtr, sessionId, patchPlayerSessionsSessionIdRequestBody);
        if (ret < 0)
        {
            return ret;
        }

        DefaultResponse response;

        Common::Transaction<DefaultResponse> transaction;
        transaction.start(libContextPtr);


        ret = PlayerSessionsApi::setPlayerSessionProperties(userCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            return ret;
        }

        param.terminate();
        transaction.finish();

        return 0;
    }
}
# 24 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp" 1



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnetctl.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnetctl.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnetctl_error.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnetctl.h" 2 3
# 94 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnetctl.h" 3
typedef void (*SceNetCtlCallback)(
 int eventType,
 void *arg
 );

typedef struct SceNetCtlIpv6Addr {
 char address[46];
 uint8_t prefix_len;
} SceNetCtlIpv6Addr;

typedef union SceNetCtlInfo {
 uint32_t device;
 SceNetEtherAddr ether_addr;
 uint32_t mtu;
 uint32_t link;
 SceNetEtherAddr bssid;
 char ssid[(32 + 1)];
 uint32_t wifi_security;
 int32_t rssi_dbm;
 uint8_t rssi_percentage;
 uint8_t channel;
 uint32_t ip_config;
 char dhcp_hostname[(255 + 1)];
 char pppoe_auth_name[(127 + 1)];
 char ip_address[(16)];
 char netmask[(16)];
 char default_route[(16)];
 char primary_dns[(16)];
 char secondary_dns[(16)];
 uint32_t http_proxy_config;
 char http_proxy_server[(255 + 1)];
 uint16_t http_proxy_port;
} SceNetCtlInfo;

typedef union SceNetCtlInfoV6 {
 SceNetCtlIpv6Addr ip_address;
 SceNetCtlIpv6Addr link_local_address;
 char default_route[46];
 char primary_dns[46];
 char secondary_dns[46];
 uint8_t reserved[256];
} SceNetCtlInfoV6;

typedef struct SceNetCtlIfStat {
 uint32_t device;
 uint64_t txBytes;
 uint64_t rxBytes;
 uint32_t reserved[8];
} SceNetCtlIfStat;

typedef struct SceNetCtlNatInfo {
 unsigned int size;
 int stunStatus;
 int natType;
 SceNetInAddr mappedAddr;
} SceNetCtlNatInfo;
# 161 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libnetctl.h" 3
extern "C" {



int
sceNetCtlInit(
 void
 );

void
sceNetCtlTerm(
 void
 );

int
sceNetCtlCheckCallback(
 void
 );



int
sceNetCtlRegisterCallback(
 SceNetCtlCallback func,
 void *arg,
 int *cid
 );



int
sceNetCtlRegisterCallbackV6(
 SceNetCtlCallback func,
 void *arg,
 int *cid
);

int
sceNetCtlUnregisterCallback(
 int cid
 );

int
sceNetCtlUnregisterCallbackV6(
 int cid
);

int
sceNetCtlGetResult(
 int eventType,
 int *errorCode
 );

int
sceNetCtlGetResultV6(
 int eventType,
 int *errorCode
);

int
sceNetCtlGetState(
 int *state
 );

int
sceNetCtlGetStateV6(
 int *state
);

int
sceNetCtlGetInfo(
 int code,
 SceNetCtlInfo *info
 );

int
sceNetCtlGetInfoV6(
 int code,
 SceNetCtlInfoV6 *info
);

int
sceNetCtlGetIfStat(
 SceNetCtlIfStat *ifStat
 );

int
sceNetCtlGetNatInfo(
 SceNetCtlNatInfo *natInfo
 );


}
# 5 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp" 2


#pragma comment(lib,"libSceNpSessionSignaling_stub_weak.a")

namespace psn
{
    std::list<SessionSignalling::SignallingEvent> SessionSignalling::s_PendingSignallingEventsList;

    std::map<SceNpSessionSignalingContextId, SessionSignalling::ActiveContext*> SessionSignalling::s_ActiveCtxList;

    void SessionSignalling::AddContext(SessionSignalling::ActiveContext* ctx)
    {
        s_ActiveCtxList.insert(std::pair<SceUserServiceUserId, ActiveContext*>(ctx->m_ctxId, ctx));
    }

    void SessionSignalling::RemoveContext(SessionSignalling::ActiveContext* ctx)
    {
        s_ActiveCtxList.erase(ctx->m_ctxId);
    }

    SessionSignalling::ActiveContext* SessionSignalling::FindContext(SceNpSessionSignalingContextId ctxId)
    {
        auto it = s_ActiveCtxList.find(ctxId);

        if (it == s_ActiveCtxList.end())
        {
            return __null;
        }

        return it->second;
    }

    SessionSignalling::ActiveContext* SessionSignalling::FindContext(Int32 userId)
    {
        for (auto it = s_ActiveCtxList.begin(); it != s_ActiveCtxList.end(); it++)
        {
            if (it->second != __null && it->second->m_userId == userId)
            {
                return it->second;
            }
        }

        return __null;
    }

    void SessionSignalling::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::FetchSignallingEvent, SessionSignalling::FetchSignallingEventImpl);
        MsgHandler::AddMethod(Methods::UserToUserSignalling, SessionSignalling::UserToUserSignallingImpl);
        MsgHandler::AddMethod(Methods::ActivateUser, SessionSignalling::ActivateUserImpl);
        MsgHandler::AddMethod(Methods::Deactivate, SessionSignalling::DeactivateImpl);
        MsgHandler::AddMethod(Methods::GetLocalNetInfo, SessionSignalling::GetLocalNetInfoImpl);
        MsgHandler::AddMethod(Methods::GetNatRouterInfo, SessionSignalling::GetNatRouterInfoImpl);
        MsgHandler::AddMethod(Methods::GetConnectionStatus, SessionSignalling::GetConnectionStatusImpl);
        MsgHandler::AddMethod(Methods::GetConnectionInfo, SessionSignalling::GetConnectionInfoImpl);
        MsgHandler::AddMethod(Methods::CreateUserContext, SessionSignalling::CreateUserContextImpl);
        MsgHandler::AddMethod(Methods::DestroyUserContext, SessionSignalling::DestroyUserContextImpl);
        MsgHandler::AddMethod(Methods::ActivateSession, SessionSignalling::ActivateSessionImpl);
    }

    int SessionSignalling::InitializeLib(int32_t libhttp2CtxId)
    {

        SceNpSessionSignalingInitParam initParam;
        initParam.libhttp2CtxId = libhttp2CtxId;
        initParam.poolSize = (512 * 1024);
        initParam.cpuAffinityMask = 0;
        initParam.threadPriority = 700;
        initParam.threadStackSize = (32 * 1024);

        return sceNpSessionSignalingInitialize(&initParam);
    }

    int SessionSignalling::TerminateLib()
    {
        return sceNpSessionSignalingTerminate();
    }
# 122 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp"
    void SessionSignalling::SignallingEvent::Init()
    {
        type = Request;

        userId = 0;

        ctxId = (0);
        errorCode = 0;

        id = (0);
        eventDesc = -1;

        grpIdForConnectionEvent = (0);
    }

    void SessionSignalling::FetchSignallingEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        if (s_PendingSignallingEventsList.empty() == true)
        {
            *resultsSize = 0;
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
            return;
        }


        SignallingEvent event = s_PendingSignallingEventsList.front();
        s_PendingSignallingEventsList.pop_front();


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(event.type);

        writer.WriteInt32(event.userId);
        writer.WriteUInt32(event.ctxId);
        writer.WriteInt32(event.errorCode);

        writer.WriteUInt32(event.id);
        writer.WriteInt32(event.eventDesc);

        if (event.type == SignallingEvent::EventType::Group && event.eventDesc == SCE_NP_SESSION_SIGNALING_GROUP_EVENT_PEER_ACTIVATED && event.errorCode == 0)
        {
            writer.WriteUInt64(event.peerActivatedData.accountId);
            writer.WriteInt32(event.peerActivatedData.platform);
        }

        if (event.type == SignallingEvent::EventType::Connection)
        {
            writer.WriteUInt32(event.grpIdForConnectionEvent);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::RequestCallback(SceNpSessionSignalingContextId ctxId, SceNpSessionSignalingRequestId reqId, SceNpSessionSignalingRequestEvent event, const void* eventData, int errorCode, void* arg)
    {


        SignallingEvent sEvent;

        sEvent.Init();

        SessionSignalling::ActiveContext* activeContext = SessionSignalling::FindContext(ctxId);
        if (activeContext != __null)
        {
            sEvent.userId = activeContext->m_userId;
        }

        sEvent.type = SignallingEvent::Request;

        sEvent.ctxId = ctxId;
        sEvent.errorCode = errorCode;

        sEvent.id = reqId;
        sEvent.eventDesc = event;

        s_PendingSignallingEventsList.push_back(sEvent);
    }

    void SessionSignalling::GroupCallback(SceNpSessionSignalingContextId ctxId, SceNpSessionSignalingGroupId grpId, SceNpSessionSignalingGroupEvent event, const void* eventData, int errorCode, void* arg)
    {


        SignallingEvent sEvent;

        sEvent.Init();

        SessionSignalling::ActiveContext* activeContext = SessionSignalling::FindContext(ctxId);
        if (activeContext != __null)
        {
            sEvent.userId = activeContext->m_userId;
        }

        sEvent.type = SignallingEvent::Group;

        sEvent.ctxId = ctxId;
        sEvent.errorCode = errorCode;

        sEvent.id = grpId;
        sEvent.eventDesc = event;

        if (event == SCE_NP_SESSION_SIGNALING_GROUP_EVENT_PEER_ACTIVATED && errorCode == 0)
        {
            memcpy(&sEvent.peerActivatedData, eventData, sizeof(sEvent.peerActivatedData));
        }

        s_PendingSignallingEventsList.push_back(sEvent);
    }


    void SessionSignalling::ConnectionCallback(SceNpSessionSignalingContextId ctxId, SceNpSessionSignalingGroupId grpId, SceNpSessionSignalingConnectionId connId, SceNpSessionSignalingConnectionEvent event, int errorCode, void* arg)



    {


        SignallingEvent sEvent;

        sEvent.Init();

        SessionSignalling::ActiveContext* activeContext = SessionSignalling::FindContext(ctxId);
        if (activeContext != __null)
        {
            sEvent.userId = activeContext->m_userId;
        }

        sEvent.type = SignallingEvent::Connection;

        sEvent.ctxId = ctxId;
        sEvent.errorCode = errorCode;

        sEvent.id = connId;
        sEvent.eventDesc = event;


        sEvent.grpIdForConnectionEvent = grpId;


        s_PendingSignallingEventsList.push_back(sEvent);
    }

    void SessionSignalling::CreateUserContextImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();


        SceNpSessionSignalingCreateContext2Param createCtxParam;
        createCtxParam.userId = userId;
        createCtxParam.serviceLabel = 0;
        createCtxParam.reqCbFunc = RequestCallback;
        createCtxParam.reqCbArg = __null;
        createCtxParam.grpCbFunc = GroupCallback;
        createCtxParam.grpCbArg = __null;
        createCtxParam.connCbFunc = ConnectionCallback;
        createCtxParam.connCbArg = __null;

        SceNpSessionSignalingContextId ctxId;

        ret = sceNpSessionSignalingCreateContext2(&createCtxParam, &ctxId);
# 305 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp"
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 307));
            return;
        }

        ActiveContext* newCtx = new ActiveContext();
        newCtx->m_ctxId = ctxId;
        newCtx->m_userId = userId;

        AddContext(newCtx);

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteUInt32(ctxId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::DestroyUserContextImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNpSessionSignalingContextId ctxId = reader.ReadUInt32();

        ret = sceNpSessionSignalingDestroyContext(ctxId);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 339));
            return;
        }

        ActiveContext* activeCtx = FindContext(ctxId);
        if (activeCtx != __null)
        {
            RemoveContext(activeCtx);
            delete activeCtx;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::UserToUserSignallingImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNpSessionSignalingContextId ctxId = reader.ReadUInt32();

        SceNpSessionSignalingRequestId reqId = (0);

        ret = sceNpSessionSignalingRequestPrepare(ctxId, &reqId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 367));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteUInt32(reqId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::ActivateUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNpSessionSignalingContextId ctxId = reader.ReadUInt32();

        SceNpPeerAddressA peerAddrA;

        memset(&peerAddrA, 0, sizeof(peerAddrA));
        peerAddrA.accountId = reader.ReadUInt64();
        peerAddrA.platform = reader.ReadInt32();

        SceNpSessionSignalingRequestId grpId = (0);

        ret = sceNpSessionSignalingActivateUser(ctxId, &peerAddrA, &grpId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 400));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteUInt32(grpId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::ActivateSessionImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNpSessionSignalingContextId ctxId = reader.ReadUInt32();

        char* sessionId = reader.ReadStringPtr();

        SceNpSessionSignalingSessionType sessionType = (SceNpSessionSignalingSessionType)reader.ReadInt32();

        SceNpSessionSignalingTopologyType topology = (SceNpSessionSignalingTopologyType)reader.ReadInt32();

        SceNpSessionSignalingHostType host = (SceNpSessionSignalingHostType)reader.ReadInt32();

        SceNpSessionSignalingSessionOptParam params;
        params.topologyType = topology;
        params.hostType = host;

        SceNpSessionSignalingRequestId grpId = (0);

        ret = sceNpSessionSignalingActivateSession(ctxId, sessionId, sessionType, &params, &grpId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 439));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteUInt32(grpId);
        writer.WriteInt32(params.topologyType);
        writer.WriteInt32(params.hostType);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::DeactivateImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNpSessionSignalingContextId ctxId = reader.ReadUInt32();

        UInt32 grpId = reader.ReadUInt32();

        ret = sceNpSessionSignalingDeactivate(ctxId, grpId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 468));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::GetLocalNetInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNpSessionSignalingContextId ctxId = reader.ReadUInt32();

        SceNpSessionSignalingNetInfo localNetInfo;
        ret = sceNpSessionSignalingGetLocalNetInfo(ctxId, &localNetInfo);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 488));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteUInt32(localNetInfo.localAddr.s_addr);
        writer.WriteUInt32(localNetInfo.mappedAddr.s_addr);
        writer.WriteInt32(localNetInfo.natStatus);

        char buf1[32];
        char buf2[32];
        sceNetInetNtop(2, &localNetInfo.localAddr.s_addr, buf1, sizeof(buf1));
        sceNetInetNtop(2, &localNetInfo.mappedAddr.s_addr, buf2, sizeof(buf2));

        writer.WriteString(buf1);
        writer.WriteString(buf2);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::GetNatRouterInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;
        int ret = 0;
        SceNetCtlNatInfo natRouterInfo;
        memset(&natRouterInfo, 0, sizeof(natRouterInfo));
        natRouterInfo.size = sizeof(natRouterInfo);

        ret = sceNetCtlGetNatInfo(&natRouterInfo);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 522));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(natRouterInfo.stunStatus);
        writer.WriteInt32(natRouterInfo.natType);
        writer.WriteUInt32(natRouterInfo.mappedAddr.s_addr);

        char buf1[32];
        sceNetInetNtop(2, &natRouterInfo.mappedAddr.s_addr, buf1, sizeof(buf1));

        writer.WriteString(buf1);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::GetConnectionStatusImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);


        SceNpSessionSignalingContextId ctxId = reader.ReadUInt32();
        SceNpSessionSignalingConnectionId connId = reader.ReadUInt32();

        SceNpSessionSignalingConnectionStatus connStatus;
        SceNetInAddr peerAddr;
        SceNetInPort_t peerPort;

        ret = sceNpSessionSignalingGetConnectionStatus(ctxId, connId, &connStatus, &peerAddr, &peerPort);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 560));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(connStatus);
        writer.WriteUInt32(peerAddr.s_addr);

        char buf1[32];
        sceNetInetNtop(2, &peerAddr.s_addr, buf1, sizeof(buf1));
        writer.WriteString(buf1);

        writer.WriteUInt16(sceNetNtohs(peerPort));

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void SessionSignalling::GetConnectionInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);


        SceNpSessionSignalingContextId ctxId = reader.ReadUInt32();
        SceNpSessionSignalingConnectionId connId = reader.ReadUInt32();
        SceNpSessionSignalingConnectionInfoCode code = (SceNpSessionSignalingConnectionInfoCode)reader.ReadInt32();

        SceNpSessionSignalingConnectionInfo connInfo;
        ret = sceNpSessionSignalingGetConnectionInfo(ctxId, connId, code, &connInfo);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionSignalling.cpp", 596));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);







        writer.WriteInt32(code);

        if (code == SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_RTT)
        {
            writer.WriteUInt32(connInfo.rtt);
        }
        else if (code == SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_PEER_ADDRESS)
        {
            writer.WriteUInt64(connInfo.peerAddrA.accountId);
            writer.WriteInt32(connInfo.peerAddrA.platform);
        }
        else if (code == SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_NET_ADDRESS || code == SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_MAPPED_ADDRESS)
        {
            writer.WriteUInt32(connInfo.address.addr.s_addr);

            char buf1[32];
            sceNetInetNtop(2, &connInfo.address.addr.s_addr, buf1, sizeof(buf1));
            writer.WriteString(buf1);

            writer.WriteUInt16(sceNetNtohs(connInfo.address.port));
        }
        else if (code == SCE_NP_SESSION_SIGNALING_CONNECTION_INFO_PACKET_LOSS)
        {
            writer.WriteUInt32(connInfo.packetLoss);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 25 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\SessionsManager.cpp" 1







namespace psn
{
    void SessionsManager::RegisterMethods()
    {
        PlayerSessionCommands::RegisterMethods();
        GameSessionCommands::RegisterMethods();
        MatchesCommands::RegisterMethods();
        MatchMakingSystem::RegisterMethods();
    }

    void SessionsManager::InitializeLib()
    {
    }

    void SessionsManager::TerminateLib()
    {
    }
}
# 26 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Sockets.cpp" 1







namespace psn
{
    void Sockets::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::SetupUdpP2PSocket, Sockets::SetupUdpP2PSocketImpl);
        MsgHandler::AddMethod(Methods::TerminateSocket, Sockets::TerminateSocketImpl);
        MsgHandler::AddMethod(Methods::SendTo, Sockets::SendToImpl);
        MsgHandler::AddMethod(Methods::RecvThreadUpdate, Sockets::RecvThreadUpdateImpl);
    }

    void Sockets::SetupUdpP2PSocketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        char* socketName = reader.ReadStringPtr();
        UInt16 virtualPort = reader.ReadUInt16();

        SceNetInAddr addr;
        addr.s_addr = reader.ReadUInt32();

        ret = sceNetSocket(socketName, 2, 6, 0);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Sockets.cpp", 34));
            return;
        }

        const SceNetId socket = ret;

        SceNetSockaddrIn sinaddr;
        memset(&sinaddr, 0, sizeof(sinaddr));

        sinaddr.sin_family = 2;
        sinaddr.sin_len = sizeof(sinaddr);
        sinaddr.sin_port = sceNetHtons((3658));
        sinaddr.sin_vport = sceNetHtons(virtualPort);

        if (addr.s_addr != 0)
        {
            sinaddr.sin_addr.s_addr = addr.s_addr;
        }

        ret = sceNetBind(socket, (struct SceNetSockaddr*)&sinaddr, sizeof(sinaddr));
        if (ret < 0)
        {
            sceNetSocketClose(socket);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Sockets.cpp", 57));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(socket);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Sockets::TerminateSocketImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNetId netId = reader.ReadInt32();

        sceNetSocketAbort(netId, 0);

        ret = sceNetSocketClose(netId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Sockets.cpp", 84));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Sockets::SendToImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNetId netId = reader.ReadInt32();

        int dataSize = reader.ReadInt32();
        void* data = reader.ReadDataPtr(dataSize);

        UInt16 recvVirtualPort = reader.ReadUInt16();

        UInt32 sendToAddr = reader.ReadUInt32();
        UInt16 sendToPort = reader.ReadUInt16();

        bool encrypt = reader.ReadBool();

        SceNetSockaddrIn sin;
        memset(&sin, 0, sizeof(sin));
        sin.sin_len = sizeof(sin);
        sin.sin_family = 2;
        sin.sin_vport = sceNetHtons(recvVirtualPort);

        sin.sin_addr.s_addr = sendToAddr;
        sin.sin_port = sceNetHtons(sendToPort);

        int flags = 0;
        if (encrypt == true)
        {
            flags |= 0x00100000;
        }

        ret = sceNetSendto(netId, data, dataSize, flags, (SceNetSockaddr*)&sin, sizeof(sin));
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Sockets.cpp", 128));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void Sockets::RecvThreadUpdateImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        SceNetId netId = reader.ReadUInt32();
        UInt32 maxReceiveSize = reader.ReadUInt32();

        std::vector<char> payload(maxReceiveSize);

        SceNetSockaddrIn sin;
        memset(&sin, 0, sizeof(sin));
        SceSize len = sizeof(sin);

        ret = sceNetRecvfrom(netId, &payload[0], maxReceiveSize, 0x00000080, (SceNetSockaddr*)&sin, (SceNetSocklen_t*)&len);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Sockets.cpp", 154));
            return;
        }

        int dataLen = ret;

        if (dataLen > maxReceiveSize)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "RecvThreadUpdate has received more data than expected", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Sockets.cpp", 162));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        if (dataLen > 0)
        {
            writer.WriteBool(true);
            writer.WriteData(&payload[0], dataLen);

            writer.WriteUInt32(sin.sin_addr.s_addr);
            writer.WriteUInt16(sceNetNtohs(sin.sin_port));
            writer.WriteUInt16(sceNetNtohs(sin.sin_vport));
        }
        else
        {
            writer.WriteBool(false);
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 27 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp" 1




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\istream" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\istream" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ios" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ios" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocnum" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocnum" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cctype" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cctype" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cctype" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 2 3
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 3
extern "C" {
typedef const short *_Ctype_t;

_Ctype_t _Getpctype(void);
_Ctype_t _Getptolower(void);
_Ctype_t _Getptoupper(void);
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 3
}



extern "C" {
inline int isalnum(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x20|0x10|0x02|0x200));
 }

inline int isalpha(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x10|0x02|0x200));
 }

inline int iscntrl(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x80);
 }

inline int isdigit(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x20);
 }

inline int isgraph(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x20|0x10|0x08|0x02|0x200));
 }

inline int islower(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x10);
 }

inline int isprint(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x20|0x10|0x08|0x04|0x02|0x200));
 }

inline int ispunct(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x08);
 }

inline int _Isspace(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x40|0x04|0x100));
 }

inline int isspace(int _Ch)
 {
 return (_Isspace(_Ch));
 }

inline int isupper(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x02);
 }

inline int isxdigit(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x01);
 }


inline int isblank(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x04|0x400));
 }


inline int tolower(int _Ch)
 {
 return __extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getptolower()[_Tmp] : _Tmp; });
 }

inline int toupper(int _Ch)
 {
 return __extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getptoupper()[_Tmp] : _Tmp; });
 }
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cctype" 2 3



namespace std {
using :: isalnum; using :: isalpha; using :: iscntrl;
using :: isdigit; using :: isgraph; using :: islower;
using :: isprint; using :: ispunct; using :: isspace;
using :: isupper; using :: isxdigit; using :: tolower;
using :: toupper; using :: _Isspace;

using :: isblank;







}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\clocale" 1 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 5 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\clocale" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\locale.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\locale.h" 2 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\locale.h" 3
struct lconv
 {

 char *currency_symbol;
 char *int_curr_symbol;
 char *mon_decimal_point;
 char *mon_grouping;
 char *mon_thousands_sep;
 char *negative_sign;
 char *positive_sign;

 char frac_digits;
 char n_cs_precedes;
 char n_sep_by_space;
 char n_sign_posn;
 char p_cs_precedes;
 char p_sep_by_space;
 char p_sign_posn;

 char int_frac_digits;

 char int_n_cs_precedes;
 char int_n_sep_by_space;
 char int_n_sign_posn;
 char int_p_cs_precedes;
 char int_p_sep_by_space;
 char int_p_sign_posn;
 short :16;



 char *decimal_point;
 char *grouping;
 char *thousands_sep;
 char *_Frac_grouping;
 char *_Frac_sep;
 char *_False;
 char *_True;


 char *_No;
 char *_Yes;
 };

struct _Linfo;


extern "C" {
struct lconv *localeconv(void);
char *setlocale(int, const char *);
extern struct lconv __thread _Locale;
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\clocale" 2 3



namespace std {
using :: lconv; using :: localeconv; using :: setlocale;
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 2 3
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 32 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 2 3
# 108 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 3
namespace std {
using :: clock_t; using :: size_t;
using :: time_t; using :: tm;
using :: asctime; using :: clock; using :: ctime;
using :: timespec;
# 123 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 3
using :: difftime; using :: gmtime; using :: localtime;


using :: mktime; using :: strftime; using :: time;
using :: timespec_get;
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstrxfrm.h" 1 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstate.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstate.h" 2 3
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstate.h" 3
typedef struct
 {
 const unsigned short *_Tab[16];
 } _Statab;
# 6 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstrxfrm.h" 2 3


typedef struct Xfrm {
 const unsigned char *sbegin;
 const unsigned char *sin;
 const unsigned char *send;
 long weight;
 unsigned short phase, state, wc;
 } Xfrm;


extern "C" {
int _Strcollx(const char *, const char *, _Statab *);
size_t _Strxfrmx(char *, const char *, size_t, _Statab *);

size_t _CStrxfrm(char *, size_t, Xfrm *, _Statab *);
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtinfo.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtinfo.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtinfo.h" 2 3



typedef struct
 {
 const char *_Am_pm;
 const char *_Days;
  const char *_Abday;
  const char *_Day;
 const char *_Months;
  const char *_Abmon;
  const char *_Mon;
 const char *_Formats;
  const char *_D_t_fmt;
  const char *_D_fmt;
  const char *_T_fmt;
  const char *_T_fmt_ampm;
 const char *_Era_Formats;
  const char *_Era_D_t_fmt;
  const char *_Era_D_fmt;
  const char *_Era_T_fmt;
  const char *_Era_T_fmt_ampm;
 const char *_Era;
 const char *_Alt_digits;
 const char *_Isdst;
 const char *_Tzone;
 } _Tinfo;


extern "C" {
size_t _CStrftime(char *, size_t, const char *,
 const struct tm *, const _Tinfo *);
_Tinfo *_Getptimes(void);
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcsxfrm.h" 1 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwchar.h" 1 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 1 3
# 5 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwchar.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 2 3
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 3
typedef _Sizet wctrans_t;




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcc.h" 1 3




extern "C" {
int _Iswctype(wint_t, wctype_t);
wint_t _Towctrans(wint_t, wctrans_t);

}



extern "C" {
inline int iswalnum(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 1));
 }

inline int iswalpha(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 2));
 }

inline int iswcntrl(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 3));
 }

inline int iswctype(wint_t _Wc, wctype_t _Off)
 {
 return (_Iswctype(_Wc, _Off));
 }

inline int iswdigit(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 4));
 }

inline int iswgraph(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 5));
 }

inline int iswlower(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 6));
 }

inline int iswprint(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 7));
 }

inline int iswpunct(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 8));
 }

inline int iswspace(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 9));
 }

inline int iswupper(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 10));
 }

inline int iswxdigit(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 11));
 }

inline wint_t towlower(wint_t _Wc)
 {
 return (_Towctrans(_Wc, 1));
 }

inline wint_t towupper(wint_t _Wc)
 {
 return (_Towctrans(_Wc, 2));
 }


inline int iswblank(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 12));
 }


}
# 33 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 2 3

extern "C" {
wctrans_t wctrans(const char *);
wctype_t wctype(const char *);
}



extern "C" {
inline wint_t (towctrans)(wint_t _Wc, wctrans_t _Off)
 {
 return (_Towctrans(_Wc, _Off));
 }
}
# 6 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwchar.h" 2 3



extern "C" {

int _Mbtowc(wchar_t *, const char *, size_t, mbstate_t *);
size_t _Wcsftime(wchar_t *, size_t, const char *, size_t,
 const struct tm *);
int _Wctomb(char *, wchar_t, mbstate_t *);
long double _WStold(const wchar_t *, wchar_t **, long);
_Longlong _WStoll(const wchar_t *, wchar_t **, int);
unsigned long _WStoul(const wchar_t *, wchar_t **, int);
_ULonglong _WStoull(const wchar_t *, wchar_t **, int);

int _Mbtowcx(wchar_t *, const char *, size_t, mbstate_t *,
 _Statab *);
int _Wctombx(char *, wchar_t, mbstate_t *,
 _Statab *, _Statab *);

_Statab *_Getpmbstate(void);
_Statab *_Getpwcstate(void);
_Statab *_Getpcostate(void);
_Statab *_Getpwcostate(void);
}
# 6 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcsxfrm.h" 2 3


extern "C" {
int _Wcscollx(const wchar_t *,
 const wchar_t *, _Statab *);
size_t _Wcsxfrmx(wchar_t *,
 const wchar_t *, size_t, _Statab *);

size_t _CWcsxfrm(wchar_t *, const wchar_t **, size_t,
 mbstate_t *, _Statab *);
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 3
namespace std {
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 3
struct _Collvec
 {
 :: _Statab *_Costate;
 :: _Statab *_WCostate;
 };


struct _Ctypevec
 {
 const short *_Table;
 const short *_Tolotab;
 const short *_Touptab;
 int _Delfl;
 int :32;
 };


struct _Cvtvec
 {
 :: _Statab *_Mbstate;
 :: _Statab *_Wcstate;
 };


class _Timevec
 {
public:
 _Timevec()
  : _Timestuff(*:: _Getptimes())
  {
  }

 const void *_Getptr() const
  {
  return ((const void *)&_Timestuff);
  }

private:
 :: _Tinfo _Timestuff;
 };


class _Locinfo
 {
public:
 typedef ::std:: _Collvec _Collvec;
 typedef ::std:: _Ctypevec _Ctypevec;
 typedef ::std:: _Cvtvec _Cvtvec;
 typedef ::std:: _Timevec _Timevec;

 _Locinfo(const char * = "C");
 _Locinfo(const string&);
 _Locinfo(int, const char *);

 ~_Locinfo() noexcept;

 _Locinfo& _Addcats(int, const char *);

 const char *_Getname() const
  {

  return (_Newlocname);



  }

 _Collvec _Getcoll() const
  {
  _Collvec _X;
  _X._Costate = :: _Getpcostate();
  _X._WCostate = :: _Getpwcostate();
  return (_X);
  }

 _Ctypevec _Getctype() const
  {
  _Ctypevec _X;
  _X._Table = :: _Getpctype();
  _X._Tolotab = :: _Getptolower();
  _X._Touptab = :: _Getptoupper();
  _X._Delfl = 0;
  return (_X);
  }

 _Cvtvec _Getcvt() const
  {
  _Cvtvec _X;
  _X._Mbstate = :: _Getpmbstate();
  _X._Wcstate = :: _Getpwcstate();
  return (_X);
  }

 const lconv *_Getlconv() const
  {
  return (localeconv());
  }

 _Timevec _Gettnames() const
  {
  return (_Timeinfo);
  }

 const char *_Getdays() const
  {
  return (:: _Getptimes()->_Days);
  }

 const char *_Getmonths() const
  {
  return (:: _Getptimes()->_Months);
  }

 const char *_Getfalse() const
  {
  return (localeconv()->_False);
  }

 const char *_Gettrue() const
  {
  return (localeconv()->_True);
  }

private:

 _Timevec _Timeinfo;

 const char *_Oldlocname;
 const char *_Newlocname;




 };


template<class _Elem> inline
 int _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
  const _Elem *_First2, const _Elem *_Last2, const _Collvec *)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
  if (*_First1 < *_First2)
   return (-1);
  else if (*_First2 < *_First1)
   return (+1);

 return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
 }

template<> inline
 int _LStrcoll(const char *_First1, const char *_Last1,
  const char *_First2, const char *_Last2, const _Collvec *_Pcoll)
 {
 string _Str1, _Str2;
 size_t _Len1 = (size_t)(_Last1 - _First1);
 size_t _Len2 = (size_t)(_Last2 - _First2);

 if (0 < _Len1 && _Last1[-1] != '\0')
  {
  _Str1.assign(_First1, _Last1);
  _First1 = _Str1.c_str();
  }
 if (0 < _Len2 && _Last2[-1] != '\0')
  {
  _Str2.assign(_First2, _Last2);
  _First2 = _Str2.c_str();
  }

 int _Ans = 0;
 while (0 < _Len1 && 0 < _Len2
  && (_Ans = _Strcollx(_First1, _First2, _Pcoll->_Costate)) == 0)
  {
  size_t _Prefix = :: strlen(_First1) + 1;
  if (_Len1 <= _Prefix || _Len2 <= _Prefix)
   return (_Len1 < _Len2 ? -1 : _Len1 == _Len2 ? 0 : +1);

  _Len1 -= _Prefix, _Len2 -= _Prefix;
  _First1 += _Prefix, _First2 += _Prefix;
  }
 return (_Ans != 0 || _Len1 == _Len2 ? _Ans
  : _Len1 < _Len2 ? -1 : +1);
  }

template<> inline
 int _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
  const wchar_t *_First2, const wchar_t *_Last2, const _Collvec *_Pcoll)
 {
 wstring _Str1, _Str2;
 size_t _Len1 = (size_t)(_Last1 - _First1);
 size_t _Len2 = (size_t)(_Last2 - _First2);

 if (0 < _Len1 && _Last1[-1] != L'\0')
  {
  _Str1.assign(_First1, _Last1);
  _First1 = _Str1.c_str();
  }
 if (0 < _Len2 && _Last2[-1] != L'\0')
  {
  _Str2.assign(_First2, _Last2);
  _First2 = _Str2.c_str();
  }

 int _Ans = 0;
 while (0 < _Len1 && 0 < _Len2
  && (_Ans = _Wcscollx(_First1, _First2, _Pcoll->_WCostate)) == 0)
  {
  size_t _Prefix = :: wcslen(_First1) + 1;
  if (_Len1 <= _Prefix || _Len2 <= _Prefix)
   return (_Len1 < _Len2 ? -1 : _Len1 == _Len2 ? 0 : +1);

  _Len1 -= _Prefix, _Len2 -= _Prefix;
  _First1 += _Prefix, _First2 += _Prefix;
  }
 return (_Ans != 0 || _Len1 == _Len2 ? _Ans
  : _Len1 < _Len2 ? -1 : +1);
  }


template<class _Elem> inline
 size_t _LStrxfrm(_Elem *_First1, _Elem *_Last1,
  const _Elem *_First2, const _Elem *_Last2,
   const _Locinfo::_Collvec *)
 {
 size_t _Count = _Last2 - _First2;

 if (_Count <= (size_t)(_Last1 - _First1))
  :: memcpy(_First1, _First2, _Count * sizeof (_Elem));
 return (_Count);
 }

template<> inline
 size_t _LStrxfrm(char *_First1, char *_Last1,
  const char *_First2, const char *_Last2,
   const _Locinfo::_Collvec *_Pcoll)
 {
 string _Str2;
 size_t _Len1 = (size_t)(_Last1 - _First1);
 size_t _Len2 = (size_t)(_Last2 - _First2);

 if (0 < _Len2 && _Last2[-1] != '\0')
  {
  _Str2.assign(_First2, _Last2);
  _First2 = _Str2.c_str();
  }

 size_t _Count = 0;
 while (0 < _Len2)
  {
  size_t _Num = _Strxfrmx(_First1, _First2, _Len1,
   _Pcoll->_Costate);
  _Count += _Num;
  if (_Len1 < _Num)
   break;

  size_t _Prefix = :: strlen(_First2) + 1;
  if (_Len1 <= _Prefix)
   break;
  _Len1 -= _Num;
  _First1 += _Num;
  _First2 += _Prefix;
  }
 return (_Count);
 }

template<> inline
 size_t _LStrxfrm(wchar_t *_First1, wchar_t *_Last1,
  const wchar_t *_First2, const wchar_t *_Last2,
   const _Locinfo::_Collvec *_Pcoll)
 {
 wstring _Str2;
 size_t _Len1 = (size_t)(_Last1 - _First1);
 size_t _Len2 = (size_t)(_Last2 - _First2);

 if (0 < _Len2 && _Last2[-1] != L'\0')
  {
  _Str2.assign(_First2, _Last2);
  _First2 = _Str2.c_str();
  }

 size_t _Count = 0;
 while (0 < _Len2)
  {
  size_t _Num = _Wcsxfrmx(_First1, _First2, _Len1,
   _Pcoll->_WCostate);
  _Count += _Num;
  if (_Len1 < _Num)
   break;

  size_t _Prefix = :: wcslen(_First2) + 1;
  if (_Len1 <= _Prefix)
   break;
  _Len1 -= _Num;
  _First1 += _Num;
  _First2 += _Prefix;
  }
 return (_Count);
 }


inline int _Mbrtowc(wchar_t *_Wptr, const char *_Ptr, size_t _Count,
 mbstate_t *_Pstate, const _Cvtvec *_Pcvt)
 {
 return (:: _Mbtowcx(_Wptr, _Ptr, _Count, _Pstate,
  _Pcvt->_Mbstate));
 }


inline size_t _Strftime(char *_Ptr, size_t _Count, const char *_Format,
 const struct tm *_Ptime, const void *_Timeptr)
 {
 return (:: _CStrftime(_Ptr, _Count, _Format, _Ptime,
  (const :: _Tinfo *)_Timeptr));
 }


inline int _Tolower(int _Byte, const _Ctypevec *_Pctype)
 {
 return (_Pctype->_Tolotab[_Byte & 0xff]);
 }


inline int _Toupper(int _Byte, const _Ctypevec *_Pctype)
 {
 return (_Pctype->_Touptab[_Byte & 0xff]);
 }


inline int _Wcrtomb(char *_Ptr, wchar_t _Char,
 mbstate_t *_Pstate, const _Cvtvec *_Pcvt)
 {
 return (:: _Wctombx(_Ptr, _Char, _Pstate,
  _Pcvt->_Mbstate, _Pcvt->_Wcstate));
 }
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 2 3





extern "C" {
void *_Getgloballocale();
void _Setgloballocale(void *);
}


namespace std {

class _Facet_base
 {
public:
 virtual ~_Facet_base() noexcept
  {
  }

 virtual void _Incref() = 0;
 virtual _Facet_base *_Decref() = 0;
 };


template<class _Dummy>
 class _Locbase
 {
public:
 static const int collate = ((1 << (1)) >> 1);
 static const int ctype = ((1 << (2)) >> 1);
 static const int monetary = ((1 << (3)) >> 1);
 static const int numeric = ((1 << (4)) >> 1);
 static const int time = ((1 << (5)) >> 1);
 static const int messages = ((1 << (6)) >> 1);
 static const int all = (((1 << (7)) >> 1) - 1);
 static const int none = 0;
 };

template<class _Dummy>
 const int _Locbase<_Dummy>::collate;
template<class _Dummy>
 const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
 const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
 const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
 const int _Locbase<_Dummy>::time;
template<class _Dummy>
 const int _Locbase<_Dummy>::messages;
template<class _Dummy>
 const int _Locbase<_Dummy>::all;
template<class _Dummy>
 const int _Locbase<_Dummy>::none;


class locale;
template<class _Facet>
 const _Facet& use_facet(const locale&);
template<class _Elem>
 class collate;

class locale
 : public _Locbase<int>
 {
public:
 typedef int category;


 class id
  {
 public:
  id(size_t _Val = 0)
   : _Id(_Val)
   {
   }

  operator size_t()
   {
   if (_Id == 0)
    {
    {::std:: _Lockit _Lock(0);
     if (_Id == 0)
      _Id = (size_t)++_Id_cnt;
    }
    }
   return (_Id);
   }

 private:
  size_t _Id;

  static int _Id_cnt;

 public:
  id(const id&) = delete;
  id& operator=(const id&) = delete;
  };

 class _Locimp;


 class facet
  : public _Facet_base
  {
 public:
  static size_t _Getcat(const facet ** = 0,
   const locale * = 0)
   {
   return ((size_t)(-1));
   }

  void _Register();

  virtual void _Incref()
   {
   _Inc_atomic_counter_explicit(_Refs, memory_order_relaxed);
   }

  virtual _Facet_base *_Decref()
   {
   if (_Dec_atomic_counter_explicit(_Refs, memory_order_acq_rel) == 0)
    return (this);
   else
    return (0);
   }


 private:
  _Atomic_counter_t _Refs;
  int :32;

 protected:
  explicit facet(size_t _Initrefs = 0)
   {
   _Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
   }

 public:
  virtual ~facet() noexcept
   {
   }

  bool _Shared() const
   {
   return (1 < _Get_atomic_count(_Refs));
   }
# 203 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 3
 public:
  facet(const facet&) = delete;
  facet& operator=(const facet&) = delete;
  };



 class _Locimp
  : public facet
  {
 protected:
  ~_Locimp() noexcept;

 private:
  friend class locale;

  static _Locimp *_New_Locimp(bool _Transparent = false)
   {
   return (new _Locimp(_Transparent));
   }

  static _Locimp *_New_Locimp(const _Locimp& _Right)
   {
   return (new _Locimp(_Right));
   }

  _Locimp(bool _Transparent = false);

  _Locimp(const _Locimp&);

  void _Addfac(facet *, size_t);

  static _Locimp *_Makeloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  static void _Makewloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  static void _Makexloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  facet **_Facetvec;
  size_t _Facetcount;
  category _Catmask;
  bool _Xparent;


  char :8;
  short :16;
  const char *_Name;




  static _Locimp *_Clocptr;
  };

 template<class _Elem,
  class _Traits,
  class _Alloc>
  bool operator()(const basic_string<_Elem, _Traits, _Alloc>&,
   const basic_string<_Elem, _Traits, _Alloc>&)
    const;

 template<class _Facet>
  locale combine(const locale& _Loc) const
  {
  _Facet *_Facptr;

  {{
   _Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
  } if (0) {
   _Xruntime_error("locale::combine facet missing");
  }}

  _Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
  _Newimp->_Addfac(_Facptr, _Facet::id);
  _Newimp->_Catmask = none;
  _Newimp->_Name = "*";
  return (locale(_Newimp));
  }


 template<class _Facet>
  locale(const locale& _Loc, const _Facet *_Facptr)
   : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {
  if (_Facptr != 0)
   _Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
  _Ptr->_Catmask = 0;
  _Ptr->_Name = "*";
  }
# 309 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 3
 locale(_Uninitialized)
  {
  }

 locale(const locale& _Right) noexcept
  : _Ptr(_Right._Ptr)
  {
  _Ptr->_Incref();
  }

 locale() noexcept
  : _Ptr(_Init())
  {
  _Getgloballocale()->_Incref();
  }


 locale(const locale& _Loc, const locale& _Other,
  category _Cat)
  {
  if (_Loc._Ptr == _Other._Ptr)
   {
   _Ptr = _Loc._Ptr;
   _Ptr->_Incref();
   }
  else
   {
   _Ptr = _Locimp::_New_Locimp(*_Loc._Ptr);
   {{
   {::std:: _Lockit _Lock(0); _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name);
    _Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
     _Other._Ptr->_Name), _Cat, _Ptr, &_Other);
   }
   } if (0) {
   delete _Ptr->_Decref();
           ;
   }}
   }
  }

 explicit locale(const char *_Locname,
  category _Cat = all)
  {
  if (_Locname == __null
   || (:: strcmp(_Locname, "C") != 0
    && :: strcmp(_Locname, "") != 0))
   _Xruntime_error("bad locale name");

  _Ptr = classic()._Ptr;
  _Ptr->_Incref();
  }

 locale(const locale& _Loc, const char *_Locname,
  category _Cat)
  {
  if (_Locname == __null
   || (:: strcmp(_Locname, "C") != 0
    && :: strcmp(_Locname, "") != 0))
   _Xruntime_error("bad locale name");

  if (_Loc._Ptr == classic()._Ptr)
   {
   _Ptr = classic()._Ptr;
   _Ptr->_Incref();
   }
  else
   {
   _Ptr = _Locimp::_New_Locimp(*_Loc._Ptr);
   {{
   {::std:: _Lockit _Lock(0); _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name);
    bool _Hadname = !_Badname(_Lobj);
    _Lobj._Addcats(_Cat, _Locname);

    if (_Hadname && _Badname(_Lobj))
     _Xruntime_error("bad locale name");

    _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
   }
   } if (0) {
   delete _Ptr->_Decref();
           ;
   }}
   }
  }

 explicit locale(const string& _Str,
  category _Cat = all)
  {
  if (!_Str.compare("C") && !_Str.compare(""))
   _Xruntime_error("bad locale name");

  _Ptr = classic()._Ptr;
  _Ptr->_Incref();
  }

 locale(const locale& _Loc, const string& _Str,
  category _Cat)
  {
  if (!_Str.compare("C") && !_Str.compare(""))
   _Xruntime_error("bad locale name");

  _Ptr = _Locimp::_New_Locimp(*_Loc._Ptr);
  {{
  _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name);
  bool _Hadname = !_Badname(_Lobj);
  _Lobj._Addcats(_Cat, _Str.c_str());

  if (_Hadname && _Badname(_Lobj))
   _Xruntime_error("bad locale name");
  _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
  } if (0) {
  delete _Ptr->_Decref();
          ;
  }}
  }
# 524 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 3
 ~locale() noexcept
  {
  if (_Ptr != 0)
   delete _Ptr->_Decref();
  }

 locale& operator=(const locale& _Right) noexcept
  {
  if (_Ptr != _Right._Ptr)
   {
   delete _Ptr->_Decref();
   _Ptr = _Right._Ptr;
   _Ptr->_Incref();
   }
  return (*this);
  }

 string name() const
  {

  return (_Ptr == 0 ? string() : _Ptr->_Name);



  }

 const char *c_str() const
  {

  return (_Ptr == 0 ? "" : _Ptr->_Name);



  }

 const facet *_Getfacet(size_t _Id) const
  {
  const facet *_Facptr = _Id < _Ptr->_Facetcount
   ? _Ptr->_Facetvec[_Id] : 0;
  if (_Facptr != 0 || !_Ptr->_Xparent)
   return (_Facptr);
  else
   {
   locale::_Locimp *_Ptr0 = _Getgloballocale();
   return (_Id < _Ptr0->_Facetcount
    ? _Ptr0->_Facetvec[_Id]
    : 0);
   }
  }

 bool operator==(const locale& _Loc) const
  {
  return (_Ptr == _Loc._Ptr
   || (name().compare("*") != 0
    && name().compare(_Loc.name()) == 0));
  }

 bool operator!=(const locale& _Right) const
  {
  return (!(*this == _Right));
  }

 static const locale& classic();

 static locale global(const locale&);

 static locale empty();

private:
 locale(_Locimp *_Ptrimp)
  : _Ptr(_Ptrimp)
  {
  }

 static _Locimp *_Init();
 static _Locimp *_Init(
  bool _Do_incref);
 static _Locimp *_Getgloballocale();
 static void _Setgloballocale(void *);

 bool _Badname(const _Locinfo& _Lobj)
  {
  return (:: strcmp(_Lobj._Getname(), "*") == 0);
  }

 _Locimp *_Ptr;
 };




inline _Locinfo& _Get_locinfo()
 {
 static _Locinfo _Lobj;
 return (_Lobj);
 }

template<class _Facet>
 class _Wrap_facet
  : public _Facet
 {
public:
 _Wrap_facet()
  : _Facet(_Get_locinfo())
  {
  }
 };


template<class _Facet>
 struct _Facetptr
 {
 static const locale::facet *_Psave;
 };

template<class _Facet>
 const locale::facet *_Facetptr<_Facet>::
  _Psave = 0;






template<class _Facet> inline
 const _Facet& use_facet(const locale& _Loc)

 {
 {::std:: _Lockit _Lock(0);
  const locale::facet *_Psave =
   _Facetptr<_Facet>::_Psave;

  size_t _Id = _Facet::id;
  const locale::facet *_Pf = _Loc._Getfacet(_Id);

  if (_Pf != 0)
   ;
  else if (_Psave != 0)
   _Pf = _Psave;
  else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))
                            ;

  else
   {
   _Pf = _Psave;
   _Facetptr<_Facet>::_Psave = _Psave;

   locale::facet *_Pfmod = (_Facet *)_Psave;
   _Pfmod->_Incref();
   _Pfmod->_Register();
   }

  return ((const _Facet&)(*_Pf));
 }
 }


template<class _Elem,
 class _InIt> inline
 int _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
  const _Elem *_Ptr)
 {
 for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
  if (_Ptr[_Off] == _Ptr[0])
   ++_Numfields;
 string _Str(_Numfields, '\0');

 int _Ans = -2;
 for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++_Field)
   {
   for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
    ;

   if (_Str[_Field] != '\0')
    _Off += (size_t)_Str[_Field];
   else if (_Ptr[_Off += _Column] == _Ptr[0]
    || _Ptr[_Off] == (_Elem)0)
    {
    _Str[_Field] = (char)(_Column < 127
     ? _Column : 127);
    _Ans = (int)_Field;
    }
   else if (_First == _Last
    || tolower(_Ptr[_Off]) != tolower(*_First))
    _Str[_Field] = (char)(_Column < 127
     ? _Column : 127);
   else
    _Prefix = true;
   }

  if (!_Prefix || _First == _Last)
   break;
  }
 return (_Ans);
 }





template<class _Elem> inline
 char _Maklocbyte(_Elem _Char,
  const _Locinfo::_Cvtvec&)
 {
 return ((char)(unsigned char)_Char);
 }

template<> inline
 char _Maklocbyte(wchar_t _Char,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 char _Byte = '\0';
 _Mbstatet _Mbst1;
 _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
 return (_Byte);
 }





template<class _Elem> inline
 _Elem _Maklocchr(char _Byte, _Elem *,
  const _Locinfo::_Cvtvec&)
 {
 return ((_Elem)(unsigned char)_Byte);
 }

template<> inline
 wchar_t _Maklocchr(char _Byte, wchar_t *,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 wchar_t _Wc = L'\0';
 _Mbstatet _Mbst1;
 _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
 return (_Wc);
 }





template<class _Elem> inline
 _Elem *_Maklocstr(const char *_Ptr, _Elem *,
  const _Locinfo::_Cvtvec&)
 {
 size_t _Count = :: strlen(_Ptr) + 1;
 _Elem *_Ptrdest = (_Elem *):: malloc(_Count * sizeof (_Elem));
 if (!_Ptrdest)
  _Xbad_alloc();

 for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
  *_Ptrnext = (_Elem)(unsigned char)*_Ptr;
 return (_Ptrdest);
 }

template<> inline
 wchar_t *_Maklocstr(const char *_Ptr, wchar_t *,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 size_t _Count, _Count1;
 size_t _Wchars;
 const char *_Ptr1;
 int _Bytes;
 wchar_t _Wc;
 _Mbstatet _Mbst1;

 _Count1 = :: strlen(_Ptr) + 1;
 for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
  _Count -= (size_t)_Bytes, _Ptr1 += _Bytes, ++_Wchars)
  if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
   break;
 ++_Wchars;

 wchar_t *_Ptrdest = (wchar_t *):: malloc(_Wchars * sizeof (wchar_t));
 if (!_Ptrdest)
  _Xbad_alloc();
 wchar_t *_Ptrnext = _Ptrdest;
 _Mbstatet _Mbst2;

 for (; 0 < _Wchars;
  _Count -= (size_t)_Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
  if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
   break;
 *_Ptrnext = L'\0';
 return (_Ptrdest);
 }

template<class _Ty>
class _Makloc
        {
public:
        static _Ty *Currencysign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("", (_Ty *)0, _Cvt);
                }

        static _Ty *Plussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("", (_Ty *)0, _Cvt);
                }

        static _Ty *Minussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("-", (_Ty *)0, _Cvt);
                }

        static char *MonGrouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("", (char *)0, _Cvt);
                }

        static char *Grouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("", (char *)0, _Cvt);
                }

        static _Ty *Falsename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("false", (_Ty *)0, _Cvt);
                }

        static _Ty *Truename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("true", (_Ty *)0, _Cvt);
                }

        static _Ty *Days(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr(":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday", (_Ty *)0, _Cvt);
                }

        static _Ty *Months(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr(":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December", (_Ty *)0, _Cvt);
                }

        static _Ty *Ampm(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr(":AM:am:PM:pm", (_Ty *)0, _Cvt);
                }

        template<class _Ty2>
        static void destroy(_Ty2 *ptr)
                {
                delete ptr;
                }
 };

template<>
class _Makloc<char>
        {
public:
        static const char *Currencysign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Plussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Minussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "-";
                }

        static const char *MonGrouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Grouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Falsename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "false";
                }

        static const char *Truename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "true";
                }

        static const char *Days(const _Locinfo::_Cvtvec& _Cvt)
                {
                return ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
                }

        static const char *Months(const _Locinfo::_Cvtvec& _Cvt)
                {
                return ":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
                }

        static const char *Ampm(const _Locinfo::_Cvtvec& _Cvt)
                {
                return ":AM:am:PM:pm";
                }

        static void destroy(void *ptr)
                {
                }
        };

template<>
class _Makloc<wchar_t>
        {
public:
        static const wchar_t *Currencysign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"";
                }

        static const wchar_t *Plussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"";
                }

        static const wchar_t *Minussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"-";
                }

        static const char *MonGrouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Grouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const wchar_t *Falsename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"false";
                }

        static const wchar_t *Truename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"true";
                }

        static const wchar_t *Days(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
                }

        static const wchar_t *Months(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
                }

        static const wchar_t *Ampm(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L":AM:am:PM:pm";
                }

        static void destroy(void *ptr)
                {
                }
        };



class codecvt_base
 : public locale::facet
 {
public:
 enum
  {
  ok, partial, error, noconv};
 typedef int result;

 codecvt_base(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  }

 bool always_noconv() const noexcept
  {
  return (do_always_noconv());
  }

 int max_length() const noexcept
  {
  return (do_max_length());
  }

 int encoding() const noexcept
  {
  return (do_encoding());
  }

 ~codecvt_base() noexcept
  {
  }

protected:
 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return (1);
  }

 virtual int do_encoding() const noexcept
  {
  return (1);
  }
 };


template<class _Elem,
 class _Byte,
 class _Statype>
 class codecvt
  : public codecvt_base
 {
public:
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (always_noconv() ? noconv
   : do_unshift(_State, _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

 static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Locinfo());
  }

 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (is_same<_Byte, _Elem>::value);
  }

 virtual result do_in(_Statype&,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if (is_same<_Byte, _Elem>::value)
   return (noconv);
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
    *_Mid2 = (_Elem)*_Mid1;
   return (ok);
   }
  }

 virtual result do_out(_Statype&,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if (is_same<_Byte, _Elem>::value)
   return (noconv);
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
    *_Mid2 = (_Byte)*_Mid1;
   return (ok);
   }
  }

 virtual result do_unshift(_Statype&,
  _Byte *_First2, _Byte *, _Byte *&_Mid2) const
  {
  _Mid2 = _First2;
  return (ok);
  }

 virtual int do_length(_Statype&, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return ((int)(_Count < (size_t)(_Last1 - _First1)
   ? _Count : _Last1 - _First1));
  }
 };


template<class _Elem,
 class _Byte,
 class _Statype>
 locale::id codecvt<_Elem, _Byte, _Statype>::id;

extern template class codecvt<char, char, _Mbstatet>;


enum _Codecvt_mode {
 _Consume_header = 4,
 _Generate_header = 2
 };


template<>
 class codecvt<char16_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
 typedef char16_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

 static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
  {
  _Init(_Lobj);
  }

 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
  _Codecvt_mode _Mode_arg, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned char _By = (unsigned char)*_Mid1;
   unsigned long _Ch;
   int _Nextra, _Nskip;

   if (*_Pstate <= 1)
    ;
   else if (_By < 0x80 || 0xc0 <= _By)
    return (_Mybase::error);
   else
    {
    ++_Mid1;
    *_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
    *_Pstate = 1;
    continue;
    }

   if (_By < 0x80)
    _Ch = _By, _Nextra = 0;
   else if (_By < 0xc0)
    {
    ++_Mid1;
    return (_Mybase::error);
    }
   else if (_By < 0xe0)
    _Ch = _By & 0x1f, _Nextra = 1;
   else if (_By < 0xf0)
    _Ch = _By & 0x0f, _Nextra = 2;
   else if (_By < 0xf8)
    _Ch = _By & 0x07, _Nextra = 3;
   else
    _Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

   _Nskip = _Nextra < 3 ? 0 : 1;
   _First1 = _Mid1;

   if (_Nextra == 0)
    ++_Mid1;
   else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
    break;
   else
    for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
     if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
      return (_Mybase::error);
     else
      _Ch = _Ch << 6 | (_By & 0x3f);
   if (0 < _Nskip)
    _Ch <<= 6;

   if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
    return (_Mybase::error);
   else if (0xffff < _Ch)
    {
    unsigned short _Ch0 =
     (unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

    *_Mid2++ = (_Elem)_Ch0;
    *_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
    continue;
    }

   if (_Nskip == 0)
    ;
   else if (_Mid1 == _Last1)
    {
    _Mid1 = _First1;
    break;
    }
   else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
    return (_Mybase::error);
   else
    _Ch |= _By & 0x3f;

   if (*_Pstate == 0)
    {
    *_Pstate = 1;

    if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
     {
     result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
      _First2, _Last2, _Mid2);

     if (_Ans == _Mybase::partial)
      {
      *_Pstate = 0;
      _Mid1 = _First1;
      }
     return (_Ans);
     }
    }

   *_Mid2++ = (_Elem)_Ch;
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned long _Ch;
   unsigned short _Ch1 = (unsigned short)*_Mid1;
   bool _Save = false;

   if (1 < *_Pstate)
    {
    if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
     return (_Mybase::error);
    _Ch = (unsigned long)((*_Pstate << 10) | (_Ch1 - 0xdc00));
    }
   else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
    {
    _Ch = (unsigned long)((_Ch1 - 0xd800 + 0x0040) << 10);
    _Save = true;
    }
   else
    _Ch = _Ch1;

   _Byte _By;
   int _Nextra;

   if (_Ch < 0x0080)
    _By = (_Byte)_Ch, _Nextra = 0;
   else if (_Ch < 0x0800)
    _By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
   else if (_Ch < 0x10000)
    _By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
   else
    _By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;

   int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

   if (_Last2 - _Mid2 < _Nput)
    break;
   else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
    ;
   else if (_Last2 - _Mid2 < 3 + _Nput)
    break;
   else
    {
    *_Mid2++ = (_Byte)(unsigned char)0xef;
    *_Mid2++ = (_Byte)(unsigned char)0xbb;
    *_Mid2++ = (_Byte)(unsigned char)0xbf;
    }

   ++_Mid1;
   if (_Save || _Nextra < 3)
    {
    *_Mid2++ = _By;
    --_Nput;
    }
   for (; 0 < _Nput; --_Nput)
    *_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);

   *_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *, _Byte *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid2 = _First2;

  return (1 < *_Pstate
   ? _Mybase::error : _Mybase::ok);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  size_t _Wchars = 0;
  _Statype _Mystate = _State;

  for (; _Wchars < _Count && _First1 != _Last1; )
   {
   const _Byte *_Mid1;
   _Elem *_Mid2;
   _Elem _Ch;

   switch (do_in(_Mystate, _First1, _Last1, _Mid1,
    &_Ch, &_Ch + 1, _Mid2))
    {
   case _Mybase::noconv:
    return ((int)(_Wchars + (size_t)(_Last1 - _First1)));

   case _Mybase::ok:
    if (_Mid2 == &_Ch + 1)
     ++_Wchars;
    _First1 = _Mid1;
    break;

   default:
    return ((int)_Wchars);
    }
   }

  return ((int)_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return ((_Mode & _Consume_header) != 0 ? 9
   : (_Mode & _Generate_header) != 0 ? 7
   : 6);
  }

 virtual int do_encoding() const noexcept
  {
  return (0);
  }

private:
 unsigned long _Maxcode;
 _Codecvt_mode _Mode;
 int :32;
 };


template<>
 class codecvt<char32_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
 typedef char32_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

 static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
  {
  _Init(_Lobj);
  }

 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
  _Codecvt_mode _Mode_arg, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  char *_Pstate = (char *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned char _By = (unsigned char)*_Mid1;
   unsigned long _Ch;
   int _Nextra;

   if (_By < 0x80)
    _Ch = _By, _Nextra = 0;
   else if (_By < 0xc0)
    {
    ++_Mid1;
    return (_Mybase::error);
    }
   else if (_By < 0xe0)
    _Ch = _By & 0x1f, _Nextra = 1;
   else if (_By < 0xf0)
    _Ch = _By & 0x0f, _Nextra = 2;
   else if (_By < 0xf8)
    _Ch = _By & 0x07, _Nextra = 3;
   else
    _Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

   if (_Nextra == 0)
    ++_Mid1;
   else if (_Last1 - _Mid1 < _Nextra + 1)
    break;
   else
    for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
     if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
      return (_Mybase::error);
     else
      _Ch = _Ch << 6 | (_By & 0x3f);

   if (*_Pstate == 0)
    {
    *_Pstate = 1;

    if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
     {
     result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
      _First2, _Last2, _Mid2);

     if (_Ans == _Mybase::partial)
      {
      *_Pstate = 0;
      _Mid1 = _First1;
      }
     return (_Ans);
     }
    }

   if (_Maxcode < _Ch)
    return (_Mybase::error);
   *_Mid2++ = (_Elem)_Ch;
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  char *_Pstate = (char *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   _Byte _By;
   int _Nextra;
   unsigned long _Ch = (unsigned long)*_Mid1;

   if (_Maxcode < _Ch)
    return (_Mybase::error);

   if (_Ch < 0x0080)
    _By = (_Byte)_Ch, _Nextra = 0;
   else if (_Ch < 0x0800)
    _By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
   else if (_Ch < 0x00010000)
    _By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
   else if (_Ch < 0x00200000)
    _By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
   else if (_Ch < 0x04000000)
    _By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
   else
    _By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;

   if (*_Pstate == 0)
    {
    *_Pstate = 1;
    if ((_Mode & _Generate_header) == 0)
     ;
    else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
     return (_Mybase::partial);
    else
     {
     *_Mid2++ = (_Byte)(unsigned char)0xef;
     *_Mid2++ = (_Byte)(unsigned char)0xbb;
     *_Mid2++ = (_Byte)(unsigned char)0xbf;
     }
    }

   if (_Last2 - _Mid2 < 1 + _Nextra)
    break;

   ++_Mid1;
   for (*_Mid2++ = _By; 0 < _Nextra; )
    *_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
   }
  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_unshift(_Statype&,
  _Byte *_First2, _Byte *, _Byte *& _Mid2) const
  {
  _Mid2 = _First2;
  return (_Mybase::ok);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  int _Wchars = 0;
  _Statype _Mystate = _State;

  for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
   {
   const _Byte *_Mid1;
   _Elem *_Mid2;
   _Elem _Ch;

   switch (do_in(_Mystate, _First1, _Last1, _Mid1,
    &_Ch, &_Ch + 1, _Mid2))
    {
   case _Mybase::noconv:
    return ((int)(_Wchars + (int)(_Last1 - _First1)));

   case _Mybase::ok:
    if (_Mid2 == &_Ch + 1)
     ++_Wchars;
    _First1 = _Mid1;
    break;

   default:
    return ((int)_Wchars);
    }
   }

  return ((int)_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return ((_Mode & (_Consume_header | _Generate_header)) != 0
   ? 9 : 6);
  }

 virtual int do_encoding() const noexcept
  {
  return ((_Mode & (_Consume_header | _Generate_header)) != 0
   ? -1 : 0);
  }

private:
 unsigned long _Maxcode;
 _Codecvt_mode _Mode;
 int :32;
 };


template<>
 class codecvt<wchar_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef wchar_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

 static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Cvt = _Lobj._Getcvt();
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
   _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  result _Ans = _Mid1 == _Last1 ? ok : partial;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, (size_t)(_Last1 - _Mid1),
    &_State, &_Cvt))
   {
   case -2:
    _Mid1 = _Last1;
    return (_Ans);

   case -1:
    return (error);

   case 0:
    if (*_Mid2 == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Mid2;
    _Ans = ok;
   }
  return (_Ans);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
   _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   if ((int)6 <= _Last2 - _Mid2)
    if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else
     ++_Mid1, _Mid2 += _Bytes;
   else
    {
    _Byte _Buf[6];
    _Statype _Stsave = _State;

    if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else if (_Last2 - _Mid2 < _Bytes)
     {
     _State = _Stsave;
     break;
     }
    else
     {
     :: memcpy(_Mid2, _Buf, _Bytes);
     ++_Mid1, _Mid2 += _Bytes;
     }
    }
  return (_Mid1 == _Last1 ? ok : partial);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
  _Mid2 = _First2;
  result _Ans = ok;
  int _Bytes;
  _Byte _Buf[6];
  _Statype _Stsave = _State;

  if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
   _Ans = error;
  else if (_Last2 - _Mid2 < --_Bytes)
   {
   _State = _Stsave;
   _Ans = partial;
   }
  else if (0 < _Bytes)
   {
   :: memcpy(_Mid2, _Buf, _Bytes);
   _Mid2 += _Bytes;
   }
  return (_Ans);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
                               ;
  int _Wchars;
  const _Byte *_Mid1;
  _Statype _Mystate = _State;

  for (_Wchars = 0, _Mid1 = _First1;
   (size_t)_Wchars < _Count && _Mid1 != _Last1; )
   {
   int _Bytes;
   _Elem _Ch;

   switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, (size_t)(_Last1 - _Mid1),
    &_Mystate, &_Cvt))
    {
   case -2:
    return (_Wchars);

   case -1:
    return (_Wchars);

   case 0:
    if (_Ch == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Wchars;
    }
   }
  return (_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return (6);
  }

 virtual int do_encoding() const noexcept
  {
  return (0);
  }

private:
 _Locinfo::_Cvtvec _Cvt;
 };


template<class _Elem,
 class _Byte,
 class _Statype>
 class codecvt_byname
  : public codecvt<_Elem, _Byte, _Statype>
 {
public:
 explicit codecvt_byname(const char *_Locname, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit codecvt_byname(const string& _Str, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

 explicit codecvt_byname(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Lobj, _Refs)
  {
  }

protected:
 virtual ~codecvt_byname() noexcept
  {
  }
 };



struct ctype_base
 : public locale::facet
 {
 enum
  {
  alnum = 0x20 | 0x10 | 0x02 | 0x200, alpha = 0x10 | 0x02 | 0x200,
  cntrl = 0x80, digit = 0x20, graph = 0x20 | 0x10 | 0x08 | 0x02 | 0x200,
  lower = 0x10, print = 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x200 | 0x01,
  punct = 0x08, space = 0x40 | 0x04 | 0x100, upper = 0x02,
  xdigit = 0x01, blank = 0x40 | 0x04 | 0x100 | 0x400};
 typedef short mask;

 ctype_base(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  }

 ~ctype_base() noexcept
  {
  }
 };


template<class _Elem>
 class ctype
  : public ctype_base
 {
public:
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem *is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem *scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem *scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char *widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

 static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() noexcept
  {
  if (_Ctype._Delfl)
   :: free((void *)_Ctype._Table);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
   & _Maskval) != 0);
  }

 virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
  return (_First);
  }

 virtual const _Elem *do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem *do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Tolower(_Byte, &_Ctype)));
  }

 virtual const _Elem *do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Tolower(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Toupper(_Byte, &_Ctype)));
  }

 virtual const _Elem *do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Toupper(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
  }

 virtual const char *do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Byte;
  if (_Ch == (_Elem)0)
   return ('\0');
  else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
   return (_Dflt);
  else
   return (_Byte);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem *do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };


template<class _Elem>
 locale::id ctype<_Elem>::id;


template<>
 class ctype<char>
 : public ctype_base
 {
 typedef ctype<char> _Myt;

public:
 typedef char _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
  }

 const _Elem *is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)*_First];
  return (_First);
  }

 const _Elem *scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 const _Elem *scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const _Elem *widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 _Elem narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

 static locale::id id;

 explicit ctype(const mask *_Table = 0,
  bool _Deletetable = false,
  size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }

  _Tidy();
  if (_Table != 0)
   {
   _Ctype._Table = _Table;
   _Ctype._Delfl = _Deletetable ? -1 : 0;
   }
  else
   {
   _Ctype._Table = classic_table();
   _Ctype._Delfl = 0;
   }
  }

 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

 const mask *table() const noexcept
  {
  return (_Ctype._Table);
  }

 static const mask *classic_table() noexcept
  {
  const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
  return (_Ctype_fac.table());
  }

 static const size_t table_size;

protected:
 virtual ~ctype() noexcept
  {
  _Tidy();
  }

 void _Init(const _Locinfo& _Lobj)
  {




  _Ctype = _Lobj._Getctype();
  }

 void _Tidy()
  {
  if (0 < _Ctype._Delfl)
   :: free((void *)_Ctype._Table);
  else if (_Ctype._Delfl < 0)
   delete[] _Ctype._Table;
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
  }

 virtual const _Elem *do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
  }

 virtual const _Elem *do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Byte);
  }

 virtual const _Elem *do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  :: memcpy(_Dest, _First, _Last - _First);
  return (_Last);
  }

 virtual _Elem do_narrow(_Elem _Ch, char) const
  {
  return (_Ch);
  }

 virtual const _Elem *do_narrow(const _Elem *_First,
  const _Elem *_Last, char, char *_Dest) const
  {
                                        ;
  :: memcpy(_Dest, _First, _Last - _First);
  return (_Last);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 };


template<>
 class ctype<wchar_t>
 : public ctype_base
 {
 typedef ctype<wchar_t> _Myt;

public:
 typedef wchar_t _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem *is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem *scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem *scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char *widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

 static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() noexcept
  {
  if (_Ctype._Delfl)
   :: free((void *)_Ctype._Table);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
   & _Maskval) != 0);
  }

 virtual const _Elem *do_is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
  return (_First);
  }

 virtual const _Elem *do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem *do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Tolower(_Byte, &_Ctype)));
  }

 virtual const _Elem *do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Tolower(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Toupper(_Byte, &_Ctype)));
  }

 virtual const _Elem *do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Toupper(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 _Elem _Dowiden(char _Byte) const
  {
  _Mbstatet _Mbst;
  wchar_t _Wc;
  return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
   ? (wchar_t)((:: wint_t)(-1)) : _Wc);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Dowiden(_Byte));
  }

 virtual const char *do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Dowiden(*_First);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Buf[6];
  _Mbstatet _Mbst;
  return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
   ? _Dflt : _Buf[0]);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem *do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };


template<class _Elem>
 class ctype_byname
 : public ctype<_Elem>
 {
public:
 explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
  : ctype<_Elem>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit ctype_byname(const string& _Str, size_t _Refs = 0)
  : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

 explicit ctype_byname(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype<_Elem>(_Lobj, _Refs)
  {
  }

protected:
 virtual ~ctype_byname() noexcept
  {
  }
 };


template<>
 class ctype_byname<char>
 : public ctype<char>
 {
public:
 explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
  : ctype<char>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit ctype_byname(const string& _Str, size_t _Refs = 0)
  : ctype<char>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

 explicit ctype_byname(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype<char>(_Lobj, _Refs)
  {
  }

protected:
 virtual ~ctype_byname() noexcept
  {
  }
 };


extern std::locale _sceLibcClassicLocale;


}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cerrno" 1 3
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cerrno" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cerrno" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\errno.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\errno.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/errno.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/errno.h" 3
extern "C" {
int * __error(void);
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\errno.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\errno.h" 2 3
# 33 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cerrno" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 2 3



namespace std {

enum class errc {
 address_family_not_supported = 47,
 address_in_use = 48,
 address_not_available = 49,
 already_connected = 56,
 argument_list_too_long = 7,
 argument_out_of_domain = 33,
 bad_address = 14,
 bad_file_descriptor = 9,
 bad_message = 89,
 broken_pipe = 32,
 connection_aborted = 53,
 connection_already_in_progress = 37,
 connection_refused = 61,
 connection_reset = 54,
 cross_device_link = 18,
 destination_address_required = 39,
 device_or_resource_busy = 16,
 directory_not_empty = 66,
 executable_format_error = 8,
 file_exists = 17,
 file_too_large = 27,
 filename_too_long = 63,
 function_not_supported = 78,
 host_unreachable = 65,
 identifier_removed = 82,
 illegal_byte_sequence = 86,
 inappropriate_io_control_operation = 25,
 interrupted = 4,
 invalid_argument = 22,
 invalid_seek = 29,
 io_error = 5,
 is_a_directory = 21,
 message_size = 40,
 network_down = 50,
 network_reset = 52,
 network_unreachable = 51,
 no_buffer_space = 55,
 no_child_process = 10,
 no_link = 91,
 no_lock_available = 77,
 no_message_available = 1040,
 no_message = 83,
 no_protocol_option = 42,
 no_space_on_device = 28,
 no_stream_resources = 1050,
 no_such_device_or_address = 6,
 no_such_device = 19,
 no_such_file_or_directory = 2,
 no_such_process = 3,
 not_a_directory = 20,
 not_a_socket = 38,
 not_a_stream = 1051,
 not_connected = 57,
 not_enough_memory = 12,
 not_supported = 45,
 operation_canceled = 85,
 operation_in_progress = 36,
 operation_not_permitted = 1,
 operation_not_supported = 45,
 operation_would_block = 35,
 owner_dead = 108,
 permission_denied = 13,
 protocol_error = 92,
 protocol_not_supported = 43,
 read_only_file_system = 30,
 resource_deadlock_would_occur = 11,
 resource_unavailable_try_again = 35,
 result_out_of_range = 34,
 state_not_recoverable = 107,
 stream_timeout = 1074,
 text_file_busy = 26,
 timed_out = 60,
 too_many_files_open_in_system = 23,
 too_many_files_open = 24,
 too_many_links = 31,
 too_many_symbolic_link_levels = 62,
 value_too_large = 84,
 wrong_protocol_type = 41
 };

typedef errc _Errc;


typedef errc generic_errno;



enum class io_errc {
 stream = 1
 };

typedef io_errc _Io_errc;
}
namespace std {

template<class _Enum>
 struct is_error_code_enum
  : public false_type
 {
 };

template<>
 struct is_error_code_enum<_Io_errc>
  : public true_type
 {
 };


template<class _Enum>
 struct is_error_condition_enum
  : public false_type
 {
 };

template<>
 struct is_error_condition_enum<generic_errno>
  : public true_type
 {
 };
}
namespace std {





class error_code;
class error_condition;
error_code make_error_code(_Errc) noexcept;
error_code make_error_code(_Io_errc) noexcept;
error_condition make_error_condition(_Errc) noexcept;
error_condition make_error_condition(_Io_errc) noexcept;


class error_category;

const error_category& generic_category() noexcept;
const error_category& iostream_category() noexcept;
const error_category& system_category() noexcept;

class error_category
 {
public:
 constexpr error_category() noexcept
  {
  }

 virtual ~error_category() noexcept;

 virtual const char *name() const noexcept = 0;

 virtual string message(int _Errval) const = 0;

 virtual error_condition
  default_error_condition(int _Errval) const noexcept;

 virtual bool equivalent(int _Errval,
  const error_condition& _Cond) const noexcept;

 virtual bool equivalent(const error_code& _Code,
  int _Errval) const noexcept;

 bool operator==(const error_category& _Right) const noexcept
  {
  return (this == &_Right);
  }

 bool operator!=(const error_category& _Right) const noexcept
  {
  return (!(*this == _Right));
  }

 bool operator<(const error_category& _Right) const noexcept
  {
  return (this < &_Right);
  }

 error_category(const error_category&) = delete;
 error_category& operator=(const error_category&) = delete;
 };


class error_code
 {
public:
 typedef error_code _Myt;

 error_code() noexcept
  : _Myval(0),
   _Mycat(&system_category())
  {
  }

 error_code(int _Val, const error_category& _Cat) noexcept
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = enable_if_t<is_error_code_enum<_Enum>::value,
   void> >
  error_code(_Enum _Errcode) noexcept
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_code(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) noexcept
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum>
  enable_if_t<is_error_code_enum<_Enum>::value,
   error_code>&
  operator=(_Enum _Errcode) noexcept
  {
  *this = make_error_code(_Errcode);
  return (*this);
  }

 void clear() noexcept
  {
  _Myval = 0;
  _Mycat = &system_category();
  }

 int value() const noexcept
  {
  return (_Myval);
  }

 const error_category& category() const noexcept
  {
  return (*_Mycat);
  }

 error_condition default_error_condition() const noexcept;

 string message() const
  {
  return (category().message(value()));
  }


 int _No_bool_decl = 0;


 explicit operator bool() const noexcept
  {
  return (value() != 0);
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


class error_condition
 {
public:
 typedef error_condition _Myt;

 error_condition() noexcept
  : _Myval(0),
   _Mycat(&generic_category())
  {
  }

 error_condition(int _Val, const error_category& _Cat) noexcept
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = enable_if_t<is_error_condition_enum<_Enum>::value,
   void> >
  error_condition(_Enum _Errcode) noexcept
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_condition(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) noexcept
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum,
  class = enable_if_t<is_error_condition_enum<_Enum>::value,
   void> >
  error_condition& operator=(_Enum _Errcode) noexcept
  {
  *this = make_error_condition(_Errcode);
  return (*this);
  }

 void clear() noexcept
  {
  _Myval = 0;
  _Mycat = &generic_category();
  }

 int value() const noexcept
  {
  return (_Myval);
  }

 const error_category& category() const noexcept
  {
  return (*_Mycat);
  }

 string message() const
  {
  return (category().message(value()));
  }


        int _No_bool_decl;


 explicit operator bool() const noexcept
  {
  return (value() != 0);
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


inline bool operator==(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (_Left.category() == _Right.category()
  && _Left.value() == _Right.value());
 }

inline bool operator==(
 const error_code& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category().equivalent(_Left.value(), _Right)
  || _Right.category().equivalent(_Left, _Right.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_code& _Right) noexcept
 {
 return (_Right.category().equivalent(_Right.value(), _Left)
  || _Left.category().equivalent(_Right, _Left.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category() == _Right.category()
  && _Left.value() == _Right.value());
 }


inline bool operator!=(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_code& _Left,
 const error_condition& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_code& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


inline bool operator<(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (_Left.category() < _Right.category()
  || (_Left.category() == _Right.category()
   && _Left.value() < _Right.value()));
 }

inline bool operator<(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category() < _Right.category()
  || (_Left.category() == _Right.category()
   && _Left.value() < _Right.value()));
 }


inline error_condition error_code::default_error_condition() const noexcept
 {
 return (category().default_error_condition(value()));
 }


inline error_code make_error_code(_Errc _Errno) noexcept
 {
 return (error_code((int)_Errno, generic_category()));
 }

inline error_code make_error_code(_Io_errc _Errno) noexcept
 {
 return (error_code((int)_Errno, iostream_category()));
 }


inline error_condition make_error_condition(_Errc _Errno) noexcept
 {
 return (error_condition((int)_Errno, generic_category()));
 }

inline error_condition make_error_condition(_Io_errc _Errno) noexcept
 {
 return (error_condition((int)_Errno, iostream_category()));
 }
}
namespace std {

template<>
 struct hash<error_code>
 {
 typedef error_code argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (hash<int>()(_Keyval.value()));
  }
 };
# 490 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 3
}
namespace std {

class _System_error
 : public runtime_error
 {
private:
 static string _Makestr(error_code _Errcode, string _Message)
  {
  if (!_Message.empty())
   _Message.append(": ");
  _Message.append(_Errcode.message());
  return (_Message);
  }

protected:
 _System_error(error_code _Errcode, const string& _Message)
  : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
  {
  }

 error_code _Mycode;
 };

class system_error
 : public _System_error
 {
private:
 typedef _System_error _Mybase;

public:
 system_error(error_code _Errcode)
  : _Mybase(_Errcode, "")
  {
  }

 system_error(error_code _Errcode, const string& _Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(error_code _Errcode, const char *_Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat)
  : _Mybase(error_code(_Errval, _Errcat), "")
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const string& _Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const char *_Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }


 virtual ~system_error() noexcept;


 const error_code& code() const noexcept
  {
  return (_Mycode);
  }




protected:
 virtual void _Doraise() const;

 };

const char *_Syserror_map(int);


class _Generic_error_category
 : public error_category
 {
public:
 _Generic_error_category() noexcept
  {
  }

 virtual const char *name() const noexcept
  {
  return ("generic");
  }

 virtual string message(int _Errcode) const
  {
  const char *_Name = _Syserror_map(_Errcode);
  return (string(_Name != 0 ? _Name : "unknown error"));
  }
 };

template<class _Ty>
 struct _Immortalizer
 {
 _Immortalizer()
  {
  ::new (static_cast<void *>(&_Storage)) _Ty();
  }

 ~_Immortalizer() noexcept
  {
  }

 _Immortalizer(const _Immortalizer&) = delete;
 _Immortalizer& operator=(const _Immortalizer&) = delete;

 typename aligned_union<1, _Ty>::type _Storage;
 };

template<class _Ty> inline
 _Ty& _Immortalize()
 {
 static _Immortalizer<_Ty> _Static;
 return (*reinterpret_cast<_Ty *>(&_Static._Storage));
 }
# 629 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 2 3



namespace std {
# 75 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 3
template<class _Dummy>
 class _Iosb
 {
public:
 enum _Dummy_enum {_Dummy_enum_val = 1};
 enum _Fmtflags
  {
  _Fmtmask = 0xffff, _Fmtzero = 0};

 static constexpr _Fmtflags skipws = (_Fmtflags)0x0001;
 static constexpr _Fmtflags unitbuf = (_Fmtflags)0x2000;
 static constexpr _Fmtflags uppercase = (_Fmtflags)0x0200;
 static constexpr _Fmtflags showbase = (_Fmtflags)0x0080;
 static constexpr _Fmtflags showpoint = (_Fmtflags)0x0100;
 static constexpr _Fmtflags showpos = (_Fmtflags)0x0400;
 static constexpr _Fmtflags left = (_Fmtflags)0x0002;
 static constexpr _Fmtflags right = (_Fmtflags)0x0004;
 static constexpr _Fmtflags internal = (_Fmtflags)0x0008;
 static constexpr _Fmtflags dec = (_Fmtflags)0x0010;
 static constexpr _Fmtflags oct = (_Fmtflags)0x0020;
 static constexpr _Fmtflags hex = (_Fmtflags)0x0040;
 static constexpr _Fmtflags scientific = (_Fmtflags)0x0800;
 static constexpr _Fmtflags fixed = (_Fmtflags)0x1000;

 static constexpr _Fmtflags hexfloat =
  (_Fmtflags)0x1800;

 static constexpr _Fmtflags boolalpha = (_Fmtflags)0x8000;
 static constexpr _Fmtflags _Stdio = (_Fmtflags)0x4000;
 static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0002
  | 0x0004 | 0x0008);
 static constexpr _Fmtflags basefield = (_Fmtflags)(0x0010
  | 0x0020 | 0x0040);
 static constexpr _Fmtflags floatfield = (_Fmtflags)(0x0800
  | 0x1000);

 enum _Iostate
  {
  _Statmask = 0x17};

 static constexpr _Iostate goodbit = (_Iostate)0x0;
 static constexpr _Iostate eofbit = (_Iostate)0x1;
 static constexpr _Iostate failbit = (_Iostate)0x2;
 static constexpr _Iostate badbit = (_Iostate)0x4;

 enum _Openmode
  {
  _Openmask = 0xff};

 static constexpr _Openmode in = (_Openmode)0x01;
 static constexpr _Openmode out = (_Openmode)0x02;
 static constexpr _Openmode ate = (_Openmode)0x04;
 static constexpr _Openmode app = (_Openmode)0x08;
 static constexpr _Openmode trunc = (_Openmode)0x10;
 static constexpr _Openmode _Nocreate = (_Openmode)0x20;
 static constexpr _Openmode _Noreplace = (_Openmode)0x40;
 static constexpr _Openmode binary = (_Openmode)0x80;

 enum _Seekdir
  {
  _Seekbeg,
  _Seekcur,
  _Seekend
  };

 static constexpr _Seekdir beg = _Seekbeg;
 static constexpr _Seekdir cur = _Seekcur;
 static constexpr _Seekdir end = _Seekend;

 enum
  {
  _Openprot = 0666};
 };

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags
  _Iosb<_Dummy>::hexfloat;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;


class ios_base
 : public _Iosb<int>
 {
public:
 typedef _Fmtflags fmtflags;
 typedef _Iostate iostate;
 typedef _Openmode openmode;
 typedef _Seekdir seekdir;

 typedef ::std:: streamoff streamoff;
 typedef ::std:: streampos streampos;

 enum event
  {
  erase_event, imbue_event, copyfmt_event};

 typedef void (*event_callback)(event, ios_base&, int);
 typedef unsigned int io_state, open_mode, seek_dir;


 class failure
  : public system_error
  {
 public:
  explicit failure(const string &_Message,
   const error_code& _Errcode = make_error_code(io_errc::stream))
   : system_error(_Errcode, _Message)
   {
   }

  explicit failure(const char *_Message,
   const error_code& _Errcode = make_error_code(io_errc::stream))
   : system_error(_Errcode, _Message)
   {
   }


  virtual ~failure() noexcept;





 protected:
  virtual void _Doraise() const;

  };


 class Init
  {
 public:
  Init();

  ~Init() noexcept;

 private:
  static int _Init_cnt;
  };

 operator void *() const
  {
  return (fail() ? 0 : (void *)this);
  }

 explicit operator bool() const
  {
  return (!fail());
  }

 bool operator!() const
  {
  return (fail());
  }

 void clear(iostate _State, bool _Reraise)
  {
  _Mystate = (iostate)(_State & _Statmask);
  if ((_Mystate & _Except) == 0)
   ;
  else if (_Reraise)
           ;
  else if (_Mystate & _Except & badbit)
   failure("ios_base::badbit set")._Raise();
  else if (_Mystate & _Except & failbit)
   failure("ios_base::failbit set")._Raise();
  else
   failure("ios_base::eofbit set")._Raise();
  }

 void clear(iostate _State = goodbit)
  {
  clear(_State, false);
  }

 void clear(io_state _State)
  {
  clear((iostate)_State);
  }

 iostate rdstate() const
  {
  return (_Mystate);
  }

 void setstate(iostate _State, bool _Exreraise)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
  }

 void setstate(iostate _State)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), false);
  }

 void setstate(io_state _State)
  {
  setstate((iostate)_State);
  }

 bool good() const
  {
  return (rdstate() == goodbit);
  }

 bool eof() const
  {
  return ((int)rdstate() & (int)eofbit);
  }

 bool fail() const
  {
  return (((int)rdstate()
   & ((int)badbit | (int)failbit)) != 0);
  }

 bool bad() const
  {
  return (((int)rdstate() & (int)badbit) != 0);
  }

 iostate exceptions() const
  {
  return (_Except);
  }

 void exceptions(iostate _Newexcept)
  {
  _Except = (iostate)((int)_Newexcept & (int)_Statmask);
  clear(_Mystate);
  }

 void exceptions(io_state _State)
  {
  exceptions((iostate)_State);
  }

 fmtflags flags() const
  {
  return (_Fmtfl);
  }

 fmtflags flags(fmtflags _Newfmtflags)
  {
  fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
  return (_Oldfmtflags);
  }

 fmtflags setf(fmtflags _Newfmtflags)
  {
  ios_base::fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)((int)_Fmtfl
   | ((int)_Newfmtflags & (int)_Fmtmask));
  return (_Oldfmtflags);
  }

 fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask)
  {
  ios_base::fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
   | ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
  return (_Oldfmtflags);
  }

 void unsetf(fmtflags _Mask)
  {
  _Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
  }

 streamsize precision() const
  {
  return (_Prec);
  }

 streamsize precision(streamsize _Newprecision)
  {
  streamsize _Oldprecision = _Prec;
  _Prec = _Newprecision;
  return (_Oldprecision);
  }

 streamsize width() const
  {
  return (_Wide);
  }

 streamsize width(streamsize _Newwidth)
  {
  streamsize _Oldwidth = _Wide;
  _Wide = _Newwidth;
  return (_Oldwidth);
  }

 locale getloc() const
  {
  return (*_Ploc);
  }

 locale imbue(const locale& _Loc)
  {
  locale _Oldlocale = *_Ploc;

  if (_Ploc == &_sceLibcClassicLocale)
   _Ploc = new locale(_Loc);
  else
   *_Ploc = _Loc;



  _Callfns(imbue_event);
  return (_Oldlocale);
  }

 static int xalloc()
  {
  {::std:: _Lockit _Lock(2);
   return (_Index++);
  }
  }

 long& iword(int _Idx)
  {
  return (_Findarr(_Idx)._Lo);
  }

 void *& pword(int _Idx)
  {
  return (_Findarr(_Idx)._Vp);
  }

 void register_callback(event_callback _Pfn,
  int _Idx)
  {
  _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
  }

 ios_base& copyfmt(const ios_base& _Other)
  {
  if (this != &_Other)
   {
   _Tidy();

   if (_Ploc == &_sceLibcClassicLocale)
    _Ploc = new locale(*_Other._Ploc);
   else
    *_Ploc = *_Other._Ploc;



   _Fmtfl = _Other._Fmtfl;
   _Prec = _Other._Prec;
   _Wide = _Other._Wide;
   _Iosarray *_Ptr = _Other._Arr;

   for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
    if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
     {
     iword(_Ptr->_Index) = _Ptr->_Lo;
     pword(_Ptr->_Index) = _Ptr->_Vp;
     }

   for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
    _Pfa = _Pfa->_Next)
    register_callback(_Pfa->_Pfn, _Pfa->_Index);

   _Callfns(copyfmt_event);
   exceptions(_Other._Except);
   }
  return (*this);
  }

 static bool sync_with_stdio(bool _Newsync = true)
  {
  {::std:: _Lockit _Lock(2);
   const bool _Oldsync = _Sync;
   _Sync = _Newsync;
   return (_Oldsync);
  }
  }

 void swap(ios_base& _Right)
  {
  if (this != &_Right)
   {
   ::std:: swap(_Mystate, _Right._Mystate);
   ::std:: swap(_Except, _Right._Except);
   ::std:: swap(_Fmtfl, _Right._Fmtfl);
   ::std:: swap(_Prec, _Right._Prec);
   ::std:: swap(_Wide, _Right._Wide);

   ::std:: swap(_Arr, _Right._Arr);
   ::std:: swap(_Calls, _Right._Calls);
   ::std:: swap(_Ploc, _Right._Ploc);
   }
  }

 virtual ~ios_base() noexcept;

 static void _Addstd(ios_base *);

 size_t _Stdstr;

protected:
 ios_base()
  {
  }

 void _Init()
  {
  _Ploc = 0;
  _Stdstr = 0;
  _Except = goodbit;
  _Fmtfl = (fmtflags)(skipws | dec);
  _Prec = 6;
  _Wide = 0;
  _Arr = 0;
  _Calls = 0;
  clear(goodbit);

  _Ploc = &_sceLibcClassicLocale;



  }

private:

 struct _Iosarray
  {
 public:
  _Iosarray(int _Idx, _Iosarray *_Link)
   : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
   {
   }

  _Iosarray *_Next;
  int _Index;
  int :32;
  long _Lo;
  void *_Vp;
  };


 struct _Fnarray
  {
  _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
   : _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
   {
   }

  _Fnarray *_Next;
  int _Index;
  int :32;
  event_callback _Pfn;
  };

 void _Callfns(event _Ev)
  {
  for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
   (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
  }

 _Iosarray& _Findarr(int _Idx)
  {
  _Iosarray *_Ptr1, *_Ptr2;

  for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
   if (_Ptr1->_Index == _Idx)
    return (*_Ptr1);
   else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
    _Ptr2 = _Ptr1;

  if (_Ptr2 != 0)
   {
   _Ptr2->_Index = _Idx;
   return (*_Ptr2);
   }

  _Arr = new _Iosarray(_Idx, _Arr);
  return (*_Arr);
  }

 void _Tidy()
  {
  _Callfns(erase_event);
  _Iosarray *_Ptr1, *_Ptr2;

  for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
   {
   _Ptr2 = _Ptr1->_Next;
   delete _Ptr1;
   }
  _Arr = 0;

  _Fnarray *_Pfa1, *_Pfa2;
  for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
   {
   _Pfa2 = _Pfa1->_Next;
   delete _Pfa1;
   }
  _Calls = 0;
  }

 iostate _Mystate;
 iostate _Except;
 fmtflags _Fmtfl;
 streamsize _Prec;
 streamsize _Wide;
 _Iosarray *_Arr;
 _Fnarray *_Calls;
 locale *_Ploc;

 static int _Index;
 static bool _Sync;

public:
 ios_base(const ios_base&) = delete;
 ios_base& operator=(const ios_base&) = delete;
 };

inline ios_base::_Fmtflags& operator&=(ios_base::_Fmtflags& _Left, ios_base::_Fmtflags _Right) { _Left = (ios_base::_Fmtflags)((int)_Left & (int)_Right); return (_Left); } inline ios_base::_Fmtflags& operator|=(ios_base::_Fmtflags& _Left, ios_base::_Fmtflags _Right) { _Left = (ios_base::_Fmtflags)((int)_Left | (int)_Right); return (_Left); } inline ios_base::_Fmtflags& operator^=(ios_base::_Fmtflags& _Left, ios_base::_Fmtflags _Right) { _Left = (ios_base::_Fmtflags)((int)_Left ^ (int)_Right); return (_Left); } inline constexpr ios_base::_Fmtflags operator&(ios_base::_Fmtflags _Left, ios_base::_Fmtflags _Right) { return ((ios_base::_Fmtflags)((int)_Left & (int)_Right)); } inline constexpr ios_base::_Fmtflags operator|(ios_base::_Fmtflags _Left, ios_base::_Fmtflags _Right) { return ((ios_base::_Fmtflags)((int)_Left | (int)_Right)); } inline constexpr ios_base::_Fmtflags operator^(ios_base::_Fmtflags _Left, ios_base::_Fmtflags _Right) { return ((ios_base::_Fmtflags)((int)_Left ^ (int)_Right)); } inline constexpr ios_base::_Fmtflags operator~(ios_base::_Fmtflags _Left) { return ((ios_base::_Fmtflags)(~(int)_Left & 0xffff)); }
inline ios_base::_Iostate& operator&=(ios_base::_Iostate& _Left, ios_base::_Iostate _Right) { _Left = (ios_base::_Iostate)((int)_Left & (int)_Right); return (_Left); } inline ios_base::_Iostate& operator|=(ios_base::_Iostate& _Left, ios_base::_Iostate _Right) { _Left = (ios_base::_Iostate)((int)_Left | (int)_Right); return (_Left); } inline ios_base::_Iostate& operator^=(ios_base::_Iostate& _Left, ios_base::_Iostate _Right) { _Left = (ios_base::_Iostate)((int)_Left ^ (int)_Right); return (_Left); } inline constexpr ios_base::_Iostate operator&(ios_base::_Iostate _Left, ios_base::_Iostate _Right) { return ((ios_base::_Iostate)((int)_Left & (int)_Right)); } inline constexpr ios_base::_Iostate operator|(ios_base::_Iostate _Left, ios_base::_Iostate _Right) { return ((ios_base::_Iostate)((int)_Left | (int)_Right)); } inline constexpr ios_base::_Iostate operator^(ios_base::_Iostate _Left, ios_base::_Iostate _Right) { return ((ios_base::_Iostate)((int)_Left ^ (int)_Right)); } inline constexpr ios_base::_Iostate operator~(ios_base::_Iostate _Left) { return ((ios_base::_Iostate)(~(int)_Left & 0x1f)); }
inline ios_base::_Openmode& operator&=(ios_base::_Openmode& _Left, ios_base::_Openmode _Right) { _Left = (ios_base::_Openmode)((int)_Left & (int)_Right); return (_Left); } inline ios_base::_Openmode& operator|=(ios_base::_Openmode& _Left, ios_base::_Openmode _Right) { _Left = (ios_base::_Openmode)((int)_Left | (int)_Right); return (_Left); } inline ios_base::_Openmode& operator^=(ios_base::_Openmode& _Left, ios_base::_Openmode _Right) { _Left = (ios_base::_Openmode)((int)_Left ^ (int)_Right); return (_Left); } inline constexpr ios_base::_Openmode operator&(ios_base::_Openmode _Left, ios_base::_Openmode _Right) { return ((ios_base::_Openmode)((int)_Left & (int)_Right)); } inline constexpr ios_base::_Openmode operator|(ios_base::_Openmode _Left, ios_base::_Openmode _Right) { return ((ios_base::_Openmode)((int)_Left | (int)_Right)); } inline constexpr ios_base::_Openmode operator^(ios_base::_Openmode _Left, ios_base::_Openmode _Right) { return ((ios_base::_Openmode)((int)_Left ^ (int)_Right)); } inline constexpr ios_base::_Openmode operator~(ios_base::_Openmode _Left) { return ((ios_base::_Openmode)(~(int)_Left & 0xff)); }
inline ios_base::_Seekdir& operator&=(ios_base::_Seekdir& _Left, ios_base::_Seekdir _Right) { _Left = (ios_base::_Seekdir)((int)_Left & (int)_Right); return (_Left); } inline ios_base::_Seekdir& operator|=(ios_base::_Seekdir& _Left, ios_base::_Seekdir _Right) { _Left = (ios_base::_Seekdir)((int)_Left | (int)_Right); return (_Left); } inline ios_base::_Seekdir& operator^=(ios_base::_Seekdir& _Left, ios_base::_Seekdir _Right) { _Left = (ios_base::_Seekdir)((int)_Left ^ (int)_Right); return (_Left); } inline constexpr ios_base::_Seekdir operator&(ios_base::_Seekdir _Left, ios_base::_Seekdir _Right) { return ((ios_base::_Seekdir)((int)_Left & (int)_Right)); } inline constexpr ios_base::_Seekdir operator|(ios_base::_Seekdir _Left, ios_base::_Seekdir _Right) { return ((ios_base::_Seekdir)((int)_Left | (int)_Right)); } inline constexpr ios_base::_Seekdir operator^(ios_base::_Seekdir _Left, ios_base::_Seekdir _Right) { return ((ios_base::_Seekdir)((int)_Left ^ (int)_Right)); } inline constexpr ios_base::_Seekdir operator~(ios_base::_Seekdir _Left) { return ((ios_base::_Seekdir)(~(int)_Left & 0x3)); }
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 2 3


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {

template<class _Elem,
 class _Traits>
 class basic_streambuf
 {
 typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
 basic_streambuf()

  : _Plocale(&_sceLibcClassicLocale)



  {
  _Init();
  }

 basic_streambuf(_Uninitialized)
  {
  }

 basic_streambuf(const _Myt& _Right)

  : _Plocale(_Right._Plocale == &_sceLibcClassicLocale ? &_sceLibcClassicLocale : new locale(_Right.getloc()))



  {
  _Init();
  setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
  setg(_Right.eback(), _Right.gptr(), _Right.egptr());
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
   setg(_Right.eback(), _Right.gptr(), _Right.egptr());
   pubimbue(_Right.getloc());
   }
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   {
   _Elem *_Pfirst0 = pbase();
   _Elem *_Pnext0 = pptr();
   _Elem *_Pend = epptr();
   _Elem *_Gfirst0 = eback();
   _Elem *_Gnext0 = gptr();
   _Elem *_Gend = egptr();

   setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
   _Right.setp(_Pfirst0, _Pnext0, _Pend);

   setg(_Right.eback(), _Right.gptr(), _Right.egptr());
   _Right.setg(_Gfirst0, _Gnext0, _Gend);

   ::std:: swap(_Plocale, _Right._Plocale);
   }
  }

public:
 typedef _Elem char_type;
 typedef _Traits traits_type;

 virtual ~basic_streambuf() noexcept
  {

  if (_Plocale != &_sceLibcClassicLocale)
   delete _Plocale;



  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 pos_type pubseekoff(off_type _Off,
  ios_base::seekdir _Way,
  ios_base::openmode _Mode = ios_base::in | ios_base::out)
  {
  return (seekoff(_Off, _Way, _Mode));
  }

 pos_type pubseekoff(off_type _Off,
  ios_base::seek_dir _Way,
  ios_base::open_mode _Mode)
  {
  return (pubseekoff(_Off, (ios_base::seekdir)_Way,
   (ios_base::openmode)_Mode));
  }

 pos_type pubseekpos(pos_type _Pos,
  ios_base::openmode _Mode = ios_base::in | ios_base::out)
  {
  return (seekpos(_Pos, _Mode));
  }

 pos_type pubseekpos(pos_type _Pos,
  ios_base::open_mode _Mode)
  {
  return (seekpos(_Pos, (ios_base::openmode)_Mode));
  }

 _Myt *pubsetbuf(_Elem *_Buffer,
  streamsize _Count)
  {
  return (setbuf(_Buffer, _Count));
  }

 locale pubimbue(const locale &_Newlocale)
  {
  locale _Oldlocale = *_Plocale;
  imbue(_Newlocale);

  if (_Plocale == &_sceLibcClassicLocale)
   _Plocale = new locale(_Newlocale);
  else
   *_Plocale = _Newlocale;



  return (_Oldlocale);
  }

 locale getloc() const
  {
  return (*_Plocale);
  }

 streamsize in_avail()
  {
  streamsize _Res = _Gnavail();
  return (0 < _Res ? _Res : showmanyc());
  }

 int pubsync()
  {
  return (sync());
  }

 int_type sbumpc()
  {
  return (0 < _Gnavail()
   ? _Traits::to_int_type(*_Gninc()) : uflow());
  }

 int_type sgetc()
  {
  return (0 < _Gnavail()
   ? _Traits::to_int_type(*gptr()) : underflow());
  }

 streamsize sgetn(_Elem *_Ptr,
  streamsize _Count)
  {
  return (xsgetn(_Ptr, _Count));
  }

 int_type snextc()
  {
  return (1 < _Gnavail()
   ? _Traits::to_int_type(*_Gnpreinc())
   : _Traits::eq_int_type(_Traits::eof(), sbumpc())
    ? _Traits::eof() : sgetc());
  }

 int_type sputbackc(_Elem _Ch)
  {
  return (gptr() != 0 && eback() < gptr()
   && _Traits::eq(_Ch, gptr()[-1])
   ? _Traits::to_int_type(*_Gndec())
   : pbackfail(_Traits::to_int_type(_Ch)));
  }

 void stossc()
  {
  if (0 < _Gnavail())
   _Gninc();
  else
   uflow();
  }

 int_type sungetc()
  {
  return (gptr() != 0 && eback() < gptr()
   ? _Traits::to_int_type(*_Gndec()) : pbackfail());
  }

 int_type sputc(_Elem _Ch)
  {
  return (0 < _Pnavail()
   ? _Traits::to_int_type(*_Pninc() = _Ch)
   : overflow(_Traits::to_int_type(_Ch)));
  }

 streamsize sputn(const _Elem *_Ptr,
  streamsize _Count)
  {
  return (xsputn(_Ptr, _Count));
  }

 virtual void _Lock()
  {
  }

 virtual void _Unlock()
  {
  }

protected:
 _Elem *eback() const
  {
  return (*_IGfirst);
  }

 _Elem *gptr() const
  {
  return (*_IGnext);
  }

 _Elem *pbase() const
  {
  return (*_IPfirst);
  }

 _Elem *pptr() const
  {
  return (*_IPnext);
  }
# 358 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 3
 _Elem *egptr() const
  {
  return (*_IGlast);
  }

 void gbump(int _Off)
  {
  *_IGnext += _Off;
  }

 void setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
  {
  *_IGfirst = _First, *_IGnext = _Next, *_IGlast = _Last;
  }

 _Elem *epptr() const
  {
  return (*_IPlast);
  }

 _Elem *_Gndec()
  {
  return (--*_IGnext);
  }

 _Elem *_Gninc()
  {
  return ((*_IGnext)++);
  }

 _Elem *_Gnpreinc()
  {
  return (++(*_IGnext));
  }

 streamsize _Gnavail() const
  {
  return ((streamsize)(*_IGnext != 0 ? *_IGlast - *_IGnext : 0));
  }

 void pbump(int _Off)
  {
  *_IPnext += _Off;
  }

 void setp(_Elem *_First, _Elem *_Last)
  {
  *_IPfirst = _First;
  *_IPnext = _First;
  *_IPlast = _Last;
  }

 void setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
  {
  *_IPfirst = _First;
  *_IPnext = _Next;
  *_IPlast = _Last;
  }

 _Elem *_Pninc()
  {
  return ((*_IPnext)++);
  }

 streamsize _Pnavail() const
  {
  return ((streamsize)(*_IPnext != 0 ? *_IPlast - *_IPnext : 0));
  }

 void _Init()
  {
  _IGfirst = &_Gfirst;
  _IPfirst = &_Pfirst;
  _IGnext = &_Gnext;
  _IPnext = &_Pnext;
  _IGlast = &_Glast;
  _IPlast = &_Plast;
  setp(0, 0);
  setg(0, 0, 0);
  }

 void _Init(_Elem **_Gf, _Elem **_Gn, _Elem **_Gl,
  _Elem **_Pf, _Elem **_Pn, _Elem **_Pl)
  {
  _IGfirst = _Gf;
  _IPfirst = _Pf;
  _IGnext = _Gn;
  _IPnext = _Pn;
  _IGlast = _Gl;
  _IPlast = _Pl;
  }



public:
 int allocate()
  {
  return (0);
  }

 _Elem *base() const
  {
  return (eback());
  }

 int blen() const
  {
  return (egptr() == 0 ? 0 : (int)(egptr() - eback()));
  }

 int in_avail() const
  {
  return (egptr() == 0 ? 0 : (int)(egptr() - gptr()));
  }

 int out_waiting() const
  {
  return (epptr() == 0 ? 0 : (int)(epptr() - pptr()));
  }

 void setb(char *, char *, int)
  {
  }


 virtual int_type overflow(int_type = _Traits::eof())
  {
  return (_Traits::eof());
  }

 virtual int_type pbackfail(int_type = _Traits::eof())
  {
  return (_Traits::eof());
  }

 virtual streamsize showmanyc()
  {
  return (0);
  }

 virtual int_type underflow()
  {
  return (_Traits::eof());
  }

 virtual int_type uflow()
  {
  return (_Traits::eq_int_type(_Traits::eof(), underflow())
   ? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
  }

 virtual streamsize xsgetn(_Elem * _Ptr,
  streamsize _Count)
  {
  int_type _Meta;
  streamsize _Size, _Copied;

  for (_Copied = 0; 0 < _Count; )
   if (0 < (_Size = _Gnavail()))
    {
    if (_Count < _Size)
     _Size = _Count;
    _Traits::copy(_Ptr, gptr(), (size_t)_Size);
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    gbump((int)_Size);
    }
   else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
    break;
   else
    {
    *_Ptr++ = _Traits::to_char_type(_Meta);
    ++_Copied;
    --_Count;
    }

  return (_Copied);
  }

 virtual streamsize xsputn(const _Elem *_Ptr,
  streamsize _Count)
  {
  streamsize _Size, _Copied;

  for (_Copied = 0; 0 < _Count; )
   if (0 < (_Size = _Pnavail()))
    {
    if (_Count < _Size)
     _Size = _Count;
    _Traits::copy(pptr(), _Ptr, (size_t)_Size);
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    pbump((int)_Size);
    }
   else if (_Traits::eq_int_type(_Traits::eof(),
    overflow(_Traits::to_int_type(*_Ptr))))
    break;
   else
    {
    ++_Ptr;
    ++_Copied;
    --_Count;
    }

  return (_Copied);
  }

 virtual pos_type seekoff(off_type,
  ios_base::seekdir,
  ios_base::openmode = ios_base::in | ios_base::out)
  {
  return (streampos(_BADOFF));
  }

 virtual pos_type seekpos(pos_type,
  ios_base::openmode = ios_base::in | ios_base::out)
  {
  return (streampos(_BADOFF));
  }

 virtual _Myt *setbuf(_Elem *, streamsize)
  {
  return (this);
  }

 virtual int sync()
  {
  return (0);
  }

 virtual void imbue(const locale&)
  {
  }

private:
 _Elem *_Gfirst;
 _Elem *_Pfirst;
 _Elem **_IGfirst;
 _Elem **_IPfirst;
 _Elem *_Gnext;
 _Elem *_Pnext;
 _Elem **_IGnext;
 _Elem **_IPnext;
# 611 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 3
 _Elem *_Glast;
 _Elem *_Plast;
 _Elem **_IGlast;
 _Elem **_IPlast;


protected:
 locale *_Plocale;
 };


template<class _Elem,
 class _Traits>
 class istreambuf_iterator
  : public iterator<input_iterator_tag,
   _Elem, typename _Traits::off_type, const _Elem *, _Elem>
 {
 typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf<_Elem, _Traits> streambuf_type;
 typedef basic_istream<_Elem, _Traits> istream_type;

 typedef typename traits_type::int_type int_type;
 typedef const _Elem *pointer;

 constexpr istreambuf_iterator(streambuf_type *_Sb = 0) noexcept
  : _Strbuf(_Sb),
   _Got(_Sb == 0),
   _Val(0)
  {
  }

 istreambuf_iterator(istream_type& _Istr) noexcept
  : _Strbuf(_Istr.rdbuf()),
   _Got(_Istr.rdbuf() == 0),
   _Val(0)
  {
  }

 _Elem operator*() const
  {
  if (!_Got)
   _Peek();






  return (_Val);
  }

 const _Elem *operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {





  _Inc();
  return (*this);
  }

 _Myt operator++(int)
  {
  if (!_Got)
   _Peek();
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 bool equal(const _Myt& _Right) const
  {
  bool _Lvalid = _Strbuf != 0
   && !traits_type::eq_int_type(traits_type::eof(),
    _Strbuf->sgetc());
  bool _Rvalid = _Right._Strbuf != 0
   && !traits_type::eq_int_type(traits_type::eof(),
    _Right._Strbuf->sgetc());
  return (_Lvalid == _Rvalid);
  }

private:
 void _Inc()
  {
  if (_Strbuf == 0
   || traits_type::eq_int_type(traits_type::eof(),
    _Strbuf->sbumpc()))
   _Strbuf = 0, _Got = true;
  else
   _Got = false;
  }

 _Elem _Peek() const
  {
  int_type _Meta;
  if (_Strbuf == 0
   || traits_type::eq_int_type(traits_type::eof(),
    _Meta = _Strbuf->sgetc()))
   _Strbuf = 0;
  else
   _Val = traits_type::to_char_type(_Meta);
  _Got = true;
  return (_Val);
  }

 mutable streambuf_type *_Strbuf;
 mutable bool _Got;
 mutable _Elem _Val;
 };

template<class _Elem,
 class _Traits>
 struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
  : public true_type
 {
 };


template<class _Elem,
 class _Traits> inline
 bool operator==(
  const istreambuf_iterator<_Elem, _Traits>& _Left,
  const istreambuf_iterator<_Elem, _Traits>& _Right)
 {
 return (_Left.equal(_Right));
 }

template<class _Elem,
 class _Traits> inline
 bool operator!=(
  const istreambuf_iterator<_Elem, _Traits>& _Left,
  const istreambuf_iterator<_Elem, _Traits>& _Right)
 {
 return (!(_Left == _Right));
 }


template<class _Elem,
 class _Traits>
 class ostreambuf_iterator
  : public _Outit
 {
 typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf<_Elem, _Traits> streambuf_type;
 typedef basic_ostream<_Elem, _Traits> ostream_type;

 ostreambuf_iterator(streambuf_type *_Sb) noexcept
  : _Failed(false), _Strbuf(_Sb)
  {
  }

 ostreambuf_iterator(ostream_type& _Ostr) noexcept
  : _Failed(false), _Strbuf(_Ostr.rdbuf())
  {
  }

 _Myt& operator=(_Elem _Right)
  {
  if (_Strbuf == 0
   || traits_type::eq_int_type(_Traits::eof(),
    _Strbuf->sputc(_Right)))
   _Failed = true;
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt& operator++(int)
  {
  return (*this);
  }

 bool failed() const noexcept
  {
  return (_Failed);
  }

private:
 bool _Failed;
 streambuf_type *_Strbuf;
 };

template<class _Elem,
 class _Traits>
 struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
  : public true_type
 {
 };
}


#pragma clang diagnostic pop
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocnum" 2 3



extern "C" {
extern float _Stofx(const char *, char **,
 long, int *);
extern double _Stodx(const char *, char **,
 long, int *);
extern long double _Stoldx(const char *, char **,
 long, int *);
extern long _Stolx(const char *, char **,
 int, int *);
extern unsigned long _Stoulx(const char *, char **,
 int, int *);
extern long long _Stollx(const char *, char **,
 int, int *);
extern unsigned long long _Stoullx(const char *, char **,
 int, int *);
}


namespace std {



template<class _Elem> inline
 size_t _Find_elem(_Elem *_Base, _Elem _Ch)
 {
 _Elem *_Ptr = _Base;
 for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
  ;
 return ((size_t)(_Ptr - _Base));
 }

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
 {
 size_t _Count = :: wcslen(_Ptr) + 1;
 wchar_t *_Ptrdest = (wchar_t *):: malloc(_Count * sizeof (wchar_t));
 if (!_Ptrdest)
  _Xbad_alloc();
 :: wmemcpy(_Ptrdest, _Ptr, _Count);
 return (_Ptrdest);
 }


template<class _Elem>
 class numpunct
  : public locale::facet
 {
public:
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  string_type;
 typedef _Elem char_type;

 static locale::id id;

 _Elem decimal_point() const
  {
  return (do_decimal_point());
  }

 _Elem thousands_sep() const
  {
  return (do_thousands_sep());
  }

 string grouping() const
  {
  return (do_grouping());
  }

 string_type falsename() const
  {
  return (do_falsename());
  }

 string_type truename() const
  {
  return (do_truename());
  }

 explicit numpunct(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
   if (_Kseparator == 0)
    _Kseparator =
     _Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
  }
  }

 numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
  : locale::facet(_Refs)
  {
  _Init(_Lobj, _Isdef);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new numpunct<_Elem>(
    _Locinfo(_Ploc->c_str()), 0, true);
  return (4);
  }

protected:
 virtual ~numpunct() noexcept
  {
  _Tidy();
  }

 numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
  : locale::facet(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj(_Locname);
   _Init(_Lobj, _Isdef);
  }
  }

 template<class _Elem2>
  void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
  {
  _Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
  _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
  }

 void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
  {
  const lconv *_Ptr = _Lobj._Getlconv();
  _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();

  _Grouping = 0;
  _Falsename = 0;
  _Truename = 0;

  {{
  _Grouping = _Makloc<_Elem>::Grouping(_Cvt);
  _Falsename = _Makloc<_Elem>::Falsename(_Cvt);
  _Truename = _Makloc<_Elem>::Truename(_Cvt);
  } if (0) {
  _Tidy();
          ;
  }}

  if (_Isdef)
   {

   _Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
   _Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
   }
  else
   _Getvals((_Elem)0, _Ptr, _Cvt);
  }

 virtual _Elem do_decimal_point() const
  {
  return (_Dp);
  }

 virtual _Elem do_thousands_sep() const
  {
  return (_Kseparator);
  }

 virtual string do_grouping() const
  {
  return (string(_Grouping));
  }

 virtual string_type do_falsename() const
  {
  return (string_type(_Falsename));
  }

 virtual string_type do_truename() const
  {
  return (string_type(_Truename));
  }

private:
 void _Tidy()
  {
  _Makloc<_Elem>::destroy(const_cast<char *>(_Grouping));
  _Makloc<_Elem>::destroy(const_cast<_Elem *>(_Falsename));
  _Makloc<_Elem>::destroy(const_cast<_Elem *>(_Truename));
 }

 const char *_Grouping;
 _Elem _Dp;
 _Elem _Kseparator;
 const _Elem *_Falsename;
 const _Elem *_Truename;
 };


template<class _Elem>
 class numpunct_byname
  : public numpunct<_Elem>
 {
public:
 explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
  : numpunct<_Elem>(_Locname, _Refs)
  {
  }

 explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
  : numpunct<_Elem>(_Str.c_str(), _Refs)
  {
  }

 explicit numpunct_byname(const _Locinfo& _Lobj, size_t _Refs = 0)
  : numpunct<_Elem>(_Lobj, _Refs)
  {
  }

protected:
 virtual ~numpunct_byname() noexcept
  {
  }
 };


template<class _Elem>
 locale::id numpunct<_Elem>::id;

extern template class numpunct<char>;
extern template class numpunct<wchar_t>;


template<class _Elem,
 class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
 class num_get
  : public locale::facet
 {
public:
 typedef numpunct<_Elem> _Mypunct;
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  _Mystr;

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new num_get<_Elem, _InIt>(
    _Locinfo(_Ploc->c_str()));
  return (4);
  }

 static locale::id id;

protected:
 virtual ~num_get() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

public:
 explicit num_get(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  _Init(_Lobj);
  }

 typedef _Elem char_type;
 typedef _InIt iter_type;

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   bool& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned short& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned int& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }


 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }


 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   float& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   double& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long double& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   void *& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

protected:
 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   bool& _Val) const
  {
                             ;
  int _Ans = -1;

  if (_Iosbase.flags() & ios_base::boolalpha)
   {
   typedef typename _Mystr::size_type _Mystrsize;
   const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
   _Mystr _Str((_Mystrsize)1, (char_type)0);
   _Str += _Punct_fac.falsename();
   _Str += (char_type)0;
   _Str += _Punct_fac.truename();
   _Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
   }
  else
   {
   char _Ac[32], *_Ep;
   int _Errno = 0;
   const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
    _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
     _Iosbase.getloc()), &_Errno);
   if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
    _Ans = _Ulo;
   }

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ans < 0)
   {
   _State |= ios_base::failbit;
   _Val = true;
   }
  else
   _Val = _Ans != 0;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned short& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
   _Iosbase.getloc());
  char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ptr || (_Ac[0] == '-' && _Ans != 0))
   {
   _State |= ios_base::failbit;
   _Val = 0;
   }
  else if (_Errno != 0 || 0xffff < _Ans)
   {
   _State |= ios_base::failbit;
   _Val = 0xffff;
   }
  else
   _Val = (unsigned short)(_Ans);
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned int& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
   _Iosbase.getloc());
  char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ptr || (_Ac[0] == '-' && _Ans != 0))
   {
   _State |= ios_base::failbit;
   _Val = 0;
   }
  else if (_Errno != 0 || 0xffffffff < _Ans)
   {
   _State |= ios_base::failbit;
   _Val = 0xffffffff;
   }
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const long _Ans = :: _Stolx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  _Val = _Ans;
  if (_Ep == _Ac || (_Ac[0] == '-' && _Ans != 0))
   {
   _State |= ios_base::failbit;
   _Val = 0;
   }
  else if (_Errno != 0)
   _State |= ios_base::failbit;
  return (_First);
  }


 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const long long _Ans = :: _Stollx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const unsigned long long _Ans = :: _Stoullx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  _Val = _Ans;
  if (_Ep == _Ac || (_Ac[0] == '-' && _Ans != 0))
   {
   _State |= ios_base::failbit;
   _Val = 0;
   }
  else if (_Errno != 0)
   _State |= ios_base::failbit;
  return (_First);
  }


 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   float& _Val) const
  {
                             ;
  char _Ac[8 + 48 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  float _Ans = :: _Stofx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexpf(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   double& _Val) const
  {
                             ;
  char _Ac[8 + 48 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  double _Ans = :: _Stodx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexp(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long double& _Val) const
  {
                             ;
  char _Ac[8 + 48 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  long double _Ans = :: _Stoldx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexpl(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   void *& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;


  int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
   _Iosbase.getloc());
  const unsigned long long _Ans =
   (sizeof (void *) == sizeof (unsigned long))
    ? (unsigned long long):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
    : :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);







  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = (void *)((char *)0 + _Ans);
  return (_First);
  }

private:
 int _Getifld(char *_Ac,
  _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
   const locale& _Loc) const
  {
  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
  const string _Grouping = _Punct_fac.grouping();
  const _Elem _Kseparator = _Grouping.size() == 0
   ? (_Elem)0 : _Punct_fac.thousands_sep();

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24};
  static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Loc);
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  char *_Ptr = _Ac;

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  _Basefield &= ios_base::basefield;
  int _Base = _Basefield == ios_base::oct ? 8
   : _Basefield == ios_base::hex ? 16
   : _Basefield == ios_base::_Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if (_First != _Last && *_First == _Atoms[0])
   {
   _Seendigit = true, ++_First;
   if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
     || *_First == _Atoms[_NUMGET_XOFF])
    && (_Base == 0 || _Base == 16))
    _Base = 16, _Seendigit = false, ++_First;
   else if (_Base == 0)
    _Base = 8;
   }

  size_t _Dlen = _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6;
  string _Groups((size_t)1, (char)_Seendigit);
  size_t _Group = 0;

  for (char *const _Pe = &_Ac[32 - 1];
   _First != _Last; ++_First)
   {
   size_t _Idx = _Find_elem(_Atoms, *_First);
   if (_Idx < _Dlen)
    {
    *_Ptr = _Src[_Idx];
    if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
     ++_Ptr, _Nonzero = true;
    _Seendigit = true;
    if (_Groups[_Group] != 0x7f)
     ++_Groups[_Group];
    }
   else if (_Groups[_Group] == '\0'
    || _Kseparator == (_Elem)0
    || *_First != _Kseparator)
    break;
   else
    {
    _Groups.append((string::size_type)1, '\0');
    ++_Group;
    }
   }

  if (_Group == 0)
   ;
  else if ('\0' < _Groups[_Group])
   ++_Group;
  else
   _Seendigit = false;

  for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
   if (*_Pg == 0x7f)
    break;
   else if ((0 < --_Group && *_Pg != _Groups[_Group])
    || (0 == _Group && *_Pg < _Groups[_Group]))
    _Seendigit = false;
   else if ('\0' < _Pg[1])
    ++_Pg;

  if (_Seendigit && !_Nonzero)
   *_Ptr++ = '0';
  else if (!_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  return (_Base);
  }

 int _Getffld(char *_Ac,
  _InIt& _First, _InIt &_Last,
  ios_base& _Iosbase, int *_Phexexp) const
  {
  if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
   return (_Getffldx(_Ac, _First, _Last,
    _Iosbase, _Phexexp));

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  char *_Ptr = _Ac;
  bool _Bad = false;
  bool _Sticky = false;

  enum {
   _NUMGET_SIGNOFF = 10,
   _NUMGET_EOFF = 12};
  static const char _Src[] = {"0123456789-+Ee"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  char *_Leading = _Ptr;
  *_Ptr++ = '0';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;
  size_t _Idx;

  const char *_Pg = &_Grouping[0];
  if (*_Pg == 0x7f || *_Pg <= '\0')
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
     _Seendigit = true, ++_First)
    if (48 <= _Significant)
     {
     ++_Pten;
     if (0 < _Idx)
      _Sticky = true;
     }
    else if (_Idx == 0 && _Significant == 0)
     ;
    else
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping.size() == 0
    ? (_Elem)0 : _Punct_fac.thousands_sep();
   string _Groups((size_t)1, '\0');
   size_t _Group = 0;

   for (; _First != _Last; ++_First)
    if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
     {
     _Seendigit = true;
     if (48 <= _Significant)
      {
      ++_Pten;
      if (0 < _Idx)
       _Sticky = true;
      }
     else if (_Idx == 0 && _Significant == 0)
      ;
     else
      {
      *_Ptr++ = _Src[_Idx];
      ++_Significant;
      }
     if (_Groups[_Group] != 0x7f)
      ++_Groups[_Group];
     }
    else if (_Groups[_Group] == '\0'
     || _Kseparator == (_Elem)0
     || *_First != _Kseparator)
     break;
    else
     {
     _Groups.append((size_t)1, '\0');
     ++_Group;
     }
   if (_Group == 0)
    ;
   else if ('\0' < _Groups[_Group])
    ++_Group;
   else
    _Bad = true;

   while (!_Bad && 0 < _Group)
    if (*_Pg == 0x7f)
     break;
    else if ((0 < --_Group && *_Pg != _Groups[_Group])
     || (0 == _Group && *_Pg < _Groups[_Group]))
     _Bad = true;
    else if ('\0' < _Pg[1])
     ++_Pg;
   }

  if (_First != _Last && *_First == _Punct_fac.decimal_point())
   *_Ptr++ = localeconv()->decimal_point[0], ++_First;

  if (_Significant == 0)
   {
   for (; _First != _Last && *_First == _Atoms[0];
    _Seendigit = true, ++_First)
    --_Pten;
   if (_Pten < 0)
    *_Ptr++ = '0', ++_Pten;
   }

  for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
    _Seendigit = true, ++_First)
   if (_Significant < 48)
    {
    *_Ptr++ = _Src[_Idx];
    ++_Significant;
    }
   else if (0 < _Idx)
    _Sticky = true;

  if (_Sticky)
   {
   char *_Px = _Ptr;
   for (; --_Px != _Leading; )
    {
    if (*_Px == localeconv()->decimal_point[0])
     ;
    else if (*_Px != '9')
     {
     ++*_Px;
     break;
     }
    else
     *_Px = '0';
    }

   if (_Px == _Leading)
    {
    *_Px = '1';
    ++_Pten;
    }
   }

  if (_Seendigit && _First != _Last
   && (*_First == _Atoms[_NUMGET_EOFF + 1]
    || *_First == _Atoms[_NUMGET_EOFF]))
   {
   *_Ptr++ = 'e', ++_First;
   _Seendigit = false, _Significant = 0;

   if (_First == _Last)
    ;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
    *_Ptr++ = '+', ++_First;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF])
    *_Ptr++ = '-', ++_First;
   for (; _First != _Last && *_First == _Atoms[0]; )
    _Seendigit = true, ++_First;
   if (_Seendigit)
    *_Ptr++ = '0';
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
    _Seendigit = true, ++_First)
    if (_Significant < 8)
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
   }

  if (_Bad || !_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  return (_Pten);
  }

 int _Getffldx(char *_Ac,
  _InIt& _First, _InIt &_Last,
  ios_base& _Iosbase, int *_Phexexp) const
  {
  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24,
   _NUMGET_POFF = 26};
  static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  char *_Ptr = _Ac;
  bool _Bad = false;
  size_t _Idx;

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  *_Ptr++ = '0';
  *_Ptr++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if (_First == _Last || *_First != _Atoms[0])
   ;
  else if (++_First != _Last
   && (*_First == _Atoms[_NUMGET_XOFF + 1]
    || *_First == _Atoms[_NUMGET_XOFF]))
   ++_First;
  else
   _Seendigit = true;

  const char *_Pg = &_Grouping[0];
  if (*_Pg == 0x7f || *_Pg <= '\0')
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
     _Seendigit = true, ++_First)
    if (48 <= _Significant)
     ++_Phex;
    else if (_Idx == 0 && _Significant == 0)
     ;
    else
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping.size() == 0
    ? (_Elem)0 : _Punct_fac.thousands_sep();
   string _Groups((size_t)1, '\0');
   size_t _Group = 0;

   for (; _First != _Last; ++_First)
    if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
     {
     _Seendigit = true;
     if (48 <= _Significant)
      ++_Phex;
     else if (_Idx == 0 && _Significant == 0)
      ;
     else
      {
      *_Ptr++ = _Src[_Idx];
      ++_Significant;
      }
     if (_Groups[_Group] != 0x7f)
      ++_Groups[_Group];
     }
    else if (_Groups[_Group] == '\0'
     || _Kseparator == (_Elem)0
     || *_First != _Kseparator)
     break;
    else
     {
     _Groups.append((size_t)1, '\0');
     ++_Group;
     }
   if (_Group == 0)
    ;
   else if ('\0' < _Groups[_Group])
    ++_Group;
   else
    _Bad = true;

   while (!_Bad && 0 < _Group)
    if (*_Pg == 0x7f)
     break;
    else if ((0 < --_Group && *_Pg != _Groups[_Group])
     || (0 == _Group && *_Pg < _Groups[_Group]))
     _Bad = true;
    else if ('\0' < _Pg[1])
     ++_Pg;
   }

  if (_Seendigit && _Significant == 0)
   *_Ptr++ = '0';

  if (_First != _Last && *_First == _Punct_fac.decimal_point())
   *_Ptr++ = localeconv()->decimal_point[0], ++_First;

  if (_Significant == 0)
   {
   for (; _First != _Last && *_First == _Atoms[0];
    _Seendigit = true, ++_First)
    --_Phex;
   if (_Phex < 0)
    *_Ptr++ = '0', ++_Phex;
   }

  for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++_First)
   if (_Significant < 48)
    {
    *_Ptr++ = _Src[_Idx];
    ++_Significant;
    }

  if (_Seendigit && _First != _Last
   && (*_First == _Atoms[_NUMGET_POFF + 1]
    || *_First == _Atoms[_NUMGET_POFF]))
   {
   *_Ptr++ = 'p', ++_First;
   _Seendigit = false, _Significant = 0;

   if (_First == _Last)
    ;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
    *_Ptr++ = '+', ++_First;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF])
    *_Ptr++ = '-', ++_First;
   for (; _First != _Last && *_First == _Atoms[0]; )
    _Seendigit = true, ++_First;
   if (_Seendigit)
    *_Ptr++ = '0';
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++_First)
    if (_Significant < 8)
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
   }

  if (_Bad || !_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  *_Phexexp = _Phex;
  return (0);
  }
 };


template<class _Elem,
 class _InIt>
 locale::id num_get<_Elem, _InIt>::id;

extern template class num_get<char>;
extern template class num_get<wchar_t>;


template<class _Elem,
 class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
 class num_put
  : public locale::facet
 {
public:
 typedef numpunct<_Elem> _Mypunct;
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  _Mystr;

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new num_put<_Elem, _OutIt>(
    _Locinfo(_Ploc->c_str()));
  return (4);
  }

 static locale::id id;

protected:
 virtual ~num_put() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

public:
 explicit num_put(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  _Init(_Lobj);
  }

 typedef _Elem char_type;
 typedef _OutIt iter_type;

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, bool _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }


 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }


 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, double _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long double _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

protected:
 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, bool _Val) const
  {
                       ;
  if (!(_Iosbase.flags() & ios_base::boolalpha))
   return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
  else
   {
   const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
   _Mystr _Str;
   if (_Val)
    _Str.assign(_Punct_fac.truename());
   else
    _Str.assign(_Punct_fac.falsename());

   size_t _Fillcount = _Iosbase.width() <= 0
    || (size_t)_Iosbase.width() <= _Str.size()
     ? 0 : (size_t)_Iosbase.width() - _Str.size();

   if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
    {
    _Dest = _Rep(_Dest, _Fill, _Fillcount);
    _Fillcount = 0;
    }
   _Dest = _Put(_Dest, _Str.c_str(), _Str.size());
   _Iosbase.width(0);
   return (_Rep(_Dest, _Fill, _Fillcount));
   }
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long _Val) const
  {
  char _Buf[2 * 32], _Fmt[6];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf),_Ifmt(_Fmt, "ld",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
  {
  char _Buf[2 * 32], _Fmt[6];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf),_Ifmt(_Fmt, "lu",
    _Iosbase.flags()), _Val)));
  }


 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long long _Val) const
  {
  char _Buf[2 * 32], _Fmt[8];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
  {
  char _Buf[2 * 32], _Fmt[8];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu",
    _Iosbase.flags()), _Val)));
  }


 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, double _Val) const
  {
  string _Buf;
  char _Fmt[8];
  bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
   == ios_base::fixed;
  bool _Ishex = (_Iosbase.flags() & ios_base::floatfield)
   == (ios_base::fixed | ios_base::scientific);
  streamsize _Precision = _Ishex ? 6 : _Iosbase.precision();
  size_t _Bufsize = (size_t)_Precision;
  if (_Isfixed && 1e10 < :: fabs(_Val))
   {
   int _Ptwo;
   (void):: frexp(_Val, &_Ptwo);
   _Bufsize += (:: abs)(_Ptwo) * 30103L / 100000L;
   }
  _Buf.resize(_Bufsize + 50);

  int _Ngen = :: snprintf((char *)_Buf.c_str(), _Bufsize + 50,
   _Ffmt(_Fmt, 0, _Iosbase.flags()), _Precision, _Val);
  return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long double _Val) const
  {
  string _Buf;
  char _Fmt[8];
  bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
   == ios_base::fixed;
  bool _Ishex = (_Iosbase.flags() & ios_base::floatfield)
   == (ios_base::fixed | ios_base::scientific);
  streamsize _Precision = _Ishex
   ? 6 : _Iosbase.precision();
  size_t _Bufsize = (size_t)_Precision;
  if (_Isfixed && 1e10 < :: fabsl(_Val))
   {
   int _Ptwo;
   (void):: frexpl(_Val, &_Ptwo);
   _Bufsize += (:: abs)(_Ptwo) * 30103L / 100000L;
   }
  _Buf.resize(_Bufsize + 50);

  int _Ngen = :: snprintf((char *)_Buf.c_str(), _Bufsize + 50,
   _Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);
  return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
  {
  char _Buf[2 * 32];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf), "%p", _Val)));
  }

private:
 char *_Ffmt(char *_Fmt,
  char _Spec, ios_base::fmtflags _Flags) const
  {
  char *_Ptr = _Fmt;
  *_Ptr++ = '%';

  if (_Flags & ios_base::showpos)
   *_Ptr++ = '+';
  if (_Flags & ios_base::showpoint)
   *_Ptr++ = '#';
  if ((_Flags & ios_base::floatfield) != (ios_base::fixed | ios_base::scientific))
   {
   *_Ptr++ = '.';
   *_Ptr++ = '*';
   }
  if (_Spec != '\0')
   *_Ptr++ = _Spec;

  ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
  if (_Flags & ios_base::uppercase)
   *_Ptr++ = _Ffl == ios_base::fixed ? 'f'
    : _Ffl == ios_base::hexfloat ? 'A'
    : _Ffl == ios_base::scientific ? 'E' : 'G';
  else
   *_Ptr++ = _Ffl == ios_base::fixed ? 'f'
    : _Ffl == ios_base::hexfloat ? 'a'
    : _Ffl == ios_base::scientific ? 'e' : 'g';

  *_Ptr = '\0';
  return (_Fmt);
  }

 _OutIt _Fput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
   size_t _Beforepoint, size_t _Afterpoint,
    size_t _Trailing, size_t _Count) const
  {
                       ;
  size_t _Prefix = 0;
  if (0 < _Count && (*_Buf == '+' || *_Buf == '-'))
   _Prefix = 1;
  else if (2 <= _Count && _Buf[0] == '0'
   && (_Buf[1] == 'x' || _Buf[1] == 'X'))
   _Prefix = 2;
  bool _Isnan_inf = _Buf[_Prefix] == 'i' || _Buf[_Prefix] == 'I'
   || _Buf[_Prefix] == 'n' || _Buf[_Prefix] == 'N';
  const char *_Exps;
  if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
   _Exps = "eE";
  else
   {
   _Exps = "pP";
   }
  const size_t _Eoff =
   :: strcspn(&_Buf[0], _Exps);
  char _Dp[2] = {"."};
  _Dp[0] = :: localeconv()->decimal_point[0];
  const size_t _Poff =
   :: strcspn(&_Buf[0], &_Dp[0]);

  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  const _Elem _E0 = _Ctype_fac.widen('0');
  _Mystr _Groupstring(_Count, _Elem(0));
  _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  const _Elem _Kseparator = _Punct_fac.thousands_sep();

  size_t _Off = _Beforepoint;
  if (_Poff == _Count)
   {
   _Off += _Eoff;
   _Groupstring.insert(_Eoff, _Beforepoint, _E0);
   }
  else
   {
   _Off += _Poff;
   _Groupstring.insert(_Eoff, _Trailing, _E0);
   _Groupstring.insert(_Poff + 1, _Afterpoint, _E0);
   _Groupstring[_Poff] = _Punct_fac.decimal_point();
   _Groupstring.insert(_Poff, _Beforepoint, _E0);
   }

  const char *_Pg = &_Grouping[0];
  while (*_Pg != 0x7f && '\0' < *_Pg
   && (size_t)*_Pg < _Off - _Prefix
   && !_Isnan_inf)
   {
   _Groupstring.insert(_Off -= (size_t)*_Pg, (size_t)1, _Kseparator);
   if ('\0' < _Pg[1])
    ++_Pg;
   }

  _Count = _Groupstring.size();
  size_t _Fillcount = _Iosbase.width() <= 0
   || (size_t)_Iosbase.width() <= _Count
    ? 0 : (size_t)_Iosbase.width() - _Count;

  ios_base::fmtflags _Adjustfield =
   _Iosbase.flags() & ios_base::adjustfield;
  if (_Adjustfield != ios_base::left
   && _Adjustfield != ios_base::internal)
   {
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   }
  else if (_Adjustfield == ios_base::internal)
   {
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   }
  else
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
  _Iosbase.width(0);
  return (_Rep(_Dest, _Fill, _Fillcount));
  }

 _OutIt _Fput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
   size_t _Count) const
  {
  return _Fput(_Dest, _Iosbase, _Fill, _Buf, 0, 0, 0, _Count);
  }

 char *_Ifmt(char *_Fmt,
  const char *_Spec, ios_base::fmtflags _Flags) const
  {
  char *_Ptr = _Fmt;
  *_Ptr++ = '%';

  if (_Flags & ios_base::showpos)
   *_Ptr++ = '+';
  if (_Flags & ios_base::showbase)
   *_Ptr++ = '#';
  if (_Spec[0] != 'L')
   *_Ptr++ = _Spec[0];
  else


   {
   *_Ptr++ = 'l';
   *_Ptr++ = 'l';
   }
# 1506 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocnum" 3
  ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
  *_Ptr++ = _Basefield == ios_base::oct ? 'o'
   : _Basefield != ios_base::hex ? _Spec[1]
   : _Flags & ios_base::uppercase ? 'X' : 'x';
  *_Ptr = '\0';
  return (_Fmt);
  }

 _OutIt _Iput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
  {
                       ;
  size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
   ? 1 : 0;
  if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
   && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
   && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
   _Prefix += 2;

  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Mystr _Groupstring(_Count, _Elem(0));
  _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  const char *_Pg = &_Grouping[0];
  if (*_Pg != 0x7f && '\0' < *_Pg)
   {
   const _Elem _Kseparator = _Punct_fac.thousands_sep();
   while (*_Pg != 0x7f && '\0' < *_Pg
    && (size_t)*_Pg < _Count - _Prefix)
    {
    _Count -= (size_t)*_Pg;
    _Groupstring.insert(_Count, 1, _Kseparator);
    if ('\0' < _Pg[1])
     ++_Pg;
    }
   }

  _Count = _Groupstring.size();
  size_t _Fillcount = _Iosbase.width() <= 0
   || (size_t)_Iosbase.width() <= _Count
    ? 0 : (size_t)_Iosbase.width() - _Count;

  ios_base::fmtflags _Adjustfield =
   _Iosbase.flags() & ios_base::adjustfield;
  if (_Adjustfield != ios_base::left
   && _Adjustfield != ios_base::internal)
   {
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   }
  else if (_Adjustfield == ios_base::internal)
   {
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   }
  else
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
  _Iosbase.width(0);
  return (_Rep(_Dest, _Fill, _Fillcount));
  }

 _OutIt _Put(_OutIt _Dest,
  const _Elem *_Ptr, size_t _Count) const
  {
  for (; 0 < _Count; --_Count, ++_Dest, (void)++_Ptr)
   *_Dest = *_Ptr;
  return (_Dest);
  }

 _OutIt _Rep(_OutIt _Dest,
  _Elem _Ch, size_t _Count) const
  {
  for (; 0 < _Count; --_Count, ++_Dest)
   *_Dest = _Ch;
  return (_Dest);
  }
 };


template<class _Elem,
 class _OutIt>
 locale::id num_put<_Elem, _OutIt>::id;

extern template class num_put<char>;
extern template class num_put<wchar_t>;

}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ios" 2 3

namespace std {

template<class _Elem,
 class _Traits>
 class basic_ios
  : public ios_base
 {
public:
 typedef basic_ios<_Elem, _Traits> _Myt;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef ctype<_Elem> _Ctype;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 explicit basic_ios(_Mysb *_Strbuf)
  {
  init(_Strbuf);
  }

 virtual ~basic_ios() noexcept
  {
  }

 void clear(iostate _State = goodbit,
  bool _Reraise = false)
  {
  ios_base::clear((iostate)(_Mystrbuf == 0
   ? (int)_State | (int)badbit : (int)_State), _Reraise);
  }

 void clear(io_state _State)
  {
  clear((iostate)_State);
  }

 void setstate(iostate _State,
  bool _Reraise = false)
  {
  clear((iostate)((int)rdstate() | (int)_State), _Reraise);
  }

 void setstate(io_state _State)
  {
  setstate((iostate)_State);
  }

 _Myt& copyfmt(const _Myt& _Right)
  {
  _Tiestr = _Right.tie();
  _Fillch = _Right.fill();
  ios_base::copyfmt(_Right);
  return (*this);
  }

 _Myos *tie() const
  {
  return (_Tiestr);
  }

 _Myos *tie(_Myos *_Newtie)
  {
  _Myos *_Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return (_Oldtie);
  }

 _Mysb *rdbuf() const
  {
  return (_Mystrbuf);
  }

 _Mysb *rdbuf(_Mysb *_Strbuf)
  {
  _Mysb *_Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear();
  return (_Oldstrbuf);
  }

 locale imbue(const locale& _Loc)
  {
  locale _Oldlocale = ios_base::imbue(_Loc);
  if (rdbuf() != 0)
   rdbuf()->pubimbue(_Loc);
  return (_Oldlocale);
  }

 _Elem fill() const
  {
  return (_Fillch);
  }

 _Elem fill(_Elem _Newfill)
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return (_Oldfill);
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
  return (_Ctype_fac.narrow(_Ch, _Dflt));
  }

 _Elem widen(char _Byte) const
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
  return (_Ctype_fac.widen(_Byte));
  }

protected:
 void move(_Myt& _Right)
  {
  if (this != &_Right)
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this->swap(_Right);
   }
  }

 void move(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this->swap(_Right);
   }
  }

 void swap(_Myt& _Right) noexcept
  {
  ios_base::swap(_Right);
  ::std:: swap(_Fillch, _Right._Fillch);
  ::std:: swap(_Tiestr, _Right._Tiestr);
  }

 void set_rdbuf(_Mysb *_Strbuf)
  {
  _Mystrbuf = _Strbuf;
  }

 void init(_Mysb *_Strbuf = 0,
  bool _Isstd = false)
  {
  _Init();
  _Mystrbuf = _Strbuf;
  _Tiestr = 0;
  _Fillch = widen(' ');

  if (_Mystrbuf == 0)
   setstate(badbit);

  if (_Isstd)
   _Addstd(this);
  }

 basic_ios()
  {
  }

private:
 _Mysb *_Mystrbuf;
 _Myos *_Tiestr;
 _Elem _Fillch;

public:
 basic_ios(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;
 };


inline ios_base& boolalpha(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::boolalpha);
 return (_Iosbase);
 }

inline ios_base& dec(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::dec, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& defaultfloat(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& fixed(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& hex(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::hex, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& hexfloat(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
 return (_Iosbase);
 }







inline ios_base& internal(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& left(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::left, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& noboolalpha(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::boolalpha);
 return (_Iosbase);
 }

inline ios_base& noshowbase(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showbase);
 return (_Iosbase);
 }

inline ios_base& noshowpoint(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showpoint);
 return (_Iosbase);
 }

inline ios_base& noshowpos(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showpos);
 return (_Iosbase);
 }

inline ios_base& noskipws(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::skipws);
 return (_Iosbase);
 }

inline ios_base& nounitbuf(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::unitbuf);
 return (_Iosbase);
 }

inline ios_base& nouppercase(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::uppercase);
 return (_Iosbase);
 }

inline ios_base& oct(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::oct, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& right(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::right, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& scientific(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& showbase(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showbase);
 return (_Iosbase);
 }

inline ios_base& showpoint(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showpoint);
 return (_Iosbase);
 }

inline ios_base& showpos(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showpos);
 return (_Iosbase);
 }

inline ios_base& skipws(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::skipws);
 return (_Iosbase);
 }

inline ios_base& unitbuf(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::unitbuf);
 return (_Iosbase);
 }

inline ios_base& uppercase(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::uppercase);
 return (_Iosbase);
 }
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 2 3


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 3
template<class _Elem,
 class _Traits>
 class basic_ostream
  : virtual public basic_ios<_Elem, _Traits>
 {
public:
 typedef basic_ostream<_Elem, _Traits> _Myt;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
 typedef num_put<_Elem, _Iter> _Nput;


 explicit basic_ostream(
  basic_streambuf<_Elem, _Traits> *_Strbuf = 0,






  bool _Isstd = false)
  {
  _Myios::init(_Strbuf, _Isstd);
  }

 basic_ostream(_Uninitialized, bool _Addit = true)
  {
  if (_Addit)
   this->_Addstd(this);
  }

protected:
 basic_ostream(_Myt&& _Right)
  {
  _Myios::init();
  _Myios::move(::std:: move(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   _Myios::swap(_Right);
  }

public:
 basic_ostream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_ostream() noexcept
  {
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 class _Sentry_base
  {
 public:
  _Sentry_base(_Myt& _Ostr)
   : _Myostr(_Ostr)
   {
   if (_Myostr.rdbuf() != 0)
    _Myostr.rdbuf()->_Lock();
   }

  ~_Sentry_base() noexcept
   {
   if (_Myostr.rdbuf() != 0)
    _Myostr.rdbuf()->_Unlock();
   }

  _Myt& _Myostr;

 private:
  _Sentry_base& operator=(const _Sentry_base&);
  };

 class sentry
  : public _Sentry_base
  {
 public:
  explicit sentry(_Myt& _Ostr)
   : _Sentry_base(_Ostr)
   {
   if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
    _Ostr.tie()->flush();
   _Ok = _Ostr.good();
   }

  ~sentry() noexcept
   {
   if (!::std:: uncaught_exception())
    this->_Myostr._Osfx();
   }


        int _No_bool_decl;


  explicit operator bool() const
   {
   return (_Ok);
   }

  sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;

 private:
  bool _Ok;
  };

 bool opfx()
  {
  if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
   _Myios::tie()->flush();
  return (this->good());
  }

 void osfx()
  {
  _Osfx();
  }

 void _Osfx()
  {
  {{
  if (this->good() && this->flags() & ios_base::unitbuf)
   if (_Myios::rdbuf()->pubsync() == -1)
    _Myios::setstate(ios_base::badbit);
  } if (0) {
  }}
  }

 _Myt& operator<<(_Myt& (*_Pfn)(_Myt&))
  {
                      ;
  return ((*_Pfn)(*this));
  }

 _Myt& operator<<(_Myios& (*_Pfn)(_Myios&))
  {
                      ;
  (*_Pfn)(*(_Myios *)this);
  return (*this);
  }

 _Myt& operator<<(ios_base& (*_Pfn)(ios_base&))
  {
                      ;
  (*_Pfn)(*(ios_base *)this);
  return (*this);
  }

           _Myt& operator<<(bool _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(short _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
   ios_base::fmtflags _Bfl =
    this->flags() & ios_base::basefield;
   long _Tmp = (_Bfl == ios_base::oct
    || _Bfl == ios_base::hex)
    ? (long)(unsigned short)_Val : (long)_Val;

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Tmp).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(unsigned short _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (unsigned long)_Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(int _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
   ios_base::fmtflags _Bfl =
    this->flags() & ios_base::basefield;
   long _Tmp = (_Bfl == ios_base::oct
    || _Bfl == ios_base::hex)
    ? (long)(unsigned int)_Val : (long)_Val;

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Tmp).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(unsigned int _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (unsigned long)_Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(unsigned long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }


           _Myt& operator<<(long long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(unsigned long long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }


           _Myt& operator<<(float _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (double)_Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(double _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(long double _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(const void *_Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(_Mysb *_Strbuf)
  {
  ios_base::iostate _State = ios_base::goodbit;
  bool _Copied = false;
  const sentry _Ok(*this);

  if (_Ok && _Strbuf != 0)
   for (int_type _Meta = _Traits::eof(); ; _Copied = true)
    {
    {{
    _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
     ? _Strbuf->sgetc() : _Strbuf->snextc();
    } if (0) {
     _Myios::setstate(ios_base::failbit);
             ;
    }}

    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     break;

    {{
     if (_Traits::eq_int_type(_Traits::eof(),
      _Myios::rdbuf()->sputc(
       _Traits::to_char_type(_Meta))))
      {
      _State |= ios_base::badbit;
      break;
      }
    } if (0) { _Myios::setstate(ios_base::badbit, true); }}
    }

  this->width(0);
  _Myios::setstate(_Strbuf == 0 ? ios_base::badbit
   : !_Copied ? _State | ios_base::failbit : _State);
  return (*this);
  }

           _Myt& put(_Elem _Ch)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (!_Ok)
   _State |= ios_base::badbit;
  else
   {
   {{
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sputc(_Ch)))
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& write(const _Elem *_Str,
  streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (!_Ok)
   _State |= ios_base::badbit;
  else if (0 < _Count)
   {
                       ;
   {{
   if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& flush()
  {
  if (_Myios::rdbuf() != 0)
   {
   const sentry _Ok(*this);

   if (_Ok && _Myios::rdbuf()->pubsync() == -1)
    _Myios::setstate(ios_base::badbit);
   }
  return (*this);
  }

           _Myt& seekp(pos_type _Pos)
  {
  const sentry _Ok(*this);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
    ios_base::out) == _BADOFF)
   _Myios::setstate(ios_base::failbit);
  return (*this);
  }

           _Myt& seekp(off_type _Off, ios_base::seekdir _Way)
  {
  const sentry _Ok(*this);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
    ios_base::out) == _BADOFF)
   _Myios::setstate(ios_base::failbit);
  return (*this);
  }

           pos_type tellp()
  {
  const sentry _Ok(*this);

  if (!this->fail())
   return (_Myios::rdbuf()->pubseekoff(0,
    ios_base::cur, ios_base::out));
  else
   return (pos_type(_BADOFF));
  }
 };




template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
 {
 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize):: strlen(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  {{
  const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
 {
 ios_base::iostate _State = ios_base::goodbit;
 const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

 if (_Ok)
  {
  const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr,
  const char *_Val)
 {
 typedef char _Elem;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize)_Traits::length(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
   _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, char _Ch)
 {
 typedef char _Elem;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myos::sentry _Ok(_Ostr);

 if (_Ok)
  {
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ch)))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize)_Traits::length(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
   _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits,
 class _Mysizt> inline
 basic_ostream<_Elem, _Traits>& _Put_basic_string(
  basic_ostream<_Elem, _Traits>& _Ostr,
  _Mysizt _Size, const _Elem *_Val)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 _Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
  ? 0 : (_Mysizt)_Ostr.width() - _Size;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
 {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, (streamsize)_Size)
    != (streamsize)_Size)
    _State |= ios_base::badbit;
  else
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr,
  const basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return _Put_basic_string(_Ostr, _Str.size(), _Str.c_str());
 }
# 878 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 3
template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myos::sentry _Ok(_Ostr);

 if (_Ok)
  {
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ch)))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
 {
 return (_Ostr << (const char *)_Val);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
 {
 return (_Ostr << (char)_Ch);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
 {
 return (_Ostr << (const char *)_Val);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
 {
 return (_Ostr << (char)_Ch);
 }

template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_ostream<_Elem, _Traits>&
  operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
 {
 return (_Ostr << _Val);
 }


template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  endl(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.put(_Ostr.widen('\n'));
 _Ostr.flush();
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  ends(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.put(_Elem());
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  flush(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.flush();
 return (_Ostr);
 }


template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
   const error_code& _Errcode)
 {
 return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
 }
}


#pragma clang diagnostic pop
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\istream" 2 3

namespace std {

template<class _Elem,
 class _Traits>
 class basic_istream
  : virtual public basic_ios<_Elem, _Traits>
 {
public:
 typedef basic_istream<_Elem, _Traits> _Myt;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef istreambuf_iterator<_Elem, _Traits> _Iter;
 typedef ctype<_Elem> _Ctype;
 typedef num_get<_Elem, _Iter> _Nget;


 explicit basic_istream(_Mysb *_Strbuf = 0,
  bool _Isstd = false)






  : _Chcount(0)
  {
  _Myios::init(_Strbuf, _Isstd);
  }

 basic_istream(_Uninitialized)
  {
  this->_Addstd(this);
  }

protected:
 basic_istream(_Myt&& _Right)
  : _Chcount(_Right._Chcount)
  {
  _Myios::init();
  _Myios::move(::std:: move(_Right));
  _Right._Chcount = 0;
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  _Myios::swap(_Right);
  ::std:: swap(_Chcount, _Right._Chcount);
  }

public:
 basic_istream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_istream() noexcept
  {
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;


 class _Sentry_base
  {
 public:
  _Sentry_base(_Myt& _Istr)
   : _Myistr(_Istr)
   {
   if (_Myistr.rdbuf() != 0)
    _Myistr.rdbuf()->_Lock();
   }

  ~_Sentry_base() noexcept
   {
   if (_Myistr.rdbuf() != 0)
    _Myistr.rdbuf()->_Unlock();
   }

  _Myt& _Myistr;

 private:
  _Sentry_base& operator=(const _Sentry_base&);
  };

 class sentry
  : public _Sentry_base
  {
 public:
  explicit sentry(_Myt& _Istr, bool _Noskip = false)
   : _Sentry_base(_Istr)
   {
   _Ok = this->_Myistr._Ipfx(_Noskip);
   }


        int _No_bool_decl;


  explicit operator bool() const
   {
   return (_Ok);
   }

  sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;

 private:
  bool _Ok;
  };

           bool _Ipfx(bool _Noskip = false)
  {
  if (this->good())
   {
   if (_Myios::tie() != 0)
    _Myios::tie()->flush();

   if (!_Noskip && this->flags() & ios_base::skipws)
    {
    const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

    {{
    int_type _Meta = _Myios::rdbuf()->sgetc();

    for (; ; _Meta = _Myios::rdbuf()->snextc())
     if (_Traits::eq_int_type(_Traits::eof(), _Meta))
      {
      _Myios::setstate(ios_base::eofbit);
      break;
      }
     else if (!_Ctype_fac.is(_Ctype::space,
      _Traits::to_char_type(_Meta)))
      break;
    } if (0) { _Myios::setstate(ios_base::badbit, true); }}
    }

   if (this->good())
    return (true);
   }
  _Myios::setstate(ios_base::failbit);
  return (false);
  }

 bool ipfx(bool _Noskip = false)
  {
  return (_Ipfx(_Noskip));
  }

 void isfx()
  {
  }

 _Myt& operator>>(_Myt& (*_Pfn)(_Myt&))
  {
                      ;
  return ((*_Pfn)(*this));
  }

 _Myt& operator>>(_Myios& (*_Pfn)(_Myios&))
  {
                      ;
  (*_Pfn)(*(_Myios *)this);
  return (*this);
  }

 _Myt& operator>>(ios_base& (*_Pfn)(ios_base&))
  {
                      ;
  (*_Pfn)(*(ios_base *)this);
  return (*this);
  }

           _Myt& operator>>(bool& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(short& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   long _Tmp = 0;
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Tmp);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}

   if (_Tmp < (-0x7fff - 1) || 0x7fff < _Tmp)
    {
    _Val = _Tmp < (-0x7fff - 1) ? (-0x7fff - 1) : 0x7fff;
    _State |= ios_base::failbit;
    }
   else
    _Val = (short)_Tmp;
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(unsigned short& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(int& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   long _Tmp = 0;
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Tmp);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}

   if (_Tmp < (-0x7fffffff - 1) || 0x7fffffff < _Tmp)
    {
    _Val = _Tmp < (-0x7fffffff - 1) ? (-0x7fffffff - 1) : 0x7fffffff;
    _State |= ios_base::failbit;
    }
   else
    _Val = _Tmp;
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(unsigned int& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(unsigned long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }


           _Myt& operator>>(long long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(unsigned long long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }


           _Myt& operator>>(float& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(double& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(long double& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(void *& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(_Mysb *_Strbuf)
  {
  ios_base::iostate _State = ios_base::goodbit;
  bool _Copied = false;
  _Chcount = 0;
  const sentry _Ok(*this);

  if (_Ok && _Strbuf != 0)
   {
   {{
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     {{
      if (_Traits::eq_int_type(_Traits::eof(),
       _Strbuf->sputc(_Traits::to_char_type(_Meta))))
       break;
     ++_Chcount;
     } if (0) {
      break;
     }}
     _Copied = true;
     }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
  return (*this);
  }

           int_type get()
  {
  int_type _Meta = 0;
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (!_Ok)
   _Meta = _Traits::eof();
  else
   {
   {{
   _Meta = _Myios::rdbuf()->sgetc();

   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    _State |= ios_base::eofbit | ios_base::failbit;
   else
    {
    _Myios::rdbuf()->sbumpc();
    ++_Chcount;
    }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (_Meta);
  }

 _Myt& get(_Elem *_Str, streamsize _Count)
  {
  return (get(_Str, _Count, _Myios::widen('\n')));
  }

           _Myt& get(_Elem *_Str,
  streamsize _Count, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   {{
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (_Traits::to_char_type(_Meta) == _Delim)
     break;
    else
     {
                         ;
     *_Str++ = _Traits::to_char_type(_Meta);
     ++_Chcount;
     }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_Chcount == 0
   ? _State | ios_base::failbit : _State);
  *_Str = _Elem();
  return (*this);
  }

 _Myt& get(_Elem& _Ch)
  {
  int_type _Meta = get();
  if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
   _Ch = _Traits::to_char_type(_Meta);
  return (*this);
  }

 _Myt& get(_Mysb& _Strbuf)
  {
  return (get(_Strbuf, _Myios::widen('\n')));
  }

           _Myt& get(_Mysb& _Strbuf, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   {{
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     {{
      _Elem _Ch = _Traits::to_char_type(_Meta);
      if (_Ch == _Delim
       || _Traits::eq_int_type(_Traits::eof(),
        _Strbuf.sputc(_Ch)))
       break;
     } if (0) {
      break;
     }}
     ++_Chcount;
     }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  if (_Chcount == 0)
   _State |= ios_base::failbit;
  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& getline(_Elem *_Str, streamsize _Count)
  {
  return (getline(_Str, _Count, _Myios::widen('\n')));
  }

           _Myt& getline(_Elem *_Str,
  streamsize _Count, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);
  const bool _Null_terminate = 0 < _Count;

  if (_Ok && _Null_terminate)
   {
   int_type _Metadelim = _Traits::to_int_type(_Delim);

   {{
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (_Meta == _Metadelim)
     {
     ++_Chcount;
     _Myios::rdbuf()->sbumpc();
     break;
     }
    else if (--_Count <= 0)
     {
     _State |= ios_base::failbit;
     break;
     }
    else
     {
                         ;
     *_Str++ = _Traits::to_char_type(_Meta);
     ++_Chcount;
     }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  if (_Null_terminate)
   *_Str = _Elem();
  _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
  return (*this);
  }

           _Myt& ignore(streamsize _Count = 1,
  int_type _Metadelim = _Traits::eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   {{
   for (; ; )
    {
    int_type _Meta;
    if (_Count != (numeric_limits<streamsize>::max)()
     && --_Count < 0)
     break;
    else if (_Traits::eq_int_type(_Traits::eof(),
     _Meta = _Myios::rdbuf()->sbumpc()))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     ++_Chcount;
     if (_Meta == _Metadelim)
      break;
     }
    }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& read(_Elem *_Str, streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   {{
                       ;
   const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
   _Chcount += _Num;
   if (_Num != _Count)
    _State |= ios_base::eofbit | ios_base::failbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           streamsize readsome(_Elem *_Str,
  streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);
  streamsize _Num;

  if (!_Ok)
   _State |= ios_base::failbit;
  else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
   _State |= ios_base::eofbit;
  else if (0 < _Count && 0 < _Num)
   {
                       ;
   read(_Str, _Num < _Count ? _Num : _Count);
   }

  _Myios::setstate(_State);
  return (gcount());
  }

           int_type peek()
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok(*this, true);

  if (!_Ok)
   _Meta = _Traits::eof();
  else
   {
   {{
   if (_Traits::eq_int_type(_Traits::eof(),
    _Meta = _Myios::rdbuf()->sgetc()))
    _State |= ios_base::eofbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (_Meta);
  }

           _Myt& putback(_Elem _Ch)
  {
  _Chcount = 0;
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   {{
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sputbackc(_Ch)))
    _State |= ios_base::badbit | _Oldstate;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& unget()
  {
  _Chcount = 0;
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   {{
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sungetc()))
    _State |= ios_base::badbit | _Oldstate;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

 streamsize gcount() const
  {
  return (_Chcount);
  }

           int sync()
  {
  const sentry _Ok(*this, true);

  if (_Myios::rdbuf() == 0)
   return (-1);
  else if (_Myios::rdbuf()->pubsync() == -1)
   {
   _Myios::setstate(ios_base::badbit);
   return (-1);
   }
  else
   return (0);
  }

 _Myt& seekg(pos_type _Pos)
  {
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
    ios_base::in) == _BADOFF)
   _Myios::setstate(_State | ios_base::failbit);
  return (*this);
  }

 _Myt& seekg(off_type _Off, ios_base::seekdir _Way)
  {
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
    ios_base::in) == _BADOFF)
   _Myios::setstate(_State | ios_base::failbit);
  return (*this);
  }

 pos_type tellg()
  {
  const sentry _Ok(*this, true);

  if (!this->fail())
   return (_Myios::rdbuf()->pubseekoff(0,
    ios_base::cur, ios_base::in));
  else
   return (pos_type(_BADOFF));
  }

private:
 streamsize _Chcount;
 };




template<class _Elem,
 class _Traits>
 class basic_iostream
 : public basic_istream<_Elem, _Traits>,
  public basic_ostream<_Elem, _Traits>
 {
public:
 typedef basic_iostream<_Elem, _Traits> _Myt;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 explicit basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
  : _Myis(_Strbuf, false),
   _Myos(_Noinit, false)
  {
  }

protected:
 basic_iostream(_Myt&& _Right)
  : _Myis(_Right.rdbuf(), false),
   _Myos(_Noinit, false)
  {
  _Myios::init();
  _Myios::move(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   _Myios::swap(_Right);
  }

public:
 basic_iostream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_iostream() noexcept
  {
  }
 };
# 941 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\istream" 3
template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits> & _Istr, _Elem *_Str)
 {
                     ;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef ctype<_Elem> _Ctype;
 ios_base::iostate _State = ios_base::goodbit;
 _Elem *_Str0 = _Str;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

  {{
  streamsize _Count = 0 < _Istr.width() ? _Istr.width()
   : (numeric_limits<streamsize>::max)();
  typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
  _Elem _Ch;
  for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Ctype_fac.is(_Ctype::space,
    _Ch = _Traits::to_char_type(_Meta))
     || _Ch == _Elem())
    break;
   else
    *_Str++ = _Traits::to_char_type(_Meta);
  } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
  }

 *_Str = _Elem();
 _Istr.width(0);
 _Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits> & _Istr, _Elem& _Ch)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;

 typename _Myis::int_type _Meta;
 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  {{
  _Meta = _Istr.rdbuf()->sbumpc();
  if (_Traits::eq_int_type(_Traits::eof(), _Meta))
   _State |= ios_base::eofbit | ios_base::failbit;
  else
   _Ch = _Traits::to_char_type(_Meta);
  } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
  }

 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits> & _Istr, signed char *_Str)
 {
 return (_Istr >> (char *)_Str);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits> & _Istr, signed char& _Ch)
 {
 return (_Istr >> (char&)_Ch);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits> & _Istr, unsigned char *_Str)
 {
 return (_Istr >> (char *)_Str);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits> & _Istr, unsigned char& _Ch)
 {
 return (_Istr >> (char&)_Ch);
 }

template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_istream<_Elem, _Traits>&
  operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
 {
 return (_Istr >> _Val);
 }


template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_istream<_Elem, _Traits>&
  operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty *_Ptr)
 {
 return (_Istr >> _Ptr);
 }



template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>&
  ws(basic_istream<_Elem, _Traits>& _Istr)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef ctype<_Elem> _Ctype;

 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myis::sentry _Ok(_Istr, true);
 if (!_Istr.eof())
  {
  if (_Ok)
   {
   const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

   {{
   for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
    _Meta = _Istr.rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (!_Ctype_fac.is(_Ctype::space,
     _Traits::to_char_type(_Meta)))
     break;
   } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
   }

  _Istr.setstate(_State);
  }
 return (_Istr);
 }
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iterator" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iterator" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {

template<class _Container>
 class back_insert_iterator
  : public _Outit
 {
public:
 typedef back_insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 explicit back_insert_iterator(_Container& _Cont)

  : container(::std:: addressof(_Cont))



  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  container->push_back(_Val);
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  container->push_back(::std:: forward<_Valty>(_Val));
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 };

template<class _Container>
 struct _Is_checked_helper<back_insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 back_insert_iterator<_Container> back_inserter(_Container& _Cont)
 {
 return (back_insert_iterator<_Container>(_Cont));
 }


template<class _Container>
 class front_insert_iterator
  : public _Outit
 {
public:
 typedef front_insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 explicit front_insert_iterator(_Container& _Cont)

  : container(::std:: addressof(_Cont))



  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  container->push_front(_Val);
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  container->push_front(::std:: forward<_Valty>(_Val));
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 };

template<class _Container>
 struct _Is_checked_helper<front_insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 front_insert_iterator<_Container> front_inserter(_Container& _Cont)
 {
 return (front_insert_iterator<_Container>(_Cont));
 }


template<class _Container>
 class insert_iterator
  : public _Outit
 {
public:
 typedef insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 insert_iterator(_Container& _Cont, typename _Container::iterator _Where)

  : container(::std:: addressof(_Cont)), iter(_Where)



  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  iter = container->insert(iter, _Val);
  ++iter;
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  iter = container->insert(iter, ::std:: forward<_Valty>(_Val));
  ++iter;
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt& operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 typename _Container::iterator iter;
 };

template<class _Container>
 struct _Is_checked_helper<insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 insert_iterator<_Container> inserter(_Container& _Cont,
  typename _Container::iterator _Where)
 {
 return (insert_iterator<_Container>(_Cont, _Where));
 }


template<class _Ty,
 class _Elem = char,
 class _Traits = char_traits<_Elem>,
 class _Diff = ptrdiff_t>
 class istream_iterator
  : public iterator<input_iterator_tag, _Ty, _Diff,
   const _Ty *, const _Ty&>
 {
 typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_istream<_Elem, _Traits> istream_type;
 typedef const _Ty *pointer;

 constexpr istream_iterator()
  : _Myistr(0), _Myval()
  {
  }

 istream_iterator(istream_type& _Istr)
  : _Myistr(::std:: addressof(_Istr))
  {
  _Getval();
  }

 const _Ty& operator*() const
  {
  return (_Myval);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {
  _Getval();
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 bool _Equal(const _Myt& _Right) const
  {
  return (_Myistr == _Right._Myistr);
  }

protected:
 void _Getval()
  {
  if (_Myistr != 0 && !(*_Myistr >> _Myval))
   _Myistr = 0;
  }

 istream_type *_Myistr;
 _Ty _Myval;
 };

template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff>
 struct _Is_checked_helper<istream_iterator<_Ty, _Elem, _Traits, _Diff> >
  : public true_type
 {
 };


template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff> inline
 bool operator==(
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff> inline
 bool operator!=(
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
 {
 return (!(_Left == _Right));
 }


template<class _Ty,
 class _Elem = char,
 class _Traits = char_traits<_Elem> >
 class ostream_iterator
  : public _Outit
 {
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_ostream<_Elem, _Traits> ostream_type;

 ostream_iterator(ostream_type& _Ostr,
  const _Elem *_Delim = 0)
  : _Myostr(::std:: addressof(_Ostr)), _Mydelim(_Delim)
  {
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
  {
  *_Myostr << _Val;
  if (_Mydelim != 0)
   *_Myostr << _Mydelim;
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator*()
  {
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator++()
  {
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator++(int)
  {
  return (*this);
  }

protected:
 const _Elem *_Mydelim;
 ostream_type *_Myostr;
 };

template<class _Ty,
 class _Elem,
 class _Traits>
 struct _Is_checked_helper<ostream_iterator<_Ty, _Elem, _Traits> >
  : public true_type
 {
 };

}


#pragma clang diagnostic pop
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 2 3

namespace std {

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 typedef ctype<_Elem> _Ctype;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
 typedef typename _Mystr::size_type _Mysizt;

 ios_base::iostate _State = ios_base::goodbit;
 bool _Changed = false;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
  _Str.erase();

  {{
  _Mysizt _Size = 0 < _Istr.width()
   && (_Mysizt)_Istr.width() < _Str.max_size()
    ? (_Mysizt)_Istr.width() : _Str.max_size();
  typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Ctype_fac.is(_Ctype::space,
    _Traits::to_char_type(_Meta)))
    break;
   else
    {
    _Str.append(1, _Traits::to_char_type(_Meta));
    _Changed = true;
    }
  } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
  }

 _Istr.width(0);
 if (!_Changed)
  _State |= ios_base::failbit;
 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str,
  const _Elem _Delim)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;

 ios_base::iostate _State = ios_base::goodbit;
 bool _Changed = false;
 const typename _Myis::sentry _Ok(_Istr, true);

 if (_Ok)
  {
  {{
  _Str.erase();
  const typename _Traits::int_type _Metadelim =
   _Traits::to_int_type(_Delim);
  typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  for (; ; _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Traits::eq_int_type(_Meta, _Metadelim))
    {
    _Changed = true;
    _Istr.rdbuf()->sbumpc();
    break;
    }
   else if (_Str.max_size() <= _Str.size())
    {
    _State |= ios_base::failbit;
    break;
    }
   else
    {
    _Str += _Traits::to_char_type(_Meta);
    _Changed = true;
    }
  } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
  }

 if (!_Changed)
  _State |= ios_base::failbit;
 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (getline(_Istr, _Str, _Istr.widen('\n')));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (::std:: move(_Istr) >> _Str);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str,
  const _Elem _Delim)
 {
 return (getline(::std:: move(_Istr), _Str, _Delim));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
 }
# 185 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 3
inline int stoi(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoi argument");
 if ((* __error()) == 34 || _Ans < (-0x7fffffff - 1) || 0x7fffffff < _Ans)
  _Xout_of_range("stoi argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return ((int)_Ans);
 }

inline long stol(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stol argument");
 if ((* __error()) == 34)
  _Xout_of_range("stol argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoul argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoul argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long long stoll(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoll argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoll argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long long stoull(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoull argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoull argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline float stof(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 float _Ans = :: strtof(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stof argument");
 if ((* __error()) == 34)
  _Xout_of_range("stof argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline double stod(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 double _Ans = :: strtod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stod argument");
 if ((* __error()) == 34)
  _Xout_of_range("stod argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long double stold(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 long double _Ans = :: strtold(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stold argument");
 if ((* __error()) == 34)
  _Xout_of_range("stold argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }


inline int stoi(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoi argument");
 if ((* __error()) == 34 || _Ans < (-0x7fffffff - 1) || 0x7fffffff < _Ans)
  _Xout_of_range("stoi argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return ((int)_Ans);
 }

inline long stol(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stol argument");
 if ((* __error()) == 34)
  _Xout_of_range("stol argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoul argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoul argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long long stoll(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoll argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoll argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long long stoull(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoull argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoull argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline float stof(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 float _Ans = :: wcstof(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stof argument");
 if ((* __error()) == 34)
  _Xout_of_range("stof argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline double stod(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 double _Ans = :: wcstod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stod argument");
 if ((* __error()) == 34)
  _Xout_of_range("stod argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 long double _Ans = :: wcstold(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stold argument");
 if ((* __error()) == 34)
  _Xout_of_range("stold argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }




template<class _Ty> inline
 string _Integral_to_string(const char *_Fmt, _Ty _Val)
 {
 static_assert(is_integral<_Ty>::value, "_Ty must be integral");

 char _Buf[21];
 int _Len = :: sprintf_s(_Buf, 21, _Fmt, _Val);
 return (string(_Buf, _Len));
 }

template<class _Ty> inline
 string _Floating_to_string(const char *_Fmt, _Ty _Val)
 {
 static_assert(is_floating_point<_Ty>::value, "_Ty must be floating point");

 for (int _Len = 21; ; )
  {
  string _Str(_Len + 1, '\0');
  int _Len2 = :: snprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
  if (_Len2 <= _Len)
   {
   _Str.resize(_Len2);
   return (_Str);
   }
  _Len = _Len2;
  }
 }

template<class _Ty> inline
 wstring _Integral_to_wstring(const wchar_t *_Fmt, _Ty _Val)
 {
 static_assert(is_integral<_Ty>::value, "_Ty must be integral");

 wchar_t _Buf[21];
 int _Len = :: swprintf_s(_Buf, 21, _Fmt, _Val);
 return (wstring(_Buf, _Len));
 }

template<class _Ty> inline
 wstring _Floating_to_wstring(const wchar_t *_Fmt, _Ty _Val)
 {
 static_assert(is_floating_point<_Ty>::value, "_Ty must be floating point");

 for (int _Len = 21; ; )
  {
  wstring _Str(_Len + 1, '\0');
  int _Len2 = :: snwprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
  if (_Len2 <= _Len)
   {
   _Str.resize(_Len2);
   return (_Str);
   }
  _Len = _Len2;
  }
 }




inline string to_string(int _Val)
 {
 return (_Integral_to_string("%d", _Val));
 }

inline string to_string(unsigned int _Val)
 {
 return (_Integral_to_string("%u", _Val));
 }

inline string to_string(long _Val)
 {
 return (_Integral_to_string("%ld", _Val));
 }

inline string to_string(unsigned long _Val)
 {
 return (_Integral_to_string("%lu", _Val));
 }

inline string to_string(long long _Val)
 {
 return (_Integral_to_string("%lld", _Val));
 }

inline string to_string(unsigned long long _Val)
 {
 return (_Integral_to_string("%llu", _Val));
 }

inline string to_string(float _Val)
 {
 return (_Floating_to_string("%f", _Val));
 }

inline string to_string(double _Val)
 {
 return (_Floating_to_string("%f", _Val));
 }

inline string to_string(long double _Val)
 {
 return (_Floating_to_string("%Lf", _Val));
 }


inline wstring to_wstring(int _Val)
 {
 return (_Integral_to_wstring(L"%d", _Val));
 }

inline wstring to_wstring(unsigned int _Val)
 {
 return (_Integral_to_wstring(L"%u", _Val));
 }

inline wstring to_wstring(long _Val)
 {
 return (_Integral_to_wstring(L"%ld", _Val));
 }

inline wstring to_wstring(unsigned long _Val)
 {
 return (_Integral_to_wstring(L"%lu", _Val));
 }

inline wstring to_wstring(long long _Val)
 {
 return (_Integral_to_wstring(L"%lld", _Val));
 }

inline wstring to_wstring(unsigned long long _Val)
 {
 return (_Integral_to_wstring(L"%llu", _Val));
 }

inline wstring to_wstring(float _Val)
 {
 return (_Floating_to_wstring(L"%f", _Val));
 }

inline wstring to_wstring(double _Val)
 {
 return (_Floating_to_wstring(L"%f", _Val));
 }

inline wstring to_wstring(long double _Val)
 {
 return (_Floating_to_wstring(L"%Lf", _Val));
 }
# 630 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 3
 inline namespace literals {
  inline namespace string_literals {
inline string operator ""s(const char *_Str, size_t _Len)
 noexcept
 {
 return (string(_Str, _Len));
 }

inline u16string operator""s(const char16_t *_Str, size_t _Len)
 noexcept
 {
 return (u16string(_Str, _Len));
 }

inline u32string operator""s(const char32_t *_Str, size_t _Len)
 noexcept
 {
 return (u32string(_Str, _Len));
 }

inline wstring operator""s(const wchar_t *_Str, size_t _Len)
 noexcept
 {
 return (wstring(_Str, _Len));
 }
  }
 }

}
# 6 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp" 2

namespace CppWebApi = sce::Np::CppWebApi;

namespace psn
{
    void TitleCloudStorage::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::AddAndGetVariable, TitleCloudStorage::AddAndGetVariableImpl);
        MsgHandler::AddMethod(Methods::SetVariableWithConditions, TitleCloudStorage::SetVariableWithConditionsImpl);
        MsgHandler::AddMethod(Methods::GetMultiVariablesBySlot, TitleCloudStorage::GetMultiVariablesBySlotImpl);

        MsgHandler::AddMethod(Methods::SetMultiVariablesByUser, TitleCloudStorage::SetMultiVariablesByUserImpl);
        MsgHandler::AddMethod(Methods::GetMultiVariablesByUser, TitleCloudStorage::GetMultiVariablesByUserImpl);
        MsgHandler::AddMethod(Methods::DeleteMultiVariablesByUser, TitleCloudStorage::DeleteMultiVariablesByUserImpl);

        MsgHandler::AddMethod(Methods::UploadData, TitleCloudStorage::UploadDataImpl);
        MsgHandler::AddMethod(Methods::DownloadData, TitleCloudStorage::DownloadDataImpl);
        MsgHandler::AddMethod(Methods::DeleteMultiDataBySlot, TitleCloudStorage::DeleteMultiDataBySlotImpl);
        MsgHandler::AddMethod(Methods::DeleteMultiDataByUser, TitleCloudStorage::DeleteMultiDataByUserImpl);
        MsgHandler::AddMethod(Methods::GetMultiDataStatusesBySlot, TitleCloudStorage::GetMultiDataStatusesBySlotImpl);
        MsgHandler::AddMethod(Methods::GetMultiDataStatusesByUser, TitleCloudStorage::GetMultiDataStatusesByUserImpl);
    }

    void TitleCloudStorage::AddAndGetVariableImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 44));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        int slotId = reader.ReadInt32();
        Int64 value = reader.ReadInt64();

        IntrusivePtr<TCS::AddAndGetVariableRequestBody> reqBodyPtr;
        ret = TCS::AddAndGetVariableRequestBodyFactory::create(libContextPtr, value, &reqBodyPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 74));
            return;
        }

        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet)
        {
            Int32 serviceLabel = reader.ReadUInt32();
            reqBodyPtr->setNpServiceLabel(serviceLabel);
        }

        bool isComparedLastUpdatedDateTimeSet = reader.ReadBool();
        if (isComparedLastUpdatedDateTimeSet)
        {
            SceRtcTick compareTick;
            compareTick.tick = reader.ReadUInt64();
            reqBodyPtr->setComparedLastUpdatedDateTime(compareTick);
        }

        bool isComparedLastUpdatedUserAccountId = reader.ReadBool();
        if (isComparedLastUpdatedUserAccountId)
        {
            UInt64 compareAccountId = reader.ReadUInt64();
            char compareAccountIdStr[32] = { 0 };
            snprintf(compareAccountIdStr, sizeof(compareAccountIdStr) - 1, "%lu", compareAccountId);
            ret = reqBodyPtr->setComparedLastUpdatedUserAccountId(compareAccountIdStr);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 102));
                return;
            }
        }

        TCS::VariablesApi::ParameterToAddAndGetVariable param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), slotId, reqBodyPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 111));
            return;
        }

        typedef Common::IntrusivePtr<TCS::Variable> VariableResponseBody;
        VariableResponseBody response;

        Common::Transaction<VariableResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = TCS::VariablesApi::addAndGetVariable(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 127));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 137));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        TCS::Variable* variable = response.get();

        WriteVariable(writer, variable);

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TitleCloudStorage::SetVariableWithConditionsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 171));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        int slotId = reader.ReadInt32();
        Int64 value = reader.ReadInt64();

        TCS::Condition condition = TCS::Condition::_NOT_SET;

        condition = (TCS::Condition)reader.ReadInt32();

        IntrusivePtr<TCS::SetVariableWithConditionsRequestBody> reqBodyPtr;
        ret = TCS::SetVariableWithConditionsRequestBodyFactory::create(libContextPtr, condition, value, &reqBodyPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 205));
            return;
        }

        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet)
        {
            Int32 serviceLabel = reader.ReadUInt32();
            reqBodyPtr->setNpServiceLabel(serviceLabel);
        }

        bool isComparedLastUpdatedDateTimeSet = reader.ReadBool();
        if (isComparedLastUpdatedDateTimeSet)
        {
            SceRtcTick compareTick;
            compareTick.tick = reader.ReadUInt64();
            reqBodyPtr->setComparedLastUpdatedDateTime(compareTick);
        }

        bool isComparedLastUpdatedUserAccountId = reader.ReadBool();
        if (isComparedLastUpdatedUserAccountId)
        {
            UInt64 compareAccountId = reader.ReadUInt64();
            char compareAccountIdStr[32] = { 0 };
            snprintf(compareAccountIdStr, sizeof(compareAccountIdStr) - 1, "%lu", compareAccountId);
            ret = reqBodyPtr->setComparedLastUpdatedUserAccountId(compareAccountIdStr);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 233));
                return;
            }
        }

        TCS::VariablesApi::ParameterToSetVariableWithConditions param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), slotId, reqBodyPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 242));
            return;
        }

        typedef Common::IntrusivePtr<TCS::Variable> VariableResponseBody;
        VariableResponseBody response;

        Common::Transaction<VariableResponseBody> transaction;
        transaction.start(libContextPtr);


        ret = TCS::VariablesApi::setVariableWithConditions(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 258));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 268));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        TCS::Variable* variable = response.get();

        WriteVariable(writer, variable);

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TitleCloudStorage::GetMultiVariablesBySlotImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 302));
            return;
        }

        std::string accountIdsStr = "";

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt32 accountIdCount = reader.ReadUInt32();

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else if (accountIdCount > 0)
        {

            for (int i = 0; i < accountIdCount; i++)
            {
                UInt64 accountId = reader.ReadUInt64();

                if (accountIdsStr.length() > 0) accountIdsStr += ",";
                accountIdsStr += std::to_string(accountId);
            }
        }

        bool hasAccountIds = accountIdsStr.length() > 0;

        int slotId = reader.ReadInt32();

        bool isLimitSet = reader.ReadBool();
        int limit = 0;
        if (isLimitSet)
        {
            limit = reader.ReadInt32();
        }

        bool isOffsetSet = reader.ReadBool();
        int offset = 0;
        if (isOffsetSet)
        {
            offset = reader.ReadInt32();
        }

        bool isGroupSet = reader.ReadBool();
        TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::Group group = TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::Group::_NOT_SET;
        if (isGroupSet)
        {
            group = (TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::Group)reader.ReadInt32();
        }

        bool isSortSet = reader.ReadBool();
        TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::Sort sort = TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::Sort::_NOT_SET;
        if (isSortSet)
        {
            sort = (TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::Sort)reader.ReadInt32();
        }

        bool isSortModeSet = reader.ReadBool();
        TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::SortMode sortMode = TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::SortMode::_NOT_SET;
        if (isSortModeSet)
        {
            sortMode = (TCS::VariablesApi::ParameterToGetMultiVariablesBySlot::SortMode)reader.ReadInt32();
        }

        Int32 serviceLabel = 0;
        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet)
        {
            serviceLabel = reader.ReadUInt32();
        }

        TCS::VariablesApi::ParameterToGetMultiVariablesBySlot param;
        ret = param.initialize(libContextPtr, slotId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 382));
            return;
        }

        if (hasAccountIds)
        {
            ret = param.setaccountIds(accountIdsStr.c_str());
            if (ret < 0)
            {
                param.terminate();
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 392));
                return;
            }
        }

        if (isLimitSet)
        {
            param.setlimit(limit);
        }

        if (isOffsetSet)
        {
            param.setoffset(offset);
        }

        if (isGroupSet)
        {
            param.setgroup(group);
        }

        if (isSortSet)
        {
            param.setsort(sort);
        }

        if (isSortModeSet)
        {
            param.setsortMode(sortMode);
        }

        if (isServiceLabelSet)
        {
            param.setnpServiceLabel(serviceLabel);
        }

        typedef Common::IntrusivePtr<TCS::GetMultiVariablesResponseBody> GetMultiVariablesBody;
        GetMultiVariablesBody response;

        Common::Transaction<GetMultiVariablesBody> transaction;
        transaction.start(libContextPtr);


        ret = TCS::VariablesApi::getMultiVariablesBySlot(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 439));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 449));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(response->limitIsSet());
        if (response->limitIsSet())
        {
            writer.WriteInt32(response->getLimit());
        }

        writer.WriteBool(response->offsetIsSet());
        if (response->offsetIsSet())
        {
            writer.WriteInt32(response->getOffset());
        }

        writer.WriteBool(response->totalVariableCountIsSet());
        if (response->totalVariableCountIsSet())
        {
            writer.WriteInt32(response->getTotalVariableCount());
        }

        size_t numVars = 0;

        if (response->variablesIsSet())
        {
            numVars = response->getVariables()->size();
        }

        writer.WriteInt32(numVars);

        if (numVars > 0)
        {
            for (const auto& variable : *response->getVariables())
            {
                WriteVariable(writer, variable.get());
            }
        }

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TitleCloudStorage::SetMultiVariablesByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 514));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        IntrusivePtr<TCS::SetMultiVariablesRequestBody> reqBodyPtr;
        ret = TCS::SetMultiVariablesRequestBodyFactory::create(libContextPtr, &reqBodyPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 541));
            return;
        }

        int numVars = reader.ReadInt32();

        Common::Vector<Common::IntrusivePtr<TCS::SetMultiVariablesRequestBody_variables> > variables(libContextPtr);
        Common::IntrusivePtr<TCS::SetMultiVariablesRequestBody_variables> variable;

        for (int i = 0; i < numVars; i++)
        {
            int slotId = reader.ReadInt32();
            Int64 value = reader.ReadInt64();

            TCS::SetMultiVariablesRequestBody_variablesFactory::create(libContextPtr, &variable);
            (*variable).setSlotId(slotId);
            (*variable).setValue(value);
            ret = variables.pushBack(variable);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 561));
                return;
            }
        }

        ret = reqBodyPtr->setVariables(variables);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 569));
            return;
        }

        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet)
        {
            Int32 serviceLabel = reader.ReadUInt32();
            reqBodyPtr->setNpServiceLabel(serviceLabel);
        }

        TCS::VariablesApi::ParameterToSetMultiVariablesByUser param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), reqBodyPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 584));
            return;
        }

        Common::DefaultResponse response;

        Common::Transaction<Common::DefaultResponse> transaction;
        transaction.start(libContextPtr);


        ret = TCS::VariablesApi::setMultiVariablesByUser(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 599));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 609));
            return;
        }

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TitleCloudStorage::GetMultiVariablesByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 634));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        std::string slotIdsStr = "";


        UInt32 slotIdCount = reader.ReadUInt32();

        if (slotIdCount > 0)
        {
            for (int i = 0; i < slotIdCount; i++)
            {
                int slotId = reader.ReadInt32();

                if (slotIdsStr.length() > 0) slotIdsStr += ",";
                slotIdsStr += std::to_string(slotId);
            }
        }

        bool isLimitSet = reader.ReadBool();
        int limit = 0;
        if (isLimitSet)
        {
            limit = reader.ReadInt32();
        }

        bool isOffsetSet = reader.ReadBool();
        int offset = 0;
        if (isOffsetSet)
        {
            offset = reader.ReadInt32();
        }

        bool isSortSet = reader.ReadBool();
        TCS::VariablesApi::ParameterToGetMultiVariablesByUser::Sort sort = TCS::VariablesApi::ParameterToGetMultiVariablesByUser::Sort::_NOT_SET;
        if (isSortSet)
        {
            sort = (TCS::VariablesApi::ParameterToGetMultiVariablesByUser::Sort)reader.ReadInt32();
        }

        bool isSortModeSet = reader.ReadBool();
        TCS::VariablesApi::ParameterToGetMultiVariablesByUser::SortMode sortMode = TCS::VariablesApi::ParameterToGetMultiVariablesByUser::SortMode::_NOT_SET;
        if (isSortModeSet)
        {
            sortMode = (TCS::VariablesApi::ParameterToGetMultiVariablesByUser::SortMode)reader.ReadInt32();
        }

        Int32 serviceLabel = 0;
        bool isServiceLabelSet = reader.ReadBool();
        if (isServiceLabelSet)
        {
            serviceLabel = reader.ReadUInt32();
        }

        TCS::VariablesApi::ParameterToGetMultiVariablesByUser param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), slotIdsStr.c_str());
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 712));
            return;
        }

        if (isLimitSet)
        {
            param.setlimit(limit);
        }

        if (isOffsetSet)
        {
            param.setoffset(offset);
        }

        if (isSortSet)
        {
            param.setsort(sort);
        }

        if (isSortModeSet)
        {
            param.setsortMode(sortMode);
        }

        if (isServiceLabelSet)
        {
            param.setnpServiceLabel(serviceLabel);
        }

        typedef Common::IntrusivePtr<TCS::GetMultiVariablesResponseBody> GetMultiVariablesBody;
        GetMultiVariablesBody response;

        Common::Transaction<GetMultiVariablesBody> transaction;
        transaction.start(libContextPtr);


        ret = TCS::VariablesApi::getMultiVariablesByUser(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 753));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 763));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(response->limitIsSet());
        if (response->limitIsSet())
        {
            writer.WriteInt32(response->getLimit());
        }

        writer.WriteBool(response->offsetIsSet());
        if (response->offsetIsSet())
        {
            writer.WriteInt32(response->getOffset());
        }

        writer.WriteBool(response->totalVariableCountIsSet());
        if (response->totalVariableCountIsSet())
        {
            writer.WriteInt32(response->getTotalVariableCount());
        }

        size_t numVars = 0;
        if (response->variablesIsSet())
        {
            numVars = response->getVariables()->size();
        }

        writer.WriteInt32(numVars);

        if (numVars > 0)
        {
            for (const auto& variable : *response->getVariables())
            {
                WriteVariable(writer, variable.get());
            }
        }

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TitleCloudStorage::DeleteMultiVariablesByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 827));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        std::string slotIdsStr = "";


        UInt32 slotIdCount = reader.ReadUInt32();

        if (slotIdCount > 0)
        {
            for (int i = 0; i < slotIdCount; i++)
            {
                int slotId = reader.ReadInt32();

                if (slotIdsStr.length() > 0) slotIdsStr += ",";
                slotIdsStr += std::to_string(slotId);
            }
        }

        TCS::VariablesApi::ParameterToDeleteMultiVariablesByUser param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), slotIdsStr.c_str());
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 870));
            return;
        }

        Common::DefaultResponse response;
        Common::Transaction<Common::DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = TCS::VariablesApi::deleteMultiVariablesByUser(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 885));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 895));
            return;
        }

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TitleCloudStorage::UploadDataImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 918));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        int slotId = reader.ReadInt32();

        Int32 dataSize = reader.ReadInt32();
        void* dataBuffer = __null;

        if (dataSize > 0)
        {
            Int64 intPtr = reader.ReadInt64();
            dataBuffer = (void*)intPtr;
        }

        Int32 infoSize = reader.ReadInt32();
        void* info = reader.ReadDataPtr(infoSize);

        bool isServiceLabelSet = reader.ReadBool();
        Int32 serviceLabel = 0;
        if (isServiceLabelSet)
        {
            serviceLabel = reader.ReadUInt32();
        }

        bool isComparedLastUpdatedDateTimeSet = reader.ReadBool();
        SceRtcTick compareTick;
        if (isComparedLastUpdatedDateTimeSet)
        {
            compareTick.tick = reader.ReadUInt64();
        }

        bool isComparedLastUpdatedUserAccountId = reader.ReadBool();
        char compareAccountIdStr[32] = { 0 };

        if (isComparedLastUpdatedUserAccountId)
        {
            UInt64 compareAccountId = reader.ReadUInt64();
            snprintf(compareAccountIdStr, sizeof(compareAccountIdStr) - 1, "%lu", compareAccountId);
        }

        UploadParams params;

        params.userWebCtx = userWebCtx;
        params.accountId = accountIdsStr.c_str();
        params.slotId = slotId;

        params.dataSize = dataSize;
        params.data = dataBuffer;

        params.infoSize = infoSize;
        params.info = info;

        params.isServiceLabelSet = isServiceLabelSet;
        params.serviceLabel = serviceLabel;

        params.isComparedLastUpdatedDateTimeSet = isComparedLastUpdatedDateTimeSet;
        params.compareTick = compareTick;

        params.isComparedLastUpdatedUserAccountId = isComparedLastUpdatedUserAccountId;
        params.compareAccountIdStr = compareAccountIdStr;

        ret = UploadDataAndSetInfo(&params);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1002));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int TitleCloudStorage::UploadDataAndSetInfo(UploadParams* uploadParams)
    {


        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        int ret = 0;


        Common::UpStreamTransaction<Common::IntrusivePtr<TCS::UploadDataResponseBody>, Common::IntrusivePtr<TCS::DataApi::UploadDataResponseHeaders> > transOfData;
        Common::IntrusivePtr<TCS::DataApi::UploadDataResponseHeaders> headersOfData;

        TCS::DataApi::ParameterToUploadData paramOfData;

        ret = transOfData.start(libContextPtr, uploadParams->dataSize);
        if (ret < 0)
        {
            return ret;
        }

        ret = paramOfData.initialize(libContextPtr, uploadParams->accountId, uploadParams->slotId);
        if (ret < 0)
        {
            transOfData.finish();
            return ret;
        }

        paramOfData.setxPsnAtomicOperation(TCS::DataApi::ParameterToUploadData::XPsnAtomicOperation::kBegin);




        ret = TCS::DataApi::uploadData(uploadParams->userWebCtx->m_webapiUserCtxId, paramOfData, transOfData);
        if (ret < 0)
        {
            transOfData.finish();
            paramOfData.terminate();
            return ret;
        }

        ret = transOfData.sendData(uploadParams->data, uploadParams->dataSize);
        if (ret < 0)
        {
            transOfData.finish();
            paramOfData.terminate();
            return ret;
        }

        ret = transOfData.getResponseHeaders(headersOfData);
        if (ret < 0)
        {
            transOfData.finish();
            paramOfData.terminate();
            return ret;
        }

        if (!headersOfData->hasXPsnAtomicOperationId())
        {
            ret = -1;
            transOfData.finish();
            paramOfData.terminate();
            return ret;
        }

        const char* atomicOperationId = nullptr;
        atomicOperationId = headersOfData->getXPsnAtomicOperationId().c_str();



        Common::Transaction<Common::DefaultResponse, Common::IntrusivePtr<TCS::DataApi::SetDataInfoResponseHeaders> > transOfInfo;
        Common::IntrusivePtr<TCS::SetDataInfoRequestBody> reqBodyOfInfo;
        TCS::DataApi::ParameterToSetDataInfo paramOfInfo;

        ret = transOfInfo.start(libContextPtr);
        if (ret < 0)
        {
            transOfData.finish();
            paramOfData.terminate();
            return ret;
        }

        ret = TCS::SetDataInfoRequestBodyFactory::create(libContextPtr, uploadParams->info, uploadParams->infoSize, &reqBodyOfInfo);
        if (ret < 0)
        {
            transOfData.finish();
            paramOfData.terminate();
            transOfInfo.finish();
            return ret;
        }

        if (uploadParams->isComparedLastUpdatedDateTimeSet)
        {
            reqBodyOfInfo->setComparedLastUpdatedDateTime(uploadParams->compareTick);
        }

        if (uploadParams->isComparedLastUpdatedUserAccountId)
        {
            ret = reqBodyOfInfo->setComparedLastUpdatedUserAccountId(uploadParams->compareAccountIdStr);
            if (ret < 0)
            {
                transOfData.finish();
                paramOfData.terminate();
                transOfInfo.finish();
                return ret;
            }
        }

        if (uploadParams->isServiceLabelSet)
        {
            reqBodyOfInfo->setNpServiceLabel(uploadParams->serviceLabel);
        }

        ret = paramOfInfo.initialize(libContextPtr, uploadParams->accountId, uploadParams->slotId, reqBodyOfInfo);
        if (ret < 0)
        {
            transOfData.finish();
            paramOfData.terminate();
            transOfInfo.finish();
            paramOfInfo.terminate();
            return ret;
        }

        paramOfInfo.setxPsnAtomicOperation(TCS::DataApi::ParameterToSetDataInfo::XPsnAtomicOperation::kEnd);



        ret = paramOfInfo.setxPsnAtomicOperationId(atomicOperationId);
        if (ret < 0)
        {
            transOfData.finish();
            paramOfData.terminate();
            transOfInfo.finish();
            paramOfInfo.terminate();
            return ret;
        }

        ret = TCS::DataApi::setDataInfo(uploadParams->userWebCtx->m_webapiUserCtxId, paramOfInfo, transOfInfo);
        if (ret < 0)
        {
            transOfData.finish();
            paramOfData.terminate();
            transOfInfo.finish();
            paramOfInfo.terminate();
            return ret;
        }

        transOfData.finish();
        paramOfData.terminate();
        transOfInfo.finish();
        paramOfInfo.terminate();

        return ret;
    }

    void TitleCloudStorage::DownloadDataImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1178));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        int slotId = reader.ReadInt32();

        char* objectId = reader.ReadStringPtr();

        char* range = __null;
        bool isRangeSet = reader.ReadBool();
        if (isRangeSet)
        {
            range = reader.ReadStringPtr();
        }

        char* ifMatch = __null;
        bool isIfMatchSet = reader.ReadBool();
        if (isIfMatchSet)
        {
            ifMatch = reader.ReadStringPtr();
        }

        bool isServiceLabelSet = reader.ReadBool();
        Int32 serviceLabel = 0;
        if (isServiceLabelSet)
        {
            serviceLabel = reader.ReadUInt32();
        }

        UInt32 bufferSize = reader.ReadUInt32();
        void* dataBuffer = __null;

        if (bufferSize > 0)
        {
            Int64 intPtr = reader.ReadInt64();
            dataBuffer = (void*)intPtr;
        }

        TCS::DataApi::ParameterToDownloadData param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), slotId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1239));
            return;
        }

        if (objectId)
        {
            ret = param.setobjectId(objectId);
            if (ret < 0)
            {
                param.terminate();
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1249));
                return;
            }
        }

        if (isRangeSet)
        {
            ret = param.setrange(range);
            if (ret < 0)
            {
                param.terminate();
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1260));
                return;
            }
        }

        if (isIfMatchSet)
        {
            ret = param.setifMatch(ifMatch);
            if (ret < 0)
            {
                param.terminate();
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1271));
                return;
            }
        }

        if (isServiceLabelSet)
        {
            param.setnpServiceLabel(serviceLabel);
        }

        typedef Common::IntrusivePtr<TCS::DataApi::DownloadDataResponseHeaders> DownloadDataBody;
        DownloadDataBody response;

        Common::DownStreamTransaction<DownloadDataBody> transaction;
        transaction.start(libContextPtr);

        ret = TCS::DataApi::downloadData(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1290));
            return;
        }



        char* ptr = (char*)dataBuffer;
        UInt64 writtenSize = 0;
        UInt64 totalReadSize = 0;

        while (true)
        {
            size_t readDataSize = 0;
            char dataBuf[1024 * 8] = { 0 };
            readDataSize = transaction.readData(dataBuf, sizeof(dataBuf) - 1);

            if (readDataSize <= 0)
            {
                break;
            }




            totalReadSize += readDataSize;


            if (writtenSize < bufferSize)
            {
                int bytesToCopy = readDataSize;


                if (writtenSize + readDataSize > bufferSize)
                {
                    bytesToCopy = bufferSize - writtenSize;
                }

                memcpy(ptr, dataBuf, bytesToCopy);

                ptr += bytesToCopy;

                writtenSize += bytesToCopy;
            }
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteUInt64(writtenSize);
        writer.WriteUInt64(totalReadSize);

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void TitleCloudStorage::DeleteMultiDataBySlotImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1365));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt32 accountIdCount = reader.ReadUInt32();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else if (accountIdCount > 0)
        {

            for (int i = 0; i < accountIdCount; i++)
            {
                UInt64 accountId = reader.ReadUInt64();

                if (accountIdsStr.length() > 0) accountIdsStr += ",";
                accountIdsStr += std::to_string(accountId);
            }
        }

        int slotId = reader.ReadInt32();

        bool isServiceLabelSet = reader.ReadBool();
        Int32 serviceLabel = 0;
        if (isServiceLabelSet)
        {
            serviceLabel = reader.ReadUInt32();
        }

        TCS::DataApi::ParameterToDeleteMultiDataBySlot param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), slotId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1408));
            return;
        }

        if (isServiceLabelSet)
        {
            param.setnpServiceLabel(serviceLabel);
        }

        Common::DefaultResponse response;
        Common::Transaction<Common::DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = TCS::DataApi::deleteMultiDataBySlot(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1428));
            return;
        }

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void TitleCloudStorage::DeleteMultiDataByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1454));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        std::string slotIdsStr = "";


        UInt32 slotIdCount = reader.ReadUInt32();

        if (slotIdCount > 0)
        {
            for (int i = 0; i < slotIdCount; i++)
            {
                int slotId = reader.ReadInt32();

                if (slotIdsStr.length() > 0) slotIdsStr += ",";
                slotIdsStr += std::to_string(slotId);
            }
        }

        bool isServiceLabelSet = reader.ReadBool();
        Int32 serviceLabel = 0;
        if (isServiceLabelSet)
        {
            serviceLabel = reader.ReadUInt32();
        }

        TCS::DataApi::ParameterToDeleteMultiDataByUser param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), slotIdsStr.c_str());
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1504));
            return;
        }

        if (isServiceLabelSet)
        {
            param.setnpServiceLabel(serviceLabel);
        }

        Common::DefaultResponse response;
        Common::Transaction<Common::DefaultResponse> transaction;

        transaction.start(libContextPtr);


        ret = TCS::DataApi::deleteMultiDataByUser(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1524));
            return;
        }

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void TitleCloudStorage::GetMultiDataStatusesBySlotImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1550));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt32 accountIdCount = reader.ReadUInt32();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else if (accountIdCount > 0)
        {

            for (int i = 0; i < accountIdCount; i++)
            {
                UInt64 accountId = reader.ReadUInt64();

                if (accountIdsStr.length() > 0) accountIdsStr += ",";
                accountIdsStr += std::to_string(accountId);
            }
        }

        bool hasAccountIds = accountIdsStr.length() > 0;

        int slotId = reader.ReadInt32();

        bool isFieldsSet = reader.ReadBool();
        char* fields = __null;
        if (isFieldsSet)
        {
            fields = reader.ReadStringPtr();
        }

        bool isLimitSet = reader.ReadBool();
        int limit = 0;
        if (isLimitSet)
        {
            limit = reader.ReadInt32();
        }

        bool isOffsetSet = reader.ReadBool();
        int offset = 0;
        if (isOffsetSet)
        {
            offset = reader.ReadInt32();
        }

        bool isGroupSet = reader.ReadBool();
        TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::Group group = TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::Group::_NOT_SET;
        if (isGroupSet)
        {
            group = (TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::Group)reader.ReadInt32();
        }

        bool isSortSet = reader.ReadBool();
        TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::Sort sort = TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::Sort::_NOT_SET;
        if (isSortSet)
        {
            sort = (TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::Sort)reader.ReadInt32();
        }

        bool isSortModeSet = reader.ReadBool();
        TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::SortMode sortMode = TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::SortMode::_NOT_SET;
        if (isSortModeSet)
        {
            sortMode = (TCS::DataApi::ParameterToGetMultiDataStatusesBySlot::SortMode)reader.ReadInt32();
        }

        bool isServiceLabelSet = reader.ReadBool();
        Int32 serviceLabel = 0;
        if (isServiceLabelSet)
        {
            serviceLabel = reader.ReadUInt32();
        }

        TCS::DataApi::ParameterToGetMultiDataStatusesBySlot param;
        ret = param.initialize(libContextPtr, slotId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1637));
            return;
        }

        if (hasAccountIds)
        {
            ret = param.setaccountIds(accountIdsStr.c_str());
            if (ret < 0)
            {
                param.terminate();
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1647));
                return;
            }
        }

        if (isFieldsSet)
        {
            ret = param.setfields(fields);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1657));
                return;
            }
        }

        if (isLimitSet)
        {
            param.setlimit(limit);
        }

        if (isOffsetSet)
        {
            param.setoffset(offset);
        }

        if (isGroupSet)
        {
            param.setgroup(group);
        }

        if (isSortSet)
        {
            param.setsort(sort);
        }

        if (isSortModeSet)
        {
            param.setsortMode(sortMode);
        }

        if (isServiceLabelSet)
        {
            param.setnpServiceLabel(serviceLabel);
        }

        typedef Common::IntrusivePtr<TCS::GetMultiDataStatusesResponseBody> GetMultiDataStatusesResponseBody;
        GetMultiDataStatusesResponseBody response;

        Common::Transaction<GetMultiDataStatusesResponseBody> transaction;
        transaction.start(libContextPtr);

        ret = TCS::DataApi::getMultiDataStatusesBySlot(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1701));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1711));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(response->limitIsSet());
        if (response->limitIsSet())
        {
            writer.WriteInt32(response->getLimit());
        }

        writer.WriteBool(response->offsetIsSet());
        if (response->offsetIsSet())
        {
            writer.WriteInt32(response->getOffset());
        }

        writer.WriteBool(response->totalDataStatusCountIsSet());
        if (response->totalDataStatusCountIsSet())
        {
            writer.WriteInt32(response->getTotalDataStatusCount());
        }

        size_t numVars = response->getDataStatusList()->size();

        writer.WriteInt32(numVars);

        if (numVars > 0)
        {
            for (const auto& dataStatus : *response->getDataStatusList())
            {
                WriteDataStatus(writer, dataStatus.get());
            }
        }

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void TitleCloudStorage::GetMultiDataStatusesByUserImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        *resultsSize = 0;

        int ret = 0;

        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1772));
            return;
        }

        bool isMe = reader.ReadBool();
        bool isAnyone = reader.ReadBool();
        UInt64 accountId = reader.ReadUInt64();

        std::string accountIdsStr = "";

        if (isMe)
        {
            accountIdsStr = "me";
        }
        else if (isAnyone)
        {
            accountIdsStr = "anyone";
        }
        else
        {
            accountIdsStr = std::to_string(accountId);
        }

        std::string slotIdsStr = "";


        UInt32 slotIdCount = reader.ReadUInt32();

        if (slotIdCount > 0)
        {
            for (int i = 0; i < slotIdCount; i++)
            {
                int slotId = reader.ReadInt32();

                if (slotIdsStr.length() > 0) slotIdsStr += ",";
                slotIdsStr += std::to_string(slotId);
            }
        }

        bool isFieldsSet = reader.ReadBool();
        char* fields = __null;
        if (isFieldsSet)
        {
            fields = reader.ReadStringPtr();
        }

        bool isLimitSet = reader.ReadBool();
        int limit = 0;
        if (isLimitSet)
        {
            limit = reader.ReadInt32();
        }

        bool isOffsetSet = reader.ReadBool();
        int offset = 0;
        if (isOffsetSet)
        {
            offset = reader.ReadInt32();
        }

        bool isSortSet = reader.ReadBool();
        TCS::DataApi::ParameterToGetMultiDataStatusesByUser::Sort sort = TCS::DataApi::ParameterToGetMultiDataStatusesByUser::Sort::_NOT_SET;
        if (isSortSet)
        {
            sort = (TCS::DataApi::ParameterToGetMultiDataStatusesByUser::Sort)reader.ReadInt32();
        }

        bool isSortModeSet = reader.ReadBool();
        TCS::DataApi::ParameterToGetMultiDataStatusesByUser::SortMode sortMode = TCS::DataApi::ParameterToGetMultiDataStatusesByUser::SortMode::_NOT_SET;
        if (isSortModeSet)
        {
            sortMode = (TCS::DataApi::ParameterToGetMultiDataStatusesByUser::SortMode)reader.ReadInt32();
        }

        bool isServiceLabelSet = reader.ReadBool();
        Int32 serviceLabel = 0;
        if (isServiceLabelSet)
        {
            serviceLabel = reader.ReadUInt32();
        }

        TCS::DataApi::ParameterToGetMultiDataStatusesByUser param;
        ret = param.initialize(libContextPtr, accountIdsStr.c_str(), slotIdsStr.c_str());
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1857));
            return;
        }

        if (isFieldsSet)
        {
            ret = param.setfields(fields);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1866));
                return;
            }
        }

        if (isLimitSet)
        {
            param.setlimit(limit);
        }

        if (isOffsetSet)
        {
            param.setoffset(offset);
        }

        if (isSortSet)
        {
            param.setsort(sort);
        }

        if (isSortModeSet)
        {
            param.setsortMode(sortMode);
        }

        if (isServiceLabelSet)
        {
            param.setnpServiceLabel(serviceLabel);
        }

        typedef Common::IntrusivePtr<TCS::GetMultiDataStatusesResponseBody> GetMultiDataStatusesResponseBody;
        GetMultiDataStatusesResponseBody response;

        Common::Transaction<GetMultiDataStatusesResponseBody> transaction;
        transaction.start(libContextPtr);

        ret = TCS::DataApi::getMultiDataStatusesByUser(userWebCtx->m_webapiUserCtxId, param, transaction);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1905));
            return;
        }


        ret = transaction.getResponse(response);
        if (ret < 0)
        {
            param.terminate();
            transaction.finish();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TitleCloudStorage.cpp", 1915));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteBool(response->limitIsSet());
        if (response->limitIsSet())
        {
            writer.WriteInt32(response->getLimit());
        }

        writer.WriteBool(response->offsetIsSet());
        if (response->offsetIsSet())
        {
            writer.WriteInt32(response->getOffset());
        }

        writer.WriteBool(response->totalDataStatusCountIsSet());
        if (response->totalDataStatusCountIsSet())
        {
            writer.WriteInt32(response->getTotalDataStatusCount());
        }

        size_t numVars = response->getDataStatusList()->size();

        writer.WriteInt32(numVars);

        if (numVars > 0)
        {
            for (const auto& dataStatus : *response->getDataStatusList())
            {
                WriteDataStatus(writer, dataStatus.get());
            }
        }

        *resultsSize = writer.GetWrittenLength();

        transaction.finish();
        param.terminate();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TitleCloudStorage::WriteVariable(BinaryWriter& writer, const TCS::IdempotentVariable* variable)
    {
        bool ownerIsSet = variable->ownerIsSet();
        bool slotIdIsSet = variable->slotIdIsSet();
        bool valueIsSet = variable->valueIsSet();
        bool prevValueIsSet = false;
        bool lastUpdatedDateTimeIsSet = variable->lastUpdatedDateTimeIsSet();
        bool lastUpdatedUserIsSet = variable->lastUpdatedUserIsSet();

        writer.WriteBool(ownerIsSet);
        if (ownerIsSet)
        {
            Common::IntrusivePtr<TCS::Owner> owner = variable->getOwner();

            bool accountIdIsSet = owner->accountIdIsSet();
            bool onlineIdIsSet = owner->onlineIdIsSet();

            writer.WriteBool(accountIdIsSet);
            if (accountIdIsSet)
            {
                writer.WriteString(owner->getAccountId().c_str());
            }

            writer.WriteBool(onlineIdIsSet);
            if (onlineIdIsSet)
            {
                writer.WriteString(owner->getOnlineId().data);
            }
        }

        writer.WriteBool(slotIdIsSet);
        if (slotIdIsSet)
        {
            writer.WriteInt32(variable->getSlotId());
        }

        writer.WriteBool(valueIsSet);
        if (valueIsSet)
        {
            writer.WriteInt64(variable->getValue());
        }

        writer.WriteBool(prevValueIsSet);

        writer.WriteBool(lastUpdatedDateTimeIsSet);
        if (lastUpdatedDateTimeIsSet)
        {
            writer.WriteRtcTick(variable->getLastUpdatedDateTime());
        }

        writer.WriteBool(lastUpdatedUserIsSet);
        if (lastUpdatedUserIsSet)
        {
            Common::IntrusivePtr<TCS::LastUpdatedUser> updatedUser = variable->getLastUpdatedUser();

            bool accountIdIsSet = updatedUser->accountIdIsSet();
            bool onlineIdIsSet = updatedUser->onlineIdIsSet();

            writer.WriteBool(accountIdIsSet);
            if (accountIdIsSet)
            {
                writer.WriteString(updatedUser->getAccountId().c_str());
            }

            writer.WriteBool(onlineIdIsSet);
            if (onlineIdIsSet)
            {
                writer.WriteString(updatedUser->getOnlineId().data);
            }
        }
    }

    void TitleCloudStorage::WriteVariable(BinaryWriter& writer, const TCS::Variable* variable)
    {
        bool ownerIsSet = variable->ownerIsSet();
        bool slotIdIsSet = variable->slotIdIsSet();
        bool valueIsSet = variable->valueIsSet();
        bool prevValueIsSet = variable->prevValueIsSet();
        bool lastUpdatedDateTimeIsSet = variable->lastUpdatedDateTimeIsSet();
        bool lastUpdatedUserIsSet = variable->lastUpdatedUserIsSet();

        writer.WriteBool(ownerIsSet);
        if (ownerIsSet)
        {
            Common::IntrusivePtr<TCS::Owner> owner = variable->getOwner();

            bool accountIdIsSet = owner->accountIdIsSet();
            bool onlineIdIsSet = owner->onlineIdIsSet();

            writer.WriteBool(accountIdIsSet);
            if (accountIdIsSet)
            {
                writer.WriteString(owner->getAccountId().c_str());
            }

            writer.WriteBool(onlineIdIsSet);
            if (onlineIdIsSet)
            {
                writer.WriteString(owner->getOnlineId().data);
            }
        }

        writer.WriteBool(slotIdIsSet);
        if (slotIdIsSet)
        {
            writer.WriteInt32(variable->getSlotId());
        }

        writer.WriteBool(valueIsSet);
        if (valueIsSet)
        {
            writer.WriteInt64(variable->getValue());
        }

        writer.WriteBool(prevValueIsSet);
        if (prevValueIsSet)
        {
            writer.WriteInt64(variable->getPrevValue());
        }

        writer.WriteBool(lastUpdatedDateTimeIsSet);
        if (lastUpdatedDateTimeIsSet)
        {
            writer.WriteRtcTick(variable->getLastUpdatedDateTime());
        }

        writer.WriteBool(lastUpdatedUserIsSet);
        if (lastUpdatedUserIsSet)
        {
            Common::IntrusivePtr<TCS::LastUpdatedUser> updatedUser = variable->getLastUpdatedUser();

            bool accountIdIsSet = updatedUser->accountIdIsSet();
            bool onlineIdIsSet = updatedUser->onlineIdIsSet();

            writer.WriteBool(accountIdIsSet);
            if (accountIdIsSet)
            {
                writer.WriteString(updatedUser->getAccountId().c_str());
            }

            writer.WriteBool(onlineIdIsSet);
            if (onlineIdIsSet)
            {
                writer.WriteString(updatedUser->getOnlineId().data);
            }
        }
    }

    void TitleCloudStorage::WriteDataStatus(BinaryWriter& writer, const TCS::DataStatus* dataStatus)
    {
        bool ownerIsSet = dataStatus->ownerIsSet();
        bool slotIdIsSet = dataStatus->slotIdIsSet();

        bool dataSizeIsSet = dataStatus->dataSizeIsSet();
        bool infoIsSet = dataStatus->infoIsSet();
        bool objectIdIsSet = dataStatus->objectIdIsSet();

        bool lastUpdatedDateTimeIsSet = dataStatus->lastUpdatedDateTimeIsSet();
        bool lastUpdatedUserIsSet = dataStatus->lastUpdatedUserIsSet();

        writer.WriteBool(ownerIsSet);
        if (ownerIsSet)
        {
            Common::IntrusivePtr<TCS::Owner> owner = dataStatus->getOwner();

            bool accountIdIsSet = owner->accountIdIsSet();
            bool onlineIdIsSet = owner->onlineIdIsSet();

            writer.WriteBool(accountIdIsSet);
            if (accountIdIsSet)
            {
                writer.WriteString(owner->getAccountId().c_str());
            }

            writer.WriteBool(onlineIdIsSet);
            if (onlineIdIsSet)
            {
                writer.WriteString(owner->getOnlineId().data);
            }
        }

        writer.WriteBool(slotIdIsSet);
        if (slotIdIsSet)
        {
            writer.WriteInt32(dataStatus->getSlotId());
        }

        writer.WriteBool(dataSizeIsSet);
        if (dataSizeIsSet)
        {
            writer.WriteInt64(dataStatus->getDataSize());
        }

        writer.WriteBool(infoIsSet);
        if (infoIsSet)
        {

            Binary* binary = dataStatus->getInfo().get();
            writer.WriteData((char*)binary->getBinary(), binary->size());
        }

        writer.WriteBool(objectIdIsSet);
        if (objectIdIsSet)
        {
            writer.WriteString(dataStatus->getObjectId().c_str());
        }

        writer.WriteBool(lastUpdatedDateTimeIsSet);
        if (lastUpdatedDateTimeIsSet)
        {
            writer.WriteRtcTick(dataStatus->getLastUpdatedDateTime());
        }

        writer.WriteBool(lastUpdatedUserIsSet);
        if (lastUpdatedUserIsSet)
        {
            Common::IntrusivePtr<TCS::LastUpdatedUser> updatedUser = dataStatus->getLastUpdatedUser();

            bool accountIdIsSet = updatedUser->accountIdIsSet();
            bool onlineIdIsSet = updatedUser->onlineIdIsSet();

            writer.WriteBool(accountIdIsSet);
            if (accountIdIsSet)
            {
                writer.WriteString(updatedUser->getAccountId().c_str());
            }

            writer.WriteBool(onlineIdIsSet);
            if (onlineIdIsSet)
            {
                writer.WriteString(updatedUser->getOnlineId().data);
            }
        }
    }
}
# 28 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp" 1




#pragma comment(lib,"libSceNpTrophy2_stub_weak.a")

namespace psn
{
    UserMap<TrophyService::UserTrophies> TrophyService::s_UsersList;
    std::list<Int32> TrophyService::s_PendingUnlockEventsList;

    TrophyService::UserTrophies::UserTrophies(SceUserServiceUserId userId)
    {
        m_userId = userId;
        m_context = (-1);
        m_handle = (-1);
    }

    int TrophyService::UserTrophies::Create()
    {
        int ret;

        ret = sceNpTrophy2CreateContext(&m_context, m_userId, 0, 0);

        if (ret < 0)
        {
            return ret;
        }

        ret = sceNpTrophy2CreateHandle(&m_handle);

        if (ret < 0)
        {
            return ret;
        }

        ret = sceNpTrophy2RegisterContext(m_context, m_handle, 0);

        if (ret < 0)
        {
            return ret;
        }

        return ret;
    }

    int TrophyService::UserTrophies::Destroy()
    {
        int ret;

        ret = sceNpTrophy2DestroyHandle(m_handle);

        if (ret < 0)
        {
            return ret;
        }

        ret = sceNpTrophy2DestroyContext(m_context);

        if (ret < 0)
        {
            return ret;
        }

        return ret;
    }

    void TrophyService::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::StartService, TrophyService::StartServiceImpl);
        MsgHandler::AddMethod(Methods::StopService, TrophyService::StopServiceImpl);
        MsgHandler::AddMethod(Methods::GetGameInfo, TrophyService::GetGameInfoImpl);
        MsgHandler::AddMethod(Methods::GetGroupInfo, TrophyService::GetGroupInfoImpl);
        MsgHandler::AddMethod(Methods::GetTrophyInfo, TrophyService::GetTrophyInfoImpl);
        MsgHandler::AddMethod(Methods::GetGameIcon, TrophyService::GetGameIconImpl);
        MsgHandler::AddMethod(Methods::GeGroupIcon, TrophyService::GeGroupIconImpl);
        MsgHandler::AddMethod(Methods::GetTrophyIcon, TrophyService::GetTrophyIconImpl);
        MsgHandler::AddMethod(Methods::GetRewardIcon, TrophyService::GetRewardIconImpl);
        MsgHandler::AddMethod(Methods::ShowTrophyList, TrophyService::ShowTrophyListImpl);
        MsgHandler::AddMethod(Methods::FetchUnlockEvent, TrophyService::FetchUnlockEventImpl);

        MsgHandler::RegisterUserCallback(HandleUserState);
    }

    void TrophyService::StartServiceImpl(APIResult* result)
    {
        int ret = sceNpTrophy2RegisterUnlockCallback(UnlockCallback, __null);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 91));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void CleanUpUsers(TrophyService::UserTrophies* userData)
    {
        sceNpTrophy2DestroyContext(userData->m_context);
    }

    void TrophyService::StopServiceImpl(APIResult* result)
    {



        int ret = sceNpTrophy2UnregisterUnlockCallback();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 112));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TrophyService::HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result)
    {
        if (state == MsgHandler::UserState::Added)
        {
            if (s_UsersList.DoesUserExist(userId) == true)
            {

                (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User already initialised with Trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 126));
                return;
            }

            UserTrophies* user = s_UsersList.CreateUser(userId);

            user->Create();
        }
        else if (state == MsgHandler::UserState::Removed)
        {
            UserTrophies* user = s_UsersList.FindUser(userId);

            if (user == __null)
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 140));
                return;
            }

            if (user->m_context == (-1))
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "User context is invalid", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 146));
                return;
            }

            user->Destroy();

            s_UsersList.DeleteUser(userId);
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TrophyService::GetGameInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        InitialiseData* data = (InitialiseData *)(sourceData);

        UserTrophies* user = s_UsersList.FindUser(data->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 166));
            return;
        }

        SceNpTrophy2GameDetails gameDetails;
        SceNpTrophy2GameData gameData;

        memset(&gameDetails, 0, sizeof(gameDetails));
        memset(&gameData, 0, sizeof(gameData));

        int ret;

        ret = sceNpTrophy2GetGameInfo(user->m_context, user->m_handle, &gameDetails, &gameData);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 182));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);


        writer.WriteUInt32(gameDetails.numGroups);
        writer.WriteUInt32(gameDetails.numTrophies);
        writer.WriteUInt32(gameDetails.numPlatinum);
        writer.WriteUInt32(gameDetails.numGold);
        writer.WriteUInt32(gameDetails.numSilver);
        writer.WriteUInt32(gameDetails.numBronze);

        writer.WriteString(gameDetails.title);


        writer.WriteUInt32(gameData.unlockedTrophies);
        writer.WriteUInt32(gameData.unlockedPlatinum);
        writer.WriteUInt32(gameData.unlockedGold);
        writer.WriteUInt32(gameData.unlockedSilver);
        writer.WriteUInt32(gameData.unlockedBronze);
        writer.WriteUInt32(gameData.progressPercentage);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    struct GroupInfoParams
    {
        SceUserServiceUserId userId;
        SceNpTrophy2GroupId groupId;
    };

    void TrophyService::GetGroupInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        GroupInfoParams* params = (GroupInfoParams *)(sourceData);

        UserTrophies* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 226));
            return;
        }

        SceNpTrophy2GroupDetails groupDetails;
        SceNpTrophy2GroupData groupData;

        memset(&groupDetails, 0, sizeof(groupDetails));
        memset(&groupData, 0, sizeof(groupData));

        int ret = sceNpTrophy2GetGroupInfo(user->m_context, user->m_handle, params->groupId, &groupDetails, &groupData);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 240));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);


        writer.WriteInt32(groupDetails.groupId);
        writer.WriteUInt32(groupDetails.numTrophies);
        writer.WriteUInt32(groupDetails.numPlatinum);
        writer.WriteUInt32(groupDetails.numGold);
        writer.WriteUInt32(groupDetails.numSilver);
        writer.WriteUInt32(groupDetails.numBronze);

        writer.WriteString(groupDetails.title);


        writer.WriteInt32(groupData.groupId);
        writer.WriteUInt32(groupData.unlockedTrophies);
        writer.WriteUInt32(groupData.unlockedPlatinum);
        writer.WriteUInt32(groupData.unlockedGold);
        writer.WriteUInt32(groupData.unlockedSilver);
        writer.WriteUInt32(groupData.unlockedBronze);
        writer.WriteUInt32(groupData.progressPercentage);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    struct TrophyInfoParams
    {
        SceUserServiceUserId userId;
        SceNpTrophy2Id trophyId;
    };

    void TrophyService::GetTrophyInfoImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        TrophyInfoParams* params = (TrophyInfoParams *)(sourceData);

        UserTrophies* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 285));
            return;
        }

        SceNpTrophy2Details trophyDetails;
        SceNpTrophy2Data trophyData;

        memset(&trophyDetails, 0, sizeof(trophyDetails));
        memset(&trophyData, 0, sizeof(trophyData));

        int ret = sceNpTrophy2GetTrophyInfo(user->m_context, user->m_handle, params->trophyId, &trophyDetails, &trophyData);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 299));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);


        writer.WriteInt32(trophyDetails.trophyId);
        writer.WriteInt32(trophyDetails.trophyGrade);
        writer.WriteInt32(trophyDetails.groupId);

        writer.WriteBool(trophyDetails.hidden);
        writer.WriteBool(trophyDetails.hasReward);

        bool isProgress = trophyDetails.target.type == (1);

        writer.WriteBool(isProgress);

        if (isProgress == true)
        {
            writer.WriteInt64(trophyDetails.target.value.valueUInt64);
        }

        writer.WriteString(trophyDetails.name);
        writer.WriteString(trophyDetails.description);
        writer.WriteString(trophyDetails.reward);


        writer.WriteInt32(trophyData.trophyId);
        writer.WriteBool(trophyData.unlocked);

        isProgress = trophyData.progress.type == (1);

        writer.WriteBool(isProgress);

        if (isProgress == true)
        {
            writer.WriteInt64(trophyData.progress.value.valueUInt64);
        }


        writer.WriteRtcTick(trophyData.timestamp);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    struct GameIconParams
    {
        SceUserServiceUserId userId;
    };

    void TrophyService::GetGameIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        GameIconParams* params = (GameIconParams *)(sourceData);

        UserTrophies* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 361));
            return;
        }

        void *buf = __null;
        size_t bufferSize = 0;

        int ret = sceNpTrophy2GetGameIcon(user->m_context, user->m_handle, __null, &bufferSize);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 372));
            return;
        }

        buf = malloc(bufferSize);

        ret = sceNpTrophy2GetGameIcon(user->m_context, user->m_handle, buf, &bufferSize);

        if (ret < 0)
        {
            free(buf);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 383));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);


        writer.WriteData((char*)buf, bufferSize);

        *resultsSize = writer.GetWrittenLength();

        free(buf);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    struct TrophyIconIdParams
    {
        SceUserServiceUserId userId;
        int32_t id;
    };

    void TrophyService::GeGroupIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        TrophyIconIdParams* params = (TrophyIconIdParams *)(sourceData);

        UserTrophies* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 414));
            return;
        }

        void *buf = __null;
        size_t bufferSize = 0;

        SceNpTrophy2GroupId groupId = params->id;

        int ret = sceNpTrophy2GetGroupIcon(user->m_context, user->m_handle, groupId, __null, &bufferSize);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 427));
            return;
        }

        buf = malloc(bufferSize);

        ret = sceNpTrophy2GetGroupIcon(user->m_context, user->m_handle, groupId, buf, &bufferSize);

        if (ret < 0)
        {
            free(buf);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 438));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);


        writer.WriteData((char*)buf, bufferSize);

        *resultsSize = writer.GetWrittenLength();

        free(buf);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TrophyService::GetTrophyIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        TrophyIconIdParams* params = (TrophyIconIdParams *)(sourceData);

        UserTrophies* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 463));
            return;
        }

        void *buf = __null;
        size_t bufferSize = 0;

        SceNpTrophy2GroupId trophyId = params->id;

        int ret = sceNpTrophy2GetTrophyIcon(user->m_context, user->m_handle, trophyId, __null, &bufferSize);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 476));
            return;
        }

        buf = malloc(bufferSize);

        ret = sceNpTrophy2GetTrophyIcon(user->m_context, user->m_handle, trophyId, buf, &bufferSize);

        if (ret < 0)
        {
            free(buf);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 487));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);


        writer.WriteData((char*)buf, bufferSize);

        *resultsSize = writer.GetWrittenLength();

        free(buf);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TrophyService::GetRewardIconImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        TrophyIconIdParams* params = (TrophyIconIdParams *)(sourceData);

        UserTrophies* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 512));
            return;
        }

        void *buf = __null;
        size_t bufferSize = 0;

        SceNpTrophy2GroupId trophyId = params->id;

        int ret = sceNpTrophy2GetRewardIcon(user->m_context, user->m_handle, trophyId, __null, &bufferSize);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 525));
            return;
        }

        buf = malloc(bufferSize);

        ret = sceNpTrophy2GetRewardIcon(user->m_context, user->m_handle, trophyId, buf, &bufferSize);

        if (ret < 0)
        {
            free(buf);
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 536));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);


        writer.WriteData((char*)buf, bufferSize);

        *resultsSize = writer.GetWrittenLength();

        free(buf);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TrophyService::ShowTrophyListImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        GameIconParams* params = (GameIconParams *)(sourceData);

        UserTrophies* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 561));
            return;
        }

        int ret = sceNpTrophy2ShowTrophyList(user->m_context);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\TrophyService.cpp", 569));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void TrophyService::Update()
    {
    }

    void TrophyService::UnlockCallback(SceNpTrophy2Context context, SceNpTrophy2Id trophyId, void *userdata)
    {

        s_PendingUnlockEventsList.push_back(trophyId);
    }

    void TrophyService::FetchUnlockEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        if (s_PendingUnlockEventsList.empty() == true)
        {
            *resultsSize = 0;
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
            return;
        }


        Int32 trophyId = s_PendingUnlockEventsList.front();
        s_PendingUnlockEventsList.pop_front();


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(trophyId);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 29 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp" 1




#pragma comment(lib,"libSceNpUniversalDataSystem_stub_weak.a")

namespace psn
{
    UserMap<UniversalDataSystem::UserContext> UniversalDataSystem::s_UsersList;

    UniversalDataSystem::UserContext::UserContext(SceUserServiceUserId userId)
    {
        m_userId = userId;
        m_context = (-1);
        m_handle = (-1);
    }

    int UniversalDataSystem::UserContext::Create()
    {
        int ret;

        ret = sceNpUniversalDataSystemCreateContext(&m_context, m_userId, 0, 0);

        if (ret < 0)
        {
            return ret;
        }

        ret = sceNpUniversalDataSystemCreateHandle(&m_handle);

        if (ret < 0)
        {
            return ret;
        }

        ret = sceNpUniversalDataSystemRegisterContext(m_context, m_handle, 0);

        if (ret < 0)
        {
            return ret;
        }

        return ret;
    }

    int UniversalDataSystem::UserContext::Destroy()
    {
        int ret;

        ret = sceNpUniversalDataSystemDestroyHandle(m_handle);

        if (ret < 0)
        {
            return ret;
        }

        ret = sceNpUniversalDataSystemDestroyContext(m_context);

        if (ret < 0)
        {
            return ret;
        }

        return ret;
    }

    void UniversalDataSystem::InitializeLib()
    {
    }

    void UniversalDataSystem::TerminateLib()
    {
    }

    void UniversalDataSystem::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::StartSystem, UniversalDataSystem::StartSystemImpl);
        MsgHandler::AddMethod(Methods::StopSystem, UniversalDataSystem::StopSystemImpl);
        MsgHandler::AddMethod(Methods::GetMemoryStats, UniversalDataSystem::GetMemoryStatsImpl);
        MsgHandler::AddMethod(Methods::PostEvent, UniversalDataSystem::PostEventImpl);
        MsgHandler::AddMethod(Methods::EventToString, UniversalDataSystem::EventToStringImpl);
        MsgHandler::AddMethod(Methods::UnlockTrophy, UniversalDataSystem::UnlockTrophyImpl);
        MsgHandler::AddMethod(Methods::UnlockTrophyProgress, UniversalDataSystem::UnlockTrophyProgressImpl);

        MsgHandler::RegisterUserCallback(HandleUserState);
    }

    void UniversalDataSystem::StartSystemImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        BinaryReader reader(sourceData, sourceSize);

        Int64 memSize = reader.ReadUInt64();

        int ret;
        SceNpUniversalDataSystemInitParam param;
        memset(&param, 0, sizeof(param));
        param.size = sizeof(param);
        param.poolSize = memSize;

        ret = sceNpUniversalDataSystemInitialize(&param);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 104));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UniversalDataSystem::StopSystemImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        int ret = sceNpUniversalDataSystemTerminate();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 117));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UniversalDataSystem::GetMemoryStatsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        SceNpUniversalDataSystemMemoryStat stat;

        memset(&stat, 0, sizeof(SceNpUniversalDataSystemMemoryStat));

        int ret = sceNpUniversalDataSystemGetMemoryStat(&stat);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 135));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteUInt64(stat.poolSize);
        writer.WriteUInt64(stat.maxInuseSize);
        writer.WriteUInt64(stat.currentInuseSize);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UniversalDataSystem::HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result)
    {
        if (state == MsgHandler::UserState::Added)
        {
            if (s_UsersList.DoesUserExist(userId) == true)
            {

                (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User already initialised with UDS service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 157));
                return;
            }

            UserContext* user = s_UsersList.CreateUser(userId);

            user->Create();
        }
        else if (state == MsgHandler::UserState::Removed)
        {
            UserContext* user = s_UsersList.FindUser(userId);

            if (user == __null)
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with UDS", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 171));
                return;
            }

            if (user->m_context == (-1))
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "User context is invalid", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 177));
                return;
            }

            user->Destroy();

            s_UsersList.DeleteUser(userId);
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    struct TrophyParams
    {
        SceUserServiceUserId userId;
        Int32 trophyId;
    };

    struct TrophyProgressParams
    {
        SceUserServiceUserId userId;
        Int32 trophyId;
        Int64 progress;
    };

    bool UniversalDataSystem::ReadProperty(BinaryReader& reader, SceNpUniversalDataSystemEventPropertyObject* properties, APIResult* result)
    {
        int ret = 0;

        char* key = reader.ReadStringPtr();

        PropertyType valueType = (PropertyType)reader.ReadUInt32();

        switch (valueType)
        {
            case PropertyType::kInt32:
                ret = sceNpUniversalDataSystemEventPropertyObjectSetInt32(properties, key, reader.ReadInt32());
                break;
            case PropertyType::kUInt32:
                ret = sceNpUniversalDataSystemEventPropertyObjectSetUInt32(properties, key, reader.ReadUInt32());
                break;
            case PropertyType::kInt64:
                ret = sceNpUniversalDataSystemEventPropertyObjectSetInt64(properties, key, reader.ReadInt64());
                break;
            case PropertyType::kUInt64:
                ret = sceNpUniversalDataSystemEventPropertyObjectSetUInt64(properties, key, reader.ReadUInt64());
                break;
            case PropertyType::kString:
                ret = sceNpUniversalDataSystemEventPropertyObjectSetString(properties, key, reader.ReadStringPtr());
                break;
            case PropertyType::kFloat:
                ret = sceNpUniversalDataSystemEventPropertyObjectSetFloat32(properties, key, reader.ReadFloat());
                break;
            case PropertyType::kFloat64:
                ret = sceNpUniversalDataSystemEventPropertyObjectSetFloat64(properties, key, reader.ReadDouble());
                break;
            case PropertyType::kBool:
                ret = sceNpUniversalDataSystemEventPropertyObjectSetBool(properties, key, reader.ReadBool());
                break;
            case PropertyType::kBinary:
            {
                int size = reader.ReadInt32();
                void* data = reader.ReadDataPtr(size);
                ret = sceNpUniversalDataSystemEventPropertyObjectSetBinary(properties, key, data, size);
            }
            break;
            case PropertyType::kProperties:
            {
                SceNpUniversalDataSystemEventPropertyObject* subProperties = ReadProperties(reader, result);

                if (subProperties == __null)
                {
                    return false;
                }

                ret = sceNpUniversalDataSystemEventPropertyObjectSetObject(properties, key, subProperties, __null);


                sceNpUniversalDataSystemDestroyEventPropertyObject(subProperties);
            }
            break;
            case PropertyType::kArray:
            {
                SceNpUniversalDataSystemEventPropertyArray* subArray = ReadPropertiesArray(reader, result);

                if (subArray == __null)
                {
                    return false;
                }

                ret = sceNpUniversalDataSystemEventPropertyObjectSetArray(properties, key, subArray, __null);


                sceNpUniversalDataSystemDestroyEventPropertyArray(subArray);
            }
            break;
            case PropertyType::kInvalid:
                break;
        }

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 279));
            return false;
        }

        return true;
    }

    bool UniversalDataSystem::ReadArrayValue(BinaryReader& reader, PropertyType arrayType, SceNpUniversalDataSystemEventPropertyArray* propertiesArray, APIResult* result)
    {
        int ret = 0;

        switch (arrayType)
        {
            case PropertyType::kInt32:
                ret = sceNpUniversalDataSystemEventPropertyArraySetInt32(propertiesArray, reader.ReadInt32());
                break;
            case PropertyType::kUInt32:
                ret = sceNpUniversalDataSystemEventPropertyArraySetUInt32(propertiesArray, reader.ReadUInt32());
                break;
            case PropertyType::kInt64:
                ret = sceNpUniversalDataSystemEventPropertyArraySetInt64(propertiesArray, reader.ReadInt64());
                break;
            case PropertyType::kUInt64:
                ret = sceNpUniversalDataSystemEventPropertyArraySetUInt64(propertiesArray, reader.ReadUInt64());
                break;
            case PropertyType::kString:
                ret = sceNpUniversalDataSystemEventPropertyArraySetString(propertiesArray, reader.ReadStringPtr());
                break;
            case PropertyType::kFloat:
                ret = sceNpUniversalDataSystemEventPropertyArraySetFloat32(propertiesArray, reader.ReadFloat());
                break;
            case PropertyType::kFloat64:
                ret = sceNpUniversalDataSystemEventPropertyArraySetFloat64(propertiesArray, reader.ReadDouble());
                break;
            case PropertyType::kBool:
                ret = sceNpUniversalDataSystemEventPropertyArraySetBool(propertiesArray, reader.ReadBool());
                break;
            case PropertyType::kBinary:
            {
                int size = reader.ReadInt32();
                void* data = reader.ReadDataPtr(size);
                ret = sceNpUniversalDataSystemEventPropertyArraySetBinary(propertiesArray, data, size);
            }
            break;
            case PropertyType::kProperties:
            {
                SceNpUniversalDataSystemEventPropertyObject* subProperties = ReadProperties(reader, result);

                if (subProperties == __null)
                {
                    return false;
                }

                ret = sceNpUniversalDataSystemEventPropertyArraySetObject(propertiesArray, subProperties, __null);


                sceNpUniversalDataSystemDestroyEventPropertyObject(subProperties);
            }
            break;
            case PropertyType::kArray:
            {
                SceNpUniversalDataSystemEventPropertyArray* subArray = ReadPropertiesArray(reader, result);

                if (subArray == __null)
                {
                    return false;
                }

                ret = sceNpUniversalDataSystemEventPropertyArraySetArray(propertiesArray, subArray, __null);


                sceNpUniversalDataSystemDestroyEventPropertyArray(subArray);
            }
            break;
            default:
                break;
        }

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 359));
            return false;
        }

        return true;
    }

    SceNpUniversalDataSystemEventPropertyArray* UniversalDataSystem::ReadPropertiesArray(BinaryReader& reader, APIResult* result)
    {
        SceNpUniversalDataSystemEventPropertyArray *propertiesArray;

        int ret = sceNpUniversalDataSystemCreateEventPropertyArray(&propertiesArray);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 374));
            return __null;
        }

        PropertyType arrayType = (PropertyType)reader.ReadUInt32();

        int numitems = reader.ReadUInt32();

        for (int i = 0; i < numitems; i++)
        {
            if (ReadArrayValue(reader, arrayType, propertiesArray, result) != true)
            {
                sceNpUniversalDataSystemDestroyEventPropertyArray(propertiesArray);
                return __null;
            }
        }

        return propertiesArray;
    }

    SceNpUniversalDataSystemEventPropertyObject* UniversalDataSystem::ReadProperties(BinaryReader& reader, APIResult* result)
    {
        SceNpUniversalDataSystemEventPropertyObject *properties;

        int ret = sceNpUniversalDataSystemCreateEventPropertyObject(&properties);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 402));
            return __null;
        }

        int numprops = reader.ReadUInt32();

        for (int i = 0; i < numprops; i++)
        {
            if (ReadProperty(reader, properties, result) != true)
            {
                sceNpUniversalDataSystemDestroyEventPropertyObject(properties);
                return __null;
            }
        }

        return properties;
    }

    SceNpUniversalDataSystemEvent* UniversalDataSystem::ReadEvent(BinaryReader& reader, APIResult* result)
    {
        int ret = 0;

        SceNpUniversalDataSystemEvent *udsEvent = __null;
        SceNpUniversalDataSystemEventPropertyObject *properties = __null;

        char* eventName;
        eventName = reader.ReadStringPtr();

        bool hasProperties = reader.ReadBool();

        if (hasProperties == false)
        {
            ret = sceNpUniversalDataSystemCreateEvent(eventName, __null, &udsEvent, __null);
            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 437));
                return __null;
            }
        }
        else
        {
            properties = ReadProperties(reader, result);

            if (properties == __null)
            {

                return __null;
            }


            int ret = sceNpUniversalDataSystemCreateEvent(eventName, properties, &udsEvent, __null);

            if (ret < 0)
            {
                sceNpUniversalDataSystemDestroyEventPropertyObject(properties);

                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 458));
                return __null;
            }


            sceNpUniversalDataSystemDestroyEventPropertyObject(properties);
        }

        return udsEvent;
    }

    void UniversalDataSystem::PostEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();
        bool reportEstimatedSize = reader.ReadBool();

        UserContext* user = s_UsersList.FindUser(userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with UDS", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 483));
            return;
        }


        SceNpUniversalDataSystemEvent* udsEvent = ReadEvent(reader, result);

        if (udsEvent != __null)
        {
            ret = sceNpUniversalDataSystemPostEvent(user->m_context, user->m_handle, udsEvent, 0);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 496));
                return;
            }

            size_t estimatedSize = 0;

            if (reportEstimatedSize == true)
            {
                ret = sceNpUniversalDataSystemEventEstimateSize(udsEvent, &estimatedSize);
                if (ret < 0)
                {
                    (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 507));
                    return;
                }
            }

            sceNpUniversalDataSystemDestroyEvent(udsEvent);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 516));
                return;
            }

            BinaryWriter writer(resultsData, resultsMaxSize);

            writer.WriteUInt64(estimatedSize);

            *resultsSize = writer.GetWrittenLength();
        }
        else
        {
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UniversalDataSystem::EventToStringImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        *resultsSize = 0;

        int ret = 0;
        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        UserContext* user = s_UsersList.FindUser(userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with UDS", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 547));
            return;
        }


        SceNpUniversalDataSystemEvent* udsEvent = ReadEvent(reader, result);

        if (udsEvent != __null)
        {
            char buf[4096];
            ret = sceNpUniversalDataSystemEventToString(udsEvent, buf, sizeof(buf), __null);

            sceNpUniversalDataSystemDestroyEvent(udsEvent);

            if (ret < 0)
            {
                (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 563));
                return;
            }

            BinaryWriter writer(resultsData, resultsMaxSize);

            writer.WriteString(buf);

            *resultsSize = writer.GetWrittenLength();
        }
        else
        {
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


    void UniversalDataSystem::UnlockTrophyImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        TrophyParams* params = (TrophyParams *)(sourceData);

        UserContext* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with UDS", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 590));
            return;
        }

        int ret;

        SceNpUniversalDataSystemEvent *event = __null;
        SceNpUniversalDataSystemEventPropertyObject *prop = __null;
        ret = sceNpUniversalDataSystemCreateEvent("_UnlockTrophy", __null, &event, &prop);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 601));
            return;
        }
        ret = sceNpUniversalDataSystemEventPropertyObjectSetInt32(prop, "_trophy_id", params->trophyId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 607));
            return;
        }
        ret = sceNpUniversalDataSystemPostEvent(user->m_context, user->m_handle, event, 0);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 613));
            return;
        }
# 624 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp"
        ret = sceNpUniversalDataSystemDestroyEvent(event);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 628));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UniversalDataSystem::UnlockTrophyProgressImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        TrophyProgressParams* params = (TrophyProgressParams*)(sourceData);

        UserContext* user = s_UsersList.FindUser(params->userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with UDS", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 643));
            return;
        }

        int ret;

        SceNpUniversalDataSystemEvent* event = __null;
        SceNpUniversalDataSystemEventPropertyObject* prop = __null;
        ret = sceNpUniversalDataSystemCreateEvent("_UpdateTrophyProgress", __null, &event, &prop);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 654));
            return;
        }
        ret = sceNpUniversalDataSystemEventPropertyObjectSetInt32(prop, "_trophy_id", params->trophyId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 660));
            return;
        }
        ret = sceNpUniversalDataSystemEventPropertyObjectSetInt32(prop, "_trophy_progress", (Int32)params->progress);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 666));
            return;
        }
        ret = sceNpUniversalDataSystemPostEvent(user->m_context, user->m_handle, event, 0);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 672));
            return;
        }
# 683 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp"
        ret = sceNpUniversalDataSystemDestroyEvent(event);

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\UniversalDataSystem.cpp", 687));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
}
# 30 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp" 1





namespace psn
{
    UserMap<UserSystem::UserIds> UserSystem::s_UsersList;


    int UserSystem::s_SignInCallbackId = -1;
    std::list<UserSystem::SigninStateEvent> UserSystem::s_PendingSigninStateList;
    std::list<UserSystem::ReachabilityStateEvent> UserSystem::s_PendingReachabilityStateList;


    void UserSystem::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::AddUser, UserSystem::AddUserImpl);
        MsgHandler::AddMethod(Methods::RemoveUser, UserSystem::RemoveUserImpl);
        MsgHandler::AddMethod(Methods::GetFriends, UserSystem::GetFriendsImpl);
        MsgHandler::AddMethod(Methods::GetProfiles, UserSystem::GetProfilesImpl);
        MsgHandler::AddMethod(Methods::GetBasicPresences, UserSystem::GetBasicPresencesImpl);
        MsgHandler::AddMethod(Methods::GetBlockingUsers, UserSystem::GetBlockingUsersImpl);


        MsgHandler::AddMethod(Methods::StartSignedStateCallback, UserSystem::StartSignedStateCallbackImpl);
        MsgHandler::AddMethod(Methods::StopSignedStateCallback, UserSystem::StopSignedStateCallbackImpl);
        MsgHandler::AddMethod(Methods::FetchSignedStateEvent, UserSystem::FetchSignedStateEventImpl);

        MsgHandler::AddMethod(Methods::StartReachabilityStateCallback, UserSystem::StartReachabilityStateCallbackImpl);
        MsgHandler::AddMethod(Methods::StopReachabilityStateCallback, UserSystem::StopReachabilityStateCallbackImpl);
        MsgHandler::AddMethod(Methods::FetchReachabilityStateEvent, UserSystem::FetchReachabilityStateEventImpl);


        MsgHandler::RegisterUserCallback(HandleUserState);
    }


    void UserSystem::AddUserImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        InitialiseData* data = (InitialiseData *)(sourceData);

        MsgHandler::NotifyAddUser(data->userId, result);
    }

    void UserSystem::RemoveUserImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        InitialiseData* data = (InitialiseData *)(sourceData);

        MsgHandler::NotifyRemoveUser(data->userId, result);
    }

    UserSystem::UserIds::UserIds(SceUserServiceUserId userId)
    {
        m_userId = userId;
        m_accountId = 0;
    }

    int UserSystem::UserIds::Create()
    {
        return sceNpGetAccountIdA(m_userId, &m_accountId);
    }

    int UserSystem::UserIds::Destroy()
    {
        return 0;
    }

    void UserSystem::HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result)
    {
        if (state == MsgHandler::UserState::Added)
        {
            if (s_UsersList.DoesUserExist(userId) == true)
            {

                (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User already initialised with User system", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 76));
                return;
            }

            UserIds* user = s_UsersList.CreateUser(userId);

            user->Create();
        }
        else if (state == MsgHandler::UserState::Removed)
        {
            UserIds* user = s_UsersList.FindUser(userId);

            if (user == __null)
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with User system", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 90));
                return;
            }

            user->Destroy();

            s_UsersList.DeleteUser(userId);
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UserSystem::GetFriendsImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = WebApi::Initialise();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 107));
            return;
        }

        *resultsSize = 0;



        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        UserIds* user = s_UsersList.FindUser(userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with User service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 122));
            return;
        }

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 130));
            return;
        }

        UInt32 offset = reader.ReadInt32();
        UInt32 limit = reader.ReadInt32();

        FriendsApi::ParameterToGetFriends::Filter filter = (FriendsApi::ParameterToGetFriends::Filter)reader.ReadUInt32();
        FriendsApi::ParameterToGetFriends::Order order = (FriendsApi::ParameterToGetFriends::Order)reader.ReadUInt32();

        Common::IntrusivePtr<Common::Vector<SceNpAccountId> > accountIdPtr;

        Int32 nextOffset, previousOffset;

        ret = GetFriendsInternal(user->m_accountId, userWebCtx, offset, limit, filter, order, accountIdPtr, nextOffset, previousOffset);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 147));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        if (accountIdPtr.get() == nullptr || accountIdPtr->size() <= 0)
        {
            writer.WriteUInt32(0);
            writer.WriteInt32(nextOffset);
            writer.WriteInt32(previousOffset);
        }
        else
        {
            size_t size = accountIdPtr->size();

            writer.WriteUInt32(size);
            writer.WriteInt32(nextOffset);
            writer.WriteInt32(previousOffset);

            for (auto it = accountIdPtr->begin(); it != accountIdPtr->end(); ++it)
            {
                SceNpAccountId friendId = (*it);
                writer.WriteUInt64(friendId);
            }
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int UserSystem::GetFriendsInternal(SceNpAccountId accountId, WebApiUserContext* user, UInt32 offset, UInt32 limit,
        FriendsApi::ParameterToGetFriends::Filter filter,
        FriendsApi::ParameterToGetFriends::Order order,
        Common::IntrusivePtr<Common::Vector<SceNpAccountId> > &accountIdPtr, Int32& nextOffset, Int32& previousOffset)
    {
        nextOffset = -1;
        previousOffset = -1;

        Common::LibContext* libContextPtr = &WebApi::Instance()->m_cppWebapiLibCtx;

        int ret = 0;

        Common::Transaction<Common::IntrusivePtr<GetFriendsResponse> > transaction;
        ret = transaction.start(libContextPtr);
        if (ret < 0)
        {
            return ret;
        }

        char errorBuf[1024] = {};
        SceNpWebApi2ResponseInformationOption respInfoOpt = {};
        respInfoOpt.pErrorObject = static_cast<char*>(errorBuf);
        respInfoOpt.errorObjectSize = 1024;
        transaction.setResponseInformationOption(&respInfoOpt);

        FriendsApi::ParameterToGetFriends param;
        param.initialize(libContextPtr, std::to_string(accountId).c_str());
        param.setoffset(offset);
        param.setlimit(limit);
        param.setfilter(filter);
        param.setorder(order);

        ret = FriendsApi::getFriends(user->m_webapiUserCtxId, param, transaction);
        param.terminate();
        if (ret < 0)
        {
            transaction.getResponseInformationOption();
# 226 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp"
            transaction.finish();
            return ret;
        }

        Common::IntrusivePtr<GetFriendsResponse> respPtr;

        ret = transaction.getResponse(respPtr);
        if (ret == 0)
        {
            accountIdPtr = respPtr->getFriends();

            if (respPtr->nextOffsetIsSet())
            {
                nextOffset = respPtr->getNextOffset();
            }

            if (respPtr->previousOffsetIsSet())
            {
                previousOffset = respPtr->getPreviousOffset();
            }
        }
        transaction.finish();
        return ret;
    }

    void UserSystem::WriteAvatarList(BinaryWriter& writer, Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar> > > avatarsPtr)
    {
        size_t numAvatars = avatarsPtr->size();

        writer.WriteUInt32(numAvatars);

        for (auto it = avatarsPtr->begin(); it != avatarsPtr->end(); ++it)
        {
            auto avatarPtr = (*it);

            bool sizeIsSet = avatarPtr->sizeIsSet();
            writer.WriteBool(sizeIsSet);
            if (sizeIsSet)
            {
                writer.WriteUInt32((UInt32)avatarPtr->getSize());
            }

            bool urlIsSet = avatarPtr->urlIsSet();
            writer.WriteBool(urlIsSet);
            if (urlIsSet)
            {
                writer.WriteString(avatarPtr->getUrl().c_str());
            }
        }
    }

    void UserSystem::GetProfilesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = WebApi::Initialise();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 282));
            return;
        }

        *resultsSize = 0;



        BinaryReader reader(sourceData, sourceSize);
        Int32 userId = reader.ReadInt32();

        UserIds* user = s_UsersList.FindUser(userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with User service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 297));
            return;
        }

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 305));
            return;
        }

        UInt32 accountIdCount = reader.ReadUInt32();

        std::string accountIdsStr = "";

        if (accountIdCount == 0)
        {

            accountIdsStr = std::to_string(user->m_accountId);
        }
        else
        {
            for (int i = 0; i < accountIdCount; i++)
            {
                UInt64 accountIds = reader.ReadUInt64();

                accountIdsStr += std::to_string(accountIds);

                if (i < accountIdCount - 1)
                {
                    accountIdsStr += ",";
                }
            }
        }

        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicProfile> > > profilesPtr;

        ret = GetProfilesInternal(accountIdsStr, userWebCtx, profilesPtr);

        if(ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 339));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        if (profilesPtr.get() == nullptr || profilesPtr->size() <= 0)
        {
            writer.WriteUInt32(0);
        }
        else
        {
            size_t size = profilesPtr->size();

            writer.WriteUInt32(size);

            for (auto it = profilesPtr->begin(); it != profilesPtr->end(); ++it)
            {
                auto basicProfilePtr = (*it);

                bool onlineIdSet = basicProfilePtr->onlineIdIsSet();
                writer.WriteBool(onlineIdSet);
                if (onlineIdSet == true)
                {
                    writer.WriteString(basicProfilePtr->getOnlineId().data);
                }

                bool personalDetailsSet = basicProfilePtr->personalDetailIsSet();
                writer.WriteBool(personalDetailsSet);
                if (personalDetailsSet == true)
                {
                    Common::IntrusivePtr<PersonalDetail> personalDetailPtr = basicProfilePtr->getPersonalDetail();

                    bool firstNameIsSet = personalDetailPtr->firstNameIsSet();
                    writer.WriteBool(firstNameIsSet);
                    if (firstNameIsSet == true) writer.WriteString(personalDetailPtr->getFirstName().c_str());

                    bool middleNameIsSet = personalDetailPtr->middleNameIsSet();
                    writer.WriteBool(middleNameIsSet);
                    if (middleNameIsSet == true) writer.WriteString(personalDetailPtr->getMiddleName().c_str());

                    bool lastNameIsSet = personalDetailPtr->lastNameIsSet();
                    writer.WriteBool(lastNameIsSet);
                    if (lastNameIsSet == true) writer.WriteString(personalDetailPtr->getLastName().c_str());

                    bool displayNameIsSet = personalDetailPtr->displayNameIsSet();
                    writer.WriteBool(displayNameIsSet);
                    if (displayNameIsSet == true) writer.WriteString(personalDetailPtr->getDisplayName().c_str());


                    bool profilePicturesIsSet = personalDetailPtr->profilePicturesIsSet();
                    writer.WriteBool(profilePicturesIsSet);
                    if (profilePicturesIsSet == true)
                    {
                        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar> > > profilePicturesPtr = personalDetailPtr->getProfilePictures();

                        WriteAvatarList(writer, profilePicturesPtr);
                    }
                }

                bool aboutMeIsSet = basicProfilePtr->aboutMeIsSet();
                writer.WriteBool(aboutMeIsSet);
                if (aboutMeIsSet)
                {
                    writer.WriteString(basicProfilePtr->getAboutMe().c_str());
                }

                bool avatarsIsSet = basicProfilePtr->avatarsIsSet();
                writer.WriteBool(avatarsIsSet);
                if (avatarsIsSet)
                {
                    Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<Avatar> > > avatarsPtr = basicProfilePtr->getAvatars();

                    WriteAvatarList(writer, avatarsPtr);
                }

                bool languagesIsSet = basicProfilePtr->languagesIsSet();
                writer.WriteBool(languagesIsSet);
                if (languagesIsSet)
                {
                    Common::IntrusivePtr<Common::Vector<Common::String> > languagesPtr = basicProfilePtr->getLanguages();

                    size_t numlanguages = languagesPtr->size();

                    writer.WriteUInt32(numlanguages);

                    for (auto languagePtr = languagesPtr->begin(); languagePtr != languagesPtr->end(); ++languagePtr)
                    {
                        writer.WriteString(languagePtr->c_str());
                    }
                }

                bool isOfficiallyVerifiedSet = basicProfilePtr->isOfficiallyVerifiedIsSet();
                writer.WriteBool(isOfficiallyVerifiedSet);
                if (isOfficiallyVerifiedSet)
                {
                    writer.WriteBool(basicProfilePtr->getIsOfficiallyVerified());
                }
            }
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int UserSystem::GetProfilesInternal(std::string accountIds, WebApiUserContext* user,
        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicProfile> > > &profilesPtr)
    {
        Common::LibContext* libContextPtr = &WebApi::Instance()->m_cppWebapiLibCtx;

        int ret = 0;

        Common::Transaction<Common::IntrusivePtr<GetPublicProfilesResponse> > transaction;
        ret = transaction.start(libContextPtr);
        if (ret < 0)
        {
            return ret;
        }

        char errorBuf[1024] = {};
        SceNpWebApi2ResponseInformationOption respInfoOpt = {};
        respInfoOpt.pErrorObject = static_cast<char*>(errorBuf);
        respInfoOpt.errorObjectSize = 1024;
        transaction.setResponseInformationOption(&respInfoOpt);

        BasicProfileApi::ParameterToGetPublicProfiles param;
        ret = param.initialize(libContextPtr, accountIds.c_str());

        if (ret < 0)
        {
            transaction.finish();
            return ret;
        }

        ret = BasicProfileApi::getPublicProfiles(user->m_webapiUserCtxId, param, transaction);
        param.terminate();
        if (ret < 0)
        {
            transaction.getResponseInformationOption();
# 491 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp"
            transaction.finish();
            return ret;
        }

        Common::IntrusivePtr<GetPublicProfilesResponse> respPtr;
        ret = transaction.getResponse(respPtr);
        if (ret == 0)
        {
            profilesPtr = respPtr->getProfiles();
        }

        transaction.finish();

        return ret;
    }

    void UserSystem::GetBasicPresencesImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = WebApi::Initialise();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 512));
            return;
        }

        *resultsSize = 0;



        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        UserIds* user = s_UsersList.FindUser(userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with User service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 528));
            return;
        }

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 536));
            return;
        }

        UInt32 accountIdCount = reader.ReadUInt32();

        std::string accountIdsStr = "";

        if (accountIdCount == 0)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "No user presences requested", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 546));
            return;
        }
        else
        {
            for (int i = 0; i < accountIdCount; i++)
            {
                UInt64 accountIds = reader.ReadUInt64();

                accountIdsStr += std::to_string(accountIds);

                if (i < accountIdCount - 1)
                {
                    accountIdsStr += ",";
                }
            }
        }

        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicPresence> > > presencesPtr;

        ret = GetBasicPresencesInternal(accountIdsStr, userWebCtx, presencesPtr);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 569));
            return;
        }


        BinaryWriter writer(resultsData, resultsMaxSize);

        if (presencesPtr.get() == nullptr || presencesPtr->size() <= 0)
        {
            writer.WriteUInt32(0);
        }
        else
        {
            size_t size = presencesPtr->size();

            writer.WriteUInt32(size);

            for (auto it = presencesPtr->begin(); it != presencesPtr->end(); ++it)
            {
                auto basicPresencePtr = (*it);

                bool accountIdIsSet = basicPresencePtr->accountIdIsSet();
                writer.WriteBool(accountIdIsSet);
                if (accountIdIsSet == true)
                {
                    writer.WriteUInt64(basicPresencePtr->getAccountId());
                }

                bool onlineStatusIsSet = basicPresencePtr->onlineStatusIsSet();
                writer.WriteBool(onlineStatusIsSet);
                if (onlineStatusIsSet == true)
                {
                    writer.WriteInt32((Int32)basicPresencePtr->getOnlineStatus());
                }

                bool inContextIsSet = basicPresencePtr->inContextIsSet();
                writer.WriteBool(inContextIsSet);
                if (inContextIsSet == true)
                {
                    writer.WriteBool(basicPresencePtr->getInContext());
                }
            }
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int UserSystem::GetBasicPresencesInternal(std::string accountIds, WebApiUserContext* user,
        Common::IntrusivePtr<Common::Vector<Common::IntrusivePtr<BasicPresence> > > &presencesPtr)
    {
        Common::LibContext* libContextPtr = &WebApi::Instance()->m_cppWebapiLibCtx;

        int ret = 0;

        Common::Transaction<Common::IntrusivePtr<GetBasicPresencesResponse> > transaction;
        ret = transaction.start(libContextPtr);
        if (ret < 0)
        {
            return ret;
        }

        char errorBuf[1024] = {};
        SceNpWebApi2ResponseInformationOption respInfoOpt = {};
        respInfoOpt.pErrorObject = static_cast<char*>(errorBuf);
        respInfoOpt.errorObjectSize = 1024;
        transaction.setResponseInformationOption(&respInfoOpt);

        PresenceApi::ParameterToGetBasicPresences param;
        ret = param.initialize(libContextPtr, accountIds.c_str());

        if (ret < 0)
        {
            transaction.finish();
            return ret;
        }

        ret = PresenceApi::getBasicPresences(user->m_webapiUserCtxId, param, transaction);
        param.terminate();
        if (ret < 0)
        {
            transaction.getResponseInformationOption();
# 663 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp"
            transaction.finish();
            return ret;
        }

        Common::IntrusivePtr<GetBasicPresencesResponse> respPtr;
        ret = transaction.getResponse(respPtr);
        if (ret == 0)
        {
            presencesPtr = respPtr->getBasicPresences();
        }

        transaction.finish();

        return ret;
    }

    void UserSystem::GetBlockingUsersImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        int ret = WebApi::Initialise();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 684));
            return;
        }

        *resultsSize = 0;



        BinaryReader reader(sourceData, sourceSize);

        Int32 userId = reader.ReadInt32();

        UserIds* user = s_UsersList.FindUser(userId);

        if (user == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with User service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 700));
            return;
        }

        WebApiUserContext* userWebCtx = WebApi::Instance()->FindUser(userId);

        if (userWebCtx == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with WebApi", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 708));
            return;
        }

        UInt32 offset = reader.ReadInt32();
        UInt32 limit = reader.ReadInt32();


        BinaryWriter writer(resultsData, resultsMaxSize);

        ret = GetBlockingUsersInternal(userWebCtx, offset, limit, writer);

        if(ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 722));
            return;
        }

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    int UserSystem::GetBlockingUsersInternal(WebApiUserContext* user, UInt32 offset, UInt32 limit, BinaryWriter& writer)
    {
        Common::LibContext* libContextPtr = &WebApi::Instance()->m_cppWebapiLibCtx;

        int ret = 0;

        Common::Transaction<Common::IntrusivePtr<GetBlockingUsersResponse> > transaction;
        ret = transaction.start(libContextPtr);
        if (ret < 0)
        {
            return ret;
        }

        char errorBuf[1024] = {};
        SceNpWebApi2ResponseInformationOption respInfoOpt = {};
        respInfoOpt.pErrorObject = static_cast<char*>(errorBuf);
        respInfoOpt.errorObjectSize = 1024;
        transaction.setResponseInformationOption(&respInfoOpt);

        BlocksApi::ParameterToGetBlockingUsers param;
        param.initialize(libContextPtr);
        param.setoffset(offset);
        param.setlimit(limit);

        ret = BlocksApi::getBlockingUsers(user->m_webapiUserCtxId, param, transaction);
        param.terminate();
        if (ret < 0)
        {
            transaction.getResponseInformationOption();
# 771 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp"
            transaction.finish();
            return ret;
        }

        Common::IntrusivePtr<GetBlockingUsersResponse> respPtr;
        ret = transaction.getResponse(respPtr);
        if (ret < 0)
        {
            return ret;
        }

        Common::IntrusivePtr<Common::Vector<SceNpAccountId> > blocksPtr;
        blocksPtr = respPtr->getBlocks();

        if (blocksPtr.get() == nullptr || blocksPtr->size() <= 0)
        {
            writer.WriteUInt32(0);
        }
        else
        {
            size_t size = blocksPtr->size();

            writer.WriteUInt32(size);

            for (auto it = blocksPtr->begin(); it != blocksPtr->end(); ++it)
            {
                SceNpAccountId friendId = (*it);
                writer.WriteUInt64(friendId);
            }
        }

        if (respPtr->nextOffsetIsSet())
        {
            writer.WriteInt32(respPtr->getNextOffset());
        }
        else
        {
            writer.WriteInt32(-1);
        }

        if (respPtr->previousOffsetIsSet())
        {
            writer.WriteInt32(respPtr->getPreviousOffset());
        }
        else
        {
            writer.WriteInt32(-1);
        }

        writer.WriteInt32(respPtr->getTotalItemCount());

        transaction.finish();

        return ret;
    }


    void UserSystem::SignedStateCallback(SceUserServiceUserId userId, SceNpState state, void *userData)
    {
        SigninStateEvent event;

        event.userId = userId;
        event.state = state;

        s_PendingSigninStateList.push_back(event);
    }

    void UserSystem::StartSignedStateCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        if (s_SignInCallbackId != -1)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Signed In callback already registered", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 842));
            return;
        }

        int ret = sceNpRegisterStateCallbackA(SignedStateCallback, __null);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 849));
            return;
        }

        s_SignInCallbackId = ret;

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UserSystem::StopSignedStateCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        if (s_SignInCallbackId == -1)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Signed In callback not registered", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 862));
            return;
        }

        int ret = sceNpUnregisterStateCallbackA(s_SignInCallbackId);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 869));
            return;
        }

        s_SignInCallbackId = -1;

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UserSystem::FetchSignedStateEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        if (s_PendingSigninStateList.empty() == true)
        {
            *resultsSize = 0;
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
            return;
        }


        SigninStateEvent event = s_PendingSigninStateList.front();
        s_PendingSigninStateList.pop_front();


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(event.userId);
        writer.WriteInt32(event.state);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UserSystem::ReachabilityStateCallback(SceUserServiceUserId userId, SceNpReachabilityState state, void *userData)
    {
        ReachabilityStateEvent event;

        event.userId = userId;
        event.state = state;

        s_PendingReachabilityStateList.push_back(event);
    }

    void UserSystem::StartReachabilityStateCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        int ret = sceNpRegisterNpReachabilityStateCallback(ReachabilityStateCallback, __null);
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 917));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UserSystem::StopReachabilityStateCallbackImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        int ret = sceNpUnregisterNpReachabilityStateCallback();
        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Users.cpp", 929));
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void UserSystem::FetchReachabilityStateEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        if (s_PendingReachabilityStateList.empty() == true)
        {
            *resultsSize = 0;
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
            return;
        }


        ReachabilityStateEvent event = s_PendingReachabilityStateList.front();
        s_PendingReachabilityStateList.pop_front();


        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(event.userId);
        writer.WriteInt32(event.state);

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }


}
# 31 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\Utils.cpp" 1




#pragma comment(lib,"libSceCommonDialog_stub_weak.a")






namespace psn
{
    int32_t addStringToVector(Common::LibContext* snccLibContext, const char* str, Common::Vector<Common::String>& vec)
    {
        int32_t ret = 0;

        Common::String addString(snccLibContext);
        ret = addString.append(str);
        if (ret < 0) return ret;

        ret = vec.pushBack(addString);
        if (ret < 0) return ret;

        return 0;
    }

    void GetAccountIdStr(SceNpAccountId accountId, char* accountIdBuf, size_t bufferSize)
    {
        sprintf_s(accountIdBuf, bufferSize, "%lu", accountId);
    }

    const char* Utils::GetThisPlatformString()
    {

        return "PS5";



    }

    uint32_t Utils::GetThisPlatformFlag()
    {

        return 1;



    }

    const char* Utils::ToPlatformString(uint32_t platformFlag)
    {
        if (platformFlag == 1)
        {
            return "PS5";
        }

        if (platformFlag == 2)
        {
            return "PS4";
        }

        return "NONE";
    }

    uint32_t Utils::GetPlatformFlag(const char* platform)
    {

        if (strncmp(platform, "PS5", 3) == 0)
        {
            return 1;
        }

        if (strncmp(platform, "PROSPERO", 8) == 0)
        {
            return 1;
        }

        if (strncmp(platform, "PS4", 3) == 0)
        {
            return 2;
        }

        return 0;
    }

    int Utils::AddPlatformStrings(uint32_t platformFlags, Vector<String>& supportedPlatforms)
    {
        Common::LibContext* libContextPtr = WebApi::Instance()->GetLibCtx();

        int ret = 0;

        if ((platformFlags & 1) != 0)
        {
            ret = addStringToVector(libContextPtr, "PS5", supportedPlatforms);
            if (ret < 0) return ret;
        }

        if ((platformFlags & 2) != 0)
        {
            ret = addStringToVector(libContextPtr, "PS4", supportedPlatforms);
            if (ret < 0) return ret;
        }

        return ret;
    }

    void Utils::DeletePtr(Vector<String>* ptr)
    {
        delete ptr;
    }

    int Utils::InitializeCommonDialog()
    {
        int ret = sceCommonDialogInitialize();

        if (ret == -2135425022)
        {
            return 0;
        }

        return ret;
    }
}
# 32 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApi.cpp" 1

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libhttp2.h" 1 3
# 67 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libhttp2.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libssl.h" 1 3
# 60 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libssl.h" 3
extern "C" {
# 4089 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libssl.h" 3
typedef enum {
 SCE_SSL_FINGERPRINT_TYPE_MD5,
 SCE_SSL_FINGERPRINT_TYPE_SHA1,
 SCE_SSL_FINGERPRINT_TYPE_SHA224,
 SCE_SSL_FINGERPRINT_TYPE_SHA256,
 SCE_SSL_FINGERPRINT_TYPE_SHA384,
 SCE_SSL_FINGERPRINT_TYPE_SHA512
} SceSslFingerprintHashAlgorithm;

typedef struct SceSslMemoryPoolStats{
  size_t poolSize;
  size_t maxInuseSize;
  size_t currentInuseSize;
  int32_t reserved;
  uint8_t padding[4];
} SceSslMemoryPoolStats;

typedef void SceSslCert;
typedef void SceSslCertName;

typedef struct SceSslCaList {
 SceSslCert **caCerts;
 int caNum;
} SceSslCaList;

typedef struct SceSslData {
 char *ptr;
 size_t size;
} SceSslData;

typedef struct SceSslCaCerts{
 SceSslData* certData;
 size_t certDataNum;
 void* pool;
} SceSslCaCerts;

typedef enum {
 SCE_SSL_VERSION_NONE = 0,
 SCE_SSL_VERSION_SSL2_0,
 SCE_SSL_VERSION_SSL3_0,
 SCE_SSL_VERSION_TLS1_0,
 SCE_SSL_VERSION_TLS1_1,
 SCE_SSL_VERSION_TLS1_2
} SceSslVersion;
# 4146 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libssl.h" 3
typedef int(*SceSslCallback)(
 int libsslCtxId,
 unsigned int verifyErr,
 SceSslCert * const sslCert[],
 int certNum,
 void *userArg);

int sceSslInit(size_t poolSize) ;
int sceSslTerm(int libsslCtxId) ;
int sceSslGetMemoryPoolStats (int libsslCtxId, SceSslMemoryPoolStats* currentStat);
int sceSslGetCaList(int libsslCtxId, SceSslCaList* caList);
int sceSslFreeCaList(int libsslCtxId, SceSslCaList* caList);
SceSslCertName *sceSslGetSubjectName (int libsslCtxId, SceSslCert *sslCert);
SceSslCertName *sceSslGetIssuerName (int libsslCtxId, SceSslCert *sslCert);
int sceSslGetNotAfter (int libsslCtxId, SceSslCert *sslCert, SceRtcTick *limit);
int sceSslGetNotBefore (int libsslCtxId, SceSslCert *sslCert, SceRtcTick *begin);
int sceSslGetNameEntryCount (int libsslCtxId, const SceSslCertName *certName);
int sceSslGetNameEntryInfo (int libsslCtxId, const SceSslCertName *certName, int entryNum, char *oidname, size_t maxOidnameLen, uint8_t *value, size_t maxValueLen, size_t *valueLen);
int sceSslFreeSslCertName (int libsslCtxId, SceSslCertName *certName);
int sceSslGetFingerprint(int libsslCtxId, SceSslCert *sslCert, int hashType, uint8_t *fingerprint);
int sceSslGetPem(int libsslCtxId, SceSslCert *sslCert, char *pem, size_t *pemSize);
int sceSslGetSerialNumber (int libsslCtxId, SceSslCert *sslCert, uint8_t *sboData, size_t *sboLen);
int sceSslGetCaCerts(int libsslCtxId, SceSslCaCerts* caCerts);
int sceSslFreeCaCerts(int libsslCtxId, SceSslCaCerts* caCerts);


int sceSslSetAlpn(int sslConnectionId, const char *proto);
const char* sceSslGetAlpnSelected(int sslConnectionId);
int sceSslCreateConnection(int libsslCtxId, SceNetId sockId, const char* hostname);
int sceSslDeleteConnection(int sslConnectionId);
int sceSslConnect(int sslConnectionId);
int sceSslWrite(int sslConnectionId, const void *buf, SceSize len, int flags);
int sceSslRead(int sslConnectionId, void *buf, SceSize len, int flags);
int sceSslClose(int sslConnectionId);
int sceSslSetVerifyCallback(int sslConnectionId, SceSslCallback cbfunc, void *userArg);
int sceSslEnableVerifyOption(int sslConnectionId, uint32_t option);
int sceSslDisableVerifyOption(int sslConnectionId, uint32_t option);
int sceSslLoadCert(int libsslCtxId, int caCertNum, const SceSslData **caList, const SceSslData *cert, const SceSslData *privKey);
int sceSslUnloadCert(int libsslCtxId);
int sceSslSetMinSslVersion(int sslConnectionId, SceSslVersion version);
int sceSslReuseConnection(int sslConnectionId, SceNetId sockId);




int sceSslSend(int sslConnectionId, const void *msg, SceSize fulllen);

int sceSslRecv(int sslConnectionId, void *buf, SceSize fulllen);
# 4204 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libssl.h" 3
}
# 68 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libhttp2.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libhttp2/libhttp2_error.h" 1 3
# 69 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libhttp2.h" 2 3




extern "C" {
# 101 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libhttp2.h" 3
typedef enum {
 SCE_HTTP2_VERSION_1_0 = 1,
 SCE_HTTP2_VERSION_1_1,
 SCE_HTTP2_VERSION_2_0
} SceHttp2HttpVersion;

typedef enum {
 SCE_HTTP2_HEADER_OVERWRITE,
 SCE_HTTP2_HEADER_ADD
} SceHttp2AddHeaderMode;


typedef enum {
 SCE_HTTP2_AUTH_BASIC,
 SCE_HTTP2_AUTH_DIGEST,
 SCE_HTTP2_AUTH_RESERVED0,
 SCE_HTTP2_AUTH_RESERVED1,
 SCE_HTTP2_AUTH_RESERVED2
} SceHttp2AuthType;
# 131 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libhttp2.h" 3
typedef int(*SceHttp2SslCallback)(
 int libsslCtxId,
 unsigned int verifyErr,
 SceSslCert * const sslCert[],
 int certNum,
 void *userArg);


typedef int(*SceHttp2AuthInfoCallback)(
 int reqId,
 SceHttp2AuthType authType,
 const char *realm,
 char *username,
 char *password,
 int isNeedEntity,
 uint8_t **entityBody,
 size_t *entitySize,
 int *isSave,
 void *userArg);

typedef int(*SceHttp2RedirectCallback)(
 int reqId,
 int32_t statusCode,
 const char **method,
 const char *location,
 void *userArg);

typedef int(*SceHttp2CookieRecvCallback)(
 int reqId,
 const char *url,
 const char *cookieHeader,
 size_t headerLen,
 void *userArg);

typedef int(*SceHttp2CookieSendCallback)(
 int reqId,
 const char *url,
 const char *cookieHeader,
 void *userArg);

typedef struct SceHttp2MemoryPoolStats {
 size_t poolSize;
 size_t maxInuseSize;
 size_t currentInuseSize;
 int32_t reserved;
 uint8_t padding[4];
} SceHttp2MemoryPoolStats;

typedef struct SceHttp2CookieStats {
 size_t currentInuseSize;
 uint32_t currentInuseNum;
 uint8_t padding1[4];
 size_t maxInuseSize;
 uint32_t maxInuseNum;
 uint32_t removedNum;
 int32_t reserved;
 uint8_t padding2[4];
} SceHttp2CookieStats;

typedef enum {
 SCE_HTTP2_CONTENTLEN_EXIST,
 SCE_HTTP2_CONTENTLEN_NOT_FOUND,
 SCE_HTTP2_CONTENTLEN_CHUNK_ENC
} SceHttp2ContentLengthType;


int sceHttp2Init(int libnetMemId, int libsslCtxId, size_t poolSize, int maxConcurrentlRequest);
int sceHttp2Term(int libhttpCtxId);
int sceHttp2GetMemoryPoolStats(int libhttp2CtxId, SceHttp2MemoryPoolStats* currentStat);

int sceHttp2CreateTemplate(int libhttpCtxId, const char *userAgent, int httpVer, int isAutoProxyConf);
int sceHttp2DeleteTemplate(int tmplId);
int sceHttp2CreateRequestWithURL(int tmplId, const char* method, const char *url, uint64_t contentLength);
int sceHttp2DeleteRequest(int reqId);

int sceHttp2SslEnableOption(int templateOrReqId, uint32_t sslFlags);
int sceHttp2SslDisableOption(int templateOrReqId, uint32_t sslFlags);
int sceHttp2SetMinSslVersion(int tmplId, SceSslVersion version);
int sceHttp2SetSslCallback(int templateOrReqId, SceHttp2SslCallback cbfunc, void *userArg);
int sceHttp2SendRequest(int reqId, const void *postData, size_t size);
int sceHttp2GetResponseContentLength(int reqId, int* result, uint64_t *contentLength);
int sceHttp2GetStatusCode(int reqId, int *statusCode);
int sceHttp2GetAllResponseHeaders(int reqId, char **header, size_t *headerSize);
int sceHttp2GetAllTrailingHeaders(int reqId, char **header, size_t *headerSize);
int sceHttp2ReadData(int reqId, void *data, size_t size);
int sceHttp2AbortRequest(int reqId);
int sceHttp2AddRequestHeader(int templateOrReqId, const char *name, const char *value, uint32_t mode);
int sceHttp2RemoveRequestHeader(int templateOrReqId, const char *name);

int sceHttp2SetRequestContentLength(int reqId, uint64_t contentLength);
int sceHttp2SetRequestNoContentLength(int reqId);
int sceHttp2SetInflateGZIPEnabled(int templateOrReqId, int isEnable);

int sceHttp2SetAuthInfoCallback(int templateOrReqId, SceHttp2AuthInfoCallback cbfunc, void *userArg);
int sceHttp2SetAuthEnabled(int templateOrReqId, int isEnable);
int sceHttp2GetAuthEnabled(int templateOrReqId, int *isEnable);
int sceHttp2AuthCacheFlush(int libhttpCtxId);
int sceHttp2SetRedirectCallback(int templateOrReqId, SceHttp2RedirectCallback cbfunc, void *userArg);
int sceHttp2SetAutoRedirect(int templateOrReqId, int isEnable);
int sceHttp2GetAutoRedirect(int templateOrReqId, int *isEnable);
int sceHttp2RedirectCacheFlush(int libhttpCtxId);
int sceHttp2SetTimeOut(int templateOrReqId, uint32_t usec);
int sceHttp2SetResolveTimeOut(int templateOrReqId, uint32_t usec);
int sceHttp2SetResolveRetry(int templateOrReqId, int retry);
int sceHttp2SetConnectTimeOut(int templateOrReqId, uint32_t usec);
int sceHttp2SetSendTimeOut(int templateOrReqId, uint32_t usec);
int sceHttp2SetRecvTimeOut(int templateOrReqId, uint32_t usec);
int sceHttp2SetConnectionWaitTimeOut(int templateOrReqId, uint32_t usec);

int sceHttp2CreateCookieBox(size_t poolSize);
int sceHttp2DeleteCookieBox(int cookieBoxId);
int sceHttp2SetCookieBox(int templateOrReqId, int cookieBoxId);
int sceHttp2GetCookieBox(int templateOrReqId, int *cookieBoxId);
int sceHttp2SetCookieRecvCallback(int templateOrReqId, SceHttp2CookieRecvCallback cbfunc, void *userArg);
int sceHttp2SetCookieSendCallback(int templateOrReqId, SceHttp2CookieSendCallback cbfunc, void *userArg);

int sceHttp2GetCookie(int cookieBoxId, const char *url, char *cookie, size_t *required, size_t prepared);
int sceHttp2AddCookie(int cookieBoxId, const char *url, const char *cookie, size_t cookieLength);
int sceHttp2CookieExport(int cookieBoxId, void *buffer, size_t bufferSize, size_t *exportSize);
int sceHttp2CookieImport(int cookieBoxId, const void *buffer, size_t bufferSize);
int sceHttp2CookieFlush(int cookieBoxId);

int sceHttp2SetCookieMaxSize(int cookieBoxId, uint32_t size);
int sceHttp2SetCookieMaxNum(int cookieBoxId, uint32_t num);
int sceHttp2SetCookieMaxNumPerDomain(int cookieBoxId, uint32_t num);
int sceHttp2GetCookieStats(int cookieBoxId, SceHttp2CookieStats* stats);

typedef enum {
 SCE_HTTP2_ASYNC_EVENT_SEND_REQUEST_FINISHED,
 SCE_HTTP2_ASYNC_EVENT_READ_DATA_FINISHED,
 SCE_HTTP2_ASYNC_EVENT_WEBSOCKET_SEND_TEXT_MESSAGE_FINISHED,
 SCE_HTTP2_ASYNC_EVENT_WEBSOCKET_SEND_DATA_MESSAGE_FINISHED,
 SCE_HTTP2_ASYNC_EVENT_WEBSOCKET_CLOSE_FINISHED,
} SceHttp2AsyncEventType;

typedef struct SceHttp2AsyncResult {
 SceHttp2AsyncEventType eventType;
 int reqId;
 int result;
 uint8_t padding[4];
 void *reserved;
}SceHttp2AsyncResult;

typedef struct SceHttp2TriggerUserEventArgs{
 SceKernelEqueue eq;
 int uniqId;
 uint8_t padding[4];
 void *udata;
 void *reserved;
}SceHttp2TriggerUserEventArgs;

int sceHttp2SendRequestAsync(int reqId, const void *postData, size_t size, SceHttp2TriggerUserEventArgs *kqueueOption, void *option);
int sceHttp2ReadDataAsync(int reqId, void *data, size_t size, SceHttp2TriggerUserEventArgs *kqueueOption, void *option);
int sceHttp2WaitAsync(int reqId, SceHttp2AsyncResult *result, SceKernelUseconds *pInOutTimeout, void *option);
# 309 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libhttp2.h" 3
typedef void(*SceHttp2WebSocketTextMessageCallback)(
 int reqId,
 const char *utf8Message,
 int flags,
 void *userArg);
typedef void(*SceHttp2WebSocketDataMessageCallback)(
 int reqId,
 const void *data,
 size_t dataSize,
 int flags,
 void *userArg);
typedef void(*SceHttp2WebSocketNormalCloseCallback)(
 int reqId,
 const uint16_t *optinalStatusCode,
 const char *optionalUtf8Message,
 int flags,
 void *userArg);
typedef void(*SceHttp2WebSocketErrorCloseCallback)(
 int reqId,
 int errorCode,
 void *userArg);
int sceHttp2WebSocketCreateRequest(
 int tmplId,
 const char *url,
 SceHttp2WebSocketTextMessageCallback textMessageFunc,
 SceHttp2WebSocketDataMessageCallback dataMessageFunc,
 SceHttp2WebSocketNormalCloseCallback normalCloseFunc,
 SceHttp2WebSocketErrorCloseCallback errorCloseFunc,
 void *recvMessageBuffer,
 size_t recvMessageBufferSize,
 void *callbackUserArg,
 void *option
);

int sceHttp2WebSocketSendTextMessage(int reqId, const char *utf8Message, int flags, void *option);
int sceHttp2WebSocketSendTextMessageAsync(int reqId, const char *utf8Message, int flags, SceHttp2TriggerUserEventArgs *kqueueOption, void *option);
int sceHttp2WebSocketSendDataMessage(int reqId, const void *data, size_t dataSize, int flags, void *option);
int sceHttp2WebSocketSendDataMessageAsync(int reqId, const void *data, size_t dataSize, int flags, SceHttp2TriggerUserEventArgs *kqueueOption, void *option);
int sceHttp2WebSocketClose(int reqId, const uint16_t *optionalStatusCode, const char *optionalUtf8Message, int flags, void *option);
int sceHttp2WebSocketCloseAsync(int reqId, const uint16_t *optionalStatusCode, const char *optionalUtf8Message, int flags, SceHttp2TriggerUserEventArgs *kqueueOption, void *option);
int sceHttp2WebSocketSetPingTimeout(int reqId, uint32_t usec);
int sceHttp2WebSocketSetPingInterval(int reqId, uint32_t usec);






}
# 3 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApi.cpp" 2


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\json2_rtti.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\json2_rtti.h" 3
namespace sce{
namespace Json{

typedef void* (*fpAlloc)(size_t, void*);
typedef void (*fpDealloc)(void*, void*);
typedef void (*fpNotifyErrCB)(int32_t, size_t, void*);
class AllocParamRtti
{
public:
 AllocParamRtti()
  : allocator(__null), deallocator(__null), notifyError(__null) {};

 AllocParamRtti(fpAlloc alc, fpDealloc dalc, fpNotifyErrCB notifyerr=__null)
  : allocator(alc), deallocator(dalc), notifyError(notifyerr) {};
 fpAlloc allocator;
 fpDealloc deallocator;
 fpNotifyErrCB notifyError;
};

class InitParameterRtti :public InitParameter
{
public:
 InitParameterRtti(AllocParamRtti *al, void *ud, size_t fbsiz);
};

class InitParameterRtti2 :public InitParameter2
{
public:
 void setAllocatorRtti(AllocParamRtti* allocParam, void* ud);
};

}
}
# 6 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApi.cpp" 2




#pragma comment(lib,"libSceSsl_stub_weak.a")
#pragma comment(lib,"libSceHttp2_stub_weak.a")



namespace psn
{
    UserMap<WebApiUserContext> WebApi::s_UsersList;

    void *WebApiAllocator::allocate(size_t size, void *user_data)
    {
        void *p = malloc(size);
        return p;
    }

    void WebApiAllocator::deallocate(void *ptr, void *user_data)
    {
        free(ptr);
    }

    void WebApiAllocator::notifyError(int32_t error, size_t size, void *userData)
    {
        switch (error)
        {
            case (-2138799870):
                printf("allocate Fail. size = %ld\n", size);
                abort();
                break;
            default:
                printf("unknown[%#x]\n", error);
                break;
        }
    }

    WebApiUserContext::WebApiUserContext(SceUserServiceUserId userId)
    {
        m_userId = userId;
        m_webapiUserCtxId = -1;
    }

    int WebApiUserContext::Create(int32_t webapiLibCtxId)
    {
        int ret;

        ret = sceNpWebApi2CreateUserContext(webapiLibCtxId, m_userId);
        if (ret < 0)
        {
            return ret;
        }

        m_webapiUserCtxId = ret;

        return ret;
    }

    int WebApiUserContext::Destroy()
    {
        int ret = 0;

        if (m_webapiUserCtxId != -1)
        {
            ret = sceNpWebApi2DeleteUserContext(m_webapiUserCtxId);

            if (ret < 0)
            {
                return ret;
            }
        }

        m_webapiUserCtxId = -1;

        return ret;
    }

    WebApi::WebApi() :
        m_isInitialised(false),
        m_libnetMemId(-1),
        m_libsslCtxId(-1),
        m_libhttp2CtxId(-1),
        m_webapiLibCtxId(-1)
    {
    }

    WebApi* WebApi::s_webApiInstance = __null;

    int WebApi::Create()
    {
        if (m_isInitialised == true)
        {
            return 0;
        }

        int32_t ret = 0;
        Common::InitParams initParams;

        sce::Json::InitParameterRtti2 jsonInitParam;





        ret = sceNetPoolCreate("WebApiUserProfile", (16 * 1024), 0);
        if (ret < 0)
        {
            return ret;
        }
        m_libnetMemId = ret;


        ret = sceSslInit((384 * 1024));
        if (ret < 0)
        {
            printf("sceSslInit() error: 0x%x\n", ret);
            return ret;
        }
        m_libsslCtxId = ret;


        ret = sceHttp2Init(m_libnetMemId, m_libsslCtxId, (512 * 1024), 1);
        if (ret < 0)
        {
            printf("sceHttpInit() error: 0x%x\n", ret);
            return ret;
        }
        m_libhttp2CtxId = ret;

        ret = sceNpWebApi2Initialize(m_libhttp2CtxId, (512 * 1024));
        if (ret < 0)
        {
            printf("sceNpWebApi2Initialize() failed. ret = 0x%x\n", ret);
            return ret;
        }
        m_webapiLibCtxId = ret;

        ret = Common::initialize(initParams, m_cppWebapiLibCtx);
        if (ret < 0)
        {
            printf("CppWebApi::Common::initialize() failed. ret = 0x%x\n", ret);
            return ret;
        }

     sce::Json::AllocParamRtti allocParam(WebApiAllocator::allocate, WebApiAllocator::deallocate, WebApiAllocator::notifyError);
        jsonInitParam.setAllocatorRtti(&allocParam, 0);




        jsonInitParam.setFileBufferSize((512));
        ret = m_initializer.initialize(&jsonInitParam);
        if (ret < 0)
        {
            printf("CppWebApi::Common::initialize() failed. ret = 0x%x\n", ret);
            return ret;
        }

        m_isInitialised = true;
        return 0;
    }

    void WebApi::Destroy()
    {
        m_isInitialised = false;
    }

    int WebApi::Initialise()
    {
        if (s_webApiInstance != __null)
        {
            return 0;
        }

        s_webApiInstance = new WebApi();
        int ret = s_webApiInstance->Create();
        if (ret < 0)
        {
            return ret;
        }

        MsgHandler::RegisterUserCallback(HandleUserState);

        return 0;
    }

    void WebApi::Terminate()
    {
        if (s_webApiInstance == __null)
        {
            return;
        }

        s_webApiInstance->Destroy();
        delete s_webApiInstance;
        s_webApiInstance = __null;
    }

    WebApiUserContext* WebApi::FindUser(SceUserServiceUserId userId)
    {
        WebApiUserContext* user = s_UsersList.FindUser(userId);

        if (user != __null && user->m_webapiUserCtxId == -1)
        {

            user->Create(WebApi::Instance()->m_webapiLibCtxId);
        }

        return user;
    }

    void WebApi::HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result)
    {
        if (state == MsgHandler::UserState::Added)
        {
            if (s_UsersList.DoesUserExist(userId) == true)
            {

                (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User already initialised with Trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApi.cpp", 225));
                return;
            }

            WebApiUserContext* user = s_UsersList.CreateUser(userId);

            user->Create(WebApi::Instance()->m_webapiLibCtxId);
        }
        else if (state == MsgHandler::UserState::Removed)
        {
            WebApiUserContext* user = s_UsersList.FindUser(userId);

            if (user == __null)
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Warning, "User not registered with trophy service", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApi.cpp", 239));
                return;
            }

            if (user->m_webapiUserCtxId == 0)
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "User WebApi context is invalid", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApi.cpp", 245));
                return;
            }

            user->Destroy();

            s_UsersList.DeleteUser(userId);
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }
# 268 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApi.cpp"
}
# 33 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp" 1



namespace psn
{
    typedef void(*EventHandler)(void*, Int32 size);
    EventHandler sEventHandlerCallback = __null;

    extern "C" __declspec (dllexport) void RegisterEventHandler (EventHandler callback)
    {
        sEventHandlerCallback = callback;
    }

    WebApiNotifications* WebApiNotifications::s_Instance = __null;

    WebApiNotifications::WebApiNotifications()

    {
    }

    WebApiNotifications::~WebApiNotifications()
    {
    }

    void WebApiNotifications::Initialise()
    {
        if (s_Instance != __null)
        {
            return;
        }

        if (WebApi::Instance() == __null)
        {
            return;
        }

        s_Instance = new WebApiNotifications();

        s_Instance->Create();
    }

    void WebApiNotifications::Terminate()
    {
        if (s_Instance == __null)
        {
            return;
        }

        s_Instance->Destroy();
        delete s_Instance;
        s_Instance = __null;
    }

    void WebApiNotifications::RegisterMethods()
    {
        MsgHandler::AddMethod(Methods::RegisterFilter, WebApiNotifications::RegisterFilterImpl);
        MsgHandler::AddMethod(Methods::UnregisterFilter, WebApiNotifications::UnregisterFilterImpl);
        MsgHandler::AddMethod(Methods::RegisterPushEvent, WebApiNotifications::RegisterPushEventImpl);
        MsgHandler::AddMethod(Methods::UnregisterPushEvent, WebApiNotifications::UnregisterPushEventImpl);

        MsgHandler::RegisterUserCallback(HandleUserState);
    }

    void WebApiNotifications::HandleUserState(SceUserServiceUserId userId, MsgHandler::UserState state, APIResult* result)
    {
    }

    PushFilter* WebApiNotifications::GetOrCreateFilter(BinaryReader& reader, APIResult* result)
    {
        Int32 currentFilterId = reader.ReadInt32();
        PushFilter* filter = __null;

        if (currentFilterId != -1)
        {

            PushFilter* filter = m_ActivePushFilters.Find(currentFilterId);

            if (filter == __null)
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Existing filter can't be found", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp", 80));
                return __null;
            }

            return filter;
        }

        filter = new PushFilter();

        if (filter->Deserialise(reader, result) == false)
        {
            delete filter;
            return __null;
        }

        m_ActivePushFilters.Add(filter->GetFilterId(), filter);

        return filter;
    }

    PushFilter* WebApiNotifications::GetFilter(BinaryReader& reader, APIResult* result)
    {
        Int32 currentFilterId = reader.ReadInt32();

        if (currentFilterId != -1)
        {

            PushFilter* filter = m_ActivePushFilters.Find(currentFilterId);

            if (filter == __null)
            {
                (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Existing filter can't be found", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp", 111));
                return __null;
            }

            return filter;
        }

        return __null;
    }

    void WebApiNotifications::RegisterFilterImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        WebApiNotifications* instance = Instance();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        PushFilter* filter = instance->GetOrCreateFilter(reader, result);

        if (filter == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "The Filter couldn't be created.", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp", 133));
            return;
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(filter->GetFilterId());

        *resultsSize = writer.GetWrittenLength();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void WebApiNotifications::UnregisterFilterImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        WebApiNotifications* instance = Instance();

        BinaryReader reader(sourceData, sourceSize);

        Int32 filterId = reader.ReadInt32();

        PushFilter* filter = instance->m_ActivePushFilters.Find(filterId);

        if (filter == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Filter Id not found", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp", 158));
            return;
        }


        filter->Destroy();

        delete filter;

        instance->m_ActivePushFilters.Remove(filterId);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void WebApiNotifications::RegisterPushEventImpl(UInt8* sourceData, int sourceSize, UInt8* resultsData, int resultsMaxSize, int* resultsSize, APIResult* result)
    {
        WebApiNotifications* instance = Instance();

        *resultsSize = 0;

        BinaryReader reader(sourceData, sourceSize);

        Int32 currentPushCallbackId = reader.ReadInt32();

        if (currentPushCallbackId != -1)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Push event looks like it is already registered", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp", 184));
            return;
        }

        Int32 userId = reader.ReadInt32();

        WebApiUserContext* userContext = WebApi::Instance()->FindUser(userId);

        if (userContext == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "No user context found", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp", 194));
            return;
        }

        bool orderGuaranteed = reader.ReadBool();

        PushFilter* filter = instance->GetFilter(reader, result);

        if (filter == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "The PushEvents filter can't be created or found", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp", 204));
            return;
        }

        bool ok = false;
        PushEventBase* newEvent;

        if (orderGuaranteed == false)
        {
            PushEvent* pushEvent = new PushEvent();
            ok = pushEvent->Deserialise(reader, userContext, filter, PushEventCallback, instance, result);
            newEvent = pushEvent;
        }
        else
        {
            OrderGuaranteedPushEvent* pushEvent = new OrderGuaranteedPushEvent();
            ok = pushEvent->Deserialise(reader, userContext, filter, OrderGuaranteedEventCallback, instance, result);
            newEvent = pushEvent;
        }

        int32_t callbackId = newEvent->GetCallbackID();

        if (ok == true)
        {

            instance->m_ActivePushEvents.Add(callbackId, newEvent);
        }

        BinaryWriter writer(resultsData, resultsMaxSize);

        writer.WriteInt32(callbackId);

        *resultsSize = writer.GetWrittenLength();

        if (ok == false)
        {
            return;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    void WebApiNotifications::UnregisterPushEventImpl(UInt8* sourceData, int sourceSize, APIResult* result)
    {
        WebApiNotifications* instance = Instance();

        BinaryReader reader(sourceData, sourceSize);

        Int32 callbackId = reader.ReadInt32();

        PushEventBase* pushEvent = instance->m_ActivePushEvents.Find(callbackId);

        if (pushEvent == __null)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Error, "Event callback Id not found", "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiNotifications.cpp", 258));
            return;
        }

        if (pushEvent->IsOrderGuaranteed())
        {
            OrderGuaranteedPushEvent* pEvent = (OrderGuaranteedPushEvent*)pushEvent;
            pEvent->Destroy();
            delete pEvent;
        }
        else
        {
            PushEvent* pEvent = (PushEvent*)pushEvent;
            pEvent->Destroy();
            delete pEvent;
        }

        instance->m_ActivePushEvents.Remove(callbackId);

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
    }

    PushEventBase* WebApiNotifications::FindPushEvent(int pushCallbackId)
    {
        WebApiNotifications* instance = Instance();

        return instance->m_ActivePushEvents.Find(pushCallbackId);
    }

    OrderGuaranteedPushEvent* WebApiNotifications::FindOrderedPushEvent(int pushCallbackId)
    {
        WebApiNotifications* instance = Instance();

        PushEventBase* pushEvent = instance->m_ActivePushEvents.Find(pushCallbackId);

        if (pushEvent == __null)
        {
            return __null;
        }

        if (pushEvent->IsOrderGuaranteed() == false)
        {
            return __null;
        }

        return (OrderGuaranteedPushEvent*)pushEvent;
    }

    void WebApiNotifications::CommonEventCallback(int32_t userCtxId, int32_t callbackId, const char *pNpServiceName, SceNpServiceLabel npServiceLabel,
        const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId,
        const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen,
        const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg,
        bool isOrderGuaranteed, const SceNpWebApi2PushEventPushContextId *pPushCtxId, SceNpWebApi2PushEventPushContextCallbackType cbType)
    {
        if (!pUserArg || !pDataType)
        {
            return;
        }

        CallbackParams* params = new CallbackParams();

        memset(params, 0, sizeof(CallbackParams));

        params->userCtxId = userCtxId;
        params->callbackId = callbackId;

        params->orderGuaranteed = isOrderGuaranteed;

        params->pNpServiceName = pNpServiceName;
        params->serviceNameLen = pNpServiceName != __null ? strlen(pNpServiceName) : 0;

        params->npServiceLabel = npServiceLabel;

        params->hasToPeer = pTo != __null ? true : false;
        params->toAccountId = pTo != __null ? pTo->accountId : 0;
        params->toPlatform = pTo != __null ? pTo->platform : 0;

        params->toOnlineId = pToOnlineId != __null ? pToOnlineId->data : __null;
        params->toOnlineIdLen = pToOnlineId != __null ? strlen(pToOnlineId->data) : 0;

        params->hasFromPeer = pFrom != __null ? true : false;
        params->fromAccountId = pFrom != __null ? pFrom->accountId : 0;
        params->fromPlatform = pFrom != __null ? pFrom->platform : 0;

        params->fromOnlineId = pFromOnlineId != __null ? pFromOnlineId->data : __null;
        params->fromOnlineIdLen = pFromOnlineId != __null ? strlen(pFromOnlineId->data) : 0;

        params->pDataType = pDataType != __null ? pDataType->val : __null;
        params->dataTypeLen = pDataType != __null ? strlen(pDataType->val) : 0;

        params->pData = pData;
        params->dataLen = dataLen;

        if (extdDataNum == 0)
        {
            params->extdData = 0;
            params->extdDataNum = 0;
        }
        else
        {
            params->extdData = new CallbackExtdData[extdDataNum];
            params->extdDataNum = extdDataNum;
            params->extdStructSize = sizeof(CallbackExtdData);

            for (int i = 0; i < extdDataNum; i++)
            {
                params->extdData[i].extdDataKey = pExtdData[i].extdDataKey.val;
                params->extdData[i].extdDataKeyLen = strlen(pExtdData[i].extdDataKey.val);
                params->extdData[i].pData = pExtdData[i].pData;
                params->extdData[i].dataLen = pExtdData[i].dataLen;
            }
        }

        params->pushCtxId = __null;
        params->pushCtxIdLen = 0;
        params->cbType = SceNpWebApi2PushEventPushContextCallbackType::SCE_NP_WEBAPI2_PUSH_EVENT_PUSH_CONTEXT_CALLBACK_TYPE_UNKNOWN;

        if (isOrderGuaranteed == true)
        {
            params->pushCtxId = pPushCtxId != __null ? pPushCtxId->uuid : __null;
            params->pushCtxIdLen = pPushCtxId != __null ? strlen(pPushCtxId->uuid) : 0;
            params->cbType = cbType;
        }

        int32_t size = sizeof(CallbackParams);

        if (sEventHandlerCallback)
        {
            sEventHandlerCallback(params, size);
        }

        if (params->extdData != __null)
        {
            delete[] params->extdData;
        }

        delete params;
    }

    void WebApiNotifications::PushEventCallback(int32_t userCtxId, int32_t callbackId, const char *pNpServiceName, SceNpServiceLabel npServiceLabel,
        const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId,
        const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen,
        const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg)
    {

        CommonEventCallback(userCtxId, callbackId, pNpServiceName, npServiceLabel,
            pTo, pToOnlineId, pFrom, pFromOnlineId,
            pDataType, pData, dataLen,
            pExtdData, extdDataNum, pUserArg);
    }

    void WebApiNotifications::OrderGuaranteedEventCallback(int32_t userCtxId, int32_t callbackId,
        const SceNpWebApi2PushEventPushContextId *pPushCtxId, SceNpWebApi2PushEventPushContextCallbackType cbType,
        const char *pNpServiceName, SceNpServiceLabel npServiceLabel,
        const SceNpPeerAddressA *pTo, const SceNpOnlineId *pToOnlineId, const SceNpPeerAddressA *pFrom, const SceNpOnlineId *pFromOnlineId,
        const SceNpWebApi2PushEventDataType *pDataType, const char *pData, size_t dataLen,
        const SceNpWebApi2PushEventExtdData *pExtdData, size_t extdDataNum, void *pUserArg)
    {

        CommonEventCallback(userCtxId, callbackId, pNpServiceName, npServiceLabel,
            pTo, pToOnlineId, pFrom, pFromOnlineId,
            pDataType, pData, dataLen,
            pExtdData, extdDataNum, pUserArg,
            true, pPushCtxId, cbType);
    }

    void WebApiNotifications::Create()
    {
    }

    void WebApiNotifications::Destroy()
    {
    }
}
# 34 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2
# 1 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp" 1



namespace psn
{
    PushFilter::PushFilter() :
        m_PushHandleId(-1),
        m_PushFilterId(-1),
        m_npServiceLabel(0),
        m_FilterParams(__null),
        m_NumberFilterParams(0),
        m_LastError(0),
        m_ReferenceCount(0)
    {
    }

    PushFilter::~PushFilter()
    {
        m_LastError = Destroy();
    }

    int PushFilter::Destroy()
    {
        int32_t libCtxId = WebApi::Instance()->GetLibCtxId();
        int ret = 0;

        if (m_FilterParams != __null)
        {
            delete m_FilterParams;
            m_FilterParams = __null;
            m_NumberFilterParams = 0;
        }

        if (m_PushFilterId != -1)
        {
            ret = sceNpWebApi2PushEventDeleteFilter(libCtxId, m_PushFilterId);
            if (ret < 0)
            {
                m_LastError = ret;
                return ret;
            }
            m_PushFilterId = -1;
        }

        if (m_PushHandleId != -1)
        {
            ret = sceNpWebApi2PushEventDeleteHandle(libCtxId, m_PushHandleId);
            if (ret < 0)
            {
                m_LastError = ret;
                return ret;
            }
            m_PushHandleId = -1;
        }

        return ret;
    }

    int PushFilter::Create(const char* serviceName, SceNpServiceLabel npServiceLabel, const char* filterTypes[], size_t filterTypesNum)
    {
        strncpy(m_ServiceName, serviceName, 255);
        m_npServiceLabel = npServiceLabel;

        m_NumberFilterParams = filterTypesNum;

        m_FilterParams = new SceNpWebApi2PushEventFilterParameter[m_NumberFilterParams];

        for (size_t i = 0; i < m_NumberFilterParams; ++i)
        {
            memset(&m_FilterParams[i].dataType, 0, sizeof(m_FilterParams[i].dataType));
            snprintf(m_FilterParams[i].dataType.val, 64, "%s", filterTypes[i]);
            m_FilterParams[i].pExtdDataKey = nullptr;
            m_FilterParams[i].extdDataKeyNum = 0;
        }

        int ret = PushFilter::Register();

        return ret;
    }

    int PushFilter::Register()
    {
        int32_t libCtxId = WebApi::Instance()->GetLibCtxId();

        int ret = sceNpWebApi2PushEventCreateHandle(libCtxId);
        if (ret < 0)
        {
            m_LastError = ret;
            return ret;
        }
        m_PushHandleId = ret;

        char* serviceName = m_ServiceName;
        if (m_ServiceName[0] == 0)
        {
            serviceName = __null;
        }

        ret = sceNpWebApi2PushEventCreateFilter(libCtxId, m_PushHandleId, serviceName, m_npServiceLabel, m_FilterParams, m_NumberFilterParams);

        if (ret < 0)
        {
            Destroy();
            m_LastError = ret;
            return ret;
        }

        m_PushFilterId = ret;

        return ret;
    }

    bool PushFilter::Deserialise(BinaryReader& reader, APIResult* result)
    {
        char* serviceName = reader.ReadStringPtr();
        SceNpServiceLabel serviceLabel = reader.ReadUInt32();

        if (serviceName != __null)
        {
            strncpy(m_ServiceName, serviceName, 255);
        }
        else
        {
            m_ServiceName[0] = 0;
        }

        m_npServiceLabel = serviceLabel;

        m_NumberFilterParams = reader.ReadUInt32();

        if (m_NumberFilterParams == 0)
        {
            (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));
            return false;
        }

        m_FilterParams = new SceNpWebApi2PushEventFilterParameter[m_NumberFilterParams];

        for (int i = 0; i < m_NumberFilterParams; i++)
        {

            char* dataType = reader.ReadStringPtr();

            memset(&m_FilterParams[i].dataType, 0, sizeof(m_FilterParams[i].dataType));

            snprintf(m_FilterParams[i].dataType.val, 64, "%s", dataType);
            m_FilterParams[i].pExtdDataKey = nullptr;
            m_FilterParams[i].extdDataKeyNum = 0;

            UInt32 numberExts = reader.ReadUInt32();

            if (numberExts > 0)
            {

                SceNpWebApi2PushEventExtdDataKey* extDataKey = new SceNpWebApi2PushEventExtdDataKey[numberExts];

                for (int e = 0; e < numberExts; e++)
                {
                    char* extKey = reader.ReadStringPtr();

                    memset(&extDataKey[e], 0, sizeof(extDataKey[e]));

                    snprintf(extDataKey[e].val, 32, "%s", extKey);
                }

                m_FilterParams[i].pExtdDataKey = extDataKey;
                m_FilterParams[i].extdDataKeyNum = numberExts;
            }
        }

        int ret = PushFilter::Register();

        if (ret < 0)
        {
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp", 175));
            return false;
        }

        return true;
    }

    PushEventBase::PushEventBase() :
        m_UserContext(__null),
        m_PushCallbackId(-1),
        m_IsOrderGuaranteed(false)
    {
    }

    PushEvent::PushEvent()
    {
    }

    PushEvent::~PushEvent()
    {
    }

    int PushEvent::Create(WebApiUserContext* userContext, PushFilter* filter, SceNpWebApi2PushEventCallback cbFunc, void* pUserArg)
    {
        m_UserContext = userContext;
        m_Filter = filter;

        int ret;
# 211 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp"
        ret = sceNpWebApi2PushEventRegisterCallback(m_UserContext->GetUserCtxId(), m_Filter->GetFilterId(), cbFunc, pUserArg);
        if (ret < 0)
        {
            Destroy();
            return ret;
        }

        m_PushCallbackId = ret;

        m_Filter->IncRefCount();

        return ret;
    }

    int PushEvent::Destroy()
    {
        int ret = 0;

        if (m_PushCallbackId != -1)
        {
            ret = sceNpWebApi2PushEventUnregisterCallback(m_UserContext->GetUserCtxId(), m_PushCallbackId);
            if (ret < 0)
            {
                return ret;
            }
            m_PushCallbackId = -1;
        }

        m_Filter->DecRefCount();







        m_UserContext = __null;

        return ret;
    }

    bool PushEvent::Deserialise(BinaryReader& reader, WebApiUserContext* userContext, PushFilter* filter, SceNpWebApi2PushEventCallback cbFunc, void* pUserArg, APIResult* result)
    {
        m_UserContext = userContext;
        m_Filter = filter;
# 265 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp"
        int ret = sceNpWebApi2PushEventRegisterCallback(m_UserContext->GetUserCtxId(), m_Filter->GetFilterId(), cbFunc, pUserArg);
        if (ret < 0)
        {
            Destroy();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp", 269));
            return false;
        }

        m_PushCallbackId = ret;
        m_Filter->IncRefCount();

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));

        return true;
    }

    OrderGuaranteedPushEvent::OrderGuaranteedPushEvent() :
        m_PushContextIdCreated(false)
    {
        m_IsOrderGuaranteed = true;
    }

    OrderGuaranteedPushEvent::~OrderGuaranteedPushEvent()
    {
    }

    int OrderGuaranteedPushEvent::Create(WebApiUserContext* userContext, PushFilter* filter, SceNpWebApi2PushEventPushContextCallback cbFunc, void* pUserArg)
    {
        m_UserContext = userContext;
        m_Filter = filter;

        int ret;
# 305 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp"
        ret = sceNpWebApi2PushEventRegisterPushContextCallback(m_UserContext->GetUserCtxId(), m_Filter->GetFilterId(), cbFunc, pUserArg);

        if (ret < 0)
        {
            Destroy();
            return ret;
        }

        m_PushCallbackId = ret;
        m_Filter->IncRefCount();

        ret = sceNpWebApi2PushEventCreatePushContext(m_UserContext->GetUserCtxId(), &m_PushContextId);

        if (ret < 0)
        {
            Destroy();
            return ret;
        }

        m_PushContextIdCreated = true;

        ret = sceNpWebApi2PushEventStartPushContextCallback(m_UserContext->GetUserCtxId(), &m_PushContextId);
        if (ret < 0)
        {
            Destroy();
            return ret;
        }

        return ret;
    }

    int OrderGuaranteedPushEvent::Destroy()
    {
        int ret = 0;

        if (m_PushContextIdCreated == true)
        {
            ret = sceNpWebApi2PushEventDeletePushContext(m_UserContext->GetUserCtxId(), &m_PushContextId);
            if (ret < 0)
            {
                return ret;
            }
            m_PushContextIdCreated = false;
        }

        if (m_PushCallbackId != -1)
        {
            ret = sceNpWebApi2PushEventUnregisterCallback(m_UserContext->GetUserCtxId(), m_PushCallbackId);
            if (ret < 0)
            {
                return ret;
            }
            m_PushCallbackId = -1;
        }

        m_Filter->DecRefCount();







        m_UserContext = __null;

        return ret;
    }

    bool OrderGuaranteedPushEvent::Deserialise(BinaryReader& reader, WebApiUserContext* userContext, PushFilter* filter, SceNpWebApi2PushEventPushContextCallback cbFunc, void* pUserArg, APIResult* result)
    {
        m_UserContext = userContext;
        m_Filter = filter;
# 386 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp"
        int ret = sceNpWebApi2PushEventRegisterPushContextCallback(m_UserContext->GetUserCtxId(), m_Filter->GetFilterId(), cbFunc, pUserArg);

        if (ret < 0)
        {
            Destroy();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp", 391));
            return false;
        }

        m_PushCallbackId = ret;
        m_Filter->IncRefCount();

        ret = sceNpWebApi2PushEventCreatePushContext(m_UserContext->GetUserCtxId(), &m_PushContextId);

        if (ret < 0)
        {
            Destroy();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp", 403));
            return false;
        }

        m_PushContextIdCreated = true;

        ret = sceNpWebApi2PushEventStartPushContextCallback(m_UserContext->GetUserCtxId(), &m_PushContextId);
        if (ret < 0)
        {
            Destroy();
            (psn::APIResult::SetSceResult(result, psn::APIResultTypes::Error, ret, "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~/PSNCore\\Source\\WebApiPushEvents.cpp", 413));
            return false;
        }

        (psn::APIResult::SetResult(result, psn::APIResultTypes::Success));

        return true;
    }
}
# 35 "C:\\code\\labyrinth\\Packages\\com.unity.psn.ps5@1.0.1\\Source~\\psn_lump.cpp" 2

