//0x10508021 sdk
//land-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 434 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/ErrorCodes.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 1






# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\assert.h" 1 3
# 47 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\assert.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/cdefs.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\assert.h" 2 3
# 65 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\assert.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 1 3
# 47 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_null.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types.h" 1 3
# 40 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/_types.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/_types.h" 3
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;




typedef long __int64_t;
typedef unsigned long __uint64_t;





typedef __int32_t __clock_t;
typedef __int64_t __critical_t;
typedef double __double_t;
typedef float __float_t;
typedef __int64_t __intfptr_t;
typedef __int64_t __intmax_t;
typedef __int64_t __intptr_t;
typedef __int32_t __int_fast8_t;
typedef __int32_t __int_fast16_t;
typedef __int32_t __int_fast32_t;
typedef __int64_t __int_fast64_t;
typedef __int8_t __int_least8_t;
typedef __int16_t __int_least16_t;
typedef __int32_t __int_least32_t;
typedef __int64_t __int_least64_t;
typedef __int64_t __ptrdiff_t;
typedef __int64_t __register_t;
typedef __int64_t __segsz_t;
typedef __uint64_t __size_t;
typedef __int64_t __ssize_t;
typedef __int64_t __time_t;
typedef __uint64_t __uintfptr_t;
typedef __uint64_t __uintmax_t;
typedef __uint64_t __uintptr_t;
typedef __uint32_t __uint_fast8_t;
typedef __uint32_t __uint_fast16_t;
typedef __uint32_t __uint_fast32_t;
typedef __uint64_t __uint_fast64_t;
typedef __uint8_t __uint_least8_t;
typedef __uint16_t __uint_least16_t;
typedef __uint32_t __uint_least32_t;
typedef __uint64_t __uint_least64_t;
typedef __uint64_t __u_register_t;
typedef __uint64_t __vm_offset_t;
typedef __int64_t __vm_ooffset_t;
typedef __uint64_t __vm_paddr_t;
typedef __uint64_t __vm_pindex_t;
typedef __uint64_t __vm_size_t;





typedef __builtin_va_list __va_list;
# 41 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types.h" 2 3




typedef __uint32_t __blksize_t;
typedef __int64_t __blkcnt_t;
typedef __int32_t __clockid_t;
typedef __uint64_t __cap_rights_t;
typedef __uint32_t __fflags_t;
typedef __uint64_t __fsblkcnt_t;
typedef __uint64_t __fsfilcnt_t;
typedef __uint32_t __gid_t;
typedef __int64_t __id_t;
typedef __uint32_t __ino_t;
typedef long __key_t;
typedef __int32_t __lwpid_t;
typedef __uint16_t __mode_t;
typedef int __accmode_t;
typedef int __nl_item;
typedef __uint16_t __nlink_t;
typedef __int64_t __off_t;
typedef __int32_t __pid_t;
typedef __int64_t __rlim_t;


typedef __uint8_t __sa_family_t;
typedef __uint32_t __socklen_t;
typedef long __suseconds_t;
typedef struct __timer *__timer_t;
typedef struct __mq *__mqd_t;
typedef __uint32_t __uid_t;
typedef unsigned int __useconds_t;
typedef int __cpuwhich_t;
typedef int __cpulevel_t;
typedef int __cpusetid_t;
# 95 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types.h" 3
typedef int __ct_rune_t;
typedef __ct_rune_t __rune_t;







typedef unsigned short __wchar_t;






typedef __ct_rune_t __wint_t;

typedef __uint32_t __dev_t;

typedef __uint32_t __fixpt_t;





typedef union {
 char __mbstate8[128];
 __int64_t _mbstateL;
} __mbstate_t;
# 49 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 532 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
typedef int _Int32t;
typedef unsigned int _Uint32t;







typedef long _Ptrdifft;







typedef unsigned long _Sizet;
# 1286 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
namespace std {}
# 1411 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
namespace std {
typedef bool _Bool;
}
# 1442 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\stdarg.h" 1 3 4
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 32 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 1443 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 2 3
# 1577 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
typedef long long _Longlong;
typedef unsigned long long _ULonglong;
# 1615 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
typedef wchar_t _Wchart;
typedef int _Wintt;
# 1712 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
typedef va_list _Va_list;
# 1755 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
typedef char _Sysch_t;
# 1779 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
extern "C" {
void _Locksyslock(int);
void _Unlocksyslock(int);
}
# 1812 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
namespace std {
enum _Uninitialized
 {
 _Noinit
 };

extern "C++" {

class _Lockit
 {
public:
# 1837 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
 _Lockit()
  : _Locktype(1)
  {

   _Locksyslock(_Locktype);
  }

 explicit _Lockit(int _Kind)
  : _Locktype(_Kind)
  {

   _Locksyslock(_Locktype);
  }

 ~_Lockit() noexcept
  {

   _Unlocksyslock(_Locktype);
  }



 _Lockit(const _Lockit&);
 _Lockit& operator=(const _Lockit&);

private:
 int _Locktype;
 };
# 1888 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 3
class _Mutex
 {
public:
 _Mutex(_Uninitialized)
  {
  }

 _Mutex();
 ~_Mutex() noexcept;
 void _Lock();
 void _Unlock();

private:
 _Mutex(const _Mutex&);
 _Mutex& operator=(const _Mutex&);
 void *_Mtx;
 };

}
}
# 50 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_errno_t.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_errno_t.h" 2 3


extern "C" {



typedef int errno_t;


}
# 52 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_size_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_size_t.h" 2 3





typedef __size_t size_t;




typedef size_t rsize_t;
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/__Mbstatet.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/__Mbstatet.h" 2 3





typedef struct _Mbstatet
 {
 unsigned long _Wchar;
 unsigned short _Byte, _State;
 int :32;


 _Mbstatet()
  : _Wchar(0), _Byte(0), _State(0)
  {
  }

 _Mbstatet(const _Mbstatet& _Right)
  : _Wchar(_Right._Wchar), _Byte(_Right._Byte),
   _State(_Right._State)
  {
  }

 _Mbstatet& operator=(const _Mbstatet& _Right)
  {
  _Wchar = _Right._Wchar;
  _Byte = _Right._Byte;
  _State = _Right._State;
  return (*this);
  }

 } _Mbstatet;
# 54 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_off_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_off_t.h" 3
typedef __off_t off_t;
# 56 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_ssize_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_ssize_t.h" 3
typedef __ssize_t ssize_t;
# 57 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_filet.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_filet.h" 2 3





typedef struct __sFILE _Filet;
# 58 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_defines/_eof.h" 1 3
# 59 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_defines/_seek.h" 1 3
# 60 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 2 3




typedef struct fpos_t
 {
 long _Off;
 _Mbstatet _Wstate;
 } fpos_t;
# 82 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 146 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 3
typedef struct __sFILE {



 unsigned short _Mode;
 unsigned char _Idx;
 signed int _Handle;

 unsigned char *_Buf, *_Bend, *_Next;
 unsigned char *_Rend, *_Wend, *_Rback;

 _Wchart *_WRback, _WBack[2];
 unsigned char *_Rsave, *_WRend, *_WWend;

 _Mbstatet _Wstate;
 char *_Tmpnam;
 unsigned char _Back[6], _Cbuf;
 void *_Mutex;


 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read)(void *, char *, int);
 fpos_t (*_seek)(void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 unsigned char *_up;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;

 struct pthread_mutex *_fl_mutex;
 struct pthread *_fl_owner;
 int _fl_count;
 int _orientation;
 __mbstate_t _mbstate;
} FILE;
# 248 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 3
extern "C" {
extern FILE _Stdin, _Stdout, _Stderr;

void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);
FILE *fopen(const char *, const char *);





int fprintf(FILE *, const char *, ...);
int fputc(int, FILE *);
int fputs(const char *, FILE *);
size_t fread(void *, size_t, size_t, FILE *);
FILE *freopen(const char *, const char *,
 FILE *);





int fscanf(FILE * , const char *, ...);
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void *, size_t, size_t,
 FILE *);
char *gets(char *);
void perror(const char *);





int printf(const char *, ...);
int puts(const char *);






int remove(const char *);
int rename(const char *, const char *);


void rewind(FILE *);





int scanf(const char *, ...);
void setbuf(FILE * , char *);
int setvbuf(FILE * , char *, int, size_t);





int sprintf(char *, const char *, ...);





int sscanf(const char *, const char *, ...);
int ungetc(int, FILE *);
int vfprintf(FILE *, const char *, _Va_list);
int vprintf(const char *, _Va_list);
int vsprintf(char *, const char *, _Va_list);


FILE *fdopen(signed int, const char *);
int fileno(FILE *);


FILE *sceLibcFopenWithFD(signed int, const char *);
FILE *sceLibcFopenWithFH(signed int, const char *);
signed int sceLibcGetFD(FILE *);
signed int sceLibcGetFH(FILE *);


int getw(FILE *);
int putw(int, FILE *);


long _Fgpos(FILE *, fpos_t *);
int _Flocale(FILE *, const char *, int);
void _Fsetlocale(FILE *, int);
int _Fspos(FILE *, const fpos_t *, long, int);


void _Lockfilelock(_Filet *);
void _Unlockfilelock(_Filet *);


extern FILE *_Files[256];







int snprintf(char *, size_t,
 const char *, ...);
int vsnprintf(char *, size_t,
 const char *, _Va_list);
int vfscanf(FILE *,
 const char *, _Va_list);
int vscanf(const char *, _Va_list);
int vsscanf(const char *,
 const char *, _Va_list);
# 385 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 3
}



extern "C" {
int getc(FILE *);
int getchar(void);
int putc(int, FILE *);
int putchar(int);
}
# 459 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdio.h" 3
extern "C" {

errno_t fopen_s(FILE * *,
 const char *, const char *);
errno_t freopen_s(FILE * *,
 const char *, const char *, FILE *);

int fprintf_s(FILE *, const char *, ...) __attribute__((format(printf, 2, 3)));
int fscanf_s(FILE *, const char *, ...);
int printf_s(const char *, ...) __attribute__((format(printf, 1, 2)));
int scanf_s(const char *, ...);
int snprintf_s(char *, rsize_t,
 const char *, ...) __attribute__((format(printf, 3, 4)));
int sscanf_s(const char *,
 const char *, ...);
int sprintf_s(char *, rsize_t,
 const char *, ...) __attribute__((format(printf, 3, 4)));
int vfprintf_s(FILE *,
 const char *,
 _Va_list);
int vfscanf_s(FILE *,
 const char *,
 _Va_list);
int vprintf_s(const char *,
 _Va_list);
int vscanf_s(const char *,
 _Va_list);
int vsnprintf_s(char *, rsize_t,
 const char *,
 _Va_list);
int vsprintf_s(char *, rsize_t,
 const char *,
 _Va_list);
int vsscanf_s(const char *,
 const char *,
 _Va_list);

char *gets_s(char *, rsize_t);
}



extern "C++" {

template<rsize_t _Size>
char *gets_s(char (&_Buf)[_Size])
 {
 return gets_s(_Buf, _Size);
 }

template<rsize_t _Size>
__attribute__((format(printf, 2, 3))) int sprintf_s(char (&_Buf)[_Size], const char *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vsnprintf_s(char (&_Buf)[_Size], const char *_Fmt, va_list _Ap)
 {
 return vsnprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
int vsprintf_s(char (&_Buf)[_Size], const char *_Fmt, va_list _Ap)
 {
 return vsprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
__attribute__((format(printf, 2, 3))) int snprintf_s(char (&_Buf)[_Size], const char *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

}
# 66 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\assert.h" 2 3
# 85 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\assert.h" 3
extern "C" {
void _Assert(const char *, const char *) __attribute__((__noreturn__));
}
# 8 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 1 3
# 24 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_defines/_weof.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int8_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int8_t.h" 3
typedef __int8_t int8_t;
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int16_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int16_t.h" 3
typedef short int16_t;
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int32_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int32_t.h" 3
typedef __int32_t int32_t;
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uint8_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uint8_t.h" 3
typedef __uint8_t uint8_t;
# 18 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uint16_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uint16_t.h" 3
typedef __uint16_t uint16_t;
# 19 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uint32_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uint32_t.h" 3
typedef __uint32_t uint32_t;
# 20 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_intptr_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_intptr_t.h" 3
typedef __intptr_t intptr_t;
# 21 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uintptr_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uintptr_t.h" 3
typedef __uintptr_t uintptr_t;
# 22 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int64_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int64_t.h" 3
typedef __int64_t int64_t;
# 23 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uint64_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uint64_t.h" 3
typedef __uint64_t uint64_t;
# 24 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 2 3
# 47 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 3
typedef long _SceInt64t;
typedef unsigned long _SceUint64t;
# 65 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 3
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef _Int32t int_least32_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef _Uint32t uint_least32_t;
# 88 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 3
typedef _Int32t int_fast8_t;
typedef _Int32t int_fast16_t;




typedef _Int32t int_fast32_t;


typedef _Uint32t uint_fast8_t;
typedef _Uint32t uint_fast16_t;




typedef _Uint32t uint_fast32_t;
# 155 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 3
typedef _SceInt64t int_least64_t;
typedef _SceUint64t uint_least64_t;
# 167 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 3
typedef _SceInt64t int_fast64_t;
typedef _SceUint64t uint_fast64_t;




typedef _SceInt64t intmax_t;
typedef _SceUint64t uintmax_t;
# 25 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 2 3
# 36 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef char SceChar8;
# 46 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef unsigned char SceUChar8;
# 56 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef int8_t SceInt8;
# 66 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef uint8_t SceUInt8;
# 76 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef int16_t SceShort16;
# 86 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef uint16_t SceUShort16;
# 96 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef int16_t SceInt16;
# 106 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef uint16_t SceUInt16;
# 116 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef int32_t SceInt32;
# 126 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef uint32_t SceUInt32;
# 136 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef int SceInt;
# 146 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef unsigned int SceUInt;
# 202 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef int64_t SceInt64;
typedef uint64_t SceUInt64;
typedef long SceLong;
typedef unsigned long SceULong;
typedef int64_t SceLong64;
typedef uint64_t SceULong64;
# 217 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef float SceFloat;
# 226 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef float SceFloat32;
# 235 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef double SceDouble;
# 244 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef double SceDouble64;
# 254 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef signed char SceSByte;
# 264 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef signed char SceSByte8;
# 274 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef unsigned char SceByte;
# 284 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef unsigned char SceByte8;
# 294 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef uint16_t SceWChar16;
# 304 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef uint32_t SceWChar32;
# 327 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef int SceBool;
# 340 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef intptr_t SceIntPtr;
# 350 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef uintptr_t SceUIntPtr;
# 360 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef void SceVoid;
# 370 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef void* ScePVoid;






typedef struct SceIVector2 {
 int x, y;
} SceIVector2;





typedef struct SceFVector2 {
 float x, y;
} SceFVector2;





typedef union SceUVector2 {
 SceIVector2 iv;
 SceFVector2 fv;
} SceUVector2;





typedef struct SceIVector3 {
 int x, y, z;
} SceIVector3;





typedef struct SceFVector3 {
 float x, y, z;
} SceFVector3;





typedef union SceUVector3 {
 SceIVector3 iv;
 SceFVector3 fv;
} SceUVector3;





typedef struct SceIVector4 {
 int x, y, z, w;
} SceIVector4;





typedef struct SceFVector4 {
 float x, y, z, w;
} SceFVector4;





typedef union SceUVector4 {
 SceIVector4 iv;
 SceFVector4 fv;
} SceUVector4;





typedef struct SceIMatrix2{
 SceIVector2 x, y;
} SceIMatrix2;





typedef struct SceFMatrix2{
 SceFVector2 x, y;
} SceFMatrix2;

typedef union SceUMatrix2 {
 SceFMatrix2 fm;
 SceIMatrix2 im;
 SceFVector2 fv[2];
 SceIVector2 iv[2];
 SceUVector2 uv[2];
 float f[2][2];
 int i[2][2];
# 482 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
} SceUMatrix2;






typedef struct SceIMatrix3 {
 SceIVector3 x, y, z;
} SceIMatrix3;





typedef struct SceFMatrix3 {
 SceFVector3 x, y, z;
} SceFMatrix3;





typedef union SceUMatrix3 {
 SceFMatrix3 fm;
 SceIMatrix3 im;
 SceFVector3 fv[3];
 SceIVector3 iv[3];
 SceUVector3 uv[3];
 float f[3][3];
 int i[3][3];
# 525 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
} SceUMatrix3;





typedef struct SceIMatrix4 {
 SceIVector4 x, y, z, w;
} SceIMatrix4;





typedef struct SceFMatrix4 {
 SceFVector4 x, y, z, w;
} SceFMatrix4;





typedef union SceUMatrix4 {
 SceFMatrix4 fm;
 SceIMatrix4 im;
 SceFVector4 fv[4];
 SceIVector4 iv[4];
 SceUVector4 uv[4];
 float f[4][4];
 int i[4][4];
# 569 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
} SceUMatrix4;






typedef struct SceFQuaternion {
 float x, y, z, w;
} SceFQuaternion;





typedef struct SceFColor {
 float r, g, b, a;
} SceFColor;
# 596 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef union SceUnion32 {
 unsigned int ui;
 int i;
 unsigned short us[2];
 short s[2];
 unsigned char uc[4];
 char c[4];
 float f;
} SceUnion32;
# 615 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef union SceUnion64 {
 SceULong64 ull;
 SceLong64 ll;
 unsigned int ui[2];
 int i[2];
 unsigned short us[4];
 short s[4];
 unsigned char uc[8];
 char c[8];
 float f[2];

 SceFVector2 fv;
 SceIVector2 iv;
 void *p;
} SceUnion64;
# 640 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef union SceUnion128 {

 SceULong64 ull[2];
 SceLong64 ll[2];
 unsigned int ui[4];
 int i[4];
 unsigned short us[8];
 short s[8];
 unsigned char uc[16];
 char c[16];
 float f[4];

 SceFVector4 fv;
 SceFQuaternion fq;
 SceFColor fc;
 SceIVector4 iv;
} SceUnion128;
# 667 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef union SceUnion512 {
 SceUnion32 un32[16];
 SceUnion64 un64[8];

 SceULong64 ull[8];
 SceLong64 ll[8];
 unsigned int ui[16];
 int i[16];
 unsigned short us[32];
 short s[32];
 unsigned char uc[64];
 char c[64];
 float f[16];

 SceFMatrix4 fm;
 SceIMatrix4 im;
 SceUMatrix4 um;

} SceUnion512;
# 696 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef struct SceDateTime {
 unsigned short year;
 unsigned short month;
 unsigned short day;
 unsigned short hour;
 unsigned short minute;
 unsigned short second;
 unsigned int microsecond;
} SceDateTime;
# 715 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef size_t SceSize;
# 725 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef SceSize ScePSize;
# 735 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef SceSize SceVSize;
# 745 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef ssize_t SceSSize;
# 755 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef SceSSize ScePSSize;
# 765 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef SceSSize SceVSSize;
# 776 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef uintptr_t SceUIntVAddr;
# 793 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef int SceUID;
# 815 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef char* SceName;
# 827 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\scetypes.h" 3
typedef off_t SceOff;




typedef SceUID ScePID;
# 10 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_error.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/endian.h" 1 3
# 40 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/endian.h" 3
extern "C" {
# 90 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/endian.h" 3
static inline __uint64_t
__bswap64_var(__uint64_t _x)
{

 __asm ("bswap %0" : "+r" (_x));
 return (_x);
}

static inline __uint32_t
__bswap32_var(__uint32_t _x)
{

 __asm ("bswap %0" : "+r" (_x));
 return (_x);
}

static inline __uint16_t
__bswap16_var(__uint16_t _x)
{

 return ((__uint16_t)((_x) << 8 | (_x) >> 8));
}
# 142 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/endian.h" 3
}
# 49 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_pthreadtypes.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_pthreadtypes.h" 3
struct pthread;
struct pthread_attr;
struct pthread_cond;
struct pthread_cond_attr;
struct pthread_mutex;
struct pthread_mutex_attr;
struct pthread_once;
struct pthread_rwlock;
struct pthread_rwlockattr;
struct pthread_barrier;
struct pthread_barrier_attr;
struct pthread_spinlock;
# 68 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_pthreadtypes.h" 3
typedef struct pthread *pthread_t;
typedef struct pthread_attr *pthread_attr_t;
typedef struct pthread_mutex *pthread_mutex_t;
typedef struct pthread_mutex_attr *pthread_mutexattr_t;
typedef struct pthread_cond *pthread_cond_t;
typedef struct pthread_cond_attr *pthread_condattr_t;
typedef int pthread_key_t;
typedef struct pthread_once pthread_once_t;
typedef struct pthread_rwlock *pthread_rwlock_t;
typedef struct pthread_rwlockattr *pthread_rwlockattr_t;
typedef struct pthread_barrier *pthread_barrier_t;
typedef struct pthread_barrierattr *pthread_barrierattr_t;
typedef struct pthread_spinlock *pthread_spinlock_t;







typedef void *pthread_addr_t;
typedef void *(*pthread_startroutine_t)(void *);




struct pthread_once {
 int state;
 pthread_mutex_t mutex;
};
# 52 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef unsigned short ushort;
typedef unsigned int uint;






# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_stdint.h" 1 3
# 68 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;

typedef __uint64_t u_quad_t;
typedef __int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t;
typedef const char * c_caddr_t;
typedef volatile char *v_caddr_t;

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_blksize_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_blksize_t.h" 3
typedef __blksize_t blksize_t;
# 83 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __cpuwhich_t cpuwhich_t;
typedef __cpulevel_t cpulevel_t;
typedef __cpusetid_t cpusetid_t;

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_blkcnt_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_blkcnt_t.h" 3
typedef __blkcnt_t blkcnt_t;
# 89 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __cap_rights_t cap_rights_t;

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_clock_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_clock_t.h" 2 3





typedef __clock_t clock_t;
# 93 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_clockid_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_clockid_t.h" 2 3





typedef __clockid_t clockid_t;
# 95 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __critical_t critical_t;
typedef __int64_t daddr_t;

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_dev_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_dev_t.h" 3
typedef __dev_t dev_t;
# 100 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_fflags_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_fflags_t.h" 3
typedef __fflags_t fflags_t;
# 102 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __fixpt_t fixpt_t;


typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_gid_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_gid_t.h" 3
typedef __gid_t gid_t;
# 110 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_in_addr_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_in_addr_t.h" 3
typedef __uint32_t in_addr_t;
# 112 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_in_port_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_in_port_t.h" 3
typedef __uint16_t in_port_t;
# 114 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __id_t id_t;

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_ino_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_ino_t.h" 3
typedef __ino_t ino_t;
# 118 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __key_t key_t;


typedef __lwpid_t lwpid_t;




# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_mode_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_mode_t.h" 3
typedef __mode_t mode_t;
# 128 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __accmode_t accmode_t;

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_nlink_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_nlink_t.h" 3
typedef __nlink_t nlink_t;
# 132 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_pid_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_pid_t.h" 3
typedef __pid_t pid_t;
# 136 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __register_t register_t;


typedef __rlim_t rlim_t;



typedef __segsz_t segsz_t;





# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_suseconds_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_suseconds_t.h" 3
typedef __suseconds_t suseconds_t;
# 151 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_time_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_time_t.h" 2 3





typedef __time_t time_t;
# 153 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __timer_t timer_t;

typedef __mqd_t mqd_t;

typedef __u_register_t u_register_t;

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uid_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_uid_t.h" 3
typedef __uid_t uid_t;
# 161 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_useconds_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_useconds_t.h" 3
typedef __useconds_t useconds_t;
# 163 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3

typedef __vm_offset_t vm_offset_t;
typedef __vm_ooffset_t vm_ooffset_t;
typedef __vm_paddr_t vm_paddr_t;
typedef __vm_pindex_t vm_pindex_t;
typedef __vm_size_t vm_size_t;
# 202 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/select.h" 1 3
# 42 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/select.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_sigset.h" 1 3
# 57 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_sigset.h" 3
typedef struct __sigset {
 __uint32_t __bits[4];
} __sigset_t;
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_timeval.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_timeval.h" 3
struct timeval {
 time_t tv_sec;
 suseconds_t tv_usec;
};
# 44 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/timespec.h" 1 3
# 42 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/timespec.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_timespec.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_timespec.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_timespec.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_timespec.h" 2 3





struct timespec {
 time_t tv_sec;
 long tv_nsec;
};
# 44 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_timespec.h" 2 3
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/timespec.h" 2 3
# 62 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/timespec.h" 3
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 45 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_sigset_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_sigset_t.h" 3
typedef __sigset_t sigset_t;
# 46 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/select.h" 2 3

typedef unsigned long __fd_mask;

typedef __fd_mask fd_mask;
# 71 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/select.h" 3
typedef struct fd_set {
 __fd_mask __fds_bits[(((1024U) + (((sizeof(__fd_mask) * 8)) - 1)) / ((sizeof(__fd_mask) * 8)))];
} fd_set;
# 97 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/select.h" 3
extern "C" {
int pselect(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict,
 const struct timespec *__restrict, const sigset_t *__restrict);




int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);


}
# 203 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3
# 219 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_ftruncate.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_ftruncate.h" 3
extern "C" {


int ftruncate(int, off_t);

}
# 220 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_lseek.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_lseek.h" 3
extern "C" {


off_t lseek(int, off_t, int);

}
# 221 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_mmap.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_mmap.h" 3
extern "C" {


void * mmap(void *, size_t, int, int, int, off_t);

}
# 222 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_truncate.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_truncate.h" 3
extern "C" {


int truncate(const char *, off_t);

}
# 223 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/types.h" 2 3
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\_types.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\_types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/event.h" 1 3
# 37 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/event.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/queue.h" 1 3
# 38 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/event.h" 2 3
# 74 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/event.h" 3
struct kevent {
 uintptr_t ident;
 short filter;
 u_short flags;
 u_int fflags;
 intptr_t data;
 void *udata;
};
# 158 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/event.h" 3
struct knote;
struct klist { struct knote *slh_first; };
struct kqueue;
struct kqlist { struct kqueue *slh_first; };
struct knlist {
 struct klist kl_list;
 void (*kl_lock)(void *);
 void (*kl_unlock)(void *);
 void (*kl_assert_locked)(void *);
 void (*kl_assert_unlocked)(void *);
 void *kl_lockarg;
};
# 295 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/event.h" 3
struct timespec;

extern "C" {
int kqueue(void);
int kevent(int kq, const struct kevent *changelist, int nchanges,
     struct kevent *eventlist, int nevents,
     const struct timespec *timeout);
}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\_types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/cpuset.h" 1 3
# 35 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/cpuset.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_cpuset.h" 1 3
# 39 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_cpuset.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/param.h" 1 3
# 79 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/syslimits.h" 1 3
# 80 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/param.h" 2 3
# 113 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/_limits.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/signal.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/signal.h" 3
typedef long sig_atomic_t;


# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/trap.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/signal.h" 2 3
# 63 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/signal.h" 3
struct sigcontext {
 struct __sigset sc_mask;
 long sc_onstack;
 long sc_rdi;
 long sc_rsi;
 long sc_rdx;
 long sc_rcx;
 long sc_r8;
 long sc_r9;
 long sc_rax;
 long sc_rbx;
 long sc_rbp;
 long sc_r10;
 long sc_r11;
 long sc_r12;
 long sc_r13;
 long sc_r14;
 long sc_r15;
 int sc_trapno;
 short sc_fs;
 short sc_gs;
 long sc_addr;
 int sc_flags;
 short sc_es;
 short sc_ds;
 long sc_err;
 long sc_rip;
 long sc_cs;
 long sc_rflags;
 long sc_rsp;
 long sc_ss;
 long sc_len;




 long sc_fpformat;
 long sc_ownedfp;
 long sc_lbrfrom;
 long sc_lbrto;
 long sc_aux1;
 long sc_aux2;
 long sc_fpstate[104] __attribute__((__aligned__(16)));

 long sc_fsbase;
 long sc_gsbase;

 long sc_spare[6];
};
# 51 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 2 3
# 145 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 3
typedef void __sighandler_t(int);


union sigval {

 int sival_int;
 void *sival_ptr;

 int sigval_int;
 void *sigval_ptr;
};



struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 union {
  __lwpid_t _threadid;
  struct {
   void (*_function)(union sigval);
   void *_attribute;
  } _sigev_thread;
  long __spare__[8];
 } _sigev_un;
};
# 190 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 3
typedef struct __siginfo {
 int si_signo;
 int si_errno;






 int si_code;
 __pid_t si_pid;
 __uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 union {
  struct {
   int _trapno;
  } _fault;
  struct {
   int _timerid;
   int _overrun;
  } _timer;
  struct {
   int _mqd;
  } _mesgq;
  struct {
   long _band;
  } _poll;
  struct {
   long __spare1__;
   int __spare2__[7];
  } __spare__;
 } _reason;
} siginfo_t;
# 289 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 3
struct __siginfo;




struct sigaction {
 union {
  void (*__sa_handler)(int);
  void (*__sa_sigaction)(int, struct __siginfo *, void *);
 } __sigaction_u;
 int sa_flags;
 sigset_t sa_mask;
};
# 346 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 3
typedef __sighandler_t *sig_t;
typedef void __siginfohandler_t(int, struct __siginfo *, void *);







typedef struct sigaltstack {



 char *ss_sp;
 __size_t ss_size;
 int ss_flags;
} stack_t;
# 375 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 3
struct sigvec {
 __sighandler_t *sv_handler;
 int sv_mask;
 int sv_flags;
};
# 402 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 3
struct sigstack {

 char *ss_sp;
 int ss_onstack;
};
# 434 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/signal.h" 3
extern "C" {
__sighandler_t *signal(int, __sighandler_t *);
}
# 114 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/param.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/param.h" 1 3
# 46 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/_align.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\x86/_align.h" 1 3
# 7 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/_align.h" 2 3
# 47 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\machine/param.h" 2 3
# 118 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/param.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/limits.h" 1 3
# 120 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/param.h" 2 3
# 40 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_cpuset.h" 2 3
# 54 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_cpuset.h" 3
typedef struct _cpuset {
 long __bits[(((128)+(((sizeof(long) * 8))-1))/((sizeof(long) * 8)))];
} cpuset_t;
# 36 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/cpuset.h" 2 3
# 224 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/cpuset.h" 3
extern "C" {
int cpuset(cpusetid_t *);
int cpuset_setid(cpuwhich_t, id_t, cpusetid_t);
int cpuset_getid(cpulevel_t, cpuwhich_t, id_t, cpusetid_t *);
int cpuset_getaffinity(cpulevel_t, cpuwhich_t, id_t, size_t, cpuset_t *);
int cpuset_setaffinity(cpulevel_t, cpuwhich_t, id_t, size_t, const cpuset_t *);
}
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\_types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/sched.h" 1 3
# 211 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/sched.h" 3
struct sched_param {
        int sched_priority;
};
# 223 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/sched.h" 3
struct timespec;

extern "C" {
int sched_get_priority_max(int);
int sched_get_priority_min(int);
int sched_getparam(pid_t, struct sched_param *);
int sched_getscheduler(pid_t);
int sched_rr_get_interval(pid_t, struct timespec *);
int sched_setparam(pid_t, const struct sched_param *);
int sched_setscheduler(pid_t, int, const struct sched_param *);
int sched_yield(void);
}
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\_types.h" 2 3


typedef struct kevent SceKernelKevent;
typedef struct timespec SceKernelTimespec;
typedef struct timeval SceKernelTimeval;
typedef clockid_t SceKernelClockid;
typedef struct sched_param SceKernelSchedParam;
typedef uint64_t SceKernelCpumask;
typedef unsigned int SceKernelUseconds;
typedef int32_t SceKernelModule;
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 52 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_defines/_clock.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 2 3
# 97 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 3
struct tm
 {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 };
# 133 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 3
extern "C" {
time_t time(time_t *);
}

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void);
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *);
size_t strftime(char *, size_t,
 const char *, const struct tm *);


int clock_getres(clockid_t, struct timespec *);
int clock_gettime(clockid_t, struct timespec *);
int nanosleep(const struct timespec *, struct timespec *);


}


extern "C" {

errno_t asctime_s(char *, rsize_t, const struct tm *);
errno_t ctime_s(char *, rsize_t, const time_t *);
struct tm *gmtime_s(const time_t *,
 struct tm *);
struct tm *localtime_s(const time_t *,
 struct tm *);
}



extern "C++" {

template<rsize_t _Size>
errno_t asctime_s(char (&_Str)[_Size], const struct tm *_Tptr)
 {
 return asctime_s(_Str, _Size, _Tptr);
 }

template<rsize_t _Size>
errno_t ctime_s(char (&_Str)[_Size], const time_t *_Tod)
 {
 return ctime_s(_Str, _Size, _Tod);
 }

}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service/user_service_defs.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\inttypes.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\inttypes.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_lldiv.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_lldiv.h" 2 3



typedef struct
{
 _Longlong quot;
 _Longlong rem;
} _Lldiv_t;
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int.h" 3
extern "C" {



typedef struct
{
 long quot;
 long rem;
} ldiv_t;

typedef _Lldiv_t lldiv_t;


extern long labs(long);
extern _Longlong llabs(_Longlong);
extern ldiv_t ldiv(long, long);
extern lldiv_t lldiv(_Longlong, _Longlong);


}
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int_cpp.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_int_cpp.h" 3
extern "C" {

extern "C++" {





  inline long abs(long _Left)
  {
    return (labs(_Left));
  }

  inline ldiv_t div(long _Left, long _Right)
  {
    return (ldiv(_Left, _Right));
  }




  inline _Longlong abs(_Longlong _Left)
  {
    return (llabs(_Left));
  }

  inline _Lldiv_t div(_Longlong _Left, _Longlong _Right)
  {
    return (lldiv(_Left, _Right));
  }


}

}
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\inttypes.h" 2 3
# 27 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\inttypes.h" 3
extern "C" {




typedef struct
 {
 intmax_t quot;
 intmax_t rem;
 } imaxdiv_t;





intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);

intmax_t strtoimax(const char *,
 char **, int);
uintmax_t strtoumax(const char *,
 char **, int);
intmax_t wcstoimax(const _Wchart *,
 _Wchart **, int);
uintmax_t wcstoumax(const _Wchart *,
 _Wchart **, int);
}
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service/user_service_defs.h" 2 3



typedef int32_t SceUserServiceUserId;
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service/user_service_api.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/time.h" 1 3
# 45 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/time.h" 3
struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 58 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/time.h" 3
struct bintime {
 time_t sec;
 uint64_t frac;
};

static inline void
bintime_addx(struct bintime *bt, uint64_t x)
{
 uint64_t u;

 u = bt->frac;
 bt->frac += x;
 if (u > bt->frac)
  bt->sec++;
}

static inline void
bintime_add(struct bintime *bt, const struct bintime *bt2)
{
 uint64_t u;

 u = bt->frac;
 bt->frac += bt2->frac;
 if (u > bt->frac)
  bt->sec++;
 bt->sec += bt2->sec;
}

static inline void
bintime_sub(struct bintime *bt, const struct bintime *bt2)
{
 uint64_t u;

 u = bt->frac;
 bt->frac -= bt2->frac;
 if (u < bt->frac)
  bt->sec--;
 bt->sec -= bt2->sec;
}

static inline void
bintime_mul(struct bintime *bt, u_int x)
{
 uint64_t p1, p2;

 p1 = (bt->frac & 0xffffffffull) * x;
 p2 = (bt->frac >> 32) * x + (p1 >> 32);
 bt->sec *= x;
 bt->sec += (p2 >> 32);
 bt->frac = (p2 << 32) | (p1 & 0xffffffffull);
}
# 131 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/time.h" 3
static inline void
bintime2timespec(const struct bintime *bt, struct timespec *ts)
{

 ts->tv_sec = bt->sec;
 ts->tv_nsec = ((uint64_t)1000000000 * (uint32_t)(bt->frac >> 32)) >> 32;
}

static inline void
timespec2bintime(const struct timespec *ts, struct bintime *bt)
{

 bt->sec = ts->tv_sec;

 bt->frac = (uint64_t)ts->tv_nsec * (uint64_t)18446744073LL;
}

static inline void
bintime2timeval(const struct bintime *bt, struct timeval *tv)
{

 tv->tv_sec = bt->sec;
 tv->tv_usec = ((uint64_t)1000000 * (uint32_t)(bt->frac >> 32)) >> 32;
}

static inline void
timeval2bintime(const struct timeval *tv, struct bintime *bt)
{

 bt->sec = tv->tv_sec;

 bt->frac = (uint64_t)tv->tv_usec * (uint64_t)18446744073709LL;
}
# 243 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/time.h" 3
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};




struct clockinfo {
 int hz;
 int tick;
 int spare;
 int stathz;
 int profhz;
};
# 334 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/time.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 1 3
# 335 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/time.h" 2 3




extern "C" {
int setitimer(int, const struct itimerval *, struct itimerval *);
int utimes(const char *, const struct timeval *);


int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int futimesat(int, const char *, const struct timeval [2]);
int lutimes(const char *, const struct timeval *);
int settimeofday(const struct timeval *, const struct timezone *);



int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval *, struct timezone *);



}
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/dmem.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/dmem.h" 3
typedef enum {
  SCE_KERNEL_WB_ONION = 0,
  SCE_KERNEL_WC_GARLIC = 3,

  SCE_KERNEL_WB_ONION_VOLATILE __attribute__ ((deprecated)) = 0,
  SCE_KERNEL_WB_ONION_NONVOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_WC_GARLIC_VOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_WC_GARLIC_NONVOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_WT_ONION_VOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_WT_ONION_NONVOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_WP_ONION_VOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_WP_ONION_NONVOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_UC_GARLIC_VOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_UC_GARLIC_NONVOLATILE __attribute__ ((deprecated)),
  SCE_KERNEL_WB_GARLIC,

  SCE_KERNEL_MEMORY_TYPE_END
} SceKernelMemoryType;






enum {

 __SCE_KERNEL_MAIN_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x0000000000L,
 __SCE_KERNEL_DMEM_END
  __attribute__ ((deprecated)) = 0x5000000000L,
 __SCE_KERNEL_GPU_SHARED_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x1000000000L,
 __SCE_KERNEL_GPU_PRIVATE_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x2000000000L,
 __SCE_KERNEL_GPU_SHARED_DMEM_SIZE
  __attribute__ ((deprecated)) = 0x0d000000L,
 __SCE_KERNEL_GPU_PRIVATE_DMEM_SIZE
  __attribute__ ((deprecated)) = 0x80000000L
};
# 81 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/dmem.h" 3
enum {

 __SCE_KERNEL_FIXED_PRT_APERTURE_START_ADDR
  __attribute__ ((deprecated)) = 0x0f00000000UL,
 __SCE_KERNEL_FIXED_PRT_APERTURE_SIZE
  __attribute__ ((deprecated)) = 0x0010000000UL,
 __SCE_KERNEL_FIXED_PRT_APERTURE_END_ADDR
  __attribute__ ((deprecated)) = 0x0f00000000UL + 0x0010000000UL
};
# 106 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/dmem.h" 3
extern "C" {

typedef enum {
  SCE_KERNEL_MAP_OP_MAP_DIRECT,
  SCE_KERNEL_MAP_OP_UNMAP,
  SCE_KERNEL_MAP_OP_PROTECT,
  SCE_KERNEL_MAP_OP_MAP_FLEXIBLE,
  SCE_KERNEL_MAP_OP_TYPE_PROTECT,
} SceKernelMapEntryOperation;

typedef struct
{
 void *start;
 off_t offset;
   size_t length;
 char protection;
 char type;
 short pad1;
 int operation;
} SceKernelBatchMapEntry;



typedef struct
{
 void *start;
 void *end;
 off_t offset;
 int protection;
 int memoryType;
 unsigned isFlexibleMemory:1;
 unsigned isDirectMemory:1;
 unsigned isStack:1;
 unsigned isPooledMemory:1;
 unsigned isCommitted:1;
 char name[32];
} SceKernelVirtualQueryInfo;



typedef struct
{
 off_t start;
 off_t end;
 int memoryType;
} SceKernelDirectMemoryQueryInfo;
# 161 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/dmem.h" 3
typedef struct
{
 unsigned op;
 unsigned flags;
 union {
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
   unsigned char type;
  } commit;
  struct {
   void *addr;
   size_t len;
  } decommit;
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
  } protect;
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
   unsigned char type;
  } typeProtect;
  struct {
   void *dst;
   void *src;
   size_t len;
  } move;
  uintptr_t padding[3];
 };
} SceKernelMemoryPoolBatchEntry;

typedef struct
{
 int availableFlushedBlocks;
 int availableCachedBlocks;
 int allocatedFlushedBlocks;
 int allocatedCachedBlocks;
} SceKernelMemoryPoolBlockStats;

size_t sceKernelGetDirectMemorySize();

int32_t sceKernelMapFlexibleMemory(void** addrInOut, size_t len,
       int prot, int flags);
int32_t sceKernelReleaseFlexibleMemory(void* addr, size_t len);
int32_t sceKernelSetPrtAperture(int index, void *addr, size_t len);
int32_t sceKernelGetPrtAperture(int index, void **addr, size_t *len);

int32_t sceKernelAllocateDirectMemory(off_t searchStart, off_t searchEnd,
          size_t len, size_t alignment,
          int memoryType,
          off_t *physAddrOut);
int32_t sceKernelAllocateMainDirectMemory(size_t len, size_t alignment,
       int memoryType,
       off_t *physAddrOut);
int32_t sceKernelReleaseDirectMemory(off_t start, size_t len);
int32_t sceKernelCheckedReleaseDirectMemory(off_t start, size_t len);
int32_t sceKernelMapDirectMemory(void **addr, size_t len,
     int prot, int flags, off_t directMemoryStart,
     size_t maxPageSize);
int32_t sceKernelMapDirectMemory2(void **addr, size_t len,
      int type, int prot,
      int flags, off_t directMemoryStart,
     size_t maxPageSize);
int32_t sceKernelGetDirectMemoryType(off_t start,
         int *memoryType,
         off_t *regionStartOut,
         off_t *regionEndOut);

int32_t sceKernelBatchMap(SceKernelBatchMapEntry* entries,
     int numberOfEntries,
     int* numberOfEntriesOut);
int32_t sceKernelBatchMap2(SceKernelBatchMapEntry* entries,
      int numberOfEntries,
      int* numberOfEntriesOut,
      int flags);

int32_t
sceKernelJitCreateSharedMemory(const char *name, size_t len, int maxProt,
          int *fdOut);
int32_t sceKernelJitCreateAliasOfSharedMemory(int fd, int maxProt, int *fdOut);
int32_t sceKernelJitMapSharedMemory(int fd, int prot, void **startOut);
int32_t sceKernelJitGetSharedMemoryInfo(int fd, char* name, int nameBufferSize,
     void **startOut, size_t *lenOut,
     int *maxProtOut);

int32_t sceKernelQueryMemoryProtection(void* addr,
           void** start, void** end, int* prot);
int32_t sceKernelIsStack(void* addr, void** start, void** end);
int32_t sceKernelVirtualQuery(const void *addr, int flags,
         SceKernelVirtualQueryInfo *info,
         size_t infoSize);
int32_t sceKernelSetVirtualRangeName(void* start, size_t len,
    const char *name);

int32_t sceKernelMapNamedFlexibleMemory(void** addrInOut, size_t len,
     int prot, int flags, const char *name);
int32_t sceKernelMapNamedDirectMemory(void **addr, size_t len,
          int prot, int flags,
          off_t directMemoryStart,
          size_t alignment, const char *name);
int sceKernelReserveVirtualRange(void **addr, size_t len, int flags,
     size_t alignment);

int32_t sceKernelDirectMemoryQuery(off_t offset,
       int flags,
       void *info,
       size_t infoSize);
int32_t sceKernelMtypeprotect(const void *addr, size_t size, int type,
    int prot);

int32_t sceKernelAvailableDirectMemorySize(off_t start,
        off_t end,
        size_t alignment,
        off_t *startOut,
        size_t *sizeOut);
int32_t sceKernelGetPageTableStats(int* cpuTotal, int* cpuAvailable,
       int* gpuTotal, int* gpuAvailable);


int32_t sceKernelMemoryPoolBatch(const SceKernelMemoryPoolBatchEntry *entries,
    int n, int *indexOut, int flags);
int32_t sceKernelMemoryPoolCommit(void *addr, size_t len, int type, int prot,
    int flags);
int32_t sceKernelMemoryPoolDecommit(void *addr, size_t len, int flags);
int32_t sceKernelMemoryPoolExpand(off_t searchStart, off_t searchEnd,
    size_t len, size_t alignment, off_t *physAddrOut);
int32_t sceKernelMemoryPoolGetBlockStats(SceKernelMemoryPoolBlockStats *output,
    size_t outputSize);
int32_t sceKernelMemoryPoolMove(void *dst, void *src, size_t len, int flags);
int32_t sceKernelMemoryPoolReserve(void *addrIn, size_t len, size_t alignment,
    int flags, void **addrOut);

}
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/sce_errno.h" 1 3
# 47 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/sce_errno.h" 3
extern "C" {
# 677 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/sce_errno.h" 3
}
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sched.h" 1 3
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 1 3
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 2 3
# 41 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 3
extern "C" {

typedef struct
{
 size_t size;
} SceKernelLoadModuleOpt;

typedef struct
{
 size_t size;
} SceKernelUnloadModuleOpt;


int sceKernelMlock(const void *addr, size_t len);
int sceKernelMunlock(const void *addr, size_t len);
int sceKernelMprotect(const void *addr, size_t len, int prot);
int sceKernelMsync(void *addr, size_t len, int flags);
int sceKernelMunmap(void *addr, size_t len);
int sceKernelMlockall(int flags);
int sceKernelMunlockall(void);
unsigned int sceKernelSleep(unsigned int seconds);
int sceKernelUsleep(SceKernelUseconds microseconds);
int sceKernelNanosleep(const SceKernelTimespec *rqtp, SceKernelTimespec *rmtp);
int sceKernelClockGetres(SceKernelClockid clockId, SceKernelTimespec *tp);
int sceKernelClockGettime(SceKernelClockid clockId, SceKernelTimespec *tp);
int sceKernelGettimeofday(SceKernelTimeval *tp);

uint64_t sceKernelGetTscFrequency(void);
uint64_t sceKernelReadTsc(void);
uint64_t sceKernelGetProcessTime(void);
uint64_t sceKernelGetProcessTimeCounter(void);
uint64_t sceKernelGetProcessTimeCounterFrequency(void);
int sceKernelGetCurrentCpu(void);

SceKernelModule sceKernelLoadStartModule(const char *moduleFileName,
        size_t args, const void *argp, uint32_t flags,
        const SceKernelLoadModuleOpt *pOpt, int *pRes);
int sceKernelStopUnloadModule(SceKernelModule handle, size_t args,
        const void *argp, uint32_t flags, const SceKernelUnloadModuleOpt *pOpt,
        int *pRes);
int sceKernelDlsym(SceKernelModule handle, const char *symbol, void **addrp) __attribute__((noinline));


int __attribute__((visibility ("hidden"))) module_start(size_t args, const void *argp);
int __attribute__((visibility ("hidden"))) module_stop(size_t args, const void *argp);

void sceKernelSetGPO(uint32_t uiBits);
uint64_t sceKernelGetGPI();

int sceKernelSetFsstParam(int prio, SceKernelCpumask mask);
# 102 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_kernel.h" 3
int sceKernelGetCpumode();
int sceKernelIsNeoMode();

}
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 1 3
# 52 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sched.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 1 3
# 54 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\pthread.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\pthread.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sched.h" 1 3
# 52 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\time.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 1 3
# 54 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\pthread.h" 2 3
# 125 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\pthread.h" 3
enum pthread_mutextype {
 PTHREAD_MUTEX_ERRORCHECK = 1,
 PTHREAD_MUTEX_RECURSIVE = 2,
 PTHREAD_MUTEX_NORMAL = 3,
 PTHREAD_MUTEX_ADAPTIVE_NP = 4,
 PTHREAD_MUTEX_TYPE_MAX
};



struct _pthread_cleanup_info {
 __uintptr_t pthread_cleanup_pad[8];
};




extern "C" {
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getstack(const pthread_attr_t * __restrict,
   void ** __restrict, size_t * __restrict);
int pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
int pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
int pthread_attr_getstackaddr(const pthread_attr_t *, void **);
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t);
int pthread_attr_setguardsize(pthread_attr_t *, size_t);
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
int pthread_attr_setstackaddr(pthread_attr_t *, void *);
int pthread_attr_setdetachstate(pthread_attr_t *, int);
int pthread_barrier_destroy(pthread_barrier_t *);
int pthread_barrier_init(pthread_barrier_t *,
   const pthread_barrierattr_t *, unsigned);
int pthread_barrier_wait(pthread_barrier_t *);
int pthread_barrierattr_destroy(pthread_barrierattr_t *);
int pthread_barrierattr_getpshared(const pthread_barrierattr_t *,
   int *);
int pthread_barrierattr_init(pthread_barrierattr_t *);
int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
# 178 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\pthread.h" 3
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_getclock(const pthread_condattr_t *,
   clockid_t *);
int pthread_condattr_getpshared(const pthread_condattr_t *, int *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
int pthread_condattr_setpshared(pthread_condattr_t *, int);
int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t *,
   const pthread_condattr_t *);
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t *,
   pthread_mutex_t *, const struct timespec *);
int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
int pthread_create(pthread_t *, const pthread_attr_t *,
   void *(*) (void *), void *);
int pthread_detach(pthread_t);
int pthread_equal(pthread_t, pthread_t);
void pthread_exit(void *) __attribute__((__noreturn__));
void *pthread_getspecific(pthread_key_t);
int pthread_getcpuclockid(pthread_t, clockid_t *);
int pthread_join(pthread_t, void **);
int pthread_key_create(pthread_key_t *,
   void (*) (void *));
int pthread_key_delete(pthread_key_t);
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,
   int *);
int pthread_mutexattr_gettype(pthread_mutexattr_t *, int *);
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_init(pthread_mutex_t *,
   const pthread_mutexattr_t *);
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_timedlock(pthread_mutex_t *,
   const struct timespec *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_once(pthread_once_t *, void (*) (void));
int pthread_rwlock_destroy(pthread_rwlock_t *);
int pthread_rwlock_init(pthread_rwlock_t *,
   const pthread_rwlockattr_t *);
int pthread_rwlock_rdlock(pthread_rwlock_t *);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *,
   const struct timespec *);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *,
   const struct timespec *);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int pthread_rwlock_trywrlock(pthread_rwlock_t *);
int pthread_rwlock_unlock(pthread_rwlock_t *);
int pthread_rwlock_wrlock(pthread_rwlock_t *);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *,
   int *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,
   int *);
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *, int);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
pthread_t pthread_self(void);
int pthread_setspecific(pthread_key_t, const void *);

int pthread_cancel(pthread_t);
int pthread_setcancelstate(int, int *);
int pthread_setcanceltype(int, int *);
void pthread_testcancel(void);


int pthread_getprio(pthread_t);
int pthread_setprio(pthread_t, int);
void pthread_yield(void);


int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *,
   int *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,
   int);
int pthread_mutex_getprioceiling(pthread_mutex_t *, int *);
int pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);

int pthread_mutexattr_getprotocol(pthread_mutexattr_t *, int *);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

int pthread_attr_getinheritsched(const pthread_attr_t *, int *);
int pthread_attr_getschedparam(const pthread_attr_t *,
   struct sched_param *);
int pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
int pthread_attr_getscope(const pthread_attr_t *, int *);
int pthread_attr_setinheritsched(pthread_attr_t *, int);
int pthread_attr_setschedparam(pthread_attr_t *,
   const struct sched_param *);
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_getschedparam(pthread_t pthread, int *,
   struct sched_param *);
int pthread_setschedparam(pthread_t, int,
   const struct sched_param *);

int pthread_getconcurrency(void);
int pthread_setconcurrency(int);


void __pthread_cleanup_push_imp(void (*)(void *), void *,
   struct _pthread_cleanup_info *);
void __pthread_cleanup_pop_imp(int);
}
# 57 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\semaphore.h" 1 3
# 42 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\semaphore.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_umtx.h" 1 3
# 35 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_umtx.h" 3
struct umtx {
 volatile unsigned long u_owner;
};

struct umutex {
 volatile __lwpid_t m_owner;
 __uint32_t m_flags;
 __uint32_t m_ceilings[2];
 __uint32_t m_spare[4];
};

struct ucond {
 volatile __uint32_t c_has_waiters;
 __uint32_t c_flags;
 __uint32_t c_clockid;
 __uint32_t c_spare[1];
};

struct urwlock {
 volatile __int32_t rw_state;
 __uint32_t rw_flags;
 __uint32_t rw_blocked_readers;
 __uint32_t rw_blocked_writers;
 __uint32_t rw_spare[4];
};

struct _usem {
 volatile __uint32_t _has_waiters;
 volatile __uint32_t _count;
 __uint32_t _flags;
};
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\semaphore.h" 2 3


struct _sem {
 __uint16_t _magic;
 __uint16_t _nameid;
 struct _usem _kern;
};

typedef struct _sem sem_t;




struct timespec;

extern "C" {
int sem_destroy(sem_t *);
int sem_getvalue(sem_t * __restrict, int * __restrict);
int sem_init(sem_t *, int, unsigned int);
int sem_post(sem_t *);
int sem_reltimedwait_np(sem_t *, useconds_t);
int sem_timedwait(sem_t * __restrict, const struct timespec * __restrict);
int sem_trywait(sem_t *);
int sem_unlink(const char *);
int sem_wait(sem_t *);
}
# 58 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 2 3
# 137 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 3
typedef enum ScePthreadMutextype {
 SCE_PTHREAD_MUTEX_ERRORCHECK = 1,
 SCE_PTHREAD_MUTEX_RECURSIVE = 2,
 SCE_PTHREAD_MUTEX_NORMAL = 3,
 SCE_PTHREAD_MUTEX_ADAPTIVE = 4,
 SCE_PTHREAD_MUTEX_TYPE_MAX
} ScePthreadMutextype;

typedef enum ScePthreadRwlocktype {
 SCE_PTHREAD_RWLOCK_NORMAL = 1,
 SCE_PTHREAD_RWLOCK_PREFER_READER = 2,
 SCE_PTHREAD_RWLOCK_TYPE_MAX
} ScePthreadRwlocktype;
# 163 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 3
typedef pthread_attr_t ScePthreadAttr;
typedef pthread_barrier_t ScePthreadBarrier;
typedef pthread_barrierattr_t ScePthreadBarrierattr;
typedef pthread_condattr_t ScePthreadCondattr;
typedef pthread_cond_t ScePthreadCond;
typedef pthread_t ScePthread;
typedef pthread_key_t ScePthreadKey;
typedef pthread_mutex_t ScePthreadMutex;
typedef pthread_mutexattr_t ScePthreadMutexattr;
typedef pthread_once_t ScePthreadOnce;
typedef pthread_rwlock_t ScePthreadRwlock;
typedef pthread_rwlockattr_t ScePthreadRwlockattr;
typedef sem_t ScePthreadSem;





extern "C" {
int scePthreadAttrDestroy(ScePthreadAttr *attr);
int scePthreadAttrGetstack(const ScePthreadAttr * __restrict attr,
   void ** __restrict stackAddr, size_t * __restrict stackSize);
int scePthreadAttrGetstacksize(const ScePthreadAttr *attr, size_t *stackSize);
int scePthreadAttrGetguardsize(const ScePthreadAttr *attr, size_t *guardSize);
int scePthreadAttrGetstackaddr(const ScePthreadAttr *attr, void **stackAddr);
int scePthreadAttrGetdetachstate(const ScePthreadAttr *attr, int *state);
int scePthreadAttrInit(ScePthreadAttr *attr);
int scePthreadAttrSetstacksize(ScePthreadAttr *attr, size_t stackSize);
int scePthreadAttrSetguardsize(ScePthreadAttr *attr, size_t guardSize);
int scePthreadAttrSetstack(ScePthreadAttr *attr, void *addr, size_t size);
int scePthreadAttrSetstackaddr(ScePthreadAttr *attr, void *addr);
int scePthreadAttrSetdetachstate(ScePthreadAttr *attr, int state);
int scePthreadBarrierDestroy(ScePthreadBarrier *barrier);
int scePthreadBarrierInit(ScePthreadBarrier *barrier,
   const ScePthreadBarrierattr *attr, unsigned count, const char *name);
int scePthreadBarrierWait(ScePthreadBarrier *barrier);
int scePthreadBarrierattrDestroy(ScePthreadBarrierattr *barrier);
int scePthreadBarrierattrInit(ScePthreadBarrierattr *barrier);
# 214 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_pthread.h" 3
int scePthreadCondattrDestroy(ScePthreadCondattr *attr);
int scePthreadCondattrInit(ScePthreadCondattr *attr);
int scePthreadCondBroadcast(ScePthreadCond *cond);
int scePthreadCondDestroy(ScePthreadCond *cond);
int scePthreadCondInit(ScePthreadCond *cond,
   const ScePthreadCondattr *attr, const char *name);
int scePthreadCondSignal(ScePthreadCond *cond);
int scePthreadCondSignalto(ScePthreadCond *cond, ScePthread thread);
int scePthreadCondTimedwait(ScePthreadCond *cond, ScePthreadMutex *mutex,
                        SceKernelUseconds usec);
int scePthreadCondWait(ScePthreadCond *cond, ScePthreadMutex *mutex);
int scePthreadCreate(ScePthread *thread, const ScePthreadAttr *attr,
                        void *(*entry) (void *), void *arg, const char *name);
int scePthreadDetach(ScePthread thread);
int scePthreadEqual(ScePthread thraed1, ScePthread thread2);
void scePthreadExit(void *value) __attribute__((__noreturn__));
void *scePthreadGetspecific(ScePthreadKey key);
int scePthreadGetcpuclockid(ScePthread thread, clockid_t *clock);
int scePthreadJoin(ScePthread thread, void **value);
int scePthreadKeyCreate(ScePthreadKey *key,
   void (*destructor) (void *));
int scePthreadKeyDelete(ScePthreadKey key);
int scePthreadMutexattrInit(ScePthreadMutexattr *attr);
int scePthreadMutexattrDestroy(ScePthreadMutexattr *attr);
int scePthreadMutexattrGettype(ScePthreadMutexattr *attr, int *type);
int scePthreadMutexattrSettype(ScePthreadMutexattr *attr, int type);
int scePthreadMutexDestroy(ScePthreadMutex *mutex);
int scePthreadMutexInit(ScePthreadMutex *mutex,
   const ScePthreadMutexattr *attr, const char *name);
int scePthreadMutexLock(ScePthreadMutex *mutex);
int scePthreadMutexTrylock(ScePthreadMutex *mutex);
int scePthreadMutexTimedlock(ScePthreadMutex *mutex, SceKernelUseconds usec);
int scePthreadMutexUnlock(ScePthreadMutex *mutex);
int scePthreadOnce(ScePthreadOnce *once, void (*init) (void));
int scePthreadRwlockDestroy(ScePthreadRwlock *rwlock);
int scePthreadRwlockInit(ScePthreadRwlock *rwlock,
   const ScePthreadRwlockattr *attr, const char *name);
int scePthreadRwlockRdlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockTimedrdlock(ScePthreadRwlock *rwlock, SceKernelUseconds usec);
int scePthreadRwlockTimedwrlock(ScePthreadRwlock *rwlock, SceKernelUseconds usec);
int scePthreadRwlockTryrdlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockTrywrlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockUnlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockWrlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockattrDestroy(ScePthreadRwlockattr *attr);
int scePthreadRwlockattrInit(ScePthreadRwlockattr *attr);
int scePthreadRwlockattrGettype(ScePthreadRwlockattr *attr, int *type);
int scePthreadRwlockattrSettype(ScePthreadRwlockattr *attr, int type);
ScePthread scePthreadSelf(void);
int scePthreadSetspecific(ScePthreadKey key, const void *value);

int scePthreadCancel(ScePthread thread);
int scePthreadSetcancelstate(int state, int *oldState);
int scePthreadSetcanceltype(int type, int *oldType);
void scePthreadTestcancel(void);

int scePthreadGetprio(ScePthread thread, int *prio);
int scePthreadSetprio(ScePthread thread, int prio);
void scePthreadYield(void);

int scePthreadMutexattrGetprioceiling(ScePthreadMutexattr *attr,
   int *prio);
int scePthreadMutexattrSetprioceiling(ScePthreadMutexattr *attr,
   int prio);
int scePthreadMutexGetprioceiling(ScePthreadMutex *mutex, int *prio);
int scePthreadMutexSetprioceiling(ScePthreadMutex *mutex, int prio, int *oldPrio);

int scePthreadMutexattrGetprotocol(ScePthreadMutexattr *attr, int *protocol);
int scePthreadMutexattrSetprotocol(ScePthreadMutexattr *attr, int protocol);

int scePthreadAttrGetinheritsched(const ScePthreadAttr *attr, int *inheritSched);
int scePthreadAttrGetschedparam(const ScePthreadAttr *attr,
   SceKernelSchedParam *param);
int scePthreadAttrGetschedpolicy(const ScePthreadAttr *attr, int *policy);
int scePthreadAttrSetinheritsched(ScePthreadAttr *attr, int inheritSched);
int scePthreadAttrSetschedparam(ScePthreadAttr *attr,
   const SceKernelSchedParam *param);
int scePthreadAttrSetschedpolicy(ScePthreadAttr *attr, int policy);
int scePthreadGetschedparam(ScePthread thread, int *policy,
     SceKernelSchedParam *param);
int scePthreadSetschedparam(ScePthread thread, int policy,
     const SceKernelSchedParam *param);

int scePthreadSemInit(ScePthreadSem *sem, int flag, unsigned int value,
    const char *name);
int scePthreadSemDestroy(ScePthreadSem *sem);
int scePthreadSemTimedwait(ScePthreadSem *sem, SceKernelUseconds usec);
int scePthreadSemGetvalue(ScePthreadSem * __restrict sem, int * __restrict sval);
int scePthreadSemPost(ScePthreadSem *sem);
int scePthreadSemTrywait(ScePthreadSem *sem);
int scePthreadSemWait(ScePthreadSem *sem);


int scePthreadAttrGet(ScePthread thread, ScePthreadAttr *attr);
int scePthreadAttrGetaffinity(const ScePthreadAttr *attr, SceKernelCpumask *mask);
int scePthreadAttrSetaffinity(ScePthreadAttr *attr, const SceKernelCpumask mask);
int scePthreadGetaffinity(ScePthread thread, SceKernelCpumask *mask);
int scePthreadSetaffinity(ScePthread thread, const SceKernelCpumask mask);
int scePthreadGetthreadid(void);
int scePthreadRename(ScePthread thread, const char *name);
int scePthreadGetname(ScePthread thread, char *name);

}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/uio.h" 1 3
# 42 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/uio.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_iovec.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_iovec.h" 3
struct iovec {
 void *iov_base;
 size_t iov_len;
};
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/uio.h" 2 3




enum uio_rw { UIO_READ, UIO_WRITE };


enum uio_seg {
 UIO_USERSPACE,
 UIO_SYSSPACE,
 UIO_NOCOPY
};
# 104 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/uio.h" 3
extern "C" {
ssize_t readv(int, const struct iovec *, int);
ssize_t writev(int, const struct iovec *, int);

ssize_t preadv(int, const struct iovec *, int, off_t);
ssize_t pwritev(int, const struct iovec *, int, off_t);

}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/stat.h" 1 3
# 68 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/stat.h" 3
struct ostat {
 __uint16_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 __uint16_t st_uid;
 __uint16_t st_gid;
 __uint16_t st_rdev;
 __int32_t st_size;
 struct timespec st_atim;
 struct timespec st_mtim;
 struct timespec st_ctim;
 __int32_t st_blksize;
 __int32_t st_blocks;
 fflags_t st_flags;
 __uint32_t st_gen;
};


struct stat {
 __dev_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 uid_t st_uid;
 gid_t st_gid;
 __dev_t st_rdev;
 struct timespec st_atim;
 struct timespec st_mtim;
 struct timespec st_ctim;
 off_t st_size;
 blkcnt_t st_blocks;
 blksize_t st_blksize;
 fflags_t st_flags;
 __uint32_t st_gen;
 __int32_t st_lspare;
 struct timespec st_birthtim;
# 113 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/stat.h" 3
 unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
 unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
};


struct nstat {
 __dev_t st_dev;
 ino_t st_ino;
 __uint32_t st_mode;
 __uint32_t st_nlink;
 uid_t st_uid;
 gid_t st_gid;
 __dev_t st_rdev;
 struct timespec st_atim;
 struct timespec st_mtim;
 struct timespec st_ctim;
 off_t st_size;
 blkcnt_t st_blocks;
 blksize_t st_blksize;
 fflags_t st_flags;
 __uint32_t st_gen;
 struct timespec st_birthtim;



 unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
 unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
};
# 263 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/stat.h" 3
extern "C" {

int chflags(const char *, unsigned long);

int chmod(const char *, mode_t);

int fchflags(int, unsigned long);


int fchmod(int, mode_t);

int fstat(int, struct stat *);
int mkdir(const char *, mode_t);
int stat(const char * __restrict, struct stat * __restrict);
}
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/dirent.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/dirent.h" 3
struct dirent {
 __uint32_t d_fileno;
 __uint16_t d_reclen;
 __uint8_t d_type;
 __uint8_t d_namlen;


 char d_name[255 + 1];



};
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/file.h" 1 3
# 38 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/file.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/fcntl.h" 1 3
# 228 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/fcntl.h" 3
struct flock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
 int l_sysid;
};





struct oflock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
};
# 263 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/fcntl.h" 3
extern "C" {
int open(const char *, int, ...);
int creat(const char *, mode_t);
int fcntl(int, int, ...);

int flock(int, int);

}
# 39 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/file.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/unistd.h" 1 3
# 40 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/file.h" 2 3
# 173 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/file.h" 3
struct xfile {
 size_t xf_size;
 pid_t xf_pid;
 uid_t xf_uid;
 int xf_fd;
 void *xf_file;
 short xf_type;
 int xf_count;
 int xf_msgcount;
 off_t xf_offset;
 void *xf_data;
 void *xf_vnode;
 u_int xf_flag;
};
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/mman.h" 1 3
# 237 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/mman.h" 3
extern "C" {
int getpagesizes(size_t *, int);
int madvise(void *, size_t, int);
int mincore(const void *, size_t, char *);
int minherit(void *, size_t, int);
}

extern "C" {
int mlock(const void *, size_t);
int mprotect(const void *, size_t, int);
int msync(void *, size_t, int);
int munlock(const void *, size_t);
int munmap(void *, size_t);
}

extern "C" {
int posix_madvise(void *, size_t, int);
}


extern "C" {
int mlockall(int);
int munlockall(void);
int shm_open(const char *, int, mode_t);
int shm_unlink(const char *);
int physhm_open(const char *, int, mode_t, int);
int physhm_unlink(const char *);
void *mmap_dmem(void *, size_t, int, int, int, off_t);
}
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits.h" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\fcntl.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 2 3
# 99 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 3
typedef struct iovec SceKernelIovec;
typedef struct stat SceKernelStat;
typedef struct dirent SceKernelDirent;
typedef mode_t SceKernelMode;

extern "C" {

ssize_t sceKernelRead(int d, void *buf, size_t nbytes);
ssize_t sceKernelWrite(int d, const void *buf, size_t nbytes);
int sceKernelOpen(const char *path, int flags, SceKernelMode mode);
int sceKernelClose(int d);
int sceKernelUnlink(const char *path);
int sceKernelChmod(const char *path, SceKernelMode mode);
int sceKernelCheckReachability(const char *path);
void sceKernelSync(void);
int sceKernelFsync(int fd);
int sceKernelFdatasync(int fd);
int sceKernelFcntl(int fd, int cmd, ...);
ssize_t sceKernelReadv(int d, const SceKernelIovec *iov, int iovcnt);
ssize_t sceKernelWritev(int d, const SceKernelIovec *iov, int iovcnt);
int sceKernelFchmod(int fd, SceKernelMode mode);
int sceKernelRename(const char *from, const char *to);
int sceKernelMkdir(const char *path, SceKernelMode mode);
int sceKernelRmdir(const char *path);
int sceKernelUtimes(const char *path, const SceKernelTimeval *times);
int sceKernelStat(const char *path, SceKernelStat *sb);
int sceKernelFstat(int fd, SceKernelStat *sb);
int sceKernelFutimes(int fd, const SceKernelTimeval *times);
int sceKernelGetdirentries(int fd, char *buf, int nbytes, long *basep);
int sceKernelGetdents(int fd, char *buf, int nbytes);
ssize_t sceKernelPreadv(int d, const SceKernelIovec *iov, int iovcnt, off_t offset);
ssize_t sceKernelPwritev(int d, const SceKernelIovec *iov, int iovcnt, off_t offset);
ssize_t sceKernelPread(int d, void *buf, size_t nbytes, off_t offset);
ssize_t sceKernelPwrite(int d, const void *buf, size_t nbytes, off_t offset);
int sceKernelMmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset,
        void **res);
off_t sceKernelLseek(int fildes, off_t offset, int whence);
int sceKernelTruncate(const char *path, off_t length);
int sceKernelFtruncate(int fd, off_t length);
int sceKernelSetCompressionAttribute(int fd, int flag);
int sceKernelLwfsSetAttribute(int fd, int flags);
int sceKernelLwfsAllocateBlock(int fd, off_t size);
int sceKernelLwfsTrimBlock(int fd, off_t size);
off_t sceKernelLwfsLseek(int fd, off_t offset, int whence);
ssize_t sceKernelLwfsWrite(int fd, const void *buf, size_t nbytes);
# 159 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 3
typedef struct SceKernelAioResult {
 int64_t returnValue;
 uint32_t state;
} SceKernelAioResult;
# 183 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/_fs.h" 3
typedef struct SceKernelAioSchedulingParam {
 int schedulingWindowSize;
 int delayedCountLimit;
 uint32_t enableSplit;
 uint32_t splitSize;
 uint32_t splitChunkSize;
} SceKernelAioSchedulingParam;

typedef struct SceKernelAioParam {
 SceKernelAioSchedulingParam low;
 SceKernelAioSchedulingParam mid;
 SceKernelAioSchedulingParam high;
} SceKernelAioParam;

typedef int SceKernelAioSubmitId;

int sceKernelAioDeleteRequests(SceKernelAioSubmitId id[], int num, int ret[]);

int sceKernelAioDeleteRequest(SceKernelAioSubmitId id, int *ret);

int sceKernelAioWaitRequests(SceKernelAioSubmitId id[],
        int num,
        int state[],
        uint32_t mode,
        SceKernelUseconds *usec);

int sceKernelAioWaitRequest(SceKernelAioSubmitId id,
       int *state,
       SceKernelUseconds *usec);

int sceKernelAioInitialize(SceKernelAioParam* param);

int sceKernelAioInitializeImpl(void* p, int size);


int sceKernelAioCancelRequests(SceKernelAioSubmitId id[], int num, int state[]);

int sceKernelAioCancelRequest(SceKernelAioSubmitId id, int *state);

int sceKernelAioPollRequest(SceKernelAioSubmitId id,
       int *state);

int sceKernelAioPollRequests(SceKernelAioSubmitId id[],
        int num,
        int state[]);



typedef struct SceKernelAioRWRequest {
 off_t offset;
 size_t nbyte;
 void* buf;
 struct SceKernelAioResult *result;
 int fd;
} SceKernelAioRWRequest;

int sceKernelAioSubmitReadCommands(SceKernelAioRWRequest req[],
           int size,
           int prio,
           SceKernelAioSubmitId *id);

int sceKernelAioSubmitReadCommandsMultiple(SceKernelAioRWRequest req[],
             int size,
             int prio,
             SceKernelAioSubmitId id[]);

int sceKernelAioSubmitWriteCommands(SceKernelAioRWRequest req[],
         int size,
         int prio,
         SceKernelAioSubmitId *id);

int sceKernelAioSubmitWriteCommandsMultiple(SceKernelAioRWRequest req[],
           int size,
           int prio,
           SceKernelAioSubmitId id[]);


void sceKernelAioInitializeParam(SceKernelAioParam* param);

int sceKernelAioSetParam(SceKernelAioSchedulingParam* param,
       int schedulingWindowSize,
       int delayedCountLimit,
       uint32_t enableSplit,
       uint32_t splitSize,
       uint32_t splitChunkSize);

typedef struct SceKernelAioRequestInfo {
 int fd;
 size_t size;
 off_t offset;
} SceKernelAioRequestInfo;

typedef struct SceKernelAioSubmitInfo {
 SceKernelAioSubmitId id;
 int status;
 int priority;
 int cmd;
} SceKernelAioSubmitInfo;

int sceKernelGetAioDebugRequestInfo(
 pid_t pid,
 SceKernelAioSubmitId id,
 SceKernelAioRequestInfo *info,
 int num,
 int *stored_num
);

int sceKernelGetAioDebugSubmitInfo(
 pid_t pid,
 SceKernelAioSubmitInfo *info,
 int num,
 int *stored_num
);

int get_aio_debug_submit_info(int pid, SceKernelAioSubmitInfo* info, int num, int *stored_num);
int get_aio_debug_request_info(int pid, int id, SceKernelAioRequestInfo* info, int num, int *stored_num);

}
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/eventflag.h" 1 3
# 22 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/eventflag.h" 3
typedef struct _SceKernelEventFlagOptParam {
 size_t size;
} SceKernelEventFlagOptParam;

typedef struct _SceKernelEventFlag* SceKernelEventFlag;




extern "C" {

int sceKernelCreateEventFlag(SceKernelEventFlag *ef, const char *pName,
        uint32_t attr, uint64_t initPattern,
        const SceKernelEventFlagOptParam *pOptParam);
int sceKernelDeleteEventFlag(SceKernelEventFlag ef);
int sceKernelWaitEventFlag(SceKernelEventFlag ef, uint64_t bitPattern,
      uint32_t waitMode, uint64_t *pResultPat,
      SceKernelUseconds *pTimeout);
int sceKernelPollEventFlag(SceKernelEventFlag ef, uint64_t bitPattern,
      uint32_t waitMode, uint64_t *pResultPat);
int sceKernelSetEventFlag(SceKernelEventFlag ef, uint64_t bitPattern);
int sceKernelClearEventFlag(SceKernelEventFlag ef, uint64_t bitPattern);
int sceKernelCancelEventFlag(SceKernelEventFlag ef, uint64_t setPattern,
        int *pNumWaitThreads);

}
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/semaphore.h" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/semaphore.h" 3
typedef struct _SceKernelSemaOptParam {
 size_t size;
} SceKernelSemaOptParam;

typedef struct _SceKernelSema* SceKernelSema;




extern "C" {

int sceKernelCreateSema(SceKernelSema *sem, const char *name, uint32_t attr,
   int init, int max, const SceKernelSemaOptParam *opt);
int sceKernelDeleteSema(SceKernelSema sem);
int sceKernelWaitSema(SceKernelSema sem, int need, SceKernelUseconds *timo);
int sceKernelPollSema(SceKernelSema sem, int need);
int sceKernelSignalSema(SceKernelSema sem, int count);
int sceKernelCancelSema(SceKernelSema sem, int count, int *threads);

}
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/equeue.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/equeue.h" 3
extern "C" {

typedef struct _SceKernelEqueue* SceKernelEqueue;
typedef struct kevent SceKernelEvent;
# 37 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/equeue.h" 3
int sceKernelGetEventFilter(const SceKernelEvent *ev);
uintptr_t sceKernelGetEventId(const SceKernelEvent *ev);
intptr_t sceKernelGetEventData(const SceKernelEvent *ev);
unsigned int sceKernelGetEventFflags(const SceKernelEvent *ev);
int sceKernelGetEventError(const SceKernelEvent *ev);
void * sceKernelGetEventUserData(const SceKernelEvent *ev);

int sceKernelCreateEqueue(SceKernelEqueue *eq, const char *name);
int sceKernelDeleteEqueue(SceKernelEqueue eq);
int sceKernelWaitEqueue(SceKernelEqueue eq, SceKernelEvent *ev, int num,
   int *out, SceKernelUseconds *timo);

int sceKernelAddTimerEvent(SceKernelEqueue eq, int id, SceKernelUseconds usec, void *udata);
int sceKernelDeleteTimerEvent(SceKernelEqueue eq, int id);
int sceKernelAddReadEvent(SceKernelEqueue eq, int fd, size_t size, void *udata);
int sceKernelDeleteReadEvent(SceKernelEqueue eq, int fd);
int sceKernelAddWriteEvent(SceKernelEqueue eq, int fd, size_t size, void *udata);
int sceKernelDeleteWriteEvent(SceKernelEqueue eq, int fd);
int sceKernelAddFileEvent(SceKernelEqueue eq, int fd, int watch, void *udata);
int sceKernelDeleteFileEvent(SceKernelEqueue eq, int fd);
int sceKernelAddUserEvent(SceKernelEqueue eq, int id);
int sceKernelAddUserEventEdge(SceKernelEqueue eq, int id);
int sceKernelDeleteUserEvent(SceKernelEqueue eq, int id);
int sceKernelTriggerUserEvent(SceKernelEqueue eq, int id, void *udata);
int sceKernelAddHRTimerEvent(SceKernelEqueue eq, int id, SceKernelTimespec *ts, void *udata);
int sceKernelDeleteHRTimerEvent(SceKernelEqueue eq, int id);

}
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/uuid.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/uuid.h" 3
extern "C" {

typedef struct {
    uint32_t timeLow;
    uint16_t timeMid;
    uint16_t timeHiAndVersion;
    uint8_t clockSeqHiAndReserved;
    uint8_t clockSeqLow;
    uint8_t node[6];
} SceKernelUuid;

int sceKernelUuidCreate(SceKernelUuid* outUuid);

}
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/memory.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include/kernel/memory.h" 3
extern "C" {

int32_t sceKernelAvailableFlexibleMemorySize(size_t *sizeOut);
int32_t sceKernelConfiguredFlexibleMemorySize(size_t *sizeOut);

}
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\kernel.h" 2 3
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service/user_service_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\inttypes.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service/user_service_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stddef.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stddef.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stddef.h" 2 3
# 45 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stddef.h" 3
typedef _Ptrdifft ptrdiff_t;
# 65 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stddef.h" 3
typedef decltype(nullptr) nullptr_t;





typedef float max_align_t __attribute__((__vector_size__ (32) ));
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service/user_service_api.h" 2 3




typedef struct SceUserServiceInitializeParams {
 int32_t priority;
} SceUserServiceInitializeParams;



typedef enum SceUserServiceEventType {
 SCE_USER_SERVICE_EVENT_TYPE_LOGIN = 0,
 SCE_USER_SERVICE_EVENT_TYPE_LOGOUT
} SceUserServiceEventType;



typedef struct SceUserServiceEvent {
 SceUserServiceEventType eventType;
 SceUserServiceUserId userId;
} SceUserServiceEvent;



typedef struct SceUserServiceLoginUserIdList {
    SceUserServiceUserId userId[(4)];
} SceUserServiceLoginUserIdList;



typedef enum SceUserServiceUserColor {
    SCE_USER_SERVICE_USER_COLOR_BLUE = 0,
    SCE_USER_SERVICE_USER_COLOR_RED,
    SCE_USER_SERVICE_USER_COLOR_GREEN,
    SCE_USER_SERVICE_USER_COLOR_PINK
} SceUserServiceUserColor;


extern "C" {




int32_t sceUserServiceInitialize(const SceUserServiceInitializeParams *initParams);



int32_t sceUserServiceInitialize2(int threadPriority, SceKernelCpumask cpuAffinityMask);



int32_t sceUserServiceTerminate();



int32_t sceUserServiceGetLoginUserIdList(SceUserServiceLoginUserIdList *userIdList);



int32_t sceUserServiceGetEvent(SceUserServiceEvent *event);



int32_t sceUserServiceGetInitialUser(SceUserServiceUserId *userId);



int32_t sceUserServiceGetUserName(const SceUserServiceUserId userId, char *userName, const size_t size);



int32_t sceUserServiceGetUserColor(const SceUserServiceUserId userId, SceUserServiceUserColor *color);



int32_t sceUserServiceGetAccessibilityPressAndHoldDelay(SceUserServiceUserId userId, int32_t *pressAndHoldDelay);



int32_t sceUserServiceGetAccessibilityVibration(SceUserServiceUserId userId, int32_t *vibration);



int32_t sceUserServiceGetAccessibilityZoomEnabled(SceUserServiceUserId userId, int32_t *zoom);


}
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service/user_service_error.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\user_service.h" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 2 3
# 45 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataMountMode;
# 63 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataMountStatus;





typedef uint32_t SceSaveDataParamType;
# 86 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataSortKey;
# 101 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataSortOrder;
# 121 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef uint64_t SceSaveDataBlocks;
# 146 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataSaveDataMemoryOption;
# 155 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataMemorySyncOption;
# 180 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataEventType;
# 199 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_defs.h" 3
typedef struct SceSaveDataTitleId {
 char data[(10)];

 char padding[6];

} SceSaveDataTitleId;




typedef struct SceSaveDataDirName {
 char data[(32)];

} SceSaveDataDirName;




typedef struct SceSaveDataMountPoint {
 char data[(16)];

} SceSaveDataMountPoint;




typedef struct SceSaveDataFingerprint {
 char data[(65)];

 char padding[15];

} SceSaveDataFingerprint;




typedef struct _SceSaveDataInitParams3 SceSaveDataInitParams3;




typedef struct SceSaveDataMount2 {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataDirName *dirName;

 SceSaveDataBlocks blocks;

 SceSaveDataMountMode mountMode;

 uint8_t reserved[32];

 int :32;

} SceSaveDataMount2;




typedef struct SceSaveDataTransferringMount {
 SceUserServiceUserId userId;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 const SceSaveDataFingerprint *fingerprint;

 uint8_t reserved[32];

} SceSaveDataTransferringMount;




typedef struct SceSaveDataMountResult {
 SceSaveDataMountPoint mountPoint;

 SceSaveDataBlocks requiredBlocks;

 uint32_t unused;

 SceSaveDataMountStatus mountStatus;

 uint8_t reserved[28];

 int :32;

} SceSaveDataMountResult;




typedef struct SceSaveDataMountInfo {
 SceSaveDataBlocks blocks;

 SceSaveDataBlocks freeBlocks;

 uint8_t reserved[32];

} SceSaveDataMountInfo;




typedef struct SceSaveDataIcon {
 void *buf;

 size_t bufSize;

 size_t dataSize;

 uint8_t reserved[32];

} SceSaveDataIcon;




typedef struct SceSaveDataParam {
 char title[(128)];

 char subTitle[(128)];


 char detail[(1024)];


 uint32_t userParam;

 int :32;

 time_t mtime;

 uint8_t reserved[32];

} SceSaveDataParam;




typedef struct SceSaveDataDelete {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 uint32_t unused;

 uint8_t reserved[32];

 int :32;

} SceSaveDataDelete;




typedef struct SceSaveDataSearchInfo {
 SceSaveDataBlocks blocks;

 SceSaveDataBlocks freeBlocks;

 uint8_t reserved[32];

} SceSaveDataSearchInfo;




typedef struct SceSaveDataDirNameSearchCond {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 SceSaveDataSortKey key;

 SceSaveDataSortOrder order;

 uint8_t reserved[32];

} SceSaveDataDirNameSearchCond;




typedef struct SceSaveDataDirNameSearchResult {
 uint32_t hitNum;

 int :32;

 SceSaveDataDirName *dirNames;

 uint32_t dirNamesNum;

 uint32_t setNum;

 SceSaveDataParam *params;

 SceSaveDataSearchInfo *infos;

 uint8_t reserved[12];

 int :32;

} SceSaveDataDirNameSearchResult;




typedef struct SceSaveDataMemorySync {
 SceUserServiceUserId userId;

 uint32_t slotId;

 SceSaveDataMemorySyncOption option;

 uint8_t reserved[28];

} SceSaveDataMemorySync;




typedef struct SceSaveDataRestoreBackupData {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 const SceSaveDataFingerprint *fingerprint;

 uint32_t unused;

 uint8_t reserved[32];

 int :32;

} SceSaveDataRestoreBackupData;




typedef struct SceSaveDataCheckBackupData {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 SceSaveDataParam *param;

 SceSaveDataIcon *icon;

 uint8_t reserved[32];

} SceSaveDataCheckBackupData;




typedef struct SceSaveDataBackup {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 const SceSaveDataFingerprint *fingerprint;

 uint8_t reserved[32];

} SceSaveDataBackup;




typedef struct SceSaveDataMemoryData
{
 void *buf;

 size_t bufSize;

 off_t offset;

 uint8_t reserved[40];

} SceSaveDataMemoryData;




typedef struct SceSaveDataMemorySetup2
{
 SceSaveDataSaveDataMemoryOption option;

 SceUserServiceUserId userId;

 size_t memorySize;

 size_t iconMemorySize;

 const SceSaveDataParam *initParam;

 const SceSaveDataIcon *initIcon;

 uint32_t slotId;

 uint8_t reserved[20];

} SceSaveDataMemorySetup2;



typedef struct SceSaveDataMemorySetupResult
{
 size_t existedMemorySize;

 uint8_t reserved[16];

} SceSaveDataMemorySetupResult;




typedef struct SceSaveDataMemoryGet2
{
 SceUserServiceUserId userId;

 uint8_t padding[4];

 SceSaveDataMemoryData *data;

 SceSaveDataParam *param;

 SceSaveDataIcon *icon;

 uint32_t slotId;

 uint8_t reserved[28];

} SceSaveDataMemoryGet2;




typedef struct SceSaveDataMemorySet2
{
 SceUserServiceUserId userId;

 uint8_t padding[4];

 const SceSaveDataMemoryData *data;

 const SceSaveDataParam *param;

 const SceSaveDataIcon *icon;

 uint32_t dataNum;

 uint32_t slotId;

 uint8_t reserved[24];

} SceSaveDataMemorySet2;




typedef struct _SceSaveDataEventParam SceSaveDataEventParam;




typedef struct SceSaveDataEvent {
 SceSaveDataEventType type;

 int32_t errorCode;

 SceUserServiceUserId userId;

 uint8_t padding[4];

 SceSaveDataTitleId titleId;

 SceSaveDataDirName dirName;

 uint8_t reserved[40];

} SceSaveDataEvent;
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_legacy.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_api.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_api.h" 3
extern "C" {
# 22 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data/save_data_api.h" 3
int32_t sceSaveDataInitialize3(const SceSaveDataInitParams3 *initParam);



int32_t sceSaveDataTerminate();



int32_t sceSaveDataMount2(const SceSaveDataMount2 *mount, SceSaveDataMountResult *mountResult);



int32_t sceSaveDataTransferringMount(const SceSaveDataTransferringMount *mount, SceSaveDataMountResult *mountResult);



int32_t sceSaveDataUmount(const SceSaveDataMountPoint *mountPoint);



int32_t sceSaveDataUmountWithBackup(const SceSaveDataMountPoint *mountPoint);



int32_t sceSaveDataGetMountInfo(const SceSaveDataMountPoint *mountPoint,
        SceSaveDataMountInfo *info);



int32_t sceSaveDataDelete(const SceSaveDataDelete *del);



int32_t sceSaveDataDirNameSearch(const SceSaveDataDirNameSearchCond *cond,
         SceSaveDataDirNameSearchResult *result);



int32_t sceSaveDataSetParam(const SceSaveDataMountPoint *mountPoint,
       SceSaveDataParamType paramType,
       const void *paramBuf, size_t paramBufSize);



int32_t sceSaveDataGetParam(const SceSaveDataMountPoint *mountPoint,
       SceSaveDataParamType paramType,
       void *paramBuf, size_t paramBufSize, size_t *gotSize);



int32_t sceSaveDataSaveIcon(const SceSaveDataMountPoint *mountPoint,
       const SceSaveDataIcon *icon);



int32_t sceSaveDataLoadIcon(const SceSaveDataMountPoint *mountPoint,
       SceSaveDataIcon *icon);



int32_t sceSaveDataSyncSaveDataMemory(const SceSaveDataMemorySync *syncParam);



int32_t sceSaveDataSetupSaveDataMemory2(const SceSaveDataMemorySetup2 *setupParam, SceSaveDataMemorySetupResult *result);



int32_t sceSaveDataGetSaveDataMemory2(SceSaveDataMemoryGet2 *getParam);



int32_t sceSaveDataSetSaveDataMemory2(const SceSaveDataMemorySet2 *setParam);



int32_t sceSaveDataRestoreBackupData(const SceSaveDataRestoreBackupData *restore);



int32_t sceSaveDataCheckBackupData(const SceSaveDataCheckBackupData *check);



int32_t sceSaveDataBackup(const SceSaveDataBackup *backup);



int32_t sceSaveDataGetProgress(float *progress);



int32_t sceSaveDataClearProgress(void);



int32_t sceSaveDataGetEventResult(const SceSaveDataEventParam *eventParam, SceSaveDataEvent *event);



}
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data.h" 2 3
# 11 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\common_dialog/common_api.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\common_dialog/common_api.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sdk_version.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\common_dialog/common_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\string.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\string.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\string.h" 2 3






# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\strings.h" 1 3
# 41 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\strings.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 42 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\strings.h" 2 3
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\strings.h" 3
extern "C" {

int bcmp(const void *, const void *, size_t) __attribute__((__pure__));
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);

}
# 56 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\string.h" 2 3
# 65 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\string.h" 3
extern "C" {
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
int strcmp(const char *, const char *);
char *strcpy(char *, const char *);
size_t strlen(const char *);

void *memmove(void *, const void *, size_t);
int strcoll(const char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int);
int strerror_r(int, char *, size_t);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
size_t strspn(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);


char *strdup(const char *);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
char *strtok_r(char *, const char *, char **);


}





extern "C" {
const char *strchr(const char *, int);
const char *strpbrk(const char *, const char *);
const char *strrchr(const char *, int);
const char *strstr(const char *, const char *);
}

extern "C++" {
inline char *strchr(char *_Str, int _Ch)
 {
 return ((char *):: strchr((const char *)_Str, _Ch));
 }

inline char *strpbrk(char *_Str1, const char *_Str2)
 {
 return ((char *):: strpbrk((const char *)_Str1, _Str2));
 }

inline char *strrchr(char *_Str, int _Ch)
 {
 return ((char *):: strrchr((const char *)_Str, _Ch));
 }

inline char *strstr(char *_Str1, const char *_Str2)
 {
 return ((char *):: strstr((const char *)_Str1, _Str2));
 }
}
# 143 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\string.h" 3
extern "C" {
const void *memchr(const void *, int, size_t);
}

extern "C++" {
inline void *memchr(void *_Str, int _Ch, size_t _Num)
 {
 return ((void *):: memchr((const void *)_Str, _Ch, _Num));
 }
}
# 163 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\string.h" 3
extern "C" {

errno_t memcpy_s(void *, rsize_t,
 const void *, rsize_t);
errno_t memmove_s(void *, rsize_t,
 const void *, rsize_t);
errno_t memset_s(void *, rsize_t, int, rsize_t);

errno_t strcpy_s(char *, rsize_t,
 const char *);
errno_t strncpy_s(char *, rsize_t,
 const char *, rsize_t);
errno_t strcat_s(char *, rsize_t,
 const char *);
errno_t strncat_s(char *, rsize_t,
 const char *, rsize_t);
char *strtok_s(char *, rsize_t *,
 const char *, char **);

errno_t strerror_s(char *, rsize_t, errno_t);
size_t strerrorlen_s(errno_t);

size_t strnlen_s(const char *, size_t);
}



extern "C++" {

template<rsize_t _Size>
errno_t strcat_s(char (&_Str1)[_Size], const char *_Str2)
 {
 return strcat_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t strcpy_s(char (&_Str1)[_Size], const char *_Str2)
 {
 return strcpy_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t strerror_s(char (&_Str)[_Size], errno_t _Errcode)
 {
 return strerror_s(_Str, _Size, _Errcode);
 }

template<rsize_t _Size>
errno_t strncat_s(char (&_Str1)[_Size], const char *_Str2, rsize_t _Num)
 {
 return strncat_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t strncpy_s(char (&_Str1)[_Size], const char *_Str2, rsize_t _Num)
 {
 return strncpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t memcpy_s(char (&_Dst)[_Size], const char *_Src, rsize_t _Num)
 {
 return memcpy_s(_Dst, _Size, _Src, _Num);
 }

template<rsize_t _Size>
errno_t memmove_s(char (&_Dst)[_Size], const char *_Src, rsize_t _Num)
 {
 return memmove_s(_Dst, _Size, _Src, _Num);
 }

template<size_t _Size>
size_t strnlen_s(const char (&_Str)[_Size])
 {
 return strnlen_s(_Str, _Size);
 }

}
# 292 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\string.h" 3
extern "C" {

size_t strlcat(char * __restrict, const char * __restrict, size_t);
size_t strlcpy(char * __restrict, const char * __restrict, size_t);


char *strndup(const char *, size_t) __attribute__((__malloc__));
size_t strnlen(const char *, size_t) __attribute__((__pure__));


char *strnstr(const char *, const char *, size_t) __attribute__((__pure__));

}
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\common_dialog/common_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\common_dialog/types.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\common_dialog/types.h" 3
typedef enum SceCommonDialogStatus {
 SCE_COMMON_DIALOG_STATUS_NONE = 0,
 SCE_COMMON_DIALOG_STATUS_INITIALIZED = 1,
 SCE_COMMON_DIALOG_STATUS_RUNNING = 2,
 SCE_COMMON_DIALOG_STATUS_FINISHED = 3
} SceCommonDialogStatus;

typedef enum SceCommonDialogResult {
 SCE_COMMON_DIALOG_RESULT_OK = 0,
 SCE_COMMON_DIALOG_RESULT_USER_CANCELED = 1,
} SceCommonDialogResult;

typedef struct SceCommonDialogBaseParam {
 size_t size;
 uint8_t reserved[36];
 uint32_t magic;
} SceCommonDialogBaseParam __attribute__ ((__aligned__(8)));
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\common_dialog/common_api.h" 2 3


extern "C" {


int32_t sceCommonDialogInitialize();
bool sceCommonDialogIsUsed();

static inline
void _sceCommonDialogSetMagicNumber( uint32_t* magic, const SceCommonDialogBaseParam* param )
{
 *magic = (uint32_t)( 0xC0D1A109 + (uint64_t)param );
}

static inline
void _sceCommonDialogBaseParamInit(SceCommonDialogBaseParam *param)
{
 memset(param, 0x0, sizeof(SceCommonDialogBaseParam));
 param->size = (uint32_t)sizeof(SceCommonDialogBaseParam);
 _sceCommonDialogSetMagicNumber( &(param->magic), param );
}


}
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\common_dialog/error.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 2 3







extern "C" {
# 38 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
 typedef int32_t SceSaveDataDialogMode;
# 50 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogType;







typedef int32_t SceSaveDataDialogFocusPos;
# 69 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogSystemMessageType;
# 87 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogWizardOption;
# 96 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogButtonType;
# 105 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogButtonId;
# 114 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogOptionBack;






typedef int32_t SceSaveDataDialogOptionFlag;





typedef int32_t SceSaveDataDialogProgressBarType;




typedef int32_t SceSaveDataDialogProgressBarTarget;





typedef int32_t SceSaveDataDialogItemStyle;







typedef int32_t SceSaveDataDialogAnimation;






typedef int32_t SceSaveDataDialogUserMessageType;






typedef int32_t SceSaveDataDialogProgressSystemMessageType;
# 172 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\save_data_dialog.h" 3
typedef struct SceSaveDataDialogAnimationParam {
 SceSaveDataDialogAnimation userOK;

 SceSaveDataDialogAnimation userCancel;

 uint8_t reserved[32];

} SceSaveDataDialogAnimationParam;




typedef struct SceSaveDataDialogNewItem {
 const char *title;

 void *iconBuf;

 size_t iconSize;

 uint8_t reserved[32];

} SceSaveDataDialogNewItem;




typedef struct SceSaveDataDialogItems {
 SceUserServiceUserId userId;

 int32_t : 32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 uint32_t dirNameNum;

 int32_t : 32;

 const SceSaveDataDialogNewItem *newItem;

 SceSaveDataDialogFocusPos focusPos;

 int32_t : 32;

 const SceSaveDataDirName *focusPosDirName;


 SceSaveDataDialogItemStyle itemStyle;


 uint8_t reserved[36];

} SceSaveDataDialogItems;




typedef struct SceSaveDataDialogUserMessageParam {
 SceSaveDataDialogButtonType buttonType;

 SceSaveDataDialogUserMessageType msgType;

 const char *msg;

 uint8_t reserved[32];

} SceSaveDataDialogUserMessageParam;




typedef struct SceSaveDataDialogSystemMessageParam {
 SceSaveDataDialogSystemMessageType sysMsgType;

 int32_t : 32;

 uint64_t value;

 uint8_t reserved[32];

} SceSaveDataDialogSystemMessageParam;




typedef struct SceSaveDataDialogErrorCodeParam {
 int32_t errorCode;

 uint8_t reserved[32];

} SceSaveDataDialogErrorCodeParam;




typedef struct SceSaveDataDialogProgressBarParam {
 SceSaveDataDialogProgressBarType barType;

 int32_t : 32;

 const char *msg;

 SceSaveDataDialogProgressSystemMessageType sysMsgType;

 uint8_t reserved[28];

} SceSaveDataDialogProgressBarParam;



typedef struct SceSaveDataDialogWizardParam {

 SceSaveDataDialogWizardOption option;


 int32_t reserved1;


 const SceSaveDataFingerprint *fingerprint;


 uint8_t reserved2[32];

} SceSaveDataDialogWizardParam;



typedef struct SceSaveDataDialogOptionParam {
 SceSaveDataDialogOptionBack back;

 SceSaveDataDialogOptionFlag flag;

 uint8_t reserved[28];

} SceSaveDataDialogOptionParam;




typedef struct SceSaveDataDialogParam {
 SceCommonDialogBaseParam baseParam;

 int32_t size;


 SceSaveDataDialogMode mode;

 SceSaveDataDialogType dispType;

 int32_t : 32;

 SceSaveDataDialogAnimationParam *animParam;

 SceSaveDataDialogItems *items;


 SceSaveDataDialogUserMessageParam *userMsgParam;

 SceSaveDataDialogSystemMessageParam *sysMsgParam;

 SceSaveDataDialogErrorCodeParam *errorCodeParam;

 SceSaveDataDialogProgressBarParam *progBarParam;


 void *userData;


 SceSaveDataDialogOptionParam *optionParam;


 SceSaveDataDialogWizardParam *wizardParam;


 uint8_t reserved[16];

} SceSaveDataDialogParam;




typedef struct SceSaveDataDialogCloseParam {
 SceSaveDataDialogAnimation anim;

 uint8_t reserved[32];

} SceSaveDataDialogCloseParam;




typedef struct SceSaveDataDialogResult {
 SceSaveDataDialogMode mode;

 int32_t result;

 SceSaveDataDialogButtonId buttonId;

 int32_t : 32;

 SceSaveDataDirName *dirName;


 SceSaveDataParam *param;


 void *userData;

 uint8_t reserved[32];

} SceSaveDataDialogResult;






static inline
void sceSaveDataDialogParamInitialize( SceSaveDataDialogParam *param )
{
 memset(param, 0x0, sizeof(SceSaveDataDialogParam));

 _sceCommonDialogBaseParamInit(&param->baseParam);
 param->size = sizeof(SceSaveDataDialogParam);
}



int32_t sceSaveDataDialogInitialize();



int32_t sceSaveDataDialogTerminate( void );



SceCommonDialogStatus sceSaveDataDialogUpdateStatus(void);



SceCommonDialogStatus sceSaveDataDialogGetStatus(void);



int32_t sceSaveDataDialogGetResult(SceSaveDataDialogResult* result);



int32_t sceSaveDataDialogOpen(const SceSaveDataDialogParam *param);



int32_t sceSaveDataDialogClose(const SceSaveDataDialogCloseParam *closeParam);



int32_t sceSaveDataDialogProgressBarInc(SceSaveDataDialogProgressBarTarget target,
          uint32_t delta);



int32_t sceSaveDataDialogProgressBarSetValue(SceSaveDataDialogProgressBarTarget target,
            uint32_t rate);



int32_t sceSaveDataDialogIsReadyToDisplay();




}
# 12 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2




# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginUnity.h" 1
# 12 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginUnity.h"
class IPluginUnity
{
public:
 virtual ~IPluginUnity() {}


 virtual int UnityIntVersion() const = 0;


 virtual const char* UnityVersion() const = 0;


 virtual bool IsDevelopmentBuild() const = 0;


 virtual bool IsDebugBuild() const = 0;
};
# 17 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginSceAppParams.h" 1
# 13 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginSceAppParams.h"
class IPluginSceAppParams
{
public:
 virtual ~IPluginSceAppParams() {}


 virtual bool IsTrialApp() const = 0;


 virtual const char* ServiceID() const = 0;


 virtual const char* TitleID() const = 0;
};
# 18 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginSceNpParams.h" 1
# 12 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginSceNpParams.h"
class IPluginSceNpParams
{
public:
 virtual ~IPluginSceNpParams() {}


 virtual const void* NpCommunicationsID() const = 0;


 virtual const void* NpCommunicationsSignature() const = 0;


 virtual const void* NpCommunicationsPassphrase() const = 0;


 virtual const char* NpServiceID() const = 0;


 virtual int NpAgeRating() const = 0;


 virtual bool NpHasTrophyPack() const = 0;


 virtual const void* NpTitleSecret() const = 0;


 virtual int NpPushNotifications() const = 0;
};
# 19 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/SonyCommonIncludes.h" 1
# 21 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2


# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/ManagedRequest.h" 1



# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/../Includes/CommonTypes.h" 1



typedef unsigned char UInt8;
typedef unsigned short UInt16;
typedef unsigned int UInt32;
typedef unsigned long long UInt64;
typedef char Int8;
typedef short Int16;
typedef int Int32;
typedef long long Int64;

typedef void (*ManagedEventCallback)();
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/ManagedRequest.h" 2

namespace SaveData
{

 class RequestBaseManaged
 {
 public:
  UInt32 functionType;
  Int32 userId;
  bool async;
  bool locked;
  bool ignoreCallback;
  UInt32 padding;
 };

}
# 24 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/ManagedResponse.h" 1



# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/../ErrorHandling/Errors.h" 1





namespace SaveData
{

 const char* LookupSceErrorCode(int errorCode);

 enum APIResultTypes
 {
  Success = 0,
  Warning = 1,
  Error = 2,
 };

 struct APIResult
 {
 public:
  APIResultTypes apiResult;
  char const * message;
  char const * filename;
  Int32 lineNumber;
  Int32 sceErrorCode;

  static void SetResult(APIResult* result, APIResultTypes type);
  static void SetResult(APIResult* result, APIResultTypes type, char const * message, char const * filename, Int32 lineNumber);
  static void SetSceResult(APIResult* result, APIResultTypes type, Int32 sceErrorCode, char const * filename, Int32 lineNumber);
 };
}
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/ManagedResponse.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/../Managed/MemoryBufferManaged.h" 1





# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdexcept" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdexcept" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstddef" 1 3
# 27 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstddef" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 28 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstddef" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stddef.h" 1 3
# 36 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstddef" 2 3



namespace std {
using :: ptrdiff_t;
using :: size_t;
using :: max_align_t;
}




namespace std {

template<class _Ty,
 _Ty _Val>
 struct integral_constant
 {
 static constexpr _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant<_Ty, _Val> type;

 constexpr operator value_type() const noexcept
  {
  return (value);
  }


 constexpr value_type operator()() const noexcept
  {
  return (value);
  }

 };


template<class _Ty,
 _Ty _Val>
 constexpr _Ty integral_constant<_Ty, _Val>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;


template<bool _Val>
        struct _Cat_base
  : integral_constant<bool, _Val>
 {
 };


template<class _Ty>
 struct remove_const
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty[]>
 {
 typedef _Ty type[];
 };

template<class _Ty, size_t _Nx>
 struct remove_const<const _Ty[_Nx]>
 {
 typedef _Ty type[_Nx];
 };


template<class _Ty>
 struct remove_volatile
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty[]>
 {
 typedef _Ty type[];
 };

template<class _Ty, size_t _Nx>
 struct remove_volatile<volatile _Ty[_Nx]>
 {
 typedef _Ty type[_Nx];
 };


template<class _Ty>
 struct remove_cv
 {
 typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
  type;
 };



template<class _Ty>
 struct is_integral
  : _Cat_base<__is_integral(_Ty)>
 {
 };
# 261 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstddef" 3
template<bool _Test,
 class _Ty = void>
 struct enable_if
 {
 };

template<class _Ty>
 struct enable_if<true, _Ty>
 {
 typedef _Ty type;
 };

template<bool _Test,
 class _Ty = void>
 using enable_if_t = typename enable_if<_Test, _Ty>::type;

using nullptr_t = decltype(nullptr);
# 363 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstddef" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdlib" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdlib" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdlib" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 2 3





# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_malloc.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_malloc.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stddef.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_malloc.h" 2 3

extern "C" {



typedef struct SceLibcMallocManagedSize {
  unsigned short size;
  unsigned short version;
  unsigned int reserved1;
  size_t maxSystemSize;
  size_t currentSystemSize;
  size_t maxInuseSize;
  size_t currentInuseSize;
} SceLibcMallocManagedSize;


}
# 50 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 2 3
# 79 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
typedef struct
 {
 int quot;
 int rem;
 } div_t;


extern "C" {
void exit(int) __attribute__((__noreturn__));

void _Exit(int) noexcept __attribute__((__noreturn__));
}

extern "C" {
int abs(int);
long labs(long);





void abort(void) noexcept __attribute__((__noreturn__));
void *calloc(size_t, size_t);
void *malloc(size_t);

void *(memalign)(size_t boundary, size_t size_arg);

void free(void *);
void *realloc(void *, size_t);

void *aligned_alloc(size_t, size_t);


div_t div(int, int);
ldiv_t ldiv(long, long);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t *,
 const char *, size_t);
int mbtowc(wchar_t *, const char *, size_t);
int rand(void);
void srand(unsigned int);
long strtol(const char *, char **, int);
size_t wcstombs(char *,
 const wchar_t *, size_t);
int wctomb(char *, wchar_t);


void *reallocalign(void *ptr, size_t size, size_t boundary);
size_t malloc_usable_size(void *ptr);
int malloc_stats(SceLibcMallocManagedSize *);
int malloc_stats_fast(SceLibcMallocManagedSize *);



void lcong48(unsigned short [7]);
unsigned short *seed48(unsigned short [3]);
void srand48(long);

double drand48(void);
long lrand48(void);
long mrand48(void);

double erand48(unsigned short [3]);
long nrand48(unsigned short [3]);
long jrand48(unsigned short [3]);

int getopt(int, char *const *, const char *);
void *memalign(size_t, size_t);
int rand_r(unsigned *);

extern char *optarg;
extern int optind, opterr, optopt;



extern "C" {
extern float _Stofx(const char *, char **,
 long, int *);
extern double _Stodx(const char *, char **,
 long, int *);
extern long double _Stoldx(const char *, char **,
 long, int *);
extern long _Stolx(const char *, char **,
 int, int *);
extern unsigned long _Stoulx(const char *, char **,
 int, int *);
extern long long _Stollx(const char *, char **,
 int, int *);
extern unsigned long long _Stoullx(const char *, char **,
 int, int *);
}


unsigned long _Stoul(const char *, char **, int);
float _Stof(const char *, char **, long);
double _Stod(const char *, char **, long);
long double _Stold(const char *, char **, long);
_Longlong _Stoll(const char *, char **, int);
_ULonglong _Stoull(const char *, char **, int);

float _Stofx(const char *, char **, long, int *);
double _Stodx(const char *, char **, long, int *);
long double _Stoldx(const char *, char **, long, int *);
long _Stolx(const char *, char **, int, int *);
unsigned long _Stoulx(const char *, char **, int, int *);
_Longlong _Stollx(const char *, char **, int, int *);
_ULonglong _Stoullx(const char *, char **, int, int *);

size_t _Getmbcurmax(void);


_Longlong llabs(_Longlong);
lldiv_t lldiv(_Longlong, _Longlong);
_Longlong strtoll(const char *,
 char **, int);
_ULonglong strtoull(const char *,
 char **, int);


int at_quick_exit(void (*)(void)) noexcept;
void quick_exit(int) noexcept __attribute__((__noreturn__));


int getargc(void);
char **getargv(void);


}


extern "C" {
typedef void _Atexfun(void);
typedef int _Cmpfun(const void *, const void *);

int atexit(void (*)(void)) noexcept;
void *bsearch(const void *, const void *,
 size_t, size_t, _Cmpfun *);
void qsort(void *, size_t, size_t, _Cmpfun *);

}

extern "C++" {
# 248 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
extern "C" {

double atof(const char *_Str);

inline int atoi(const char *_Str)
 {
 return ((int)_Stoul(_Str, 0, 10));
 }

inline long atol(const char *_Str)
 {
 return ((long)_Stoul(_Str, 0, 10));
 }
# 269 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
double strtod(const char * _Str,
 char ** _Endptr);

inline unsigned long strtoul(const char * _Str,
 char ** _Endptr, int _Base)
 {
 return (_Stoul(_Str, _Endptr, _Base));
 }



inline _Longlong atoll(const char *_Str)
 {
 return ((_Longlong)_Stoull(_Str, 0, 10));
 }

float strtof(const char * _Str,
 char ** _Endptr);

inline long double strtold(const char * _Str,
 char ** _Endptr)
 {
 return (_Stold(_Str, _Endptr, 0));
 }


}

}
# 338 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
extern "C" {


int (_Fail_s)(const char *, size_t);

typedef void (*constraint_handler_t)(const char *,
 void *, errno_t);

constraint_handler_t set_constraint_handler_s(
 constraint_handler_t);
void abort_handler_s(const char *,
 void *, errno_t);
void ignore_handler_s(const char *,
 void *, errno_t);

}


extern "C" {
typedef int _Cmpfun_s(const void *, const void *, void *);

void *bsearch_s(const void *, const void *,
 rsize_t, rsize_t, _Cmpfun_s *, void *);
errno_t qsort_s(void *,
 rsize_t, rsize_t, _Cmpfun_s *, void *);
}

extern "C++" {
# 382 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
}
# 395 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
extern "C" {
errno_t wctomb_s(int *,
 char *, rsize_t,
 wchar_t);
errno_t mbstowcs_s(size_t *,
 wchar_t *, rsize_t,
 const char *, rsize_t);
errno_t wcstombs_s(size_t *,
 char *, rsize_t,
 const wchar_t *, rsize_t);
}



extern "C++" {

template<rsize_t _Size>
errno_t mbstowcs_s(size_t *_Psize, wchar_t (&_Wcs)[_Size], const char *_Str, rsize_t _Num)
 {
 return mbstowcs_s(_Psize, _Wcs, _Size, _Str, _Num);
 }

template<rsize_t _Size>
errno_t wcstombs_s(size_t *_Psize, char (&_Str)[_Size], const wchar_t *_Wcs, rsize_t _Num)
 {
 return wcstombs_s(_Psize, _Str, _Size, _Wcs, _Num);
 }

template<rsize_t _Size>
errno_t wctomb_s(int *_Pstat, char (&_Str)[_Size], wchar_t _Wc)
 {
 return wctomb_s(_Pstat, _Str, _Size, _Wc);
 }

}
# 440 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
extern "C" {

extern size_t sceLibcHeapSize;
extern unsigned int sceLibcHeapDelayedAlloc;
extern unsigned int sceLibcHeapExtendedAlloc;
extern size_t sceLibcHeapInitialSize;
extern size_t sceLibcHeapHighAddressAlloc;
extern unsigned int sceLibcHeapMemoryLock;
extern unsigned int sceLibcHeapDebugFlags;

}
# 543 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
extern "C" {






int posix_memalign(void **, size_t, size_t);
# 572 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 3
}
# 19 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdlib" 2 3



namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;

using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;
# 66 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdlib" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\initializer_list" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\initializer_list" 3
namespace std {

template<class _Elem>
 class initializer_list
 {
public:
 typedef _Elem value_type;
 typedef const _Elem& reference;
 typedef const _Elem& const_reference;
 typedef size_t size_type;

 typedef const _Elem *iterator;
 typedef const _Elem *const_iterator;

 constexpr initializer_list() noexcept
  : _First(0), _Last(0)
  {
  }

 constexpr initializer_list(const _Elem *_First_arg,
  const _Elem *_Last_arg) noexcept
  : _First(_First_arg), _Last(_Last_arg)
  {
  }

 constexpr initializer_list(const _Elem *_First_arg, size_t _Size_arg)
  : _First(_First_arg), _Last(_First_arg + _Size_arg)
  {
  }

 constexpr const _Elem *begin() const noexcept
  {
  return (_First);
  }

 constexpr const _Elem *end() const noexcept
  {
  return (_Last);
  }

 constexpr size_t size() const noexcept
  {
  return ((size_t)(_Last - _First));
  }

private:
 const _Elem *_First;
 const _Elem *_Last;
 };
}
namespace std {

template<class _Elem> inline
 constexpr const _Elem *begin(
  ::std:: initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.begin());
 }


template<class _Elem> inline
 constexpr const _Elem *end(
  ::std:: initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.end());
 }
}
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtr1common" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtr1common" 3
namespace std {

struct _Nil
 {
 };
# 26 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtr1common" 3
template<bool _Test,
 class _Ty1,
 class _Ty2>
 struct conditional
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct conditional<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };


template<class _Ty1,
 class _Ty2>
 struct is_same
  : false_type
 {
 };

template<class _Ty1>
 struct is_same<_Ty1, _Ty1>
  : true_type
 {
 };



template<class _Ty>
 struct is_floating_point
  : _Cat_base<__is_floating_point(_Ty)>
 {
 };
# 96 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtr1common" 3
template<class _Ty>
 struct is_arithmetic
  : _Cat_base<is_integral<_Ty>::value
   || is_floating_point<_Ty>::value>
 {
 };


template<class _Ty>
 struct remove_reference
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 using remove_reference_t = typename remove_reference<_Ty>::type;


struct _Wrap_int
 {
 _Wrap_int(int)
  {
  }
 };

template<class _Ty>
 struct _Identity
 {
 typedef _Ty type;
 };
# 152 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtr1common" 3
}
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 2 3
# 30 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
namespace std {
# 117 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
template<bool,
 class _Ty1,
 class _Ty2>
 struct _If
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct _If<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };

template<class _Ty>
 struct _Always_false
  : false_type
 {
 };
# 156 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
template<class _Arg,
 class _Result>
 struct unary_function
 {
 typedef _Arg argument_type;
 typedef _Result result_type;
 };


template<class _Arg1,
 class _Arg2,
 class _Result>
 struct binary_function
 {
 typedef _Arg1 first_argument_type;
 typedef _Arg2 second_argument_type;
 typedef _Result result_type;
 };


template<class _Ty = void>
 struct plus
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left + _Right);
  }
 };


template<class _Ty = void>
 struct minus
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left - _Right);
  }
 };


template<class _Ty = void>
 struct multiplies
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left * _Right);
  }
 };


template<class _Ty = void>
 struct equal_to
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef bool result_type ;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left == _Right);
  }
 };


template<class _Ty = void>
 struct less
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef bool result_type ;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left < _Right);
  }
 };



typedef int _Is_trans;


template<>
 struct plus<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct minus<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct multiplies<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct equal_to<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct less<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right));
  }
 };





}



namespace std {

__attribute__((no_sanitize("unsigned-integer-overflow")))
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
 {

 static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
 const size_t _FNV_offset_basis = 14695981039346656037ULL;
 const size_t _FNV_prime = 1099511628211ULL;







 size_t _Val = _FNV_offset_basis;
 for (size_t _Next = 0; _Next < _Count; ++_Next)
  {
  _Val ^= (size_t)_First[_Next];
  _Val *= _FNV_prime;
  }
 return (_Val);
 }


template<class _Kty>
 struct _Bitwise_hash
 {
 typedef _Kty argument_type ;
 typedef size_t result_type ;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
  }
 };

template<class _Kty, bool = __is_enum(_Kty)>
 struct _Enum_hash : _Bitwise_hash<_Kty>
 {
 };

template<class _Kty>
 struct _Enum_hash<_Kty, false>
 {
 _Enum_hash() = delete;
 _Enum_hash(const _Enum_hash&) = delete;
 _Enum_hash& operator=(const _Enum_hash&) = delete;
 };



template<class _Kty>
 struct hash
  : public _Enum_hash<_Kty>
 {
 };





template<>
 struct hash<bool>
  : public _Bitwise_hash<bool>
 {
 };

template<>
 struct hash<char>
  : public _Bitwise_hash<char>
 {
 };

template<>
 struct hash<signed char>
  : public _Bitwise_hash<signed char>
 {
 };

template<>
 struct hash<unsigned char>
  : public _Bitwise_hash<unsigned char>
 {
 };

template<>
 struct hash<char16_t>
  : public _Bitwise_hash<char16_t>
 {
 };

template<>
 struct hash<char32_t>
  : public _Bitwise_hash<char32_t>
 {
 };

template<>
 struct hash<wchar_t>
  : public _Bitwise_hash<wchar_t>
 {
 };

template<>
 struct hash<short>
  : public _Bitwise_hash<short>
 {
 };

template<>
 struct hash<unsigned short>
  : public _Bitwise_hash<unsigned short>
 {
 };

template<>
 struct hash<int>
  : public _Bitwise_hash<int>
 {
 };

template<>
 struct hash<unsigned int>
  : public _Bitwise_hash<unsigned int>
 {
 };

template<>
 struct hash<long>
  : public _Bitwise_hash<long>
 {
 };

template<>
 struct hash<unsigned long>
  : public _Bitwise_hash<unsigned long>
 {
 };

template<>
 struct hash<long long>
  : public _Bitwise_hash<long long>
 {
 };

template<>
 struct hash<unsigned long long>
  : public _Bitwise_hash<unsigned long long>
 {
 };

template<>
 struct hash<float>
  : public _Bitwise_hash<float>
 {
 typedef float _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<double>
  : public _Bitwise_hash<double>
 {
 typedef double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<long double>
  : public _Bitwise_hash<long double>
 {
 typedef long double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  _Kty _Temp = _Keyval == 0 ? 0 : _Keyval;


  unsigned char *_Pyt = (unsigned char *)&_Temp;
  for (size_t _Idx = 10; _Idx < sizeof (long double); ++_Idx)
   _Pyt[_Idx] = 0;


  return (_Mybase::operator()(_Temp));
  }
 };

template<class _Ty>
 struct hash<_Ty *>
  : public _Bitwise_hash<_Ty *>
 {
 };

template<>
 struct hash<nullptr_t>
 {
 using result_type = size_t;
 using argument_type = nullptr_t;

 size_t operator()(nullptr_t) const
  {
  return size_t(0);
  }
 };

}
# 781 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
namespace std {

template<class... _Types>
 struct _Arg_types
 {
 };

template<class _Ty1>
 struct _Arg_types<_Ty1>
 {
 typedef _Ty1 argument_type ;
 };

template<class _Ty1,
 class _Ty2>
 struct _Arg_types<_Ty1, _Ty2>
 {
 typedef _Ty1 first_argument_type ;
 typedef _Ty2 second_argument_type ;
 };


template<class _Ty>
 struct _Is_function
 {
 typedef false_type _Bool_type;
 };
# 820 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };
# 832 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };
# 858 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
template<class _Ty>
 struct is_function
  : _Is_function<_Ty>::_Bool_type
 {
 };


template<class _Ty> inline
 _Ty *_Addressof(_Ty& _Val, true_type) noexcept
 {
 return (_Val);
 }


template<class _Ty> inline
 _Ty *_Addressof(_Ty& _Val, false_type) noexcept
 {
 return __builtin_addressof(_Val);
 }

template<class _Ty> inline
 _Ty *addressof(_Ty& _Val) noexcept
 {
 return (_Addressof(_Val, is_function<_Ty>()));
 }
# 899 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstddef" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 2 3

namespace std {

class exception;
typedef void (*_Prhand)(const exception&);
extern _Prhand _Raise_handler;
         void _Throw(const exception&);
# 84 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 3
class exception
 {
public:
 static _Prhand _Set_raise_handler(_Prhand _Pnew);

 exception() noexcept
  {
  }

 explicit exception(const char *) noexcept
  {
  }

 virtual ~exception() noexcept;


 virtual const char *what() const;
# 110 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 3
 void _Raise() const;

protected:
 virtual void _Doraise() const;

 };


class bad_exception
 : public exception
 {
public:
 bad_exception() noexcept
  {
  }


 virtual ~bad_exception() noexcept;
# 138 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 3
protected:
 virtual void _Doraise() const;

 };



typedef void (*terminate_handler)();
typedef void (*unexpected_handler )();


         terminate_handler get_terminate() noexcept;
         terminate_handler set_terminate(terminate_handler) noexcept;
                                   unexpected_handler get_unexpected() noexcept;
                                   unexpected_handler set_unexpected(unexpected_handler) noexcept;
                        bool uncaught_exception() noexcept;
# 162 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 3
         void terminate() noexcept __attribute__((__noreturn__));
                                   void unexpected() __attribute__((__noreturn__));
# 180 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 3
}

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xxexception" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xxexception" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 2 3
# 234 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
namespace std {

template<class _Ty>
 struct _Ptr_traits
 {
 };

template<class _Ty>
 struct _Ptr_traits<_Ty *>
 {
 static const bool _Is_const = false;
 static const bool _Is_volatile = false;
 };

template<class _Ty>
 struct _Ptr_traits<const _Ty *>
 {
 static const bool _Is_const = true;
 static const bool _Is_volatile = false;
 };

template<class _Ty>
 struct _Ptr_traits<volatile _Ty *>
 {
 static const bool _Is_const = false;
 static const bool _Is_volatile = true;
 };

template<class _Ty>
 struct _Ptr_traits<const volatile _Ty *>
 {
 static const bool _Is_const = true;
 static const bool _Is_volatile = true;
 };

template<class _Ty>
 struct _Is_memfunptr
 {
 typedef false_type _Bool_type;
 };
# 287 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) & > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) && > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };
# 301 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };



template<class _Ty>
 struct _Has_cv_ref_qual
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) &>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) &&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const&&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile&&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile&&>
  : true_type
 {
 };


template<class _Ty>
 struct add_const
 {
 typedef const _Ty type;
 };


template<class _Ty>
 struct add_volatile
 {
 typedef volatile _Ty type;
 };


template<class _Ty>
 struct add_cv
 {
 typedef const volatile _Ty type;
 };


template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_lvalue_reference
 {
 typedef _Ty& type;
 };

template<class _Ty>
 struct _Do_add_lvalue_reference<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_lvalue_reference
  : _Do_add_lvalue_reference<_Ty,
   _Has_cv_ref_qual<_Ty>::value>
 {
 };
# 437 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<> struct add_lvalue_reference< void> { typedef void type; }; template<> struct add_lvalue_reference<const void> { typedef const void type; }; template<> struct add_lvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_lvalue_reference<const volatile void> { typedef const volatile void type; };



template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_rvalue_reference
 {
 typedef typename remove_reference<_Ty>::type&& type;
 };

template<class _Ty>
 struct _Do_add_rvalue_reference<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_rvalue_reference
  : _Do_add_rvalue_reference<_Ty,
   _Has_cv_ref_qual<_Ty>::value>
 {
 };

template<class _Ty>
 struct add_rvalue_reference<_Ty&>
 {
 typedef _Ty& type;
 };
# 474 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<> struct add_rvalue_reference< void> { typedef void type; }; template<> struct add_rvalue_reference<const void> { typedef const void type; }; template<> struct add_rvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_rvalue_reference<const volatile void> { typedef const volatile void type; };



template<class _Ty>
 typename add_rvalue_reference<_Ty>::type
  declval() noexcept;


template<class _Ty>
 struct remove_extent
 {
 typedef _Ty type;
 };

template<class _Ty,
 size_t _Ix>
 struct remove_extent<_Ty[_Ix]>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_extent<_Ty[]>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_all_extents
 {
 typedef _Ty type;
 };

template<class _Ty,
 size_t _Ix>
 struct remove_all_extents<_Ty[_Ix]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };

template<class _Ty>
 struct remove_all_extents<_Ty[]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };


template<class _Ty>
 struct remove_pointer
 {
 typedef _Ty type;
 };
# 536 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };



template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_pointer
 {
 typedef typename remove_reference<_Ty>::type *type;
 };

template<class _Ty>
 struct _Do_add_pointer<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_pointer
  : _Do_add_pointer<_Ty, _Has_cv_ref_qual<_Ty>::value>
 {
 };



template<class _Ty>
 struct _Is_void
  : false_type
 {
 };

template<>
 struct _Is_void<void>
  : true_type
 {
 };

template<class _Ty>
 struct is_void
  : _Is_void<typename remove_cv<_Ty>::type>
 {
 };


template<class _Ty>
 struct is_array
  : false_type
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_array<_Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_array<_Ty[]>
  : true_type
 {
 };


template<class _Ty>
 struct is_lvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_lvalue_reference<_Ty&>
  : true_type
 {
 };


template<class _Ty>
 struct is_rvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_rvalue_reference<_Ty&&>
  : true_type
 {
 };


template<class _Ty>
 struct is_reference
  : _Cat_base<is_lvalue_reference<_Ty>::value
  || is_rvalue_reference<_Ty>::value>
 {
 };


template<class _Ty,
 bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
 struct _Is_member_object_pointer
  : false_type
 {
 };

template<class _Ty1,
 class _Ty2>
 struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
  : true_type
 {
 typedef _Ty2 _Class_type;
 };

template<class _Ty>
 struct is_member_object_pointer
  : _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
 {
 };


template<class _Ty>
 struct is_member_function_pointer
  : _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
 {
 };


template<class _Ty>
 struct _Is_pointer
  : false_type
 {
 };

template<class _Ty>
 struct _Is_pointer<_Ty *>
  : _Cat_base<!is_member_object_pointer<_Ty *>::value
  && !is_member_function_pointer<_Ty *>::value>
 {
 };

template<class _Ty>
 struct is_pointer
  : _Is_pointer<typename remove_cv<_Ty>::type>
 {
 };



template<class _Ty>
 struct _Is_nullptr_t
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };
# 700 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 struct is_null_pointer
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };
# 716 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 struct is_union
  : _Cat_base<__is_union(_Ty)>
 {
 };


template<class _Ty>
 struct is_class
  : _Cat_base<__is_class(_Ty)>
 {
 };


template<class _Ty>
 struct is_fundamental
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_void<_Ty>::value
  || _Is_nullptr_t<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_object
  : _Cat_base<!is_function<_Ty>::value
  && !is_reference<_Ty>::value
  && !is_void<_Ty>::value>
 {
 };


template<class _Ty,
 bool = is_object<_Ty>::value || is_reference<_Ty>::value>
 struct _Is_referenceable
  : true_type
 {
 };

template<class _Ty>
 struct _Is_referenceable<_Ty, false>
  : false_type
 {
 };
# 769 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ret, class... _Types> struct _Is_referenceable<_Ret (_Types...) , false> : true_type { };
# 780 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ret, class... _Types> struct _Is_referenceable<_Ret (_Types..., ...) , false> : true_type { };
# 819 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _From,
 class _To>
 struct is_convertible


  : _Cat_base<is_void<typename remove_volatile<_From>::type>::value && is_void<typename remove_volatile<_To>::type>::value || __is_convertible_to(typename remove_volatile<_From>::type, typename remove_volatile<_To>::type)>






 {
 };
# 871 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 struct is_enum
  : _Cat_base<__is_enum(_Ty)>
 {
 };


template<class _Ty>
 struct is_compound
  : _Cat_base<!is_fundamental<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_member_pointer
  : _Cat_base<is_member_object_pointer<_Ty>::value
  || is_member_function_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_scalar
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_enum<_Ty>::value
  || is_pointer<_Ty>::value
  || is_member_pointer<_Ty>::value
  || _Is_nullptr_t<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_const
  : _Cat_base<_Ptr_traits<_Ty *>::_Is_const
  && !is_function<_Ty>::value>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_const<_Ty[_Nx]>
  : false_type
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_const<const _Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_const<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_const<_Ty&&>
  : false_type
 {
 };


template<class _Ty>
 struct is_volatile
  : _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
  && !is_function<_Ty>::value>
 {
 };

template<class _Ty>
 struct is_volatile<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_volatile<_Ty&&>
  : false_type
 {
 };


template<class _Ty1,
 class _Ty2>
 struct _Copy_cv
 {
 typedef conditional<is_const<_Ty1>::value,
  typename add_const<_Ty2>::type,
  _Ty2> _Tx;
 typedef conditional<is_volatile<_Ty1>::value,
  typename add_volatile<_Tx>::type,
  _Tx> type;
 };

template<class _Ty1,
 class _Ty2>
 using _Copy_cv_t = typename _Copy_cv<_Ty1, _Ty2>::type;

template<class _Ty1,
 class _Ty2>
 struct _Composite_ptr
 {
 typedef
  typename conditional<is_same<_Ty1 *, nullptr_t>::value,
   _Ty2 *,
  typename conditional<is_same<_Ty2 *, nullptr_t>::value,
   _Ty1 *,
  typename conditional<is_same<typename remove_cv<_Ty1>::type,
   void>::value,
   _Copy_cv_t<_Ty1, _Ty2> *,
   _Copy_cv_t<_Ty2, _Ty1> *
   >::type >::type >::type type;
 };

template<class _Ty1,
 class _Ty2>
 using _Composite_ptr_t = typename _Composite_ptr<_Ty1, _Ty2>::type;


template<class _Ty>
 struct _Is_pod
  : _Cat_base<is_scalar<_Ty>::value || __is_pod(_Ty)>
 {
 };

template<class _Ty>
 struct is_pod
  : _Is_pod<typename remove_all_extents<_Ty>::type>
 {
 };


template<class _Ty>
 struct is_empty
  : _Cat_base<__is_empty(_Ty)>
 {
 };


template<class _Ty>
 struct is_polymorphic
  : _Cat_base<__is_polymorphic(_Ty)>
 {
 };


template<class _Ty>
 struct is_abstract
  : _Cat_base<__is_abstract(_Ty)>
 {
 };


template<class _Ty>
 struct is_standard_layout : _Cat_base<__is_standard_layout(_Ty)>
 {
 };


template<class _Ty>
 struct is_literal_type
  : _Cat_base<__is_literal_type(_Ty)>
 {
 };


template<class _Ty>
 struct is_trivial
  : _Cat_base<__is_trivial(_Ty)>
 {
 };


template<class _Ty>
 struct has_virtual_destructor
  : _Cat_base<__has_virtual_destructor(_Ty)>
 {
 };



template<bool,
 class _Ty,
 class... _Types>
 struct _Is_constructible
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Is_constructible<true, _Ty, _Types...>
 {
 template<class _Uty>
  static auto _Fn(int)
   -> decltype((void)_Uty(::std:: declval<_Types>()...), true_type());
 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_Ty>(0)) type;
 };


template<class _Ty,
 class... _Types>
 struct is_constructible
  : _Cat_base<__is_constructible(_Ty, _Types...)>
 {
 };
# 1100 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<bool,
 class _Ty>
 struct _Is_cc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_cc<true, _Ty>
  : is_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct _Is_cc<true, _Ty&>
  : is_constructible<_Ty&, _Ty&>
 {
 };

template<class _Ty>
 struct is_copy_constructible
  : _Is_cc<!is_void<_Ty>::value && !is_array<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_default_constructible
  : is_constructible<_Ty>::type
 {
 };


template<bool,
 class _Ty>
 struct _Is_mc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_mc<true, _Ty>
  : is_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct _Is_mc<true, _Ty&>
  : is_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_move_constructible
  : _Is_mc<!is_void<_Ty>::value && !is_array<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _To,
 class _From>
 struct _Is_assignable
  : false_type
 {
 };

template<class _To,
 class _From>
 struct _Is_assignable<true, _To, _From>
 {
 template<class _Uty>
  static auto _Fn(int)
   -> decltype((void)(::std:: declval<_Uty>() = ::std:: declval<_From>()),
    true_type());

 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_To>(0)) type;
 };

template<class _To,
 class _From>
 struct is_assignable
  : _Is_assignable<
   is_object<typename remove_reference<_To>::type>::value
   && !is_array<typename remove_reference<_To>::type>::value
   && is_object<typename remove_reference<_From>::type>::value
   && !is_array<typename remove_reference<_From>::type>::value,
   _To, _From>::type

 {
 };


template<bool,
 class _Ty>
 struct _Is_ca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ca<false, _Ty>
  : is_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_copy_assignable
  : _Is_ca<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ma
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ma<false, _Ty>
  : is_assignable<_Ty&, _Ty&&>
 {
 };

template<class _Ty>
 struct is_move_assignable
  : _Is_ma<is_void<_Ty>::value, _Ty>
 {
 };







template<class _Ty, unsigned int _Nx>
 struct extent;

template<class _Ty>
 struct __is_array_unknown_bounds
  : public _Cat_base<__is_array(_Ty) && !extent<_Ty, 0>::value>
 {
 };

struct __is_destructible_concrete_sub
 {
 template<class _Uty>
  struct __w { _Uty __u; };

 template<class _Ty, class = decltype(declval<__w<_Ty>&>().~__w<_Ty>())>
  static true_type __test(int);

 template<class>
  static false_type __test(...);
 };

template<class _Ty>
 struct __is_destructible_concrete
  : public __is_destructible_concrete_sub
 {
 typedef decltype(__test<_Ty>(0)) type;
 };

struct __is_destructible_abstract_sub
 {
 template<class _Ty, class = decltype(declval<_Ty&>().~_Ty())>
  static true_type __test(int);

 template<class>
  static false_type __test(...);
 };

template<class _Ty>
 struct __is_destructible_abstract
  : public __is_destructible_abstract_sub
 {
 typedef decltype(__test<_Ty>(0)) type;
 };


template<class _Ty,
 bool __b1 = is_void<_Ty>::value || __is_array_unknown_bounds<_Ty>::value || is_function<_Ty>::value,
 bool __b2 = is_reference<_Ty>::value>
 struct __is_destructible_sub;







template<class _Ty>
 struct __is_destructible_sub<_Ty, false, false>
  : public _If<is_abstract<_Ty>::value,
   __is_destructible_abstract<_Ty>,
   __is_destructible_concrete<_Ty>>::type::type
 {
 };

template<class _Ty>
 struct __is_destructible_sub<_Ty, true, false>
  : public false_type
 {
 };

template<class _Ty>
 struct __is_destructible_sub<_Ty, false, true>
  : public true_type
 {
 };

template<class _Ty>
 struct is_destructible
  : _Cat_base<__is_destructible_sub<_Ty>::value>
 {
 };





template<class _Ty,
 class... _Types>
 struct is_trivially_constructible
  : _Cat_base<__is_trivially_constructible(_Ty, _Types...)>
 {
 };
# 1358 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<bool,
 class _Ty>
 struct _Is_tcc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tcc<false, _Ty>
  : is_trivially_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct is_trivially_copy_constructible
  : _Is_tcc<is_void<_Ty>::value || is_array<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_trivially_default_constructible
  : is_trivially_constructible<_Ty>::type
 {
 };


template<bool,
 class _Ty>
 struct _Is_tmc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tmc<false, _Ty>
  : is_trivially_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_trivially_move_constructible
  : _Is_tmc<is_void<_Ty>::value || is_array<_Ty>::value, _Ty>
 {
 };


template<class _To,
 class _From>
 struct is_trivially_assignable
  : _Cat_base<__is_trivially_assignable(_To, _From)>
 {
 };


template<bool,
 class _Ty>
 struct _Is_tca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tca<false, _Ty>
  : is_trivially_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_trivially_copy_assignable
  : _Is_tca<is_void<_Ty>::value
   || has_virtual_destructor<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_trivially_copyable
  : _Cat_base<__is_trivially_copyable(_Ty)>
 {
 };
# 1450 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 struct is_trivially_move_assignable
  : is_trivially_assignable<typename add_lvalue_reference< typename remove_volatile<_Ty>::type>::type, typename add_rvalue_reference< typename remove_volatile<_Ty>::type>::type>::type
 {
 };


template<class _Ty>
 struct is_trivially_destructible
  : _Cat_base<is_pod<_Ty>::value || __has_trivial_destructor(_Ty)>
 {
 };


template<bool,
 class _Ty,
 class... _Types>
 struct _Is_ntc
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Is_ntc<true, _Ty, _Types...>
  : _Cat_base<noexcept(_Ty(declval<_Types>()...))>
 {
 };

template<class _Ty,
 class _Type>
 struct _Is_ntc<true, _Ty, _Type>
  : _Cat_base<noexcept(static_cast<_Ty>(declval<_Type>()))>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct _Is_ntc<true, _Ty[_Nx]>
  : _Cat_base<noexcept(_Ty())>
 {
 };

template<class _Ty>
 struct _Is_ntc<true, _Ty>
  : _Cat_base<noexcept(_Ty())>
 {
 };
# 1511 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty,
 class... _Types>
 struct is_nothrow_constructible
  : _Is_ntc<is_constructible<_Ty, _Types...>::value,
   _Ty, _Types...>
 {
 };


template<class _Ty,
 size_t _Nx>
 struct is_nothrow_constructible<_Ty[_Nx]>
  : is_nothrow_constructible<_Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntcc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntcc<true, _Ty>
  : is_nothrow_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct _Is_ntcc<true, _Ty&>
  : is_nothrow_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct is_nothrow_copy_constructible
  : _Is_ntcc<!is_void<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_copy_constructible<_Ty[_Nx]>
  : false_type
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntdc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntdc<true, _Ty>
  : _Cat_base<noexcept(_Ty())>
 {
 };

template<class _Ty>
 struct is_nothrow_default_constructible
  : _Is_ntdc<is_default_constructible<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_default_constructible<_Ty[_Nx]>
  : is_nothrow_default_constructible<_Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntmc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntmc<true, _Ty>
  : is_nothrow_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct _Is_ntmc<true, _Ty&>
  : is_nothrow_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_nothrow_move_constructible
  : _Is_ntmc<!is_void<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_move_constructible<_Ty[_Nx]>
  : false_type
 {
 };


template<bool,
 class _To,
 class _From>
 struct _Is_nta
  : false_type
 {
 };

template<class _To,
 class _From>
 struct _Is_nta<true, _To, _From>
  : _Cat_base<





  noexcept(::std:: declval<_To>() = ::std:: declval<_From>())>
 {
 };

template<class _To,
 class _From>
 struct is_nothrow_assignable
  : _Is_nta<is_assignable<_To, _From>::value, _To, _From>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntca<false, _Ty>
  : is_nothrow_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_nothrow_copy_assignable
  : _Is_ntca<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntma
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntma<false, _Ty>
  : is_nothrow_assignable<_Ty&, _Ty&&>
 {
 };

template<class _Ty>
 struct is_nothrow_move_assignable
  : _Is_ntma<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntd
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntd<true, _Ty>
  : _Cat_base<noexcept(::std:: declval<_Ty>().~_Ty())>
 {
 };

template<class _Ty>
 struct is_nothrow_destructible
  : _Is_ntd<is_destructible<_Ty>::value, _Ty>
 {
 };

template<class _Ty, size_t _Nx>
 struct is_nothrow_destructible<_Ty[_Nx]>
  : is_nothrow_destructible<_Ty>
 {
 };

template<class _Ty>
 struct is_nothrow_destructible<_Ty&>
  : true_type
 {
 };



template<class _Ty>
 struct add_reference
 {
 typedef typename remove_reference<_Ty>::type& type;
 };
# 1736 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<> struct add_reference< void> { typedef void type; }; template<> struct add_reference<const void> { typedef const void type; }; template<> struct add_reference<volatile void> { typedef volatile void type; }; template<> struct add_reference<const volatile void> { typedef const volatile void type; };





template<class _Ty>
 struct has_copy_constructor
  : is_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_default_constructor
  : is_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_move_constructor
  : is_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_copy_assign
  : is_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_move_assign
  : is_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_copy_constructor
  : is_trivially_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_default_constructor
  : is_trivially_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_move_constructor
  : is_trivially_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_copy_assign
  : is_trivially_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_move_assign
  : is_trivially_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_copy_constructor
  : is_nothrow_copy_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_default_constructor
  : is_nothrow_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_move_constructor
  : is_nothrow_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_copy_assign
  : is_nothrow_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_move_assign
  : is_nothrow_move_assignable<_Ty>::type
 {
 };



template<class _Ty>
 struct has_trivial_constructor
  : _Cat_base<is_pod<_Ty>::value || !is_array<_Ty>::value && __has_trivial_constructor(_Ty)>
 {
 };


template<class _Ty>
 struct has_trivial_copy
  : _Cat_base<!is_array<_Ty>::value && __has_trivial_copy(_Ty)>
 {
 };


template<class _Ty>
 struct has_trivial_assign
  : _Cat_base<!is_array<_Ty>::value && (is_pod<typename remove_reference<_Ty>::type>::value || __has_trivial_assign(typename remove_reference<_Ty>::type))>
 {
 };


template<class _Ty>
 struct has_trivial_destructor
  : _Cat_base<is_pod<_Ty>::value || __has_trivial_destructor(_Ty)>
 {
 };


template<class _Ty>
 struct has_nothrow_constructor
  : is_nothrow_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_copy
  : is_nothrow_copy_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_assign
  : is_nothrow_assignable<_Ty, _Ty>
 {
 };




template<class _Ty,
 bool = is_integral<_Ty>::value>
 struct _Sign_base
 {
 typedef typename remove_cv<_Ty>::type _Uty;
 typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
 typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
 };

template<class _Ty>
 struct _Sign_base<_Ty, false>
 {

 typedef is_floating_point<_Ty> _Signed;
 typedef false_type _Unsigned;
 };

template<class _Ty>
 struct is_signed
  : _Sign_base<_Ty>::_Signed
 {
 };


template<class _Ty>
 struct is_unsigned
  : _Sign_base<_Ty>::_Unsigned
 {
 };


template<class _Ty>
 struct _Change_sign
 {
 _Change_sign()
  {
 static_assert(((is_integral<_Ty>::value || is_enum<_Ty>::value) && !is_same<_Ty, bool>::value), "make_signed<T>/make_unsigned<T> require that T shall be a (possibly " "cv-qualified) integral type or enumeration but not a bool type.");




  }

 typedef
  typename _If<is_same<_Ty, signed char>::value
   || is_same<_Ty, unsigned char >::value, signed char,
  typename _If<is_same<_Ty, short >::value
   || is_same<_Ty, unsigned short >::value, short,
  typename _If<is_same<_Ty, int >::value
   || is_same<_Ty, unsigned int >::value, int,
  typename _If<is_same<_Ty, long >::value
   || is_same<_Ty, unsigned long >::value, long,
  typename _If<is_same<_Ty, long long >::value
   || is_same<_Ty, unsigned long long>::value, long long,
  typename _If<is_same<_Ty, __int128_t >::value
   || is_same<_Ty, __uint128_t >::value, __int128_t,
  typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
  typename _If<sizeof (_Ty) == sizeof (short ), short,
  typename _If<sizeof (_Ty) == sizeof (int ), int,
  typename _If<sizeof (_Ty) == sizeof (long ), long,
  typename _If<sizeof (_Ty) == sizeof (long long ), long long,
   __int128_t
  >::type>::type>::type>::type>::type>::type>::type>::type>::type>::type>::type
   _Signed;

 typedef
  typename _If<is_same<_Signed, signed char>::value, unsigned char,
  typename _If<is_same<_Signed, short >::value, unsigned short,
  typename _If<is_same<_Signed, int >::value, unsigned int,
  typename _If<is_same<_Signed, long >::value, unsigned long,
  typename _If<is_same<_Signed, long long >::value, unsigned long long,
   __uint128_t
  >::type>::type>::type>::type>::type
   _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const _Ty>
 {
 typedef const typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<volatile _Ty>
 {
 typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const volatile _Ty>
 {
 typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };


template<class _Ty>
 struct make_signed
 {
 typedef typename _Change_sign<_Ty>::_Signed type;
 };


template<class _Ty>
 struct make_unsigned
 {
 typedef typename _Change_sign<_Ty>::_Unsigned type;
 };
# 2026 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 struct alignment_of
  : integral_constant<size_t, __alignof__(_Ty)>
 {
 };






template<size_t _Len,
 class _Ty,
 bool _Ok>
 struct _Aligned;

template<size_t _Len,
 class _Ty>
 struct _Aligned<_Len, _Ty, true>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = __alignof__(_Ty);
 };

template<size_t _Len>
 struct _Aligned<_Len, short, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, char, __alignof__(char) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, int, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, short, __alignof__(short) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, long, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, int, __alignof__(int) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, long double, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, long, __alignof__(long) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, max_align_t, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, long double, __alignof__(long double) <= _Len>::value;
 };

template<size_t _Len,
 size_t _Align = _Aligned<_Len, max_align_t, __alignof__(max_align_t) <= _Len>::value>
 struct aligned_storage
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 typedef struct {
  alignas(_Align) unsigned char __data[_Len];
 } type;
 };


template<size_t _Len,
 class... _Types>
 struct aligned_union;

template<size_t _Len>
 struct aligned_union<_Len>
 {
 typedef typename aligned_storage<(_Len > sizeof(char)) ? _Len : sizeof(char), __alignof__(char)>::type type;
 };

template<size_t _Len,
 class _Ty,
 class... _Rest>
 struct aligned_union<_Len, _Ty, _Rest...>
 {
 typedef union
  {
  typename aligned_storage<(_Len > sizeof(_Ty)) ? _Len : sizeof(_Ty), __alignof__(_Ty)>::type _Ty1;
  typename aligned_union<_Len, _Rest...>::type _Ty2;
  } type;
 static const size_t alignment_value = alignment_of<type>::value;
 };


template<class _Ty>
 struct underlying_type
 {
 typedef __underlying_type(_Ty) type;
 };


template<class _Ty>
 struct rank
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty,
 size_t _Ix>
 struct rank<_Ty[_Ix]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };

template<class _Ty>
 struct rank<_Ty[]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };


template<class _Ty, unsigned int _Nx>
 struct _Extent
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty,
 size_t _Ix>
 struct _Extent<_Ty[_Ix], 0>
  : integral_constant<size_t, _Ix>
 {
 };

template<class _Ty,
 unsigned int _Nx,
 size_t _Ix>
 struct _Extent<_Ty[_Ix], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx>
 struct _Extent<_Ty[], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx = 0>
 struct extent
  : _Extent<_Ty, _Nx>
 {
 };


template<class _Base,
 class _Der>
 struct is_base_of
  : _Cat_base<__is_base_of(_Base, _Der)>
 {
 };


template<class _Ty>
 struct decay
 {
 template<class _Ty2>
 struct _Remove_extent_ptr
  {
  typedef typename remove_extent<_Ty2>::type *type;
  };

 typedef typename remove_reference<_Ty>::type _Ty1;

 typedef
  typename _If<is_array<_Ty1>::value,
   _Remove_extent_ptr<_Ty1>,
   typename _If<is_function<_Ty1>::value,
    add_pointer<_Ty1>,
    remove_cv<_Ty1>
   >::type
  >::type::type type;
 };


template<class _Ty>
 using decay_t = typename decay<_Ty>::type;





template<class...>
 using __void_t = void;
# 2290 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 struct _Common_type_success
 {
 using type = _Ty;
 };

struct _Common_type_fail
 {
 };

template<class... _Ty>
 struct common_type;

template<>
 struct common_type<>
 {
 };

template<class _Ty>
 struct common_type<_Ty>



 : decay<_Ty>

 {
 };

template<class _Ty1,
 class _Ty2,
 class _Dty1 = decay_t<_Ty1>,
 class _Dty2 = decay_t<_Ty2>,
 bool _Already_decayed = is_same<_Ty1, _Dty1>::value && is_same<_Ty2, _Dty2>::value>
 struct _Common_type2
 {
 using type = common_type<_Dty1, _Dty2>;
 };

template<class _Ty1,
 class _Ty2,
 class _Dty1,
 class _Dty2>
 struct _Common_type2<_Ty1, _Ty2, _Dty1, _Dty2, true>
 {
 template<class _Uty1, class _Uty2>
 static auto _Fn(int) -> _Common_type_success<
   decay_t<decltype(false ? declval<_Uty1>() : declval<_Uty2>())>
  >;

 template<class _Uty1, class _Uty2>
 static auto _Fn(_Wrap_int) -> _Common_type_fail;

 using type = decltype(_Fn<_Dty1, _Dty2>(0));
 };

template<class _Ty1,
 class _Ty2>
 struct common_type<_Ty1, _Ty2>





 {
 using type = decay_t<decltype(true ? declval<_Ty1>() : declval<_Ty2>())>;
 };


template<class _Ty1,
 class _Ty2,
 class... _Ty>
 struct _Common_type_rec
 {
 template<class _Uty1, class _Uty2, class... _Uty>
 static auto _Fn(int) -> _Common_type_success<
   typename common_type<typename common_type<_Uty1, _Uty2>::type, _Uty...>::type
  >;

 template<class _Uty1, class _Uty2, class... _Uty>
 static auto _Fn(_Wrap_int) -> _Common_type_fail;

 using type = decltype(_Fn<_Ty1, _Ty2, _Ty...>(0));
 };

template<class _Ty1,
 class _Ty2,
 class... _Ty>
 struct common_type<_Ty1, _Ty2, _Ty...>
 : _Common_type_rec<_Ty1, _Ty2, _Ty...>::type
 {
 };




template<class _Ty,
 _Ty... _Vals>
 struct integer_sequence
 {
 static_assert(is_integral<_Ty>::value, "integer_sequence<T, I...> requires T to be an integral type.");


 typedef integer_sequence<_Ty, _Vals...> type;
 typedef _Ty value_type;

 static constexpr size_t size() noexcept
  {
  return (sizeof...(_Vals));
  }
 };


template<bool _Negative,
 bool _Zero,
 class _Int_con,
 class _Int_seq>
 struct _Make_seq
 {
 static_assert(!_Negative, "make_integer_sequence<T, N> requires N to be non-negative.");

 };

template<class _Ty,
 _Ty... _Vals>
 struct _Make_seq<false, true,
  integral_constant<_Ty, 0>,
  integer_sequence<_Ty, _Vals...> >
  : integer_sequence<_Ty, _Vals...>
 {
 };

template<class _Ty,
 _Ty _Ix,
 _Ty... _Vals>
 struct _Make_seq<false, false,
  integral_constant<_Ty, _Ix>,
  integer_sequence<_Ty, _Vals...> >
  : _Make_seq<false, _Ix == 1,
   integral_constant<_Ty, _Ix - 1>,
   integer_sequence<_Ty, _Ix - 1, _Vals...> >
 {
 };


template<class _Ty,
 _Ty _Size>
 using make_integer_sequence = typename _Make_seq<_Size < 0, _Size == 0,
  integral_constant<_Ty, _Size>, integer_sequence<_Ty> >::type;

template<size_t... _Vals>
 using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
 using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
 using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 2480 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 struct identity
 {
 typedef _Ty type;

 const _Ty& operator()(const _Ty& _Left) const
  {
  return (_Left);
  }
 };


template<class _Ty> inline
 constexpr _Ty&& forward(
  remove_reference_t<_Ty>& _Arg) noexcept
 {
 return (static_cast<_Ty&&>(_Arg));
 }

template<class _Ty> inline
 constexpr _Ty&& forward(
  remove_reference_t<_Ty>&& _Arg) noexcept
 {
 static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
 return (static_cast<_Ty&&>(_Arg));
 }


template<class _Ty> inline
 constexpr remove_reference_t<_Ty>&&
  move(_Ty&& _Arg) noexcept
 {
 return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename remove_reference<_Ty>::type&&
  _Move(_Ty&& _Arg) noexcept
 {
 return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
  && is_copy_constructible<_Ty>::value,
   const _Ty&, _Ty&&>::type
 move_if_noexcept(_Ty& _Arg) noexcept
 {
 return (::std:: move(_Arg));
 }


template<class _Ty> inline
 decay_t<_Ty> _Decay_copy(_Ty&& _Arg)
 {
 return (::std:: forward<_Ty>(_Arg));
 }


template<class...>
 struct _Param_tester
 {
 typedef void type;
 };

template<class _Ty>
 class reference_wrapper;

template<class _Ty>
 struct _Is_reference_wrapper
  : false_type
 {
 };

template<class _Ty>
 struct _Is_reference_wrapper<reference_wrapper<_Ty>>
  : true_type
 {
 };


struct _Invoker_pmf_object
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmf_pointer
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmf_reference_wrapper
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return ((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmd_object
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd))
  -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd)
  {
  return (::std:: forward<_Ty1>(_Arg1).*_Pmd);
  }
 };

struct _Invoker_pmd_pointer
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd))
  -> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)
  {
  return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd);
  }
 };

struct _Invoker_pmd_reference_wrapper
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd))
  -> decltype(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)
  {
  return (::std:: forward<_Ty1>(_Arg1).get().*_Pmd);
  }
 };

struct _Invoker_functor
 {
 template<class _Callable,
  class... _Types>
  static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args)
  noexcept(noexcept(::std:: forward<_Callable>(_Obj)( ::std:: forward<_Types>(_Args)...)))

  -> decltype(::std:: forward<_Callable>(_Obj)(
   ::std:: forward<_Types>(_Args)...))
  {
  return (::std:: forward<_Callable>(_Obj)(
   ::std:: forward<_Types>(_Args)...));
  }
 };

template<class _Callable,
 class _Ty1,
 class _Decayed = decay_t<_Callable>,
 bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
 bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
 struct _Invoker1;

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
  : _If<is_base_of<
   typename _Is_memfunptr<_Decayed>::_Class_type,
   decay_t<_Ty1> >::value,
  _Invoker_pmf_object,
  typename _If<_Is_reference_wrapper<decay_t<_Ty1>>::value,
  _Invoker_pmf_reference_wrapper,
  _Invoker_pmf_pointer>::type>::type
 {
 };

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
  : _If<is_base_of<
   typename _Is_member_object_pointer<_Decayed>::_Class_type,
   decay_t<_Ty1> >::value,
  _Invoker_pmd_object,
  typename _If<_Is_reference_wrapper<decay_t<_Ty1>>::value,
  _Invoker_pmd_reference_wrapper,
  _Invoker_pmd_pointer>::type>::type
 {
 };

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
  : _Invoker_functor
 {
 };

template<class _Callable,
 class... _Types>
 struct _Invoker;

template<class _Callable>
 struct _Invoker<_Callable>
  : _Invoker_functor
 {
 };

template<class _Callable,
 class _Ty1,
 class... _Types2>
 struct _Invoker<_Callable, _Ty1, _Types2...>
  : _Invoker1<_Callable, _Ty1>
 {
 };
# 2740 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Callable,
 class... _Types> inline
 constexpr auto _Invoke1(_Callable&& _Obj, _Types&&... _Args)
 noexcept(noexcept((_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))))

 -> decltype(_Invoker<_Callable, _Types...>::_Call(
  ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))
 {
 return (_Invoker<_Callable, _Types...>::_Call(
  ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));
 }

template<class _Rx,
 bool = is_void<_Rx>::value>
 struct _Forced
 {
 };

struct _Unforced
 {
 };

template<class _Cv_void,
 class... _Valtys> inline
 void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
 {
 ::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...);
 }

template<class _Rx,
 class... _Valtys> inline
 _Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
 {
 return (::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...));
 }

template<class... _Valtys> inline
 auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
 -> decltype(::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...))
 {
 return (::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...));
 }


template<class _Void,
 class _Func,
 class... _Types>
 struct _Invoke_result
 {
 };

template<class _Func,
 class... _Types>
 struct _Invoke_result<decltype(void(_Invoker<_Func, _Types...>::_Call(::std:: declval<_Func>(),
  ::std:: declval<_Types>()...))), _Func, _Types...>
 {
 typedef decltype(_Invoker<_Func, _Types...>::_Call(::std:: declval<_Func>(),
  ::std:: declval<_Types>()...)) type;
 };
# 2810 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty,
 class = void>
 struct _Weak_result_type
 {
 };

template<class _Ty>
 struct _Weak_result_type<_Ty, typename _Param_tester<
  typename _Ty::result_type>::type>
 {
 typedef typename _Ty::result_type result_type ;
 };

template<class _Ty,
 class = void>
 struct _Weak_argument_type
  : _Weak_result_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_argument_type<_Ty, typename _Param_tester<
  typename _Ty::argument_type>::type>
  : _Weak_result_type<_Ty>
 {
 typedef typename _Ty::argument_type argument_type ;
 };

template<class _Ty,
 class = void>
 struct _Weak_binary_args
  : _Weak_argument_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_binary_args<_Ty, typename _Param_tester<
  typename _Ty::first_argument_type,
  typename _Ty::second_argument_type>::type>
  : _Weak_argument_type<_Ty>
 {
 typedef typename _Ty::first_argument_type first_argument_type ;
 typedef typename _Ty::second_argument_type second_argument_type ;
 };

template<class _Ty>
 struct _Weak_types
 {
 typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
 typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
 typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
  typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
  _Weak_binary_args<_Ty> >::type>::type type;
 };


template<class _Ty>
 class reference_wrapper
  : public _Weak_types<_Ty>::type
 {
public:
 static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
  "reference_wrapper<T> requires T to be an object type "
  "or a function type.");

 typedef _Ty type;

 reference_wrapper(_Ty& _Val) noexcept
  : _Ptr(::std:: addressof(_Val))
  {
  }

 operator _Ty&() const noexcept
  {
  return (*_Ptr);
  }

 _Ty& get() const noexcept
  {
  return (*_Ptr);
  }

 template<class... _Types>
  auto operator()(_Types&&... _Args) const
  -> decltype(_Invoke1(this->get(), ::std:: forward<_Types>(_Args)...))
  {
  return (_Invoke1(get(), ::std:: forward<_Types>(_Args)...));
  }

 reference_wrapper(_Ty&&) = delete;

private:
 _Ty *_Ptr;
 };


template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(_Ty& _Val) noexcept
 {
 return (reference_wrapper<_Ty>(_Val));
 }

template<class _Ty>
 void ref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: ref(_Val.get()));
 }

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(const _Ty& _Val) noexcept
 {
 return (reference_wrapper<const _Ty>(_Val));
 }

template<class _Ty>
 void cref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: cref(_Val.get()));
 }


template<class _Ty>
 struct _Unrefwrap_helper
 {
 typedef _Ty type;
 static const bool _Is_refwrap = false;
 };

template<class _Ty>
 struct _Unrefwrap_helper<reference_wrapper<_Ty> >
 {
 typedef _Ty& type;
 static const bool _Is_refwrap = true;
 };

template<class _Ty>
 struct _Unrefwrap
 {
 typedef decay_t<_Ty> _Ty1;
 typedef typename _Unrefwrap_helper<_Ty1>::type type;
 static const bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
 };


template<bool _Is_ref,
 class _Ty>
 struct _Rerefwrap
 {
 static _Ty _Apply(_Ty _Arg)
  {
  return (_Arg);
  }
 };

template<class _Ty>
 struct _Rerefwrap<true, _Ty>
 {
 static auto _Apply(_Ty _Arg) -> decltype(::std:: ref(_Arg))
  {
  return (::std:: ref(_Arg));
  }
 };


template<class _Ty>
 struct _Result_of_success
 {
 typedef _Ty type;
 };

struct _Result_of_fail
 {
 };

template<class _Ty0,
 class _Ty1>
 struct _Is_same_or_base_of;

template<class _Ret,
 class _Ty0,
 class _Ty1>
 struct _Is_same_or_base_of<_Ret _Ty0::*, _Ty1>
  : public integral_constant<bool, is_same<_Ty0, _Ty1>::value || is_base_of<_Ty0, _Ty1>::value>
 {
 };

template<bool,
 bool,
 class _Fty,
 class... _Args>
 struct _Result_of
 {
 typedef _Result_of_fail type;
 };

template<bool,
 class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf;

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf<true, _Fty, _Arg0, _Args...>
 {
 private:
 template<class _Ufty, class _Uarg0, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype((declval<_Uarg0>().*declval<_Ufty>())(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0, _Args...>(0)) type;
 };

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf<false, _Fty, _Arg0, _Args...>
 {
 private:
 template<class _Ufty, class _Uarg0, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype(((*declval<_Uarg0>()).*declval<_Ufty>())(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0, _Args...>(0)) type;
 };

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of<true, false, _Fty, _Arg0, _Args...>
 {
 typedef typename _Result_of_pmf<
  _Is_same_or_base_of<typename decay<_Fty>::type,
   typename remove_cv<typename remove_reference<_Arg0>::type>::type>::value,
  _Fty, _Arg0, _Args...>::type type;
 };

template<bool,
 class _Fty,
 class _Arg0>
 struct _Result_of_pmd;

template<class _Fty,
 class _Arg0>
 struct _Result_of_pmd<true, _Fty, _Arg0>
 {
 private:
 template<class _Ufty, class _Uarg0>
 static auto _Fn(int) -> _Result_of_success<decltype(declval<_Uarg0>().*declval<_Ufty>())>;

 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0>(0)) type;
 };

template<class _Fty,
 class _Arg0>
 struct _Result_of_pmd<false, _Fty, _Arg0>
 {
 private:
 template<class _Ufty, class _Uarg0>
 static auto _Fn(int) -> _Result_of_success<decltype((*declval<_Uarg0>()).*declval<_Ufty>())>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0>(0)) type;
 };

template<class _Fty,
 class _Arg0>
 struct _Result_of<false, true, _Fty, _Arg0>
 {
 typedef typename _Result_of_pmd<
  _Is_same_or_base_of<typename decay<_Fty>::type,
   typename remove_cv<typename remove_reference<_Arg0>::type>::type>::value,
  _Fty, _Arg0>::type type;
 };

template<class _Fty,
 class... _Args>
 struct _Result_of<false, false, _Fty, _Args...>
 {
 private:
 template<class _Ufty, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype(declval<_Ufty>()(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;
 public:
 typedef decltype(_Fn<_Fty, _Args...>(0)) type;
 };

template<class _Fty>
 struct result_of;
# 3131 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Fty,
 class... _Args>
 struct result_of<_Fty(_Args...)>
 : public _Result_of<
  is_member_function_pointer<typename remove_reference<_Fty>::type>::value,
  is_member_object_pointer<typename remove_reference<_Fty>::type>::value,
  _Fty, _Args...>::type
 {
 };

template<class _Fty,
 class... _Args>
 struct result_of<reference_wrapper<_Fty>(_Args...)>
 : public _Result_of<
  is_member_function_pointer<typename remove_reference<_Fty>::type>::value,
  is_member_object_pointer<typename remove_reference<_Fty>::type>::value,
  _Fty, _Args...>::type
 {
 };
# 3487 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 struct is_final
  : _Cat_base<__is_final(_Ty)>
 {
 };
# 3538 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
template<class _Ty>
 using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
 using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
 using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
 using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
 using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
 using add_cv_t = typename add_cv<_Ty>::type;




template<class _Ty>
 using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
 using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
 using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
 using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
 using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
 using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
 using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
 using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
 size_t _Align = _Aligned<_Len, max_align_t, __alignof__(max_align_t) <= _Len>::value>
 using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
 class... _Types>
 using aligned_union_t = typename aligned_union<_Len, _Types...>::type;





template<bool _Test,
 class _Ty1,
 class _Ty2>
 using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
 using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
 using underlying_type_t = typename underlying_type<_Ty>::type;







template<class _Ty>
 using result_of_t = typename result_of<_Ty>::type;
# 3879 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\type_traits" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xxexception" 2 3

namespace std {

extern "C" {
 void *__cxa_current_primary_exception(void) throw();
 void __cxa_rethrow_primary_exception(void *);
 void __cxa_increment_exception_refcount(void *) throw();
 void __cxa_decrement_exception_refcount(void *) throw();
}






class exception_ptr {
 void *_exptr_;

 friend void rethrow_exception(exception_ptr e);
 friend exception_ptr current_exception() noexcept;
public:
 exception_ptr(void *p = nullptr) noexcept
  : _exptr_(p)
 {
 }

 exception_ptr(const exception_ptr& rhs) noexcept
  : _exptr_(rhs._exptr_)
 {
  __cxa_increment_exception_refcount(_exptr_);
 }

 ~exception_ptr()
 {
  __cxa_decrement_exception_refcount(_exptr_);
 }

 exception_ptr& operator=(const exception_ptr& rhs)
 {
  __cxa_increment_exception_refcount(rhs._exptr_);
  __cxa_decrement_exception_refcount(_exptr_);
  _exptr_ = rhs._exptr_;
  return *this;
 }

 friend bool operator==(const exception_ptr& lhs, const exception_ptr& rhs)
 {
  return lhs._exptr_ == rhs._exptr_;
 }

 friend bool operator!=(const exception_ptr& lhs, const exception_ptr& rhs)
 {
  return lhs._exptr_ != rhs._exptr_;
 }

 explicit operator bool() const
 {
  return _exptr_ != nullptr;
 }
};


inline exception_ptr current_exception() noexcept
 {
 exception_ptr e;
 e._exptr_ = __cxa_current_primary_exception();
 return e;
 }

inline void rethrow_exception(exception_ptr e) __attribute__((__noreturn__));
inline void rethrow_exception(exception_ptr e)
 {
 __cxa_rethrow_primary_exception(e._exptr_);
 terminate();
 }
}

namespace std {

template<class _Excep> inline
 exception_ptr make_exception_ptr(_Excep _Ex) noexcept
 {
 {{
 ::std:: _Throw(_Ex);
 } if (0) {
 return (current_exception());
 }}
 return (exception_ptr());
 }


class nested_exception
 {
public:
 nested_exception() noexcept
  : _Myptr(current_exception())
  {
  }

 nested_exception(const nested_exception& _Right) = default;

 nested_exception& operator=(
  const nested_exception& _Right) = default;

 virtual ~nested_exception() noexcept;

 exception_ptr nested_ptr() const noexcept
  {
  return (_Myptr);
  }

 __attribute__((__noreturn__)) void rethrow_nested() const
  {
  rethrow_exception(_Myptr);
  }

private:
 exception_ptr _Myptr;
 };


template<class _Ty>
 struct _Wrapped_with_nested
  : _Ty, nested_exception
 {
 explicit _Wrapped_with_nested(const _Ty& _Val)
  : _Ty((_Val))
  {
  }
 };

template<class _Ty> inline
 void _Throw_with_nested(_Ty&& _Val,
  typename enable_if<is_class<typename remove_reference<_Ty>::type>::value
   && !is_base_of<nested_exception, typename remove_reference<_Ty>::type>::value
   >::type* = 0)
 {
                                                                                        ;
 }

template<class _Ty> inline
 void _Throw_with_nested(_Ty&& _Val,
  typename enable_if<!is_class<typename remove_reference<_Ty>::type>::value
   || is_base_of<nested_exception, typename remove_reference<_Ty>::type>::value
   >::type* = 0)
 {
                            ;
 }

template<class _Ty> inline
 void throw_with_nested(_Ty&& _Val) __attribute__((__noreturn__));
template<class _Ty> inline
 void throw_with_nested(_Ty&& _Val)
 {
 _Throw_with_nested(_Val);
 }


template<class _Ex> inline
 void _Rethrow_if_nested(const _Ex& _Val,
  typename enable_if<is_polymorphic<_Ex>::value>::type* = 0)
 {
 const nested_exception *e = dynamic_cast<const nested_exception *>(&_Val);
 if (e)
  e->rethrow_nested();
 }

template<class _Ex> inline
 void _Rethrow_if_nested(const _Ex& _Val,
  typename enable_if<!is_polymorphic<_Ex>::value>::type* = 0)
 {
 }

template<class _Ex> inline
 void rethrow_if_nested(const _Ex& _Val)
 {
 _Rethrow_if_nested(_Val);
 }
}
# 183 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\exception" 2 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdexcept" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdint" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdint" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdint" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdint" 2 3
# 35 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdint" 3
namespace std {
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdint" 3
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t; using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t; using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;


using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
# 112 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdint" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\ymath.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\ymath.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\ymath.h" 2 3

 extern "C" {
# 132 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\ymath.h" 3
void _Feraise(int);

typedef union
 {
 unsigned short _Word[8];
 float _Float;
 double _Double;
 long double _Long_double;
 } _Dconst;


double _Cosh(double, double);
short _Dtest(double *);
double _Sinh(double, double);
double _Divide(double, double);
short _Exp(double *, double, long);
double _Log(double, int);
double _Recip(double);
double _Sinx(double, unsigned int);
double _Sin(double, unsigned int, int);
int __fpclassifyd(double);
int __isfinite(double);
int __isinf(double);
int __isnan(double);
int __isnormal(double);
int __signbit(double);

extern const _Dconst _Denorm, _Hugeval, _Inf,
 _Nan, _Snan;


float _FCosh(float, float);
short _FDtest(float *);
float _FSinh(float, float);
float _FDivide(float, float);
short _FExp(float *, float, long);
float _FLog(float, int);
float _FRecip(float);
float _FSinx(float, unsigned int);
float _FSin(float, unsigned int, int);
int __fpclassifyf(float);
int __isfinitef(float);
int __isinff(float);
int __isnanf(float);
int __isnormalf(float);
int __signbitf(float);

extern const _Dconst _FDenorm, _FInf, _FNan, _FSnan;


long double _LCosh(long double, long double);
short _LDtest(long double *);
long double _LSinh(long double, long double);
long double _LDivide(long double, long double);
short _LExp(long double *, long double, long);
long double _LLog(long double, int);
long double _LRecip(long double);
long double _LSinx(long double, unsigned int);
long double _LSin(long double, unsigned int, int);
int __fpclassifyl(long double);
int __isfinitel(long double);
int __isinfl(long double);
int __isnanl(long double);
int __isnormall(long double);
int __signbitl(long double);

extern const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
# 210 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\ymath.h" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cfloat" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cfloat" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\float.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\float.h" 3
typedef struct
 {
 int _Ddig, _Dmdig, _Dmax10e, _Dmaxe, _Dmin10e, _Dmine;
 union
  {
  unsigned short _Us[8];
  float _Float;
  double _Double;
  long double _Long_double;
  } _Deps, _Dmax, _Dmin;
 } _Dvals;



extern "C" {
int _Fltrounds(void);
extern const _Dvals _Dbl, _Flt, _Hlf, _Ldbl;
}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cfloat" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\climits" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cmath" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cmath" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cmath" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 1 3
# 30 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtgmath.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtgmath.h" 3
namespace std {
template<class _Ty>
 struct _Promote_to_float
 {
 typedef typename conditional<is_same<_Ty, long double>::value,
 long double,
 typename conditional<is_same<_Ty, double>::value
  || is_integral<_Ty>::value, double,
  float>::type>::type type;
 };

template<class _Ty1,
 class _Ty2>
 struct _Common_float_type
 {
 typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
 typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
 typedef typename conditional<is_same<_Ty1f, long double>::value
  || is_same<_Ty2f, long double>::value, long double,
  typename conditional<is_same<_Ty1f, double>::value
   || is_same<_Ty2f, double>::value, double,
   float>::type>::type type;
 };
}
# 81 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtgmath.h" 3
extern "C" double pow(double, double);
float pow(float, float);
long double pow(long double, long double);

template<class _Ty1,
 class _Ty2> inline
 typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
  && ::std:: is_arithmetic<_Ty2>::value,
  typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
 pow(const _Ty1 _Left, const _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: pow(type(_Left), type(_Right)));
 }


extern "C" double acos(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C" double asin(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C" double atan(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C" double atan2( double, double); float atan2(float, float); long double atan2(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" double ceil(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C" double cos(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C" double cosh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C" double exp(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }
extern "C" double fabs(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }
extern "C" double floor(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C" double fmod( double, double); float fmod(float, float); long double fmod(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" double frexp(double, int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left, int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" double ldexp(double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left, int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C" double log(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C" double log10(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C" double sin(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C" double sinh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C" double sqrt(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C" double tan(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C" double tanh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }
# 130 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xtgmath.h" 3
extern "C" double fma(double, double, double);
float fma(float, float, float);
long double fma(long double, long double, long double);




template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (:: fma((type)_Left, (type)_Middle, (type)_Right));
 }

template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 hypot3(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (:: hypot3((type)_Left, (type)_Middle, (type)_Right));
 }

extern "C" double remquo(double, double, int *);
float remquo(float, float, int *);
long double remquo(long double, long double, int *);



template<class _Ty1,
 class _Ty2> inline
 typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
 remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: remquo((type)_Left, (type)_Right, _Pquo));
 }

extern "C" double acosh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C" double asinh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C" double atanh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C" double cbrt(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C" double copysign( double, double); float copysign(float, float); long double copysign(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C" double erf(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C" double erfc(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C" double expm1(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C" double exp2(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C" double fdim( double, double); float fdim(float, float); long double fdim(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C" double fmax( double, double); float fmax(float, float); long double fmax(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C" double fmin( double, double); float fmin(float, float); long double fmin(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C" double hypot( double, double); float hypot(float, float); long double hypot(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }

extern "C" int ilogb(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C" double lgamma(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C" long long llrint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C" long long llround(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C" double log1p(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C" double log2(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C" double logb(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C" long lrint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C" long lround(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C" double nearbyint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C" double nextafter( double, double); float nextafter(float, float); long double nextafter(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C" double nexttoward(double, long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left, long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C" double remainder( double, double); float remainder(float, float); long double remainder(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C" double rint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C" double round(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C" double scalbln(double, long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left, long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C" double scalbn(double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left, int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C" double tgamma(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C" double trunc(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }
# 31 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 2 3
# 62 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 3
typedef float float_t;
typedef double double_t;
# 107 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 3
extern "C" {
int _FFpcomp(float, float);
int _Fpcomp(double, double);
int _LFpcomp(long double, long double);

int _FDclass(float);
int _Dclass(double);
int _LDclass(long double);

int _FDsign(float);
int _Dsign(double);
int _LDsign(long double);
}



inline int _FPCOMP(float _Left, float _Right)
 {
 return (_FFpcomp(_Left, _Right));
 }

inline int _FPCOMP(double _Left, double _Right)
 {
 return (_Fpcomp(_Left, _Right));
 }

inline int _FPCOMP(long double _Left, long double _Right)
 {
 return (_LFpcomp(_Left, _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 int _FPCOMP(_Ty1 _Left, _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (_FPCOMP((type)_Left, (type)_Right));
 }


inline int fpclassify(float _Left)
 {
 return (__fpclassifyf(_Left));
 }

inline int fpclassify(double _Left)
 {
 return (__fpclassifyd(_Left));
 }

inline int fpclassify(long double _Left)
 {
 return (__fpclassifyl(_Left));
 }

template<class _Ty> inline
 int fpclassify(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: fpclassify((type)_Left));
 }


inline bool signbit(float _Left)
 {
 return (__signbitf(_Left) != 0);
 }

inline bool signbit(double _Left)
 {
 return (__signbit(_Left) != 0);
 }

inline bool signbit(long double _Left)
 {
 return (__signbitl(_Left) != 0);
 }

template<class _Ty> inline
 bool signbit(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: signbit((type)_Left));
 }


inline bool isfinite(float _Left)
 {
 return (__isfinitef(_Left) != 0);
 }

inline bool isfinite(double _Left)
 {
 return (__isfinite(_Left) != 0);
 }

inline bool isfinite(long double _Left)
 {
 return (__isfinitel(_Left) != 0);
 }

template<class _Ty> inline
 bool isfinite(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isfinite((type)_Left));
 }


inline bool isinf(float _Left)
 {
 return (__isinff(_Left) != 0);
 }

inline bool isinf(double _Left)
 {
 return (__isinf(_Left) != 0);
 }

inline bool isinf(long double _Left)
 {
 return (__isinfl(_Left) != 0);
 }

template<class _Ty> inline
 bool isinf(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isinf((type)_Left));
 }


inline bool isnan(float _Left)
 {
 return (__isnanf(_Left) != 0);
 }

inline bool isnan(double _Left)
 {
 return (__isnan(_Left) != 0);
 }

inline bool isnan(long double _Left)
 {
 return (__isnanl(_Left) != 0);
 }

template<class _Ty> inline
 bool isnan(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isnan((type)_Left));
 }


inline bool isnormal(float _Left)
 {
 return (__isnormalf(_Left) != 0);
 }

inline bool isnormal(double _Left)
 {
 return (__isnormal(_Left) != 0);
 }

inline bool isnormal(long double _Left)
 {
 return (__isnormall(_Left) != 0);
 }

template<class _Ty> inline
 bool isnormal(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isnormal((type)_Left));
 }


template<class _Ty1, class _Ty2> inline
 bool isgreater(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & 4) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isgreaterequal(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (2 | 4)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isless(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & 1) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool islessequal(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (1 | 2)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool islessgreater(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (1 | 4)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isunordered(_Ty1 _Left, _Ty2 _Right)
 {
 return (_FPCOMP(_Left, _Right) == 0);
 }
# 525 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 3
extern "C" {

double acos(double);
double asin(double);
double atan(double);
double atan2(double, double);
double ceil(double);
double cos(double);
double exp(double);
double fabs(double);
double floor(double);
double fmod(double, double);
double frexp(double, int *);
double ldexp(double, int);
double log(double);
double log10(double);
double modf(double, double *);
double pow(double, double);
double sin(double);
void sincos(double, double *, double *);
double sqrt(double);
double tan(double);
double tanh(double);


double acosh(double);
double asinh(double);
double atanh(double);
double cbrt(double);
double copysign(double, double);
double erf(double);
double erfc(double);
double exp2(double);
double expm1(double);
double fdim(double, double);
double fma(double, double, double);
double fmax(double, double);
double fmin(double, double);
double hypot(double, double);
double hypot3(double, double, double);
int ilogb(double);
double lgamma(double);
long long llrint(double);
long long llround(double);
double log1p(double);
double log2(double);
double logb(double);
long lrint(double);
long lround(double);
double nan(const char *);
double nearbyint(double);
double nextafter(double, double);
double nexttoward(double, long double);
double remainder(double, double);
double remquo(double, double, int *);
double rint(double);
double round(double);
double scalbn(double, int);
double scalbln(double, long);
double tgamma(double);
double trunc(double);
# 632 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 3
double gamma(double x);
double gamma_r(double x, int *signgamp);
double j0(double x);
double y0(double x);
double j1(double x);
double y1(double x);
double jn(int n, double x);
double yn(int n, double x);
double lgamma_r(double x, int *signgamp);
double scalb(double x, int fn);
double drem(double x, double y);




float acosf(float);
float asinf(float);
float atanf(float);
float atan2f(float, float);
float ceilf(float);
float cosf(float);
float expf(float);
float fabsf(float);
float floorf(float);
float fmodf(float, float);
float frexpf(float, int *);
float ldexpf(float, int);
float logf(float);
float log10f(float);
float modff(float, float *);
float powf(float, float);
void sincosf(float, float *, float *);
float sinf(float);
float sqrtf(float);
float tanf(float);
float tanhf(float);


float acoshf(float);
float asinhf(float);
float atanhf(float);
float cbrtf(float);
float copysignf(float, float);
float erff(float);
float erfcf(float);
float expm1f(float);
float exp2f(float);
float fdimf(float, float);
float fmaf(float, float, float);
float fmaxf(float, float);
float fminf(float, float);
float hypotf(float, float);
float hypot3f(float, float, float);
int ilogbf(float);
float lgammaf(float);
long long llrintf(float);
long long llroundf(float);
float log1pf(float);
float log2f(float);
float logbf(float);
long lrintf(float);
long lroundf(float);
float nanf(const char *);
float nearbyintf(float);
float nextafterf(float, float);
float nexttowardf(float, long double);
float remainderf(float, float);
float remquof(float, float, int *);
float rintf(float);
float roundf(float);
float scalbnf(float, int);
float scalblnf(float, long);
float tgammaf(float);
float truncf(float);
# 752 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 3
float gammaf(float x);
float gammaf_r(float x, int *signgamp);
float j0f(float x);
float y0f(float x);
float j1f(float x);
float y1f(float x);
float jnf(int n, float x);
float ynf(int n, float x);
float lgammaf_r(float x, int *signgamp);
float scalbf(float x, int fn);
float dremf(float x, float y);




long double acosl(long double);
long double asinl(long double);
long double atanl(long double);
long double atan2l(long double, long double);
long double ceill(long double);
long double cosl(long double);
long double expl(long double);
long double fabsl(long double);
long double floorl(long double);
long double fmodl(long double, long double);
long double frexpl(long double, int *);
long double ldexpl(long double, int);
long double logl(long double);
long double log10l(long double);
long double modfl(long double, long double *);
long double powl(long double, long double);
long double sinl(long double);
long double sqrtl(long double);
long double tanl(long double);
long double tanhl(long double);


long double acoshl(long double);
long double asinhl(long double);
long double atanhl(long double);
long double cbrtl(long double);
long double copysignl(long double, long double);
long double erfl(long double);
long double erfcl(long double);
long double exp2l(long double);
long double expm1l(long double);
long double fdiml(long double, long double);
long double fmal(long double, long double, long double);
long double fmaxl(long double, long double);
long double fminl(long double, long double);
long double hypotl(long double, long double);
long double hypot3l(long double, long double, long double);
int ilogbl(long double);
long double lgammal(long double);
long long llrintl(long double);
long long llroundl(long double);
long double log1pl(long double);
long double log2l(long double);
long double logbl(long double);
long lrintl(long double);
long lroundl(long double);
long double nanl(const char *);
long double nearbyintl(long double);
long double nextafterl(long double, long double);
long double nexttowardl(long double, long double);
long double remainderl(long double, long double);
long double remquol(long double, long double, int *);
long double rintl(long double);
long double roundl(long double);
long double scalbnl(long double, int);
long double scalblnl(long double, long);
long double tgammal(long double);
long double truncl(long double);
# 870 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 3
inline double cosh(double _Left)
 {
 return (_Cosh(_Left, 1.0));
 }

inline double sinh(double _Left)
 {
 return (_Sinh(_Left, 1.0));
 }


}



inline double abs(double _Left)
 {
 return (fabs(_Left));
 }


extern "C" {

inline float coshf(float _Left)
 {
 return (_FCosh(_Left, 1.0F));
 }

inline float sinhf(float _Left)
 {
 return (_FSinh(_Left, 1.0F));
 }

}

inline float abs(float _Left)
 {
 return (fabsf(_Left));
 }

inline float acos(float _Left)
 {
 return (acosf(_Left));
 }

inline float asin(float _Left)
 {
 return (asinf(_Left));
 }

inline float atan(float _Left)
 {
 return (atanf(_Left));
 }

inline float atan2(float _Left, float _Right)
 {
 return (atan2f(_Left, _Right));
 }

inline float ceil(float _Left)
 {
 return (ceilf(_Left));
 }

inline float cos(float _Left)
 {
 return (cosf(_Left));
 }

inline float cosh(float _Left)
 {
 return (_FCosh(_Left, 1.0F));
 }

inline float exp(float _Left)
 {
 return (expf(_Left));
 }

inline float fabs(float _Left)
 {
 return (fabsf(_Left));
 }

inline float floor(float _Left)
 {
 return (floorf(_Left));
 }

inline float fmod(float _Left, float _Right)
 {
 return (fmodf(_Left, _Right));
 }

inline float frexp(float _Left, int *_Right)
 {
 return (frexpf(_Left, _Right));
 }

inline float ldexp(float _Left, int _Right)
 {
 return (ldexpf(_Left, _Right));
 }

inline float log(float _Left)
 {
 return (logf(_Left));
 }

inline float log10(float _Left)
 {
 return (log10f(_Left));
 }

inline float modf(float _Left, float *_Right)
 {
 return (modff(_Left, _Right));
 }

inline float pow(float _Left, float _Right)
 {
 return (powf(_Left, _Right));
 }

inline float sin(float _Left)
 {
 return (sinf(_Left));
 }

inline float sinh(float _Left)
 {
 return (_FSinh(_Left, 1.0F));
 }

inline float sqrt(float _Left)
 {
 return (sqrtf(_Left));
 }

inline float tan(float _Left)
 {
 return (tanf(_Left));
 }

inline float tanh(float _Left)
 {
 return (tanhf(_Left));
 }


inline float acosh(float _Left)
 {
 return (acoshf(_Left));
 }

inline float asinh(float _Left)
 {
 return (asinhf(_Left));
 }

inline float atanh(float _Left)
 {
 return (atanhf(_Left));
 }

inline float cbrt(float _Left)
 {
 return (cbrtf(_Left));
 }

inline float copysign(float _Left, float _Right)
 {
 return (copysignf(_Left, _Right));
 }

inline float erf(float _Left)
 {
 return (erff(_Left));
 }

inline float erfc(float _Left)
 {
 return (erfcf(_Left));
 }

inline float exp2(float _Left)
 {
 return (exp2f(_Left));
 }

inline float expm1(float _Left)
 {
 return (expm1f(_Left));
 }

inline float fdim(float _Left, float _Right)
 {
 return (fdimf(_Left, _Right));
 }

inline float fma(float _Left, float _Right, float _Addend)
 {
 return (fmaf(_Left, _Right, _Addend));
 }

inline float fmax(float _Left, float _Right)
 {
 return (fmaxf(_Left, _Right));
 }

inline float fmin(float _Left, float _Right)
 {
 return (fminf(_Left, _Right));
 }

inline float hypot(float _Left, float _Right)
 {
 return (hypotf(_Left, _Right));
 }

inline float hypot3(float _Left, float _Mid, float _Right)
 {
 return (hypot3f(_Left, _Mid, _Right));
 }

inline int ilogb(float _Left)
 {
 return (ilogbf(_Left));
 }

inline float lgamma(float _Left)
 {
 return (lgammaf(_Left));
 }

inline long long llrint(float _Left)
 {
 return (llrintf(_Left));
 }

inline long long llround(float _Left)
 {
 return (llroundf(_Left));
 }

inline float log1p(float _Left)
 {
 return (log1pf(_Left));
 }

inline float log2(float _Left)
 {
 return (log2f(_Left));
 }

inline float logb(float _Left)
 {
 return (logbf(_Left));
 }

inline long lrint(float _Left)
 {
 return (lrintf(_Left));
 }

inline long lround(float _Left)
 {
 return (lroundf(_Left));
 }

inline float nearbyint(float _Left)
 {
 return (nearbyintf(_Left));
 }

inline float nextafter(float _Left, float _Right)
 {
 return (nextafterf(_Left, _Right));
 }

inline float nexttoward(float _Left, long double _Right)
 {
 return (nexttowardf(_Left, _Right));
 }

inline float remainder(float _Left, float _Right)
 {
 return (remainderf(_Left, _Right));
 }

inline float remquo(float _Left, float _Right, int *_Pval)
 {
 return (remquof(_Left, _Right, _Pval));
 }

inline float rint(float _Left)
 {
 return (rintf(_Left));
 }

inline float round(float _Left)
 {
 return (roundf(_Left));
 }

inline float scalbn(float _Left, int _Right)
 {
 return (scalbnf(_Left, _Right));
 }

inline float scalbln(float _Left, long _Right)
 {
 return (scalblnf(_Left, _Right));
 }

inline float tgamma(float _Left)
 {
 return (tgammaf(_Left));
 }

inline float trunc(float _Left)
 {
 return (truncf(_Left));
 }
# 1350 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\math.h" 3
inline float gamma(float x)
{
  return gammaf(x);
}

inline float gamma_r(float x, int *signgamp)
{
  return gammaf_r(x, signgamp);
}

inline float j0(float x)
{
  return j0f(x);
}

inline float y0(float x)
{
  return y0f(x);
}

inline float j1(float x)
{
  return j1f(x);
}

inline float y1(float x)
{
  return y1f(x);
}

inline float jn(int n, float x)
{
  return jnf(n, x);
}

inline float yn(int n, float x)
{
  return ynf(n, x);
}

inline float lgamma_r(float x, int *signgamp)
{
  return lgammaf_r(x, signgamp);
}

inline float scalb(float x, int fn)
{
  return scalbf(x, fn);
}

inline float drem(float x, float y)
{
  return dremf(x, y);
}

inline void sincos(float _Left, float *_Psin, float *_Pcos)
{
  sincosf(_Left, _Psin, _Pcos);
}



extern "C" {

inline long double coshl(long double _Left)
 {
 return (_LCosh(_Left, 1.0L));
 }

inline long double sinhl(long double _Left)
 {
 return (_LSinh(_Left, 1.0L));
 }

}

inline long double abs(long double _Left)
 {
 return (fabsl(_Left));
 }

inline long double acos(long double _Left)
 {
 return (acosl(_Left));
 }

inline long double asin(long double _Left)
 {
 return (asinl(_Left));
 }

inline long double atan(long double _Left)
 {
 return (atanl(_Left));
 }

inline long double atan2(long double _Left, long double _Right)
 {
 return (atan2l(_Left, _Right));
 }

inline long double ceil(long double _Left)
 {
 return (ceill(_Left));
 }

inline long double cos(long double _Left)
 {
 return (cosl(_Left));
 }

inline long double cosh(long double _Left)
 {
 return (_LCosh(_Left, 1.0L));
 }

inline long double exp(long double _Left)
 {
 return (expl(_Left));
 }

inline long double fabs(long double _Left)
 {
 return (fabsl(_Left));
 }

inline long double floor(long double _Left)
 {
 return (floorl(_Left));
 }

inline long double fmod(long double _Left, long double _Right)
 {
 return (fmodl(_Left, _Right));
 }

inline long double frexp(long double _Left, int *_Right)
 {
 return (frexpl(_Left, _Right));
 }

inline long double ldexp(long double _Left, int _Right)
 {
 return (ldexpl(_Left, _Right));
 }

inline long double log(long double _Left)
 {
 return (logl(_Left));
 }

inline long double log10(long double _Left)
 {
 return (log10l(_Left));
 }

inline long double modf(long double _Left, long double *_Right)
 {
 return (modfl(_Left, _Right));
 }

inline long double pow(long double _Left, long double _Right)
 {
 return (powl(_Left, _Right));
 }

inline long double sin(long double _Left)
 {
 return (sinl(_Left));
 }

inline long double sinh(long double _Left)
 {
 return (_LSinh(_Left, 1.0L));
 }

inline long double sqrt(long double _Left)
 {
 return (sqrtl(_Left));
 }

inline long double tan(long double _Left)
 {
 return (tanl(_Left));
 }

inline long double tanh(long double _Left)
 {
 return (tanhl(_Left));
 }


inline long double acosh(long double _Left)
 {
 return (acoshl(_Left));
 }

inline long double asinh(long double _Left)
 {
 return (asinhl(_Left));
 }

inline long double atanh(long double _Left)
 {
 return (atanhl(_Left));
 }

inline long double cbrt(long double _Left)
 {
 return (cbrtl(_Left));
 }

inline long double copysign(long double _Left, long double _Right)
 {
 return (copysignl(_Left, _Right));
 }

inline long double erf(long double _Left)
 {
 return (erfl(_Left));
 }

inline long double erfc(long double _Left)
 {
 return (erfcl(_Left));
 }

inline long double exp2(long double _Left)
 {
 return (exp2l(_Left));
 }

inline long double expm1(long double _Left)
 {
 return (expm1l(_Left));
 }

inline long double fdim(long double _Left, long double _Right)
 {
 return (fdiml(_Left, _Right));
 }

inline long double fma(long double _Left, long double _Right,
 long double _Addend)
 {
 return (fmal(_Left, _Right, _Addend));
 }

inline long double fmax(long double _Left, long double _Right)
 {
 return (fmaxl(_Left, _Right));
 }

inline long double fmin(long double _Left, long double _Right)
 {
 return (fminl(_Left, _Right));
 }

inline long double hypot(long double _Left, long double _Right)
 {
 return (hypotl(_Left, _Right));
 }

inline long double hypot3(long double _Left, long double _Mid,
 long double _Right)
 {
 return (hypot3l(_Left, _Mid, _Right));
 }

inline int ilogb(long double _Left)
 {
 return (ilogbl(_Left));
 }

inline long double lgamma(long double _Left)
 {
 return (lgammal(_Left));
 }

inline long long llrint(long double _Left)
 {
 return (llrintl(_Left));
 }

inline long long llround(long double _Left)
 {
 return (llroundl(_Left));
 }

inline long double log1p(long double _Left)
 {
 return (log1pl(_Left));
 }

inline long double log2(long double _Left)
 {
 return (log2l(_Left));
 }

inline long double logb(long double _Left)
 {
 return (logbl(_Left));
 }

inline long lrint(long double _Left)
 {
 return (lrintl(_Left));
 }

inline long lround(long double _Left)
 {
 return (lroundl(_Left));
 }

inline long double nearbyint(long double _Left)
 {
 return (nearbyintl(_Left));
 }

inline long double nextafter(long double _Left, long double _Right)
 {
 return (nextafterl(_Left, _Right));
 }

inline long double nexttoward(long double _Left, long double _Right)
 {
 return (nexttowardl(_Left, _Right));
 }

inline long double remainder(long double _Left, long double _Right)
 {
 return (remainderl(_Left, _Right));
 }

inline long double remquo(long double _Left, long double _Right,
 int *_Pval)
 {
 return (remquol(_Left, _Right, _Pval));
 }

inline long double rint(long double _Left)
 {
 return (rintl(_Left));
 }

inline long double round(long double _Left)
 {
 return (roundl(_Left));
 }

inline long double scalbn(long double _Left, int _Right)
 {
 return (scalbnl(_Left, _Right));
 }

inline long double scalbln(long double _Left, long _Right)
 {
 return (scalblnl(_Left, _Right));
 }

inline long double tgamma(long double _Left)
 {
 return (tgammal(_Left));
 }

inline long double trunc(long double _Left)
 {
 return (truncl(_Left));
 }
# 19 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cmath" 2 3



namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2; using :: hypot;
using :: hypot3; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f; using :: hypotf;
using :: hypot3f; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l; using :: hypotl;
using :: hypot3l; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
# 191 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cmath" 3
using :: gamma;
using :: gamma_r;
using :: j0;
using :: y0;
using :: j1;
using :: y1;
using :: jn;
using :: yn;
using :: lgamma_r;
using :: scalb;
using :: drem;
using :: sincos;

using :: gammaf;
using :: gammaf_r;
using :: j0f;
using :: y0f;
using :: j1f;
using :: y1f;
using :: jnf;
using :: ynf;
using :: lgammaf_r;
using :: scalbf;
using :: dremf;
using :: sincosf;


}
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cwchar" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cwchar" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cwchar" 2 3
# 36 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cwchar" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 2 3




# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_mbstate_t.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_mbstate_t.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_mbstate_t.h" 2 3





typedef _Mbstatet mbstate_t;
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_wc.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_types/_wc.h" 2 3





typedef _Sizet wctype_t;




typedef _Wintt wint_t;
# 18 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 2 3
# 33 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 3
struct tm;
struct _Dnk_filet;







extern "C" {

wint_t fgetwc(_Filet *);
wchar_t *fgetws(wchar_t *, int,
 _Filet *);
wint_t fputwc(wchar_t, _Filet *);
int fputws(const wchar_t *,
 _Filet *);
int fwide(_Filet *, int);
int fwprintf(_Filet *,
 const wchar_t *, ...);
int fwscanf(_Filet *,
 const wchar_t *, ...);
wint_t getwc(_Filet *);
wint_t getwchar(void);
wint_t putwc(wchar_t, _Filet *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t *, size_t,
 const wchar_t *, ...);
int swscanf(const wchar_t *,
 const wchar_t *, ...);
wint_t ungetwc(wint_t, _Filet *);
int vfwprintf(_Filet *,
 const wchar_t *, _Va_list);
int vswprintf(wchar_t *, size_t,
 const wchar_t *, _Va_list);
int vwprintf(const wchar_t *, _Va_list);
int wprintf(const wchar_t *, ...);
int wscanf(const wchar_t *, ...);


int vfwscanf(_Filet *,
 const wchar_t *, _Va_list);
int vswscanf(const wchar_t *,
 const wchar_t *, _Va_list);
int vwscanf(const wchar_t *, _Va_list);



size_t mbrlen(const char *,
 size_t, mbstate_t *);
size_t mbrtowc(wchar_t *, const char *,
 size_t, mbstate_t *);
size_t mbsrtowcs(wchar_t *,
 const char **, size_t, mbstate_t *);
int mbsinit(const mbstate_t *);
size_t wcrtomb(char *,
 wchar_t, mbstate_t *);
size_t wcsrtombs(char *,
 const wchar_t **, size_t, mbstate_t *);
long wcstol(const wchar_t *,
 wchar_t **, int);


_Longlong wcstoll(const wchar_t *,
 wchar_t **, int);
_ULonglong wcstoull(const wchar_t *,
 wchar_t **, int);



wchar_t *wcscat(wchar_t *, const wchar_t *);
int wcscmp(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t *, const wchar_t *);
size_t wcslen(const wchar_t *);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t *,
 const wchar_t *, size_t);

int wcscoll(const wchar_t *, const wchar_t *);
size_t wcscspn(const wchar_t *, const wchar_t *);
wchar_t *wcsncat(wchar_t *,
 const wchar_t *, size_t);
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcstok(wchar_t *, const wchar_t *,
 wchar_t **);
size_t wcsxfrm(wchar_t *,
 const wchar_t *, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t *,
 const wchar_t *, size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);


size_t wcsftime(wchar_t *, size_t,
 const wchar_t *, const struct tm *);

wint_t _Btowc(int);
int _Wctob(wint_t);
double _WStod(const wchar_t *, wchar_t **, long);
float _WStof(const wchar_t *, wchar_t **, long);
long double _WStold(const wchar_t *, wchar_t **, long);
unsigned long _WStoul(const wchar_t *, wchar_t **, int);
}







extern "C" {
const wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
}

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_Str, wchar_t _Ch, size_t _Num)
 {
 return ((wchar_t *)wmemchr((const wchar_t *)_Str, _Ch, _Num));
 }
}
# 165 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xwcstod.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xwcstod.h" 3
extern "C" {
double wcstod(const wchar_t *, wchar_t **);

inline unsigned long wcstoul(const wchar_t * _Str,
 wchar_t ** _Endptr, int _Base)
 {return (_WStoul(_Str, _Endptr, _Base));
 }
}
# 166 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xwstr.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xwstr.h" 3
extern "C" {
const wchar_t *wcschr(const wchar_t *, wchar_t);
const wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
const wchar_t *wcsrchr(const wchar_t *, wchar_t);
const wchar_t *wcsstr(const wchar_t *, const wchar_t *);
}

extern "C++" {
inline wchar_t *wcschr(wchar_t *_Str, wchar_t _Ch)
 {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch));
 }

inline wchar_t *wcspbrk(wchar_t *_Str1, const wchar_t *_Str2)
 {return ((wchar_t *)wcspbrk((const wchar_t *)_Str1, _Str2));
 }

inline wchar_t *wcsrchr(wchar_t *_Str, wchar_t _Ch)
 {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch));
 }

inline wchar_t *wcsstr(wchar_t *_Str1, const wchar_t *_Str2)
 {return ((wchar_t *)wcsstr((const wchar_t *)_Str1, _Str2));
 }
}

extern "C" {
inline wint_t btowc(int _By)
 {
 return (_Btowc(_By));
 }

inline int wctob(wint_t _Wc)
 {
 return (_Wctob(_Wc));
 }


float wcstof(const wchar_t *,
 wchar_t **);

inline long double wcstold(const wchar_t * _Str,
 wchar_t ** _Endptr)
 {
 return (_WStold(_Str, _Endptr, 0));
 }


}
# 167 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\wchar.h" 2 3


extern "C" {

int fwprintf_s(_Filet *,
 const wchar_t *, ...);
int fwscanf_s(_Filet *,
 const wchar_t *, ...);
int snwprintf_s(wchar_t *, rsize_t,
 const wchar_t *, ...);
int swprintf_s(wchar_t *, rsize_t,
 const wchar_t *, ...);
int swscanf_s(const wchar_t *,
 const wchar_t *, ...);
int vfwprintf_s(_Filet *,
 const wchar_t *,
 _Va_list);
int vfwscanf_s(_Filet *,
 const wchar_t *,
 _Va_list);
int vsnwprintf_s(wchar_t *, rsize_t,
 const wchar_t *,
 _Va_list);
int vswprintf_s(wchar_t *, rsize_t,
 const wchar_t *,
 _Va_list);
int vswscanf_s(const wchar_t *,
 const wchar_t *,
 _Va_list);
int vwprintf_s(const wchar_t *,
 _Va_list);
int vwscanf_s(const wchar_t *,
 _Va_list);
int wprintf_s(const wchar_t *, ...);
int wscanf_s(const wchar_t *, ...);

errno_t wcscpy_s(wchar_t *, rsize_t,
 const wchar_t *);
errno_t wcsncpy_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wmemcpy_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wmemmove_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wcscat_s(wchar_t *, rsize_t,
 const wchar_t *);
errno_t wcsncat_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
wchar_t *wcstok_s(wchar_t *, rsize_t *,
 const wchar_t *, wchar_t **);

size_t wcsnlen_s(const wchar_t *, size_t);

errno_t wcrtomb_s(size_t *,
 char *, rsize_t,
 wchar_t,
 mbstate_t *);
errno_t mbsrtowcs_s(size_t *,
 wchar_t *, rsize_t,
 const char **, rsize_t,
 mbstate_t *);
errno_t wcsrtombs_s(size_t *,
 char *, rsize_t,
 const wchar_t **, rsize_t,
 mbstate_t *);
}



extern "C++" {

template<rsize_t _Size>
errno_t mbsrtowcs_s(size_t *_Psize, wchar_t (&_Dst)[_Size], const char **_Src, rsize_t _Len, mbstate_t *_Ps)
 {
 return mbsrtowcs_s(_Psize, _Dst, _Size, _Src, _Len, _Ps);
 }

template<rsize_t _Size>
int swprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vswprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, va_list _Ap)
 {
 return vswprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
errno_t wcrtomb_s(size_t *_Psize, char (&_Str)[_Size], wchar_t _Wc, mbstate_t *_Ps)
 {
 return wcrtomb_s(_Psize, _Str, _Size, _Wc, _Ps);
 }

template<rsize_t _Size>
errno_t wcscat_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2)
 {
 return wcscat_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t wcscpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2)
 {
 return wcscpy_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t wcsncat_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wcsncat_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wcsncpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wcsncpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wcsrtombs_s(size_t *_Psize, char (&_Dst)[_Size], const wchar_t **_Src, rsize_t _Len, mbstate_t *_Ps)
 {
 return wcsrtombs_s(_Psize, _Dst, _Size, _Src, _Len, _Ps);
 }

template<rsize_t _Size>
int snwprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vsnwprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, va_list _Ap)
 {
 return vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<size_t _Size>
size_t wcsnlen_s(const wchar_t (&_Str)[_Size])
 {
 return wcsnlen_s(_Str, _Size);
 }

template<rsize_t _Size>
errno_t wmemcpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wmemcpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wmemmove_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wmemmove_s(_Str1, _Size, _Str2, _Num);
 }

}
# 37 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cwchar" 2 3





namespace std {
using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
# 75 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cwchar" 3
}
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 2 3


namespace std {
# 78 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 3
typedef enum
 {
 denorm_indeterminate = -1,
 denorm_absent = 0,
 denorm_present = 1}
  float_denorm_style;


typedef enum
 {
 round_indeterminate = -1,
 round_toward_zero = 0,
 round_to_nearest = 1,
 round_toward_infinity = 2,
 round_toward_neg_infinity = 3}
  float_round_style;


struct _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static constexpr bool has_denorm_loss = (bool)(false);
 static constexpr bool has_infinity = (bool)(false);
 static constexpr bool has_quiet_NaN = (bool)(false);
 static constexpr bool has_signaling_NaN = (bool)(false);
 static constexpr bool is_bounded = (bool)(false);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(false);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr bool is_specialized = (bool)(false);
 static constexpr bool tinyness_before = (bool)(false);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
 static constexpr int digits = (int)(0);
 static constexpr int digits10 = (int)(0);
 static constexpr int max_digits10 = (int)(0);

 static constexpr int max_exponent = (int)(0);
 static constexpr int max_exponent10 = (int)(0);
 static constexpr int min_exponent = (int)(0);
 static constexpr int min_exponent10 = (int)(0);
 static constexpr int radix = (int)(0);
 };


template<class _Ty>
 class numeric_limits
  : public _Num_base
 {
public:
 static constexpr _Ty (min)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty (max)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty lowest() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty round_error() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty infinity() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (_Ty());
  }
 };

template<class _Ty>
 class numeric_limits<const _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<const volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };


struct _Num_int_base
 : public _Num_base
 {
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(true);
 static constexpr bool is_integer = (bool)(true);
 static constexpr bool is_modulo = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr int radix = (int)(2);
 };


struct _Num_float_base
 : public _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static constexpr bool has_denorm_loss = (bool)(false);
 static constexpr bool has_infinity = (bool)(true);
 static constexpr bool has_quiet_NaN = (bool)(true);
 static constexpr bool has_signaling_NaN = (bool)(true);
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(true);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr bool tinyness_before = (bool)(true);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
 static constexpr int radix = (int)(2);
 };


struct _Num_ldbl_base
 : public _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
 static constexpr bool has_denorm_loss = (bool)(true);
 static constexpr bool has_infinity = (bool)(true);
 static constexpr bool has_quiet_NaN = (bool)(true);
 static constexpr bool has_signaling_NaN = (bool)(true);
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(true);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr bool tinyness_before = (bool)(true);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
 static constexpr int radix = (int)(2);
 };


template<> class numeric_limits<char>
 : public _Num_int_base
 {
public:
 typedef char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7f - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7f);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)((-0x7f - 1) != 0);
 static constexpr int digits = (int)(8 - ((-0x7f - 1) != 0 ? 1 : 0));
 static constexpr int digits10 = (int)((8 - ((-0x7f - 1) != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<wchar_t>
 : public _Num_int_base
 {
public:
 typedef wchar_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((_Ty)0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return ((_Ty)0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(0 != 0);
 static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0 != 0 ? 1 : 0));

 static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0 != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<bool>
 : public _Num_int_base
 {
public:
 typedef bool _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (false);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (true);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(1);
 static constexpr int digits10 = (int)(0);
 };


template<> class numeric_limits<signed char>
 : public _Num_int_base
 {
public:
 typedef signed char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7f - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7f);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 - 1);
 static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
 };


template<> class numeric_limits<unsigned char>
 : public _Num_int_base
 {
public:
 typedef unsigned char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8);
 static constexpr int digits10 = (int)(8 * 301L / 1000);
 };


template<> class numeric_limits<short>
 : public _Num_int_base
 {
public:
 typedef short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (short) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned short>
 : public _Num_int_base
 {
public:
 typedef unsigned short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned short));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);

 };


template<> class numeric_limits<char16_t>
 : public _Num_int_base
 {
public:
 typedef char16_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char16_t));
 static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);

 };


template<> class numeric_limits<int>
 : public _Num_int_base
 {
public:
 typedef int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fffffff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (int) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned int>
 : public _Num_int_base
 {
public:
 typedef unsigned int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned int));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);

 };


template<> class numeric_limits<long>
 : public _Num_int_base
 {
public:
 typedef long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fffffffffffffff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffffffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long>
 : public _Num_int_base
 {
public:
 typedef unsigned long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);

 };


template<> class numeric_limits<char32_t>
 : public _Num_int_base
 {
public:
 typedef char32_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char32_t));
 static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);

 };



template<> class numeric_limits<long long>
 : public _Num_int_base
 {
public:
 typedef long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (-0x7fffffffffffffffLL - 1);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffffffffffffLL);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long long>
 : public _Num_int_base
 {
public:
 typedef unsigned long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffffffffffULL);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long long) * 301L / 1000);

 };



template<> class numeric_limits<float>
 : public _Num_float_base
 {
public:
 typedef float _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (1.175494351E-38F);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (3.402823466E+38F);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (1.192092896E-07F);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5F);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (1.175494351E-38F);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_valf());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nanf(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nansf(""));
  }

 static constexpr int digits = (int)(24);
 static constexpr int digits10 = (int)(6);
 static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)128);
 static constexpr int max_exponent10 = (int)((int)38);
 static constexpr int min_exponent = (int)((int)-125);
 static constexpr int min_exponent10 = (int)((int)-37);
 };


template<> class numeric_limits<double>
 : public _Num_float_base
 {
public:
 typedef double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (2.2250738585072014E-308);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (1.7976931348623157E+308);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (2.2204460492503131E-016);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (2.2250738585072014E-308);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_val());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nan(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nans(""));
  }

 static constexpr int digits = (int)(53);
 static constexpr int digits10 = (int)(15);
 static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)1024);
 static constexpr int max_exponent10 = (int)((int)308);
 static constexpr int min_exponent = (int)((int)-1021);
 static constexpr int min_exponent10 = (int)((int)-307);
 };


template<> class numeric_limits<long double>
 : public _Num_ldbl_base
 {
public:
 typedef long double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (3.362103143112093506263E-4932L);
  }


 static constexpr _Ty (max)() noexcept
  {
  return (1.189731495357231765021E+4932L);
  }


 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (1.084202172485504434007E-19L);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5L);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (3.645199531882474602528E-4951L);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_vall());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nanl(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nansl(""));
  }

 static constexpr int digits = (int)(64);
 static constexpr int digits10 = (int)(18);
 static constexpr int max_digits10 = (int)(2 + 64 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)16384);
 static constexpr int max_exponent10 = (int)((int)4932);
 static constexpr int min_exponent = (int)((int)-16381);
 static constexpr int min_exponent10 = (int)((int)-4931);
 };
# 1326 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\limits" 3
}
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\new" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\new" 3
namespace std {

class bad_alloc
 : public ::std:: exception
 {
public:
 bad_alloc(const char *_Message = "bad allocation") noexcept
  : exception(_Message)
  {
  }

 virtual const char *what() const noexcept;


 virtual ~bad_alloc() noexcept;
# 36 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\new" 3
protected:
 virtual void _Doraise() const;

 };


class bad_array_new_length
 : public bad_alloc
 {
public:
 bad_array_new_length() noexcept
  : bad_alloc("bad array new length")
  {
  }


 virtual ~bad_array_new_length() noexcept;


 };
# 70 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\new" 3
struct nothrow_t
 {



 };
extern const nothrow_t nothrow;
typedef void (*new_handler)();

new_handler get_new_handler() noexcept;
new_handler set_new_handler(new_handler) noexcept;
}


void *operator new(::std:: size_t);
inline void *operator new(::std:: size_t, void *_Ptr) noexcept { return (_Ptr); }
void *operator new(::std:: size_t, const ::std:: nothrow_t&) noexcept;
# 95 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\new" 3
inline void operator delete(void *, void *) noexcept { }


void operator delete(void *) noexcept;
void operator delete(void *, const ::std:: nothrow_t&) noexcept;

void operator delete(void *, ::std:: size_t) noexcept;
void operator delete(void *, :: size_t, const ::std:: nothrow_t&) noexcept;
# 112 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\new" 3
void *operator new[](::std:: size_t);
inline void *operator new[](::std:: size_t, void *_Ptr) noexcept { return (_Ptr); }
void *operator new[](::std:: size_t, const ::std:: nothrow_t&) noexcept;
# 123 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\new" 3
inline void operator delete[](void *, void *) noexcept { }


void operator delete[](void *) noexcept;
void operator delete[](void *, const ::std:: nothrow_t&) noexcept;

void operator delete[](void *, ::std:: size_t) noexcept;
void operator delete[](void *, :: size_t, const ::std:: nothrow_t&) noexcept;
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdio" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdio" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdio" 2 3
# 22 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdio" 3
namespace std {
using :: _Filet; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: gets; using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
# 52 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstdio" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstring" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstring" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstring" 2 3
# 22 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\cstring" 3
namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strerror_r;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 2 3



namespace std {





typedef long streamoff;
typedef int streamsize;
# 33 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
extern fpos_t _Fpz;
extern const streamoff _BADOFF;


template<class _Statetype>
 class fpos
 {
 typedef fpos<_Statetype> _Myt;

public:
 fpos(streamoff _Off = 0)
  : _Myoff(_Off), _Fpos(_Fpz), _Mystate()
  {
  }

 fpos(_Statetype _State, fpos_t _Fileposition)
  : _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
  {
  }

 _Statetype state() const
  {
  return (_Mystate);
  }

 void state(_Statetype _State)
  {
  _Mystate = _State;
  }

 fpos_t seekpos() const
  {
  return (_Fpos);
  }

 operator streamoff() const
  {
  return ((streamoff)(_Myoff + ((_Fpos)._Off)));
  }

 streamoff operator-(const _Myt& _Right) const
  {
  return ((streamoff)*this - (streamoff)_Right);
  }

 _Myt& operator+=(streamoff _Off)
  {
  _Myoff += _Off;
  return (*this);
  }

 _Myt& operator-=(streamoff _Off)
  {
  _Myoff -= _Off;
  return (*this);
  }

 _Myt operator+(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt operator-(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }

private:
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };

template<class _Statetype>
 bool operator==(const fpos<_Statetype>& _Left,
  const fpos<_Statetype>& _Right)
 {
 return ((streamoff)_Left == (streamoff)_Right);
 }

template<class _Statetype>
 bool operator!=(const fpos<_Statetype>& _Left,
  const fpos<_Statetype>& _Right)
 {
 return (!(_Left == _Right));
 }
# 138 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
typedef fpos<_Mbstatet> streampos;


typedef streampos wstreampos;


template<class _Elem,
 class _Int_type>
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

           static int compare(
  const _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  for (; 0 < _Count; --_Count, ++_First1, ++_First2)
   if (!eq(*_First1, *_First2))
    return (lt(*_First1, *_First2) ? -1 : +1);
  return (0);
  }

           static size_t
  length(const _Elem *_First)
  {
  size_t _Count = 0;
  for (; !eq(*_First, _Elem()); ++_First)
   ++_Count;
  return (_Count);
  }

           static _Elem *copy(
  _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  for (; 0 < _Count; --_Count, ++_Next, ++_First2)
   assign(*_Next, *_First2);
  return (_First1);
  }

           static const _Elem *find(
  const _Elem *_First,
  size_t _Count, const _Elem& _Ch)
  {
  for (; 0 < _Count; --_Count, ++_First)
   if (eq(*_First, _Ch))
    return (_First);
  return (0);
  }

           static _Elem *move(
  _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  if (_First2 < _Next && _Next < _First2 + _Count)
   for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
    assign(*--_Next, *--_First2);
  else
   for (; 0 < _Count; --_Count, ++_Next, ++_First2)
    assign(*_Next, *_First2);
  return (_First1);
  }

           static _Elem *assign(
  _Elem *_First,
  size_t _Count, _Elem _Ch)
  {
  _Elem *_Next = _First;
  for (; 0 < _Count; --_Count, ++_Next)
   assign(*_Next, _Ch);
  return (_First);
  }

 static void
  assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return ((int_type)_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
  }
# 297 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return ((int_type)(-1));
  }
 };


template<class _Elem>
 struct char_traits
  : public _Char_traits<_Elem, long>
 {
 };


template<>
 struct char_traits<char16_t>
 : public _Char_traits<char16_t, unsigned short>
 {
 };

typedef streampos u16streampos;


template<>
 struct char_traits<char32_t>
 : public _Char_traits<char32_t, unsigned int>
 {
 };

typedef streampos u32streampos;


template<>
 struct char_traits<wchar_t>
 {
 typedef wchar_t _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;


 static int compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : __builtin_wmemcmp(_First1, _First2, _Count));
  }
# 356 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static size_t length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : __builtin_wcslen(_First));
  }
# 369 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static _Elem *copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemcpy(_First1, _First2, _Count));
  }


 static const _Elem *find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *)__builtin_wmemchr(_First, _Ch, _Count));
  }
# 392 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static _Elem *move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemmove(_First1, _First2, _Count));
  }

 static _Elem *assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: wmemset(_First, _Ch, _Count));
  }

 static void assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return (_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }
# 484 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return (((:: wint_t)(-1)));
  }
 };


template<> struct char_traits<char>
 {
 typedef char _Elem;
 typedef _Elem char_type;
 typedef int int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;


 static int compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : __builtin_memcmp(_First1, _First2, _Count));
  }
# 517 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static size_t length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : __builtin_strlen(_First));
  }
# 530 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static _Elem *copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memcpy(_First1, _First2, _Count));
  }


 static const _Elem *find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *)__builtin_memchr(_First, _Ch, _Count));
  }
# 553 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static _Elem *move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memmove(_First1, _First2, _Count));
  }

 static _Elem *assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: memset(_First, _Ch, _Count));
  }

 static void assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return ((unsigned char)_Left < (unsigned char)_Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return ((unsigned char)_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }
# 645 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return ((-1));
  }
 };


template<class _Ty>
 class allocator;
class ios_base;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ios;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class istreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class ostreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_streambuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_istream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ostream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_iostream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringbuf;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_istringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_ostringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_filebuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ifstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ofstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_fstream;


typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
 allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
 allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
 allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
 allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;


typedef basic_filebuf<char, char_traits<char> > stdiobuf;
typedef basic_fstream<char, char_traits<char> > stdiostream;



typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
 wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
}


using ::std:: ios;
using ::std:: streambuf;
using ::std:: istream;
using ::std:: ostream;
using ::std:: iostream;

using ::std:: filebuf;
using ::std:: ifstream;
using ::std:: ofstream;
using ::std:: fstream;

using ::std:: stdiobuf;
using ::std:: stdiostream;
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 2 3


namespace std {





template<class _Ty> inline

 void swap(_Ty& _Left, _Ty& _Right)
  noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)

 {
 _Ty _Tmp = _Move(_Left);
 _Left = _Move(_Right);
 _Right = _Move(_Tmp);
 }






template<class _Ty,
 size_t _Size> inline

 void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])



  noexcept(noexcept(swap(*_Left, *_Right)))

 {
 if (&_Left != &_Right)
  {
  _Ty *_First1 = _Left;
  _Ty *_Last1 = _First1 + _Size;
  _Ty *_First2 = _Right;
  for (; _First1 != _Last1; ++_First1, ++_First2)
   swap(*_First1, *_First2);
  }
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
 {
 swap(*_Left, *_Right);
 }


template<class _Ty> inline
 bool _Swap_adl(_Ty& _Left, _Ty& _Right)
  noexcept(noexcept((swap(_Left, _Right), true)))
 {
 swap(_Left, _Right);
 return (true);
 }


struct piecewise_construct_t
 {



 };



constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


template<class...>
 class tuple;

template<class _Ty1,
 class _Ty2>
 struct pair
 {
 typedef pair<_Ty1, _Ty2> _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;
# 104 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
 constexpr pair()
  : first(), second()
  {
  }

 constexpr pair(const pair&) = default;
 constexpr pair(pair&&) = default;
# 121 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<const _Other1&, _Ty1>::value
   && is_convertible<const _Other2&, _Ty2>::value,
   void> >

  constexpr pair(const pair<_Other1, _Other2>& _Right)
   : first(_Right.first), second(_Right.second)
  {
  }
# 155 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<_Other1, _Ty1>::value
   && is_convertible<_Other2, _Ty2>::value,
   void> >

  constexpr pair(pair<_Other1, _Other2>&& _Right)
   : first(::std:: forward<_Other1>(_Right.first)),
    second(::std:: forward<_Other2>(_Right.second))
  {
  }
# 191 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
  constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
   : first(_Val1), second(_Val2)
  {
  }
# 219 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<_Other1, first_type>::value
   && is_convertible<_Other2, second_type>::value,
   void> >

  constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
   : first(::std:: forward<_Other1>(_Val1)),
    second(::std:: forward<_Other2>(_Val2))
  {
  }
# 247 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   integer_sequence<size_t, _Indexes1...>,
   integer_sequence<size_t, _Indexes2...>);
# 264 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
 template<class... _Types1,
  class... _Types2> inline
  pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2);

 struct _Deleted {};





 _Myt& operator=(const _Myt& _Right)

  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }
# 291 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
 template<class _Other1,
  class _Other2>

  _Myt& operator=(const pair<_Other1, _Other2>& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }





 _Myt& operator=(_Myt&& _Right)

   noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))

  {
  first = ::std:: forward<_Ty1>(_Right.first);
  second = ::std:: forward<_Ty2>(_Right.second);
  return (*this);
  }
# 322 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
 template<class _Other1,
  class _Other2>

  _Myt& operator=(pair<_Other1, _Other2>&& _Right)
  {
  first = ::std:: forward<_Other1>(_Right.first);
  second = ::std:: forward<_Other2>(_Right.second);
  return (*this);
  }

 void swap(_Myt& _Right)




  noexcept(noexcept((_Swap_adl(this->first, _Right.first))) && noexcept((_Swap_adl(this->second, _Right.second))))


  {
  if (this != &_Right)
   {
   _Swap_adl(first, _Right.first);
   _Swap_adl(second, _Right.second);
   }
  }

 _Ty1 first;
 _Ty2 second;
 };
# 365 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
template<class _Ty1,
 class _Ty2> inline

 void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)




  noexcept(noexcept(_Left.swap(_Right)))

 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first == _Right.first && _Left.second == _Right.second);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first < _Right.first
  || (!(_Right.first < _Left.first) && _Left.second < _Right.second));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type>
  make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
 {
 typedef pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type> _Mypair;
 return (_Mypair(::std:: forward<_Ty1>(_Val1),
  ::std:: forward<_Ty2>(_Val2)));
 }


 namespace rel_ops
  {
template<class _Ty> inline
 bool operator!=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty> inline
 bool operator>(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty> inline
 bool operator<=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty> inline
 bool operator>=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left < _Right));
 }
  }
}

namespace std {
template<class _Ty,
 size_t _Size>
 class array;


template<class _Tuple>
 struct tuple_size;


template<class _Ty,
 size_t _Size>
 struct tuple_size<array<_Ty, _Size> >

  : integral_constant<int, _Size>



 {
 };
# 505 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
template<class _Ty1,
 class _Ty2>
 struct tuple_size<pair<_Ty1, _Ty2> >

 : integral_constant<int, 2>



 {
 };
# 528 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
template<class... _Types>
 struct tuple_size<tuple<_Types...> >
 : integral_constant<size_t, sizeof...(_Types)>
 {
 };



template<class _Tuple, size_t>
 using _Tuple_size_sfinae = _Tuple;

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<const _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<volatile _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<const volatile _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };
# 584 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
template<size_t _Index,
 class _Tuple>
 struct tuple_element;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 struct tuple_element<_Idx, array<_Ty, _Size> >
 {
 tuple_element()
  {
  static_assert(_Idx < _Size, "array index out of bounds");
  }

 typedef _Ty type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<0, pair<_Ty1, _Ty2> >
 {
 typedef _Ty1 type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<1, pair<_Ty1, _Ty2> >
 {
 typedef _Ty2 type;
 };

template<size_t _Index>
 struct tuple_element<_Index, tuple<> >
 {
 static_assert(_Always_false<integral_constant<size_t, _Index> >::value,
  "tuple index out of bounds");
 };

template<class _This,
 class... _Rest>
 struct tuple_element<0, tuple<_This, _Rest...> >
 {
 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<size_t _Index,
 class _This,
 class... _Rest>
 struct tuple_element<_Index, tuple<_This, _Rest...> >
  : public tuple_element<_Index - 1, tuple<_Rest...> >
 {
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };



template<size_t _Index,
 class _Tuple>
 using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;




template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 0>) noexcept
 {
 return (_Pr.first);
 }

template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 1>) noexcept
 {
 return (_Pr.second);
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
 return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }


template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  _Ctype;
 return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }


template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
  get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
 return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<0>(::std:: move(_Pr)));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<1>(::std:: move(_Pr)));
 }
# 796 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
template<class _Ty,
 class _Other = _Ty> inline
 _Ty exchange(_Ty& _Val, _Other&& _New_val)
 {
 _Ty _Old_val = ::std:: move(_Val);
 _Val = ::std:: forward<_Other>(_New_val);
 return (_Old_val);
 }
# 845 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\utility" 3
}
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 1 3
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {
# 100 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
 {
 void _Orphan_all()
  {
  }

 void _Swap_all(_Container_base0&)
  {
  }


 _Container_proxy *_Myproxy;

 };

struct _Iterator_base0
 {
                _Iterator_base0()
  : _Myproxy(0), _Mynextiter(0)
  {
  }

 void _Adopt(const void *)
  {
  }

 const _Container_base0 *_Getcont() const
  {
  return (0);
  }


 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;

 };


struct _Container_proxy
 {
 _Container_proxy()
  : _Mycont(0), _Myfirstiter(0)
  {
  }

 const _Container_base12 *_Mycont;
 _Iterator_base12 *_Myfirstiter;
 };

struct _Container_base12
 {
public:
 _Container_base12()
  : _Myproxy(0)
  {
  }

 _Container_base12(const _Container_base12&)
  : _Myproxy(0)
  {
  }

 _Container_base12& operator=(const _Container_base12&)
  {
  return (*this);
  }

 ~_Container_base12() noexcept
  {
  _Orphan_all();
  }

 _Iterator_base12 **_Getpfirst() const
  {
  return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
  }

 void _Orphan_all();
 void _Swap_all(_Container_base12&);

 _Container_proxy *_Myproxy;
 };

struct _Iterator_base12
 {
public:
 _Iterator_base12()
  : _Myproxy(0), _Mynextiter(0)
  {
  }

 _Iterator_base12(const _Iterator_base12& _Right)
  : _Myproxy(0), _Mynextiter(0)
  {
  *this = _Right;
  }

 _Iterator_base12& operator=(const _Iterator_base12& _Right)
  {
  if (_Myproxy == _Right._Myproxy)
   ;
  else if (_Right._Myproxy != 0)
   _Adopt(_Right._Myproxy->_Mycont);
  else
   {




   }
  return (*this);
  }

 ~_Iterator_base12() noexcept
  {




  }

 void _Adopt(const _Container_base12 *_Parent)
  {
  if (_Parent == 0)
   {




   }
  else
   {
   _Container_proxy *_Parent_proxy = _Parent->_Myproxy;
# 249 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
   _Myproxy = _Parent_proxy;

   }
  }

 void _Clrcont()
  {
  _Myproxy = 0;
  }

 const _Container_base12 *_Getcont() const
  {
  return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
  }

 _Iterator_base12 **_Getpnext()
  {
  return (&_Mynextiter);
  }

 void _Orphan_me()
  {
# 284 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
  }

 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;
 };


inline void _Container_base12::_Orphan_all()
 {
# 304 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
 }

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
 {




 _Container_proxy *_Temp = _Myproxy;
 _Myproxy = _Right._Myproxy;
 _Right._Myproxy = _Temp;

 if (_Myproxy != 0)
  _Myproxy->_Mycont = (_Container_base12 *)this;
 if (_Right._Myproxy != 0)
  _Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
 }


typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;







struct _Zero_then_variadic_args_t
 {
 };

struct _One_then_variadic_args_t
 {
 };

template<class _Ty1,
 class _Ty2,
 bool = is_empty<_Ty1>::value>
 class _Compressed_pair
  : private _Ty1
 {
private:
 _Ty2 _Myval2;

public:
 _Compressed_pair()
  {
  }

 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Ty1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 _Compressed_pair(const _Compressed_pair& _Right)
  : _Ty1(_Right),
   _Myval2(_Right._Myval2)
  {
  }

 _Compressed_pair(_Compressed_pair&& _Right)
  : _Ty1(::std:: move(_Right)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Compressed_pair& operator=(_Compressed_pair&& _Right)
  {
  *this = ::std:: move(_Right);
  return (*this);
  }

 _Ty1& _Get_first() noexcept
  {
  return (*this);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (*this);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (*this);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (*this);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };

template<class _Ty1,
 class _Ty2>
 class _Compressed_pair<_Ty1, _Ty2, false>
 {
private:
 _Ty1 _Myval1;
 _Ty2 _Myval2;

public:
 _Compressed_pair()
  {
  }

 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Myval1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 _Compressed_pair& operator=(_Compressed_pair&& _Right)
  {
  _Myval1 = ::std:: forward<_Ty1>(_Right._Myval1);
  _Myval2 = ::std:: forward<_Ty2>(_Right._Myval2);
  return (*this);
  }

 _Compressed_pair(const _Compressed_pair& _Right)
  : _Myval1(::std:: move(_Right._Myval1)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Compressed_pair(_Compressed_pair&& _Right)
  : _Myval1(::std:: move(_Right._Myval1)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Ty1& _Get_first() noexcept
  {
  return (_Myval1);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (_Myval1);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (_Myval1);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (_Myval1);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };






template<class _Ty>
 struct _Get_unchecked_type
  { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::_Unchecked_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Ty>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class = void>
 struct _Is_checked_helper
  : false_type
 {
 };

template<class _Ty>
 struct _Is_checked_helper<_Ty, typename _Param_tester<
  typename _Ty::_Unchecked_type>::type>
  : true_type
 {
 };


template<class _Iter> inline
 typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
 {
 return (typename _Is_checked_helper<_Iter>::type());
 }


template<class _Iter> inline
 _Iter _Unchecked(_Iter _Src)
 {
 return (_Src);
 }


template<class _Iter,
 class _UIter> inline
 _Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
 {
 _Dest = _Src;
 return (_Dest);
 }



struct input_iterator_tag
 {
 };

struct _Mutable_iterator_tag
 {
 };

struct output_iterator_tag
 : _Mutable_iterator_tag
 {
 };

struct forward_iterator_tag
 : input_iterator_tag, _Mutable_iterator_tag
 {
 };

struct bidirectional_iterator_tag
 : forward_iterator_tag
 {
 };

struct random_access_iterator_tag
 : bidirectional_iterator_tag
 {
 };


struct _Int_iterator_tag
 {
 };



struct _Nonscalar_ptr_iterator_tag
 {
 };
struct _Scalar_ptr_iterator_tag
 {
 };


template<class _Category,
 class _Ty,
 class _Diff = ptrdiff_t,
 class _Pointer = _Ty *,
 class _Reference = _Ty&>
 struct iterator
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;
 typedef _Diff distance_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
 };

template<class _Category,
 class _Ty,
 class _Diff,
 class _Pointer,
 class _Reference,
 class _Base>
 struct _Iterator012
  : public _Base
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;
 typedef _Diff distance_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
 };


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;


template<class,
 class = void>
 struct _Is_iterator
  : false_type
 {
 };

template<class _Ty>
 struct _Is_iterator<_Ty, typename _Param_tester<
  typename _Ty::iterator_category,
  typename _Ty::value_type,
  typename _Ty::difference_type,
  typename _Ty::pointer,
  typename _Ty::reference
  >::type>
  : true_type
 {
 };

template<class _Ty>
 struct _Is_iterator<_Ty *>
  : true_type
 {
 };


template<class _Iter,
 bool = _Is_iterator<_Iter>::value>
 struct _Iterator_traits_base
 {
 typedef typename _Iter::iterator_category iterator_category;
 typedef typename _Iter::value_type value_type;
 typedef typename _Iter::difference_type difference_type;
 typedef difference_type distance_type;
 typedef typename _Iter::pointer pointer;
 typedef typename _Iter::reference reference;
 };

template<class _Iter>
 struct _Iterator_traits_base<_Iter, false>
 {
 };

template<class _Iter>
 struct iterator_traits
  : _Iterator_traits_base<_Iter>
 {
 };

template<class _Ty>
 struct iterator_traits<_Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;
 typedef ptrdiff_t distance_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;
 };

template<class _Ty>
 struct iterator_traits<const _Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;
 typedef ptrdiff_t distance_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 };


template<> struct iterator_traits<_Bool>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<char>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<signed char>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<unsigned char>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<wchar_t>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<short>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<unsigned short>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<int>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<unsigned int>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<long>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<unsigned long>
 {
 typedef _Int_iterator_tag iterator_category;
 };


template<> struct iterator_traits<long long>
 {
 typedef _Int_iterator_tag iterator_category;
 };

template<> struct iterator_traits<unsigned long long>
 {
 typedef _Int_iterator_tag iterator_category;
 };




template<class _Iter> inline
                typename iterator_traits<_Iter>::iterator_category
  _Iter_cat(const _Iter&)
 {
 typename iterator_traits<_Iter>::iterator_category _Cat;
 return (_Cat);
 }



template<class _Ty1, class _Ty2> inline
auto _Ptr_cat(_Ty1&, _Ty2&)
  -> typename std::conditional<(

      (!std::is_pointer<_Ty1>::value) ||

      (!std::is_pointer<_Ty2>::value) ||

      ((std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ) ||
      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
        std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value )) ||

      (std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
      !std::is_same<typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::type>::type,
                    typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::type>::type >::value ) ||

      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
       (!std::is_same<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type,
                     typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ))),
        _Nonscalar_ptr_iterator_tag,
        _Scalar_ptr_iterator_tag>::type {

  typename std::conditional<(

      (!std::is_pointer<_Ty1>::value) ||

      (!std::is_pointer<_Ty2>::value) ||

      ((std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ) ||
      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
        std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value )) ||

      (std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
      !std::is_same<typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::type>::type,
                    typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::type>::type >::value ) ||

      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
       (!std::is_same<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type,
                     typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ))),
        _Nonscalar_ptr_iterator_tag,
        _Scalar_ptr_iterator_tag>::type _Cat;


    return (_Cat);
}
# 894 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
inline _Scalar_ptr_iterator_tag _Ptr_cat(bool *, bool *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const bool *, bool *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(char *, char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const char *, char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(signed char *, signed char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const signed char *, signed char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned char *,
 unsigned char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned char *,
 unsigned char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(short *, short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const short *, short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned short *,
 unsigned short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned short *,
 unsigned short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(int *, int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const int *, int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned int *, unsigned int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned int *, unsigned int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(long *, long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long *, long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned long *,
 unsigned long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long *,
 unsigned long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(float *, float *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const float *, float *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(double *, double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const double *, double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(long double *, long double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long double *, long double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }


inline _Scalar_ptr_iterator_tag _Ptr_cat(long long *, long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long long *, long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned long long *, unsigned long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long long *, unsigned long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }
# 1325 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
template<class _Iter> inline
 typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
 {
 return (0);
 }


template<class _InIt,
 class _Diff> inline
                void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _FwdIt,
 class _Diff> inline
                void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _BidIt,
 class _Diff> inline
                void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
 {
 for (; 0 < _Off; --_Off)
  ++_Where;
 for (; _Off < 0; ++_Off)
  --_Where;
 }

template<class _RanIt,
 class _Diff> inline
                void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
 {
 _Where += _Off;
 }

template<class _InIt,
 class _Diff> inline
                void advance(_InIt& _Where, _Diff _Off)
 {
 _Advance(_Where, _Off, _Iter_cat(_Where));
 }


template<class _Iter> inline
 typename iterator_traits<_Iter>::difference_type
  *_Dist_type(_Iter)
 {
 return (0);
 }


template<class _InIt,
 class _Diff> inline
                 void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
   input_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _FwdIt,
 class _Diff> inline
                 void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
   forward_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _BidIt,
 class _Diff> inline
                 void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
   bidirectional_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _RanIt,
 class _Diff> inline
                 void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
   random_access_iterator_tag)
 {
# 1431 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
 _Off += _Last - _First;
 }

template<class _InIt> inline
                typename iterator_traits<_InIt>::difference_type
  distance(_InIt _First, _InIt _Last)
 {
 typename iterator_traits<_InIt>::difference_type _Off = 0;
 _Distance2(_First, _Last, _Off, _Iter_cat(_First));
 return (_Off);
 }

template<class _InIt,
 class _Diff> inline
  void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
 {
 _Distance2(_First, _Last, _Off, _Iter_cat(_First));
 }
# 1464 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
template<class _FwdIt> inline
 _FwdIt next(_FwdIt _First,
  typename iterator_traits<_FwdIt>::difference_type _Off = 1)
 {
 static_assert((is_base_of<forward_iterator_tag, typename iterator_traits<_FwdIt>::iterator_category>::value), "next requires forward iterator");



 ::std:: advance(_First, _Off);
 return (_First);
 }



template<class _BidIt> inline
                _BidIt prev(_BidIt _First,
  typename iterator_traits<_BidIt>::difference_type _Off = 1)
 {
 static_assert((is_base_of<bidirectional_iterator_tag, typename iterator_traits<_BidIt>::iterator_category>::value), "prev requires bidirectional iterator");



 ::std:: advance(_First, -_Off);
 return (_First);
 }


template<class _Ty>
 struct pointer_traits;

template<class _RanIt,
 class _Base>
 class _Revranit
  : public _Base
 {
public:
 typedef _Revranit<_RanIt, _Base> _Myt;
 typedef typename _Base::difference_type difference_type;
 typedef typename _Base::pointer pointer;
 typedef typename _Base::reference reference;
 typedef _RanIt iterator_type;

                _Revranit()
  : current()
  {
  }

                explicit _Revranit(_RanIt _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2,
  class _Base2>
  _Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
  : current(_Right.base())
  {
  }

                _RanIt base() const
  {
  return (current);
  }

                reference operator*() const
  {
  _RanIt _Tmp = current;
  return (*--_Tmp);
  }

                pointer operator->() const
  {
  return (::std:: addressof(operator*()));
  }

                _Myt& operator++()
  {
  --current;
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  ++current;
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

 template<class _RanIt2,
  class _Base2>
  bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
  {
  return (current == _Right.base());
  }



                _Myt& operator+=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

                _Myt& operator-=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 template<class _RanIt2,
  class _Base2>
  bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
  {
  return (_Right.base() < current);
  }

 difference_type operator-(const _Myt& _Right) const
  {
  return (_Right.base() - current);
  }

protected:
 _RanIt current;
 };


template<class _RanIt>
 class reverse_iterator
  : public _Revranit<_RanIt, iterator<
   typename iterator_traits<_RanIt>::iterator_category,
   typename iterator_traits<_RanIt>::value_type,
   typename iterator_traits<_RanIt>::difference_type,
   typename iterator_traits<_RanIt>::pointer,
   typename iterator_traits<_RanIt>::reference> >
 {
 typedef reverse_iterator<_RanIt> _Myt;
 typedef _Revranit<_RanIt, iterator<
  typename iterator_traits<_RanIt>::iterator_category,
  typename iterator_traits<_RanIt>::value_type,
  typename iterator_traits<_RanIt>::difference_type,
  typename iterator_traits<_RanIt>::pointer,
  typename iterator_traits<_RanIt>::reference> > _Mybase;

public:
 typedef typename iterator_traits<_RanIt>::difference_type difference_type;
 typedef typename iterator_traits<_RanIt>::pointer pointer;
 typedef typename iterator_traits<_RanIt>::reference reference;
 typedef _RanIt iterator_type;

                reverse_iterator()
  {
  }

                explicit reverse_iterator(_RanIt _Right)
  : _Mybase(_Right)
  {
  }

 template<class _Other>
                 reverse_iterator(const reverse_iterator<_Other>& _Right)
  : _Mybase(_Right.base())
  {
  }

 reverse_iterator(_Mybase _Right)
  : _Mybase(_Right)
  {
  }

 template<class _Other>
                 _Myt& operator=(const reverse_iterator<_Other>& _Right)
  {
  this->current = _Right.base();
  return (*this);
  }

                _Myt& operator++()
  {
  ++*((_Mybase *)this);
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  --*((_Mybase *)this);
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myt& operator+=(difference_type _Off)
  {
  *((_Mybase *)this) += _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myt& operator-=(difference_type _Off)
  {
  *((_Mybase *)this) -= _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }
 };

template<class _RanIt>
 struct _Is_checked_helper<reverse_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt> inline
                reverse_iterator<_RanIt> operator+(
  typename reverse_iterator<_RanIt>::difference_type _Off,
  const reverse_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
                auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
   -> decltype(_Right.base() - _Left.base())
 {
 return (_Right.base() - _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator==(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Left.base() == _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator!=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right.base() < _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }



template<class _RanIt> inline
                reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
 {
 return (reverse_iterator<_RanIt>(_Iter));
 }




template<class _Container>
                auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
                auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
                auto inline end(_Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Container>
                auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array);
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array + _Size);
 }



template<class _Ty>
 class valarray;
template<class _Ty>
 _Ty *begin(valarray<_Ty>&);
template<class _Ty>
 const _Ty *begin(const valarray<_Ty>&);
template<class _Ty>
 _Ty *end(valarray<_Ty>&);
template<class _Ty>
 const _Ty *end(const valarray<_Ty>&);

template<class _Container>
 constexpr auto inline cbegin(const _Container& _Cont)
  noexcept(noexcept(::std:: begin(_Cont)))
  -> decltype(::std:: begin(_Cont))
 {
 return (::std:: begin(_Cont));
 }

template<class _Container>
 constexpr auto inline cend(const _Container& _Cont)
  noexcept(noexcept(::std:: end(_Cont)))
  -> decltype(::std:: end(_Cont))
 {
 return (::std:: end(_Cont));
 }


template<class _Container>
                auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
                auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
                auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Container>
                auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Ty,
 size_t _Size> inline
                reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array + _Size));
 }

template<class _Ty,
 size_t _Size> inline
                reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array));
 }

template<class _Elem> inline
                reverse_iterator<const _Elem *>
  rbegin(::std:: initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.end()));
 }

template<class _Elem> inline
                reverse_iterator<const _Elem *>
  rend(::std:: initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.begin()));
 }


template<class _Container>
                auto inline crbegin(const _Container& _Cont)
  -> decltype(::std:: rbegin(_Cont))
 {
 return (::std:: rbegin(_Cont));
 }

template<class _Container>
                auto inline crend(const _Container& _Cont)
  -> decltype(::std:: rend(_Cont))
 {
 return (::std:: rend(_Cont));
 }
# 2008 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
template<class _Container,
 class _Pr> inline
 void _Erase_nodes_if(_Container& _Cont, _Pr _Pred)
 {
 auto _First = _Cont.begin();
 auto _Last = _Cont.end();
                                          ;
 while (_First != _Last)
  if (_Pred(*_First))
   _First = _Cont.erase(_First);
  else
   ++_First;
 }



template<class _Ty,
 size_t _Size>
 class _Array_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty&,
   _Iterator_base>
 {
public:
 typedef _Array_const_iterator<_Ty, _Size> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;


                _Array_const_iterator()
  {
  _Ptr = 0;
  }

                explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
  : _Ptr{_Parg + _Off}
  {

  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

                reference operator*() const
  {
  return (*_Ptr);
  }

                pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

                _Myiter& operator++()
  {
  ++_Ptr;
  return (*this);
  }

                _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myiter& operator--()
  {
  --_Ptr;
  return (*this);
  }

                _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myiter& operator+=(difference_type _Off)
  {
  _Ptr += _Off;
  return (*this);
  }

                _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

                _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

                difference_type operator-(const _Myiter& _Right) const
  {
  return (_Ptr - _Right._Ptr);
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

                bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

                bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

                bool operator<(const _Myiter& _Right) const
  {
  return (_Ptr < _Right._Ptr);
  }

                bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

                bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

                bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }

 pointer _Ptr;
# 2370 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xiter" 3
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size>&
  _Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
   typename _Array_const_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
                _Array_const_iterator<_Ty, _Size> operator+(
  typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
  _Array_const_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _Ty,
 size_t _Size>
 class _Array_iterator
  : public _Array_const_iterator<_Ty, _Size>
 {
public:
 typedef _Array_iterator<_Ty, _Size> _Myiter;
 typedef _Array_const_iterator<_Ty, _Size> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;

                _Array_iterator()
  {
  }

                explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
  : _Mybase(_Parg, _Off)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  ((_Mybase *)this)->_Rechecked(_Right);
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return ((pointer)((_Mybase *)this)->_Unchecked());
  }

                reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

                pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

                _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

                _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

                _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

                _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

                _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

                difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size>&
  _Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
   typename _Array_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
                _Array_iterator<_Ty, _Size> operator+(
  typename _Array_iterator<_Ty, _Size>::difference_type _Off,
  _Array_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _RanIt>
 class move_iterator
 {
public:
 typedef move_iterator<_RanIt> _Myt;
 typedef typename iterator_traits<_RanIt>::iterator_category
  iterator_category;
 typedef typename iterator_traits<_RanIt>::value_type
  value_type;
 typedef typename iterator_traits<_RanIt>::difference_type
  difference_type;
 typedef _RanIt pointer;






 typedef value_type&& reference;

 typedef _RanIt iterator_type;

                move_iterator()
  : current()
  {
  }

                explicit move_iterator(iterator_type _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2>
                 move_iterator(const move_iterator<_RanIt2>& _Right)
  : current(_Right.base())
  {
  }

 template<class _RanIt2>
                 _Myt& operator=(const move_iterator<_RanIt2>& _Right)
  {
  current = _Right.base();
  return (*this);
  }

                _RanIt base() const
  {
  return (current);
  }

                reference operator*() const
  {
  return (::std:: move(*current));
  }

                pointer operator->() const
  {
  return (current);
  }

                _Myt& operator++()
  {
  ++current;
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  --current;
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 template<class _RanIt2>
                 bool _Equal(const move_iterator<_RanIt2>& _Right) const
  {
  return (current == _Right.base());
  }



                _Myt& operator+=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

                _Myt& operator-=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

                reference operator[](difference_type _Off) const
  {
  return (::std:: move(current[_Off]));
  }

 template<class _RanIt2>
                 bool _Less(const move_iterator<_RanIt2>& _Right) const
  {
  return (current < _Right.base());
  }

                difference_type operator-(const _Myt& _Right) const
  {
  return (current - _Right.base());
  }

protected:
 iterator_type current;
 };

template<class _RanIt>
 struct _Is_checked_helper<move_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt,
 class _Diff> inline
                move_iterator<_RanIt>
  operator+(_Diff _Off,
  const move_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
                auto inline operator-(
  move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
   -> decltype(_Left.base() - _Right.base())
 {
 return (_Left.base() - _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator==(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator!=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt> inline
                move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
 {
 return (move_iterator<_RanIt>(_Iter));
 }
}


#pragma clang diagnostic pop
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xscan" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xscan" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xscan" 2 3

namespace std {

template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_Dest)
  ::std:: iter_swap(_First1, _Dest);
 return (_Dest);
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 return (_Swap_ranges(_Unchecked(_First1), _Unchecked(_Last1),
  _Dest));
 }
# 99 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xscan" 3
template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
 return (_Rechecked(_First,
  _Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: lower_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (!_Pred(_Val, *_Mid))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
 return (_Rechecked(_First,
  _Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: upper_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  _Equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else if (_Pred(_Val, *_Mid))
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = ::std:: lower_bound(_First, _Mid, _Val, _Pred);
   ::std:: advance(_First, _Count);
   _FwdIt _Last2 = ::std:: upper_bound(++_Mid, _First, _Val, _Pred);
   return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
   }
  }

 return (pair<_FwdIt, _FwdIt>(_First, _First));
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred)
 {
 pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
  _Equal_range(_Unchecked(_First), _Unchecked(_Last),
   _Val, _Pred, _Dist_type(_First)));
 return (pair<_FwdIt, _FwdIt>(
  _Rechecked(_First, _Ans.first),
  _Rechecked(_Last, _Ans.second)));
 }


template<class _FwdIt,
 class _Ty> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val)
 {
 return (::std:: equal_range(_First, _Last, _Val, less<>()));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = ::std:: move(*_First);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Move(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Move(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 357 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xscan" 3
template<class _Ty>
 struct _Match_pred
 {
 _Match_pred(const _Ty& _Val_arg)
  : _Val(_Val_arg)
  {
  }
 bool operator()(const _Ty& _Val_arg) const
  {
  return (_Val_arg == _Val);
  }
private:
 const _Ty& _Val;
 };

template<class _Ty>
 _Match_pred<_Ty> _Make_match_pred(const _Ty& _Val)
 {
 return (_Match_pred<_Ty>(_Val));
 }


template<class _Fn1>
 struct _Negation_pred
 {
 _Negation_pred(const _Fn1& _F1)
  : _Func1(_F1)
  {
  }

 template<class _Ty>
  bool operator()(const _Ty& _Val) const
  {
  return (!_Func1(_Val));
  }
private:
 _Fn1 _Func1;
 };

template<class _Fn1>
 _Negation_pred<_Fn1> _Make_negation(const _Fn1& _F1)
 {
 return (_Negation_pred<_Fn1>(_F1));
 }
}
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 2 3

 namespace std {

template<class _FwdIt,
 class _Pr> inline
                pair<_FwdIt, _FwdIt>
  _Minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 pair<_FwdIt, _FwdIt> _Found(_First, _First);
 if (_First != _Last)
  for (; ++_First != _Last; )
   {
   _FwdIt _Next = _First;
   if (++_Next == _Last)
    {
    if (_Pred(*_First, *_Found.first))
     _Found.first = _First;
    else if (!_Pred(*_First, *_Found.second))
     _Found.second = _First;
    }
   else
    {
    if (_Pred(*_Next, *_First))
     {
     if (_Pred(*_Next, *_Found.first))
      _Found.first = _Next;
     if (!_Pred(*_First, *_Found.second))
      _Found.second = _First;
     }
    else
     {
     if (_Pred(*_First, *_Found.first))
      _Found.first = _First;
     if (!_Pred(*_Next, *_Found.second))
      _Found.second = _Next;
     }
    _First = _Next;
    }
   }
 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
                pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                                                                        ;
 pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
  _Minmax_element(_Unchecked(_First), _Unchecked(_Last), _Pred));
 return (pair<_FwdIt, _FwdIt>(
  _Rechecked(_First, _Ans.first),
  _Rechecked(_Last, _Ans.second)));
 }


template<class _FwdIt> inline
                pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: minmax_element(_First, _Last, less<>()));
 }


template<class _Ty> inline
 constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
 {
 return (((_Left) < (_Right)) ? _Right : _Left);
 }

template<class _Ty> inline
 constexpr _Ty (max)(::std:: initializer_list<_Ty> _Ilist)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (((*_Found) < (*_Next)))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty,
 class _Pr> inline
 constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right,
  _Pr _Pred)
 {
 return (_Pred(_Left, _Right) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline
 constexpr _Ty (max)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (_Pred(*_Found, *_Next))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty> inline
 constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
 {
 return (((_Right) < (_Left)) ? _Right : _Left);
 }

template<class _Ty> inline
 constexpr _Ty (min)(::std:: initializer_list<_Ty> _Ilist)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (((*_Next) < (*_Found)))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty,
 class _Pr> inline
 constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right,
  _Pr _Pred)
 {
 return (_Pred(_Right, _Left) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline
 constexpr _Ty (min)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (_Pred(*_Next, *_Found))
   _Found = _Next;
 return (*_Found);
 }
# 163 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _Ty> inline
 constexpr pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty> inline
 constexpr pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist)
 {





 const _Ty *_First = _Ilist.begin();
 const _Ty *_Last = _Ilist.end();
 const _Ty *_Largest = _First;

 if (_First != _Last)
  {
  for (const _Ty *_Next = _First; ++_Next != _Last; )
   if (*_Next < *_First)
    _First = _Next;
   else if (!(*_Next < *_Largest))
    _Largest = _Next;
  }
 return (pair<_Ty, _Ty>(*_First, *_Largest));

 }


template<class _Ty,
 class _Pr> inline
 constexpr pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
 {
 return (_Pred(_Right, _Left)
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty,
 class _Pr> inline
 constexpr pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist,
  _Pr _Pred)
 {





 const _Ty *_First = _Ilist.begin();
 const _Ty *_Last = _Ilist.end();
 const _Ty *_Largest = _First;

 if (_First != _Last)
  {
  for (const _Ty *_Next = _First; ++_Next != _Last; )
   if (_Pred(*_Next, *_First))
    _First = _Next;
   else if (!_Pred(*_Next, *_Largest))
    _Largest = _Next;
  }
 return (pair<_Ty, _Ty>(*_First, *_Largest));

 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Copy_impl(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt copy(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Copy_impl(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 337 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag)
 {
 *_Dest = *_First;
 while (0 < --_Count)
  *++_Dest = *++_First;
 return (++_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 return (_Copy_n(_First, _Count,
  _Dest, _Iter_cat(_First)));
 }
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 return (_Copy_n(_First, _Count,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 if (_Count <= 0)
  return (_Dest);
 else
  return (_Rechecked(_Dest,
   _Copy_n(_Unchecked(_First), _Count,
    _Unchecked(_Dest))));
 }
# 525 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = *--_Last;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_backward(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest - _Count, &*_First,
  _Count * sizeof (*_First));
 return (_Dest - _Count);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Copy_backward(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Rechecked(_Dest,
  _Copy_backward(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 597 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = ::std:: move(*--_Last);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_backward(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest - _Count, &*_First,
  _Count * sizeof (*_First));
 return (_Dest - _Count);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Move_backward(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Rechecked(_Dest,
  _Move_backward(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 669 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _FwdIt,
 class _Ty> inline
 void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First)
  *_First = _Val;
 }

inline void _Fill(char *_First, char *_Last, char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

template<class _FwdIt,
 class _Ty> inline
 void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
                            ;
 _Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest)
  *_Dest = _Val;
 return (_Dest);
 }

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
 signed char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
 unsigned char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
 }
# 803 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (true);
 }

inline bool _Equal(const char *_First1, const char *_Last1,
 const char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
 const signed char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
 const unsigned char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Pred));
 }
# 893 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2)
 {
 return (::std:: equal(_First1, _Last1, _First2,
  equal_to<>()));
 }

template<class _InIt1,
 class _InTy,
 size_t _InSize> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InTy (&_First2)[_InSize])
 {
 return (::std:: equal(_First1, _Last1, _First2,
  equal_to<>()));
 }



template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
   input_iterator_tag, input_iterator_tag)
 {

                                                                 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
   random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
                                            ;
 return (_Equal(_First1, _Last1, _First2, _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
 return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Iter_cat(_First1), _Iter_cat(_First2)));
 }


template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: equal(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }



template<class _InIt,
 class _Pr> inline
 _InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   break;
 return (_First);
 }

template<class _InIt,
 class _Pr> inline
 _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _InIt1,
 class _InIt2> inline
 bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (((*_First1) < (*_First2)))
   return (true);
  else if (*_First2 < *_First1)
   return (false);
 return (_First1 == _Last1 && _First2 != _Last2);
 }

inline bool _Lexicographical_compare(
 const unsigned char *_First1, const unsigned char *_Last1,
 const unsigned char *_First2, const unsigned char *_Last2)
 {
 ptrdiff_t _Num1 = _Last1 - _First1;
 ptrdiff_t _Num2 = _Last2 - _First2;
 int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
 return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
 }
# 1023 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
                              ;
                              ;
 return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2)));
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  {
  if (_Pred(*_First1, *_First2))
   return (true);
  else if (_Pred(*_First2, *_First1))
   return (false);
  }
 return (_First1 == _Last1 && _First2 != _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred));
 }


template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
 {
 return ((-0x7f - 1) <= _Val && _Val <= 0x7f);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
 {
 return (_Val <= 0x7f || static_cast<_Ty>((-0x7f - 1)) <= _Val);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
 {
 return (_Val <= 0x7f);
 }

template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
 {
 return (0 <= _Val && _Val <= 0xff);
 }

template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
 {
 return (_Val <= 0xff);
 }

template<class _InIt,
 class _Ty> inline
 bool _Within_limits(_InIt, const _Ty& _Val)
 {
 typedef typename remove_pointer<_InIt>::type _Elem;
 return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
  integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
 }

template<class _InIt> inline
 bool _Within_limits(_InIt, const bool&)
 {
 return (true);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
 {
 if (!_Within_limits(_First, _Val))
  return (_Last);
 _First = static_cast<_InIt>(:: memchr(
  _First, static_cast<unsigned char>(_Val), _Last - _First));
 return (_First ? _First : _Last);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
 {
 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   break;
 return (_First);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {

 typedef integral_constant<bool,
  (is_same<_InIt, char *>::value
  || is_same<_InIt, signed char *>::value
  || is_same<_InIt, unsigned char *>::value
  || is_same<_InIt, const char *>::value
  || is_same<_InIt, const signed char *>::value
  || is_same<_InIt, const unsigned char *>::value)
  && is_integral<_Ty>::value
 > _Memchr_opt;
 return (_Find(_First, _Last, _Val, _Memchr_opt()));
 }

template<class _InIt,
 class _Ty> inline
 _InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Rechecked(_First,
  _Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   break;
 return (_First);
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _FwdIt _Next = _First;
 for (++_First; _First != _Last; ++_First)
 if (!_Pred(*_First))
  *_Next++ = _Move(*_First);
 return (_Next);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _First = ::std:: find_if(_First, _Last, _Pred);
 if (_First == _Last)
  return (_First);
 else
  return (_Rechecked(_First,
   _Remove_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt _Remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _FwdIt _Next = _First;
 for (++_First; _First != _Last; ++_First)
  if (!(*_First == _Val))
   *_Next++ = _Move(*_First);
 return (_Next);
 }

template<class _FwdIt,
 class _Ty> inline
 _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _First = ::std:: find(_First, _Last, _Val);
 if (_First == _Last)
  return (_First);
 else
  return (_Rechecked(_First,
   _Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty> inline
 typename iterator_traits<_InIt>::difference_type
  _Count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   ++_Count;
 return (_Count);
 }

template<class _InIt,
 class _Ty> inline
 typename iterator_traits<_InIt>::difference_type
  count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Count(_Unchecked(_First), _Unchecked(_Last), _Val));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 typename iterator_traits<_InIt>::difference_type
  _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   ++_Count;
 return (_Count);
 }



template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr,
  forward_iterator_tag, forward_iterator_tag)
 {
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred,
  bidirectional_iterator_tag, bidirectional_iterator_tag)
 {

 while (_Pred(*--_Last1, *--_Last2))
  ;
 ++_Last1;
 ++_Last2;
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
 _Trim_matching_suffixes(_Last1, _Last2, _Pred,
  _Iter_cat(_Last1), _Iter_cat(_Last2));
 typedef typename iterator_traits<_FwdIt1>::difference_type _Diff1;
 typedef typename iterator_traits<_FwdIt2>::difference_type _Diff2;
 for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
  if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
   {
   _Diff2 _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
   if (_Count2 == 0)
    return (false);
   _FwdIt1 _Skip1 = ::std:: next(_Next1);
   _Diff1 _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
   if (_Count2 != _Count1)
    return (false);
   }
 return (true);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   _FwdIt2 _Last2 = ::std:: next(_First2,
    ::std:: distance(_First1, _Last1));
   return (_Check_match_counts(_First1, _Last1,
    _First2, _Last2, _Pred));
   }
 return (true);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Pred));
 }
# 1383 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, equal_to<>()));
 }

template<class _FwdIt1,
 class _InTy,
 size_t _InSize> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _InTy (&_First2)[_InSize])
 {
 return (::std:: is_permutation(_First1, _Last1, _First2, equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
  forward_iterator_tag, forward_iterator_tag)
 {

                                                                 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   if (::std:: distance(_First1, _Last1)
    != ::std:: distance(_First2, _Last2))
    return (false);
   else
    return (_Check_match_counts(_First1, _Last1,
     _First2, _Last2, _Pred));
   }
 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
  random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
                                            ;
 return (_Is_permutation(_First1, _Last1, _First2, _Pred));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {

                              ;
                              ;
 return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
  _Iter_cat(_First1), _Iter_cat(_First2)));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, _Last2, equal_to<>()));
 }



template<class _BidIt> inline
 void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
 {
 for (; _First != _Last && _First != --_Last; ++_First)
  ::std:: iter_swap(_First, _Last);
 }

template<class _BidIt> inline
 void reverse(_BidIt _First, _BidIt _Last)
 {
                            ;
 _Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
 }


template<class _FwdIt> inline
 _FwdIt _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag)
 {
 for (_FwdIt _Next = _Mid, _Res = _Last; ; )
  {
  ::std:: iter_swap(_First, _Next);
  if (++_First == _Mid)
   {
   if (++_Next == _Last)
    return (_Res == _Last ? _Mid : _Res);
   else
    _Mid = _Next;
   }
  else if (++_Next == _Last)
   {
   if (_Res == _Last)
    _Res = _First;
   _Next = _Mid;
   }
  }
 }

template<class _BidIt> inline
 pair<_BidIt, _BidIt> _Reverse_until_sentinel(
  _BidIt _First, _BidIt _Sentinel, _BidIt _Last)
 {
 while (_First != _Sentinel && _Last != _Sentinel)
  ::std:: iter_swap(_First++, --_Last);
 return (::std:: make_pair(_First, _Last));
 }

template<class _BidIt> inline
 _BidIt _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag)
 {
 ::std:: reverse(_First, _Mid);
 ::std:: reverse(_Mid, _Last);
 pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel(_First, _Mid, _Last);
 ::std:: reverse(_Tmp.first, _Tmp.second);
 return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
 }

template<class _RanIt> inline
 _RanIt _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag)
 {
 ::std:: reverse(_First, _Mid);
 ::std:: reverse(_Mid, _Last);
 ::std:: reverse(_First, _Last);
 return (_First + (_Last - _Mid));
 }

template<class _FwdIt> inline
 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
 {
                           ;
                          ;
 if (_First == _Mid)
  return (_Last);
 if (_Mid == _Last)
  return (_First);
 _Rechecked(_First, _Rotate(_Unchecked(_First), _Unchecked(_Mid),
  _Unchecked(_Last), _Iter_cat(_First)));
 return (_First);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr> inline
 _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *,
  forward_iterator_tag, forward_iterator_tag)
 {
 for (; ; ++_First1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (_Mid1 == _Last1)
    return (_Last1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr> inline
 _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *,
  random_access_iterator_tag, random_access_iterator_tag)
 {
 _Diff1 _Count1 = _Last1 - _First1;
 _Diff2 _Count2 = _Last2 - _First2;

 for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }
 return (_Last1);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Rechecked(_First1,
  _Search(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Dist_type(_First1), _Dist_type(_First2),
   _Iter_cat(_First1), _Iter_cat(_First2))));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: search(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _Diff,
 class _Urng>
 class _Rng_from_urng
 {
public:
 typedef make_unsigned_t<_Diff> _Ty0;
 typedef typename _Urng::result_type _Ty1;

 typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
  _Ty0, _Ty1>::type _Udiff;

 explicit _Rng_from_urng(_Urng& _Func)
  : _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
  {
  for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
   --_Bits;
  }

 _Diff operator()(_Diff _Index)
  {
  for (; ; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while (_Mask < _Udiff(_Index - 1))
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits();
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if (_Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff(_Index - 1))
    return (_Ret % _Index);
   }
  }

 _Udiff _Get_all_bits()
  {
  _Udiff _Ret = 0;

  for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
   _Num += _Bits)
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits();
   }

  return (_Ret);
  }

 _Rng_from_urng(const _Rng_from_urng&) = delete;
 _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
 _Udiff _Get_bits()
  {
  for (; ; )
   {
   _Udiff _Val = _Ref() - (_Urng::min)();

   if (_Val <= _Bmask)
    return (_Val);
   }
  }

 _Urng& _Ref;
 size_t _Bits;
 _Udiff _Bmask;
 };


template<class _Elem>
 class _Yarn
 {
public:
 typedef _Yarn<_Elem> _Myt;

 _Yarn()
  : _Myptr(0), _Nul(0)
  {
  }

 _Yarn(const _Myt& _Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Yarn(const _Elem *_Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Myt& operator=(const _Myt& _Right)
  {
  return (*this = _Right._Myptr);
  }

 _Myt& operator=(const _Elem *_Right)
  {
  if (_Myptr != _Right)
   {
   _Tidy();

   if (_Right != 0)
    {
    const _Elem *_Ptr = _Right;
    while (*_Ptr != (_Elem)0)
     ++_Ptr;
    size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

    _Myptr = (_Elem *):: malloc(_Count);
    if (_Myptr != 0)
     :: memcpy(_Myptr, _Right, _Count);
    }
   }
  return (*this);
  }

 ~_Yarn() noexcept
  {
  _Tidy();
  }

 bool empty() const
  {
  return (_Myptr == 0);
  }

 const _Elem *c_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

private:
 void _Tidy()
  {
  if (_Myptr != 0)
   :: free(_Myptr);

  _Myptr = 0;
  }

 _Elem *_Myptr;
 _Elem _Nul;
 };


template<class _Ty,
 class _Alloc>
 struct _Has_allocator_type
 {







 template<class _Uty>
  static auto _Fn(int)
   -> is_convertible<_Alloc,
    typename _Uty::allocator_type>;


 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_Ty>(0)) type;
 };


struct allocator_arg_t
 {



 };




constexpr allocator_arg_t allocator_arg = allocator_arg_t();


void _Xbad_alloc() __attribute__((__noreturn__));
void _Xinvalid_argument(const char *) __attribute__((__noreturn__));
void _Xlength_error(const char *) __attribute__((__noreturn__));
void _Xout_of_range(const char *) __attribute__((__noreturn__));
void _Xoverflow_error(const char *) __attribute__((__noreturn__));
void _Xruntime_error(const char *) __attribute__((__noreturn__));
# 1836 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
}

namespace std {

template<class _Ty,
 class _Alloc>
 struct uses_allocator
  : _Has_allocator_type<_Ty, _Alloc>::type
 {
 };
# 1856 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xutility" 3
}
# 15 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 2 3


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"




namespace std {
# 46 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
template<class _Ty> inline
                     _Ty *_Allocate(size_t _Count, _Ty *,
  bool _Try_aligned_allocation = true)
 {
 void *_Ptr = 0;

 if (_Count == 0)
  return (static_cast<_Ty *>(_Ptr));


 if ((size_t)(-1) / sizeof (_Ty) < _Count)
  _Xbad_alloc();
 const size_t _User_size = _Count * sizeof (_Ty);


 if (_Try_aligned_allocation
  && 4096UL <= _User_size)
  {
  static_assert(sizeof (void *) < 32UL, "Big allocations should at least match vector register size");

  const size_t _Block_size = (sizeof(void *) + 32UL - 1) + _User_size;
  if (_Block_size <= _User_size)
   _Xbad_alloc();
  const uintptr_t _Ptr_container =
   reinterpret_cast<uintptr_t>(::operator new(_Block_size));
                                                  ;
  _Ptr = reinterpret_cast<void *>((_Ptr_container + (sizeof(void *) + 32UL - 1))
   & ~(32UL - 1));
  static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;




  }
 else


  {
  _Ptr = ::operator new(_User_size);
                                        ;
  }
 return (static_cast<_Ty *>(_Ptr));
 }


template<class _Ty> inline
 void _Deallocate(_Ty * _Ptr, size_t _Count)
 {

                                                                   ;
 const size_t _User_size = _Count * sizeof (_Ty);
 if (4096UL <= _User_size)
  {
  const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);

                                                      ;
  const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
  const uintptr_t _Ptr_container =
   *reinterpret_cast<uintptr_t *>(_Ptr_ptr);
# 115 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
                                                         ;







                                 ;



                     ;

  _Ptr = reinterpret_cast<_Ty *>(_Ptr_container);
  }


 ::operator delete(_Ptr);
 }


template<class _Ty1,
 class _Ty2> inline
 void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
 {
 void *_Vptr = _Ptr;
 ::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
 }

template<class _Ty1> inline
 void _Construct(_Ty1 *_Ptr)
 {
 void *_Vptr = _Ptr;

 ::new (_Vptr) _Ty1();
 }


template<class _Ty> inline
 void _Destroy(_Ty *_Ptr)
 {
 _Ptr->~_Ty();
 }


template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al,
  _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  _Al.destroy(::std:: addressof(*_First));
 }

template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al,
  _Scalar_ptr_iterator_tag)
 {
 }

template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al)
 {
 _Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
 }


template<class _Alty>
 struct _Is_simple_alloc
  : _Cat_base<is_same<typename _Alty::size_type, size_t>::value
  && is_same<typename _Alty::difference_type, ptrdiff_t>::value
  && is_same<typename _Alty::pointer,
   typename _Alty::value_type *>::value
  && is_same<typename _Alty::const_pointer,
   const typename _Alty::value_type *>::value
  && is_same<typename _Alty::reference,
   typename _Alty::value_type&>::value
  && is_same<typename _Alty::const_reference,
   const typename _Alty::value_type&>::value>
 {
 };


template<class _Value_type>
 struct _Simple_types
 {
 typedef _Value_type value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef value_type& reference;
 typedef const value_type& const_reference;
 };


template<class _Alty,
 class _Pointer>
 struct _Get_voidptr
 {
 typedef typename _Alty::template rebind<void>::other _Alvoid;
 typedef typename _Alvoid::pointer type;
 };

template<class _Alty,
 class _Ty>
 struct _Get_voidptr<_Alty, _Ty *>
 {
 typedef void *type;
 };



template<class _Ty>
 struct _Get_first_parameter;

template<template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Get_first_parameter<_Ty<_First, _Rest...> >
 {
 typedef _First type;
 };


template<class _Newfirst,
 class _Ty>
 struct _Replace_first_parameter;

template<class _Newfirst,
 template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
 {
 typedef _Ty<_Newfirst, _Rest...> type;
 };
# 273 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
template<class _Ty>
 struct _Get_element_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_ptr_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Other>
 struct _Get_rebind_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Other>
 struct _Get_pointer_traits_rebind_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other> >; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct pointer_traits
 {
 typedef typename _Get_element_type<_Ty>::type element_type;
 typedef _Ty pointer;
 typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;


 template<class _Other>
  using rebind =
   typename _Get_pointer_traits_rebind_type<_Ty, _Other>::type;
# 321 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
 typedef typename _If<is_void<element_type>::value,
  char&,
  add_lvalue_reference_t<element_type> >::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (_Ty::pointer_to(_Val));
  }
 };


template<class _Ty>
 struct pointer_traits<_Ty *>
 {
 typedef _Ty element_type;
 typedef _Ty *pointer;
 typedef ptrdiff_t difference_type;


 template<class _Other>
  using rebind = _Other *;
# 353 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
 typedef typename _If<is_void<_Ty>::value,
  char&,
  add_lvalue_reference_t<_Ty> >::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (::std:: addressof(_Val));
  }
 };


template<class _Ty>
 struct _Get_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_const_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_const_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_size_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<make_unsigned_t< typename _Get_difference_type<_Ty>::type> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_propagate_on_container_copy
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_move
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_swap
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_is_always_equal
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::is_always_equal>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename is_empty<_Ty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



struct _Alloc_allocate
 {

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer _Hint)
   -> decltype(_Al.allocate(_Count, _Hint))
  {
  return (_Al.allocate(_Count, _Hint));
  }

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(_Wrap_int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer)
   -> decltype(_Al.allocate(_Count))
  {
  return (_Al.allocate(_Count));
  }
 };


struct _Alloc_construct
 {


 template<class _Ty,
  class _Objty,
  class... _Types>
  static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
   _Types&&... _Args)
   -> __void_t<decltype(
    _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...))>
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty,
  class _Objty,
  class... _Types>
  static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
   _Types&&... _Args)
  {
  ::new (static_cast<void *>(_Ptr))
   _Objty(::std:: forward<_Types>(_Args)...);
  }
 };


struct _Alloc_destroy
 {
 template<class _Ty,
  class _Objty>
  static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
   -> __void_t<decltype(_Al.destroy(_Ptr))>
  {
  _Al.destroy(_Ptr);
  }

 template<class _Ty,
  class _Objty>
  static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
  {
  _Ptr->~_Objty();
  }
 };


struct _Alloc_max_size
 {
 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al) noexcept
   -> decltype(_Al.max_size())
  {
  return (_Al.max_size());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty&) noexcept
   -> typename _Get_size_type<_Ty>::type
  {
  return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
  }
 };


struct _Alloc_select
 {


 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al)
   -> decltype((_Ty)_Al.select_on_container_copy_construction())
  {
  return (_Al.select_on_container_copy_construction());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty& _Al)
   -> _Ty
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct allocator_traits
 {
 typedef _Alloc allocator_type;
 typedef typename _Alloc::value_type value_type;

 typedef typename _Get_pointer_type<_Alloc>::type
  pointer;
 typedef typename _Get_const_pointer_type<_Alloc>::type
  const_pointer;
 typedef typename _Get_void_pointer_type<_Alloc>::type
  void_pointer;
 typedef typename _Get_const_void_pointer_type<_Alloc>::type
  const_void_pointer;

 typedef typename _Get_size_type<_Alloc>::type size_type;
 typedef typename _Get_difference_type<_Alloc>::type difference_type;

 typedef typename _Get_propagate_on_container_copy<_Alloc>::type
  propagate_on_container_copy_assignment;
 typedef typename _Get_propagate_on_container_move<_Alloc>::type
  propagate_on_container_move_assignment;
 typedef typename _Get_propagate_on_container_swap<_Alloc>::type
  propagate_on_container_swap;






 template<class _Other>
  using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

 template<class _Other>
  using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
# 594 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
 static pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  static void construct(_Alloc& _Al, _Ty *_Ptr,
   _Types&&... _Args)
  {
  _Alloc_construct::_Fn(0, _Al, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  static void destroy(_Alloc& _Al, _Ty *_Ptr)
  {
  _Alloc_destroy::_Fn(0, _Al, _Ptr);
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Alloc_max_size::_Fn(0, _Al));
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Alloc_select::_Fn(0, _Al));
  }
 };


template<class _Ty>
 struct _Allocator_base
 {
 typedef _Ty value_type;
 };


template<class _Ty>
 struct _Allocator_base<const _Ty>
 {
 typedef _Ty value_type;
 };


template<class _Ty>
 class allocator
  : public _Allocator_base<_Ty>
 {
public:







 typedef _Allocator_base<_Ty> _Mybase;
 typedef typename _Mybase::value_type value_type;

 typedef value_type *pointer ;
 typedef const value_type *const_pointer ;

 typedef value_type& reference ;
 typedef const value_type& const_reference ;

 typedef size_t size_type ;
 typedef ptrdiff_t difference_type ;

 typedef false_type propagate_on_container_copy_assignment;

 typedef true_type propagate_on_container_move_assignment;



 typedef false_type propagate_on_container_swap;




 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

                pointer address(reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

                const_pointer address(const_reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

 allocator() noexcept
  {
  }

 allocator(const allocator<_Ty>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<_Ty>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Deallocate(_Ptr, _Count);
  }

                     pointer allocate(size_type _Count)
  {
  return (_Allocate(_Count, (pointer)0));
  }

                                    pointer allocate(size_type _Count, const void *)
  {
  return (allocate(_Count));
  }

 template<class _Objty,
  class... _Types>
                 void construct(_Objty *_Ptr, _Types&&... _Args)
  {
  ::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
  }

 template<class _Uty>
                 void destroy(_Uty *_Ptr)
  {
  _Ptr->~_Uty();
  }

                size_t max_size() const noexcept
  {
  return ((size_t)(-1) / sizeof (_Ty));
  }
 };


template<>
 class allocator<void>
 {
public:






 typedef void value_type;

 typedef void *pointer;
 typedef const void *const_pointer;

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 allocator() noexcept
  {
  }

 allocator(const allocator<void>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<void>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const allocator<_Ty>&,
  const allocator<_Other>&) noexcept
 {
 return (true);
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const allocator<_Ty>& _Left,
  const allocator<_Other>& _Right) noexcept
 {
 return (false);
 }


template<class _Ty>
 struct allocator_traits<allocator<_Ty> >
 {
 typedef allocator<_Ty> _Alloc;

 typedef _Alloc allocator_type;

 typedef typename _Alloc::value_type value_type;




 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef void *void_pointer;
 typedef const void *const_void_pointer;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;

 typedef true_type propagate_on_container_move_assignment;



 typedef false_type propagate_on_container_swap;





 template<class _Other>
  using rebind_alloc = allocator<_Other>;

 template<class _Other>
  using rebind_traits = allocator_traits<allocator<_Other> >;
# 871 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
 static pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Al.allocate(_Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Objty,
  class... _Types>
  static void construct(_Alloc& _Al, _Objty *_Ptr,
   _Types&&... _Args)
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Uty>
  static void destroy(_Alloc& _Al, _Uty *_Ptr)
  {
  _Al.destroy(_Ptr);
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Al.max_size());
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct _Wrap_alloc
  : public _Alloc
 {






 typedef _Alloc _Mybase;
 typedef allocator_traits<_Alloc> _Mytraits;

 typedef typename _Mytraits::value_type value_type;

 typedef typename _Mytraits::pointer pointer;
 typedef typename _Mytraits::const_pointer const_pointer;
 typedef typename _Mytraits::void_pointer void_pointer;
 typedef typename _Mytraits::const_void_pointer const_void_pointer;

 typedef typename _If<is_void<value_type>::value,
  int, value_type>::type& reference;
 typedef typename _If<is_void<const value_type>::value,
  const int, const value_type>::type& const_reference;

 typedef typename _Mytraits::size_type size_type;
 typedef typename _Mytraits::difference_type difference_type;

 typedef typename _Mytraits::propagate_on_container_copy_assignment
  propagate_on_container_copy_assignment;
 typedef typename _Mytraits::propagate_on_container_move_assignment
  propagate_on_container_move_assignment;
 typedef typename _Mytraits::propagate_on_container_swap
  propagate_on_container_swap;





 _Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
  {
  return (_Mytraits::select_on_container_copy_construction(*this));
  }

 template<class _Other>
  struct rebind
  {
  typedef typename _Mytraits::template rebind_alloc<_Other>
   _Other_alloc;
  typedef _Wrap_alloc<_Other_alloc> other;
  };

 pointer address(reference _Val) const
  {
  return (::std:: addressof(_Val));
  }

 const_pointer address(const_reference _Val) const
  {
  return (::std:: addressof(_Val));
  }

 _Wrap_alloc() noexcept
  : _Mybase()
  {
  }

 _Wrap_alloc(const _Mybase& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc(const _Wrap_alloc& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Wrap_alloc(const _Other& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Wrap_alloc(_Other& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc& operator=(const _Mybase& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 _Wrap_alloc& operator=(const _Wrap_alloc& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 template<class _Other>
  _Wrap_alloc& operator=(const _Other& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

                     pointer allocate(size_type _Count)
  {
  return (_Mybase::allocate(_Count));
  }

                     pointer allocate(size_type _Count,
  const_void_pointer _Hint, _Nil = _Nil())
  {
  return (_Mytraits::allocate(*this, _Count, _Hint));
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Mybase::deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  void construct(_Ty *_Ptr,
   _Types&&... _Args)
  {
  _Mytraits::construct(*this, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  void destroy(_Ty *_Ptr)
  {
  _Mytraits::destroy(*this, _Ptr);
  }

 size_type max_size(_Nil = _Nil()) const noexcept
  {
  return (_Mytraits::max_size(*this));
  }
 };

template<class _Ty>
 struct _Wrap_alloc<_Ty *>
  : public _Wrap_alloc<allocator<_Ty *> >
 {
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
 {
 _Left = _Right;
 }

template<class _Alty> inline
 void _Pocca(_Alty&, const _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_copy_assignment _Tag;
 _Pocca(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Left = ::std:: move(_Right);
 }

template<class _Alty> inline
 void _Pocma(_Alty&, _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_move_assignment _Tag;
 _Pocma(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Swap_adl(_Left, _Right);
 }

template<class _Alty> inline
 void _Pocs(_Alty&, _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_swap _Tag;
 _Pocs(_Left, _Right, _Tag);
 }
}







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic0.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic0.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic0.h" 2 3

namespace std {

typedef enum memory_order {
 memory_order_relaxed,
 memory_order_consume,
 memory_order_acquire,
 memory_order_release,
 memory_order_acq_rel,
 memory_order_seq_cst
 } memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;
# 97 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic0.h" 3
typedef unsigned char _Atomic_flag_t;
# 119 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic0.h" 3
extern "C" {
_Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order);
int _Atomic_compare_exchange_weak_4(
 volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order);
_Uint4_t _Atomic_fetch_add_4(
 volatile _Uint4_t *, _Uint4_t, memory_order);
_Uint4_t _Atomic_fetch_sub_4(
 volatile _Uint4_t *, _Uint4_t, memory_order);
}

_Uint4_t _Atomic_load_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, memory_order);
int _Atomic_compare_exchange_weak_4_locking(
 volatile _Atomic_flag_t *, _Uint4_t *, _Uint4_t *, _Uint4_t,
  memory_order, memory_order);
_Uint4_t _Atomic_fetch_add_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, _Uint4_t, memory_order);
_Uint4_t _Atomic_fetch_sub_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, _Uint4_t, memory_order);
# 250 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic0.h" 3
typedef _Atomic_integral_t _Atomic_counter_t;


inline _Atomic_integral_t
 _Get_atomic_count(const _Atomic_counter_t& _Counter)
 {
 return (_Counter);
 }

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
 _Atomic_integral_t _Value)
 {
 _Counter = _Value;
 }

inline _Atomic_integral_t _Inc_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_fetch_add_4(&_Counter, 1, _Order) + 1);
 }

inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Dec_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_fetch_sub_4(&_Counter, 1, _Order) - 1);
 }

inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Load_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_load_4(&_Counter, _Order));
 }

inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Load_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(
 _Atomic_counter_t& _Counter,
 _Atomic_integral_t _Expected,
 memory_order _Order)
 {
 return ((_Atomic_integral_t)_Atomic_compare_exchange_weak_4(
  &_Counter, &_Expected, _Expected + 1,
  _Order, _Order));
 }

inline _Atomic_integral_t _Compare_increment_atomic_counter(
 _Atomic_counter_t& _Counter, _Atomic_integral_t _Expected)
 {
 return (_Compare_increment_atomic_counter_explicit(
  _Counter, _Expected, memory_order_seq_cst));
 }
# 351 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic0.h" 3
extern "C" {
void _Lock_shared_ptr_spin_lock();
void _Unlock_shared_ptr_spin_lock();
}
}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stddef.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic.h" 2 3
# 41 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic.h" 3
namespace std {

typedef unsigned char _Uint1_t;
typedef unsigned short _Uint2_t;

typedef unsigned long long _Uint8_t;
# 68 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic.h" 3
extern "C" {
void _Atomic_store_1(volatile _Uint1_t *_Tgt, _Uint1_t _Value,
 memory_order _Order);
_Uint1_t _Atomic_load_1(volatile _Uint1_t *_Tgt,
 memory_order _Order);
_Uint1_t _Atomic_exchange_1(volatile _Uint1_t *_Tgt,
 _Uint1_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_1(
 volatile _Uint1_t *_Tgt, _Uint1_t *_Exp, _Uint1_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_1(
 volatile _Uint1_t *_Tgt, _Uint1_t *_Exp, _Uint1_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint1_t _Atomic_fetch_add_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_sub_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_and_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_or_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_xor_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
void _Atomic_store_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_load_2(
 volatile _Uint2_t *_Tgt, memory_order _Order);
_Uint2_t _Atomic_exchange_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
int _Atomic_compare_exchange_weak_2(
 volatile _Uint2_t *_Tgt, _Uint2_t *_Exp, _Uint2_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_strong_2(
 volatile _Uint2_t *_Tgt, _Uint2_t *_Exp, _Uint2_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint2_t _Atomic_fetch_add_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_sub_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_and_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_or_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_xor_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
void _Atomic_store_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_load_4(
 volatile _Uint4_t *_Tgt, memory_order _Order);
_Uint4_t _Atomic_exchange_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_4(
 volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_4(
 volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint4_t _Atomic_fetch_add_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_sub_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_and_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_or_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_xor_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
void _Atomic_store_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_load_8(
 volatile _Uint8_t *_Tgt, memory_order _Order);
_Uint8_t _Atomic_exchange_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_8(
 volatile _Uint8_t *_Tgt, _Uint8_t *_Exp, _Uint8_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_8(
 volatile _Uint8_t *_Tgt, _Uint8_t *_Exp, _Uint8_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint8_t _Atomic_fetch_add_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_sub_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_and_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_or_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_xor_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
int _Atomic_flag_test_and_set(volatile _Atomic_flag_t *_Flag,
 memory_order _Order);
void _Atomic_flag_clear(volatile _Atomic_flag_t *_Flag,
 memory_order _Order);
void _Atomic_thread_fence(memory_order _Order);
void _Atomic_signal_fence(memory_order _Order);


int _Atomic_is_lock_free_1();
int _Atomic_is_lock_free_2();
int _Atomic_is_lock_free_4();
int _Atomic_is_lock_free_8();
}
# 190 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xatomic.h" 3
inline void _Lock_spin_lock_i(
 volatile _Atomic_flag_t *_Flag)
 {
 while (__c11_atomic_exchange ((_Atomic(_Atomic_flag_t)*)_Flag, (_Atomic_flag_t)1, memory_order_acquire))
                  ;
 }

inline void _Unlock_spin_lock_i(
 volatile _Atomic_flag_t *_Flag)
 {
 __c11_atomic_store ((_Atomic(_Atomic_flag_t)*)_Flag, (_Atomic_flag_t)0, memory_order_release);
 }



inline void _Atomic_copy_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile const void *_Src,
   memory_order _Order)
 {
 _Lock_spin_lock_i(_Flag);
 memcpy((void *)_Tgt, (void *)_Src, _Size);
 _Unlock_spin_lock_i(_Flag);
 }

inline void _Atomic_exchange_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile void *_Src,
   memory_order _Order)
 {
 unsigned char *_Left = (unsigned char *)_Tgt;
 unsigned char *_Right = (unsigned char *)_Src;

 _Lock_spin_lock_i(_Flag);
 for (; 0 < _Size; --_Size)
  {
  unsigned char _Tmp = *_Left;
  *_Left++ = *_Right;
  *_Right++ = _Tmp;
  }
 _Unlock_spin_lock_i(_Flag);
 }

inline int _Atomic_compare_exchange_weak_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile void *_Exp, const volatile void *_Src,
   memory_order _Order1, memory_order _Order2)
 {
 int _Result;

 _Lock_spin_lock_i(_Flag);
 _Result = memcmp((const void *)_Tgt, (const void *)_Exp, _Size) == 0;
 if (_Result != 0)
  memcpy((void *)_Tgt, (void *)_Src, _Size);
 else
  memcpy((void *)_Exp, (void *)_Tgt, _Size);
 _Unlock_spin_lock_i(_Flag);
 return (_Result);
 }

inline int _Atomic_compare_exchange_strong_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
 volatile void *_Tgt, volatile void *_Exp, const volatile void *_Src,
 memory_order _Order1, memory_order _Order2)
 {
 return (_Atomic_compare_exchange_weak_i(_Flag, _Size, _Tgt, _Exp, _Src,
  _Order1, _Order2));
 }
}
# 1147 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 2 3
# 1185 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory0" 3
#pragma clang diagnostic pop
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 2 3
# 28 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
namespace std {
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Ax = allocator<_Elem> >
 class basic_string;
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
template<class _Mystr>
 class _String_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Mystr::value_type,
   typename _Mystr::difference_type,
   typename _Mystr::const_pointer,
   typename _Mystr::const_reference,
   _Iterator_base>
 {
public:
 typedef _String_const_iterator<_Mystr> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::const_pointer pointer;
 typedef typename _Mystr::const_reference reference;

 _String_const_iterator()
  {
  this->_Ptr = 0;
  }

 _String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
  {
  this->_Adopt(_Pstring);
  this->_Ptr = _Parg;
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
# 106 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
  return (*this->_Ptr);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 133 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
  ++this->_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 161 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
  --this->_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
# 193 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  if (this->_Getcont() != _Right._Getcont())
   _Compat(_Right);
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
# 277 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 void _Compat(const _Myiter&) const
  {
  }


 pointer _Ptr;
 };

template<class _Mystr> inline
 typename _String_const_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_const_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr>
  _Rechecked(_String_const_iterator<_Mystr>& _Iter,
   typename _String_const_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr> operator+(
  typename _String_const_iterator<_Mystr>
   ::difference_type _Off,
  _String_const_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Mystr>
 class _String_iterator
  : public _String_const_iterator<_Mystr>
 {
public:
 typedef _String_iterator<_Mystr> _Myiter;
 typedef _String_const_iterator<_Mystr> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::pointer pointer;
 typedef typename _Mystr::reference reference;

 _String_iterator()
  {
  }

 _String_iterator(pointer _Parg, const _Container_base *_Pstring)
  : _Mybase(_Parg, _Pstring)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Mystr> inline
 typename _String_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_iterator<_Mystr>
  _Rechecked(_String_iterator<_Mystr>& _Iter,
   typename _String_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_iterator<_Mystr> operator+(
  typename _String_iterator<_Mystr>
   ::difference_type _Off,
  _String_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }



template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _String_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _String_base_types
 {
# 474 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 typedef _Alloc0 _Alloc;


 typedef _String_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _String_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _String_val
  : public _Container_base
 {
public:
 typedef _String_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;






 typedef _String_iterator<_Myt> iterator;
 typedef _String_const_iterator<_Myt> const_iterator;


 _String_val()
  {
  _Mysize = 0;
  _Myres = 0;
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
   : 16 / sizeof (value_type)};
 enum
  {
  _ALLOC_MASK = sizeof (value_type) <= 1 ? 15
   : sizeof (value_type) <= 2 ? 7
   : sizeof (value_type) <= 4 ? 3
   : sizeof (value_type) <= 8 ? 1 : 0};

 value_type *_Myptr()
  {
  return (this->_BUF_SIZE <= this->_Myres
   ? ::std:: addressof(*this->_Bx._Ptr)
   : this->_Bx._Buf);
  }

 const value_type *_Myptr() const
  {
  return (this->_BUF_SIZE <= this->_Myres
   ? ::std:: addressof(*this->_Bx._Ptr)
   : this->_Bx._Buf);
  }

 union _Bxty
  {
  value_type _Buf[_BUF_SIZE];
  pointer _Ptr;
  char _Alias[_BUF_SIZE];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _String_alloc
  : public _String_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alty _Alty;


 _String_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alval(_Al)
  {
  }

 _String_alloc(_Alloc0&& _Al)
  : _Alval(::std:: move(_Al))
  {
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Alval, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Alval, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(_Alval, _Right._Alval);
  }
# 656 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 _Alty& _Getal() noexcept
  {
  return (_Alval);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alval);
  }

 _Alty _Alval;
 };

template<class _Alloc_types>
 class _String_alloc<false, _Alloc_types>
  : public _String_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _String_alloc<false, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alty _Alty;


 _String_alloc(const _Alloc0& = _Alloc0())
  {
  }

 _String_alloc(_Alloc0&&)
  {
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 748 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Elem,
 class _Traits,
 class _Alloc>
 class basic_string
  : public _String_alloc<!is_empty<_Alloc>::value,
   _String_base_types<_Elem, _Alloc> >
 {
public:
 typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
 typedef _String_alloc<!is_empty<_Alloc>::value,
  _String_base_types<_Elem, _Alloc> > _Mybase;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
# 788 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;


 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 basic_string(const _Myt& _Right)
  : _Mybase(_Right._Getal().select_on_container_copy_construction())
  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
  : _Mybase(_Alloc())
  {
  _Tidy();
  }

 explicit basic_string(const _Alloc& _Al) noexcept
  : _Mybase(_Al)
  {
  _Tidy();
  }
# 829 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 basic_string(const _Myt& _Right, size_type _Roff,
  size_type _Count = npos)
  : _Mybase(_Right._Getal())
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }

 basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
  const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }
# 863 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 basic_string(const _Elem *_Ptr, size_type _Count)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(const _Elem *_Ptr, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(size_type _Count, _Elem _Ch)
  : _Mybase()
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
                             ;
  _Tidy();
  _Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, input_iterator_tag)
  {
  {{
  for (; _First != _Last; ++_First)
   append((size_type)1, (_Elem)*_First);
  } if (0) {
  _Tidy(true);
          ;
  }}
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, forward_iterator_tag)
  {
  size_type _Count = 0;
  _Distance(_First, _Last, _Count);
  reserve(_Count);
  _Construct(_First, _Last, input_iterator_tag());
  }

 void _Construct(_Elem *_First,
  _Elem *_Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   assign(_First, _Last - _First);
  }

 void _Construct(const _Elem *_First,
  const _Elem *_Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   assign(_First, _Last - _First);
  }

 basic_string(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Tidy();
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 basic_string(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  if (this->_Getal() != _Right._Getal())
   assign(_Right.begin(), _Right.end());
  else
   _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)




  noexcept

  {
  if (this != &_Right)
   {
   _Tidy(true);
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());
   if (this->_Getal() != _Right._Getal())
    assign(_Right.begin(), _Right.end());
   else
    _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 _Myt& assign(_Myt&& _Right) noexcept
  {
  if (this == &_Right)
   ;
  else if (get_allocator() != _Right.get_allocator()
   && this->_BUF_SIZE <= _Right._Myres)
   *this = _Right;
  else
   {
   _Tidy(true);
   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  if (_Right._Myres < this->_BUF_SIZE)
   _Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
    _Right._Mysize + 1);
  else
   {
   this->_Bx._Ptr = _Right._Bx._Ptr;
   _Right._Bx._Ptr = pointer();
   }
  this->_Mysize = _Right._Mysize;
  this->_Myres = _Right._Myres;
  _Right._Tidy();
  }

 basic_string(::std:: initializer_list<_Elem> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& assign(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& append(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
  }

 ~basic_string() noexcept
  {
  _Tidy(true);
  }

 static const size_type npos = (size_t)(-1);

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    _Tidy(true);
    this->_Copy_alloc(_Right._Getal());
    }
   assign(_Right);
   }
  return (*this);
  }
# 1090 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 _Myt& operator=(const _Elem *_Ptr)
  {
  return (assign(_Ptr));
  }

 _Myt& operator=(_Elem _Ch)
  {
  return (assign(1, _Ch));
  }

 _Myt& operator+=(const _Myt& _Right)
  {
  return (append(_Right));
  }
# 1112 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 _Myt& operator+=(const _Elem *_Ptr)
  {
  return (append(_Ptr));
  }

 _Myt& operator+=(_Elem _Ch)
  {
  return (append((size_type)1, _Ch));
  }

 _Myt& append(const _Myt& _Right)
  {
  return (append(_Right, 0, npos));
  }

 _Myt& append(const _Myt& _Right,
  size_type _Roff, size_type _Count = npos)
  {
  if (_Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;

  size_t _Oldsize = this->_Mysize;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::copy(this->_Myptr() + _Oldsize,
    _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1165 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 _Myt& append(const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (append(*this,
    _Ptr - this->_Myptr(), _Count));
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  size_type _Num;
  size_type _Oldsize = this->_Mysize;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::copy(this->_Myptr() + _Oldsize, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& append(const _Elem *_Ptr)
  {
                      ;
  return (append(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& append(size_type _Count, _Elem _Ch)
  {
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Chassign(this->_Mysize, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& append(_Iter _First, _Iter _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }




 _Myt& append(const_pointer _First, const_pointer _Last)
  {
                                            ;
  if (_Last < _First)
   _Xran();
  return (append(_First, _Last - _First));
  }


 _Myt& append(const_iterator _First, const_iterator _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& assign(const _Myt& _Right)
  {
  return (assign(_Right, 0, npos));
  }

 _Myt& assign(const _Myt& _Right,
  size_type _Roff, size_type _Count = npos)
  {
  if (_Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Count < _Num)
   _Num = _Count;

  if (this == &_Right)
   erase((size_type)(_Roff + _Num)), erase(0, _Roff);
  else if (_Grow(_Num))
   {
   _Traits::copy(this->_Myptr(),
    _Right._Myptr() + _Roff, _Num);
   _Eos(_Num);
   }
  return (*this);
  }
# 1283 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 _Myt& assign(const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (assign(*this,
    (size_type)(_Ptr - this->_Myptr()), _Count));

  if (_Grow(_Count))
   {
   _Traits::copy(this->_Myptr(), _Ptr, _Count);
   _Eos(_Count);
   }
  return (*this);
  }

 _Myt& assign(const _Elem *_Ptr)
  {
                      ;
  return (assign(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& assign(size_type _Count, _Elem _Ch)
  {
  if (_Count == npos)
   _Xlen();

  if (_Grow(_Count))
   {
   _Chassign(0, _Count, _Ch);
   _Eos(_Count);
   }
  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& assign(_Iter _First, _Iter _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }




 _Myt& assign(const_pointer _First, const_pointer _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }


 _Myt& assign(const_iterator _First, const_iterator _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& insert(size_type _Off, const _Myt& _Right)
  {
  return (insert(_Off, _Right, 0, npos));
  }

 _Myt& insert(size_type _Off,
  const _Myt& _Right, size_type _Roff, size_type _Count = npos)
  {
  if (this->_Mysize < _Off || _Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   if (this == &_Right)
    _Traits::move(this->_Myptr() + _Off,
     this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
      _Count);
   else
    _Traits::copy(this->_Myptr() + _Off,
     _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1391 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 _Myt& insert(size_type _Off,
  const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (insert(_Off, *this,
    _Ptr - this->_Myptr(), _Count));
  if (this->_Mysize < _Off)
   _Xran();
  if (npos - this->_Mysize <= _Count)
   _Xlen();
  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& insert(size_type _Off, const _Elem *_Ptr)
  {
                      ;
  return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& insert(size_type _Off,
  size_type _Count, _Elem _Ch)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (npos - this->_Mysize <= _Count)
   _Xlen();
  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 iterator insert(const_iterator _Where)
  {
  return (insert(_Where, _Elem()));
  }

 iterator insert(const_iterator _Where, _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, 1, _Ch);
  return (begin() + (difference_type)_Off);
  }

 iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, _Count, _Ch);
  return (begin() + _Off);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }




 iterator insert(const_iterator _Where,
  const_pointer _First, const_pointer _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }


 iterator insert(const_iterator _Where,
  const_iterator _First, const_iterator _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 _Myt& erase(size_type _Off = 0)
  {
  if (this->_Mysize < _Off)
   _Xran();
  _Eos(_Off);
  return (*this);
  }

 _Myt& erase(size_type _Off, size_type _Count)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off <= _Count)
   _Eos(_Off);
  else if (0 < _Count)
   {
   value_type *_Ptr = this->_Myptr() + _Off;
   size_type _Newsize = this->_Mysize - _Count;
   _Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
   _Eos(_Newsize);
   }
  return (*this);
  }

 iterator erase(const_iterator _Where)
  {
  size_type _Count = _Where - begin();
  erase(_Count, 1);
  return (begin() + _Count);
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
                             ;
  size_type _Count = _First - begin();
  erase(_Count, _Last - _First);
  return (begin() + _Count);
  }

 void clear() noexcept
  {
  _Eos(0);
  }

 _Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
  {
  return (replace(_Off, _N0, _Right, 0, npos));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Myt& _Right, size_type _Roff,
   size_type _Count = npos)
  {
  if (this->_Mysize < _Off || _Right.size() < _Roff)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();

  size_type _Nm = this->_Mysize - _N0 - _Off;
  size_type _Newsize = this->_Mysize + _Count - _N0;
  if (this->_Mysize < _Newsize)
   _Grow(_Newsize);

  if (this != &_Right)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off,
    _Right._Myptr() + _Roff, _Count);
   }
  else if (_Count <= _N0)
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   }
  else if (_Roff <= _Off)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   }
  else if (_Off + _N0 <= _Roff)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + (_Roff + _Count - _N0),
    _Count);
   }
  else
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _N0);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off + _N0,
    this->_Myptr() + _Roff + _Count,
    _Count - _N0);
   }

  _Eos(_Newsize);
  return (*this);
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (replace(_Off, _N0, *this,
    (size_type)(_Ptr - this->_Myptr()),
    _Count));
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  size_type _Num;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num = this->_Mysize + _Count - _N0))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1659 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 _Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
  {
                      ;
  return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  size_type _Num;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num = this->_Mysize + _Count - _N0))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Myt& _Right)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Right));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr, size_type _Count)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Ptr));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Count, _Ch));
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& replace(const_iterator _First, const_iterator _Last,
   _Iter _First2, _Iter _Last2)
  {
  _Myt _Right(_First2, _Last2);
  replace(_First, _Last, _Right);
  return (*this);
  }




 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  pointer _First2, pointer _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }


 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  iterator _First2, iterator _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 iterator begin() noexcept
  {
  return (iterator(this->_Myptr(), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Myptr(), this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Myptr() + this->_Mysize, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Myptr() + this->_Mysize, this));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if ((size() | this->_ALLOC_MASK) < capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 reference at(size_type _Off)
  {
  if (this->_Mysize <= _Off)
   _Xran();
  return (this->_Myptr()[_Off]);
  }

 const_reference at(size_type _Off) const
  {
  if (this->_Mysize <= _Off)
   _Xran();
  return (this->_Myptr()[_Off]);
  }
# 1882 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 reference operator[](size_type _Off)
  {
# 1892 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
  return (this->_Myptr()[_Off]);
  }

 const_reference operator[](size_type _Off) const
  {
# 1905 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
  return (this->_Myptr()[_Off]);
  }

 void push_back(_Elem _Ch)
  {
  insert(end(), _Ch);
  }

 void pop_back()
  {
  erase(this->_Mysize - 1);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 const _Elem *c_str() const noexcept
  {
  return (this->_Myptr());
  }

 const _Elem *data() const noexcept
  {
  return (c_str());
  }

 _Elem *data() noexcept
  {
  return (this->_Myptr());
  }

 size_type length() const noexcept
  {
  return (this->_Mysize);
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  size_type _Num = this->_Getal().max_size();
  return (_Num <= 1 ? 1 : _Num - 1);
  }

 void resize(size_type _Newsize)
  {
  resize(_Newsize, _Elem());
  }

 void resize(size_type _Newsize, _Elem _Ch)
  {
  if (_Newsize <= this->_Mysize)
   _Eos(_Newsize);
  else
   append(_Newsize - this->_Mysize, _Ch);
  }

 size_type capacity() const noexcept
  {
  return (this->_Myres);
  }

 void reserve(size_type _Newcap = 0)
  {
  if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
   {
   size_type _Size = this->_Mysize;
   if (_Grow(_Newcap, true))
    _Eos(_Size);
   }
  }

 bool empty() const noexcept
  {
  return (this->_Mysize == 0);
  }

 size_type copy(_Elem *_Ptr,
  size_type _Count, size_type _Off = 0) const
  {
                                      ;
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _Count)
   _Count = this->_Mysize - _Off;
  _Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

 void _Swap_bx(_Myt& _Right)
  {
  if (this->_BUF_SIZE <= this->_Myres)
   if (this->_BUF_SIZE <= _Right._Myres)
    _Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
   else
    {
    pointer _Ptr = this->_Bx._Ptr;
    _Traits::copy(this->_Bx._Buf,
     _Right._Bx._Buf, _Right._Mysize + 1);
    _Right._Bx._Ptr = _Ptr;
    }
  else
   if (_Right._Myres < this->_BUF_SIZE)
    ::std:: swap(this->_Bx._Buf, _Right._Bx._Buf);
   else
    {
    pointer _Ptr = _Right._Bx._Ptr;
    _Traits::copy(_Right._Bx._Buf,
     this->_Bx._Buf, this->_Mysize + 1);
    this->_Bx._Ptr = _Ptr;
    }
  }

 void swap(_Myt& _Right)


  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   ::std:: swap(this->_Myres, _Right._Myres);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {

   this->_Swap_alloc(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Bx, _Right._Bx);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   ::std:: swap(this->_Myres, _Right._Myres);
   }
  else
   {
   _Myt _Tmp = *this;

   *this = _Right;
   _Right = _Tmp;
   }
  }

 size_type find(const _Myt& _Right, size_type _Off = 0) const noexcept
  {
  return (find(_Right._Myptr(), _Off, _Right.size()));
  }
# 2081 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 size_type find(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Count == 0 && _Off <= this->_Mysize)
   return (_Off);

  size_type _Nm;
  if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
   {
   const _Elem *_Uptr, *_Vptr;
   for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
    (_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
    if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find(const _Elem *_Ptr, size_type _Off = 0) const
  {
                      ;
  return (find(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find(_Elem _Ch, size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type rfind(const _Myt& _Right, size_type _Off = npos) const noexcept
  {
  return (rfind(_Right._Myptr(), _Off, _Right.size()));
  }
# 2125 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 size_type rfind(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Count == 0)
   return (_Off < this->_Mysize ? _Off
    : this->_Mysize);
  if (_Count <= this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr() +
    (_Off < this->_Mysize - _Count ? _Off
     : this->_Mysize - _Count);
   for (; ; --_Uptr)
    if (_Traits::eq(*_Uptr, *_Ptr)
     && _Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
  {
                      ;
  return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type rfind(_Elem _Ch, size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_of(const _Myt& _Right,
  size_type _Off = 0) const noexcept
  {
  return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2172 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < _Count && _Off < this->_Mysize)
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_of(const _Myt& _Right,
  size_type _Off = npos) const noexcept
  {
  return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2215 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < _Count && 0 < this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_not_of(const _Myt& _Right,
  size_type _Off = 0) const noexcept
  {
  return (find_first_not_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2260 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Off < this->_Mysize)
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
   }
  return (npos);
  }

 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_not_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_not_of(const _Myt& _Right,
  size_type _Off = npos) const noexcept
  {
  return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2302 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }
  return (npos);
  }

 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_not_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 _Myt substr(size_type _Off = 0, size_type _Count = npos) const
  {
  return (_Myt(*this, _Off, _Count, get_allocator()));
  }

 int compare(const _Myt& _Right) const noexcept
  {
  return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
  }
# 2349 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 int compare(size_type _Off, size_type _N0, const _Myt& _Right) const
  {
  return (compare(_Off, _N0, _Right, 0, npos));
  }
# 2361 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 int compare(size_type _Off, size_type _N0, const _Myt& _Right,
  size_type _Roff, size_type _Count = npos) const
  {
  if (_Right.size() < _Roff)
   _Xran();
  if (_Right._Mysize - _Roff < _Count)
   _Count = _Right._Mysize - _Roff;
  return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
  }
# 2379 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
 int compare(const _Elem *_Ptr) const
  {
                      ;
  return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
  {
                      ;
  return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count) const
  {
                                      ;
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;

  int _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
   _N0 < _Count ? _N0 : _Count);
  return (_Ans != 0 ? _Ans : _N0 < _Count ? -1
   : _N0 == _Count ? 0 : +1);
  }

 allocator_type get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
  {
  if (_Count == 1)
   _Traits::assign(*(this->_Myptr() + _Off), _Ch);
  else
   _Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
  }

 void _Copy(size_type _Newsize, size_type _Oldlen)
  {
  size_type _Newres = _Newsize | this->_ALLOC_MASK;
  if (max_size() < _Newres)
   _Newres = _Newsize;
  else if (this->_Myres / 2 <= _Newres / 3)
   ;
  else if (this->_Myres <= max_size() - this->_Myres / 2)
   _Newres = this->_Myres
    + this->_Myres / 2;
  else
   _Newres = max_size();

  _Elem *_Ptr;
  {{
   _Ptr = this->_Getal().allocate(_Newres + 1);
  } if (0) {
   _Newres = _Newsize;
   {{
    _Ptr = this->_Getal().allocate(_Newres + 1);
   } if (0) {
   _Tidy(true);
           ;
   }}
  }}

  if (0 < _Oldlen)
   _Traits::copy(_Ptr, this->_Myptr(),
    _Oldlen);
  _Tidy(true);
  this->_Bx._Ptr = _Ptr;
  this->_Myres = _Newres;
  _Eos(_Oldlen);
  }

 void _Eos(size_type _Newsize)
  {
  _Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
  }

 bool _Grow(size_type _Newsize,
  bool _Trim = false)
  {
  if (max_size() < _Newsize)
   _Xlen();
  if (this->_Myres < _Newsize)
   _Copy(_Newsize, this->_Mysize);
  else if (_Trim && _Newsize < this->_BUF_SIZE)
   _Tidy(true,
    _Newsize < this->_Mysize ? _Newsize : this->_Mysize);
  else if (_Newsize == 0)
   _Eos(0);
  return (0 < _Newsize);
  }

 bool _Inside(const _Elem *_Ptr)
  {
  if (_Ptr == 0 || _Ptr < this->_Myptr()
   || this->_Myptr() + this->_Mysize <= _Ptr)
   return (false);
  else
   return (true);
  }

 void _Tidy(bool _Built = false,
  size_type _Newsize = 0)
  {
  if (!_Built)
   ;
  else if (this->_BUF_SIZE <= this->_Myres)
   {
   pointer _Ptr = this->_Bx._Ptr;
   if (0 < _Newsize)
    _Traits::copy(this->_Bx._Buf,
     ::std:: addressof(*_Ptr), _Newsize);
   this->_Getal().deallocate(_Ptr, this->_Myres + 1);
   }
  this->_Myres = this->_BUF_SIZE - 1;
  _Eos(_Newsize);
  }

 void _Xlen() const
  {
  _Xlength_error("string too long");
  }

 void _Xran() const
  {
  _Xout_of_range("invalid string position");
  }
 };
# 2522 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
template<class _Elem, class _Tr, class _Alloc>
const typename basic_string<_Elem, _Tr, _Alloc>::size_type basic_string<_Elem, _Tr, _Alloc>::npos;
# 2540 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xstring" 3
template<class _Elem,
 class _Traits,
 class _Alloc> inline
 void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Traits::length(_Left) + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(1 + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Traits::length(_Right));
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + 1);
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 if (_Right.size() <= _Left.capacity() - _Left.size()
  || _Right.capacity() - _Right.size() < _Left.size())
  return (::std:: move(_Left.append(_Right)));
 else
  return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
  size_type;
 return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem *_Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem _Right)
 {
 return (::std:: move(_Left.append(1, _Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) > 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left < _Right));
 }

typedef basic_string<char, char_traits<char>, allocator<char> >
 string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
 wstring;
}
namespace std {

template<class _Elem,
 class _Traits,
 class _Alloc>
 struct hash<basic_string<_Elem, _Traits, _Alloc> >
 {
 typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
   _Keyval.size() * sizeof (_Elem)));
  }
 };
}
namespace std {
typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
 u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
 u32string;
}
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdexcept" 2 3
namespace std {
# 25 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdexcept" 3
class logic_error
 : public ::std:: exception
 {
public:
 explicit logic_error(const string& _Message)
  : _Str(_Message)
  {
  }

 explicit logic_error(const char *_Message)
  : _Str(_Message)
  {
  }


 virtual ~logic_error() noexcept;






 virtual const char *what() const noexcept
  {
  return (_Str.c_str());
  }

private:
 string _Str;




protected:
 virtual void _Doraise() const;

 };


class domain_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit domain_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit domain_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~domain_error() noexcept;

 };


class invalid_argument
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit invalid_argument(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit invalid_argument(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~invalid_argument() noexcept;

 };


class length_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit length_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit length_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~length_error() noexcept;

 };


class out_of_range
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit out_of_range(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit out_of_range(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~out_of_range() noexcept;

 };


class runtime_error
 : public ::std:: exception
 {
public:
 explicit runtime_error(const string& _Message)
  : _Str(_Message)
  {
  }

 explicit runtime_error(const char *_Message)
  : _Str(_Message)
  {
  }


 virtual ~runtime_error() noexcept;






 virtual const char *what() const noexcept
  {
  return (_Str.c_str());
  }

private:
 string _Str;
 };


class overflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit overflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit overflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~overflow_error() noexcept;

 };


class underflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit underflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit underflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~underflow_error() noexcept;

 };


class range_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit range_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit range_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~range_error() noexcept;

 };
}
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {

template<class _Ty> inline
 pair<_Ty *, ptrdiff_t>
  get_temporary_buffer(ptrdiff_t _Count) noexcept
 {
 _Ty *_Pbuf;

 if (_Count < 0)
  _Count = 0;
 else if (((size_t)(-1) / sizeof (_Ty) < _Count))
  _Xbad_alloc();
 for (_Pbuf = 0; 0 < _Count; _Count /= 2)
  if ((_Pbuf = (_Ty *)::operator new(
   (size_t)_Count * sizeof (_Ty), nothrow)) != 0)
   break;

 return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
 }


template<class _Ty> inline
 void return_temporary_buffer(_Ty *_Pbuf)
 {
 ::operator delete(_Pbuf);
 }
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, input_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 _Construct(::std:: addressof(*_Dest),
  *_First);
 while (0 < --_Count)
  _Construct(::std:: addressof(*++_Dest), *++_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (++_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, forward_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  _Construct(::std:: addressof(*_Dest), *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 return (_Uninitialized_copy_n(_First, _Count,
  _Dest, _Iter_cat(_First)));
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag)
 {
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy_n(_First, _Count,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 if (_Count <= 0)
  return (_Dest);
 else
  return (_Rechecked(_Dest,
   _Uninitialized_copy_n(_Unchecked(_First), _Count,
    _Unchecked(_Dest))));
 }
# 259 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Construct(::std:: addressof(*_Dest), *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy0(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 370 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Nonscalar_ptr_iterator_tag)
 {
                                       ;
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Al.construct(_Dest, *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Scalar_ptr_iterator_tag)
 {
 return (_Uninit_copy(_First, _Last, _Dest,
  _Al, _Nonscalar_ptr_iterator_tag()));
 }

template<class _Ty1,
 class _Ty2> inline
 _Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<allocator<_Ty2> >&, _Scalar_ptr_iterator_tag)
 {
                                       ;
 size_t _Count = (size_t)(_Last - _First);
 return ((_Ty2 *):: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First)) + _Count);
 }
# 426 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Uninit_copy(_First, _Last, _Dest, _Al,
  _Ptr_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Rechecked(_Dest,
  _Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; (void)++_First, ++_Dest)
 ::new (static_cast<void *>(::std:: addressof(*_Dest)))
  typename iterator_traits<_FwdIt>::value_type(::std:: move(*_First));
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }


template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 pair<_InIt, _FwdIt> uninitialized_move_n(_InIt _First,
  _Diff _Count, _FwdIt _Dest)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; 0 < _Count; ++_First, (void)++_Dest, --_Count)
  ::new (static_cast<void *>(::std:: addressof(*_Dest)))
   typename iterator_traits<_FwdIt>::value_type(::std:: move(*_First));
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (pair<_InIt, _FwdIt>(_First, _Dest));
 }
# 526 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
 {
                                       ;
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Al.construct(::std:: addressof(*_Dest), (_Valty&&)*_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Al.destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
 {
 return (_Uninit_move(_First, _Last, _Dest,
  _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));
 }

template<class _Ty1,
 class _Ty2,
 class _Valty> inline
 _Ty2 *_Uninit_move(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<allocator<_Ty2> >&, _Valty *, _Scalar_ptr_iterator_tag)
 {
                                       ;
 size_t _Count = (size_t)(_Last - _First);
 return ((_Ty2 *):: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First)) + _Count);
 }
# 586 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Uninit_move(_First, _Last, _Dest, _Al,
  _Val_type(_First), _Ptr_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Rechecked(_Dest,
  _Uninit_move(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _FwdIt,
 class _Tval> inline
 void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
  _Nonscalar_ptr_iterator_tag)
 {
                            ;
 _FwdIt _Next = _First;

 {{
 for (; _First != _Last; ++_First)
  _Construct(::std:: addressof(*_First), _Val);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 }

template<class _Ty,
 class _Tval> inline
 void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
  _Scalar_ptr_iterator_tag)
 {
 ::std:: fill(_First, _Last, _Val);
 }

template<class _FwdIt,
 class _Tval> inline
 void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
 {
 _Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
 }


template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
  _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Construct(::std:: addressof(*_First), _Val);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}

 return (_First);
 }

template<class _Ty,
 class _Diff,
 class _Tval> inline
 _Ty *_Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
  _Scalar_ptr_iterator_tag)
 {
 return (_Fill_n(_First, _Count, _Val));
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval& _Val)
 {
 return (_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First)));
 }


template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty> inline
 void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
   _Valty *, _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Al.construct(_First, *_Pval);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 }

template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty> inline
 void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
   _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Uninit_fill_n(_First, _Count,
  _Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
 }

template<class _Ty,
 class _Diff,
 class _Tval,
 class _Valty> inline
 void _Uninit_fill_n(_Ty *_First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<allocator<_Ty> >&,
   _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Fill_n(_First, _Count, *_Pval);
 }
# 751 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc> inline
 void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Alloc& _Al)
 {
 _Uninit_fill_n(_First, _Count, _Pval, _Al,
  _Val_type(_First), _Ptr_cat(_First, _First));
 }


template<class _FwdIt,
 class _Diff,
 class _Alloc,
 class _Valty> inline
 void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Al.construct(_First);

 } if (0) {
 for (; _Next != _First; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc,
 class _Valty> inline
 void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Uninit_def_fill_n(_First, _Count,
  _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
 }

template<class _Ty,
 class _Diff,
 class _Valty> inline
 void _Uninit_def_fill_n(_Ty *_First, _Diff _Count,
  _Wrap_alloc<allocator<_Ty> >&, _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Fill_n(_First, _Count, (_Valty)0);
 }
# 821 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
  _Alloc& _Al)
 {
 _Uninit_def_fill_n(_First, _Count, _Al,
  _Val_type(_First), _Ptr_cat(_First, _First));
 }
# 898 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\xmemory" 3
template<class _OutIt,
 class _Ty>
 class raw_storage_iterator
  : public _Outit
 {
public:
 explicit raw_storage_iterator(_OutIt _First)
  : _Next(_First)
  {
  }

 raw_storage_iterator<_OutIt, _Ty>& operator*()
  {
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty>& operator=(const _Ty& _Val)
  {
  _Construct(::std:: addressof(*_Next), _Val);
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty>& operator++()
  {
  ++_Next;
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty> operator++(int)
  {
  raw_storage_iterator<_OutIt, _Ty> _Ans = *this;
  ++_Next;
  return (_Ans);
  }

 _OutIt base() const
  {
  return (_Next);
  }

private:
 _OutIt _Next;
 };


template<class _Ty>
 class _Temp_iterator
  : public _Outit
 {
public:
 typedef _Ty *_Pty;

 _Temp_iterator(ptrdiff_t _Count = 0)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = _Count;
  _Pbuf = &_Buf;
  }

 _Temp_iterator(const _Temp_iterator<_Ty>& _Right)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = 0;
  *this = _Right;
  }

 ~_Temp_iterator() noexcept
  {
  if (_Buf._Begin != 0)
   {
   for (_Pty _Next = _Buf._Begin;
    _Next != _Buf._Hiwater; ++_Next)
    _Destroy(_Next);
   ::std:: return_temporary_buffer(_Buf._Begin);
   }
  }

 _Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
  {
  _Pbuf = _Right._Pbuf;
  return (*this);
  }

 _Temp_iterator<_Ty>& operator=(const _Ty& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ = _Val;
  else
   {
   _Pty _Ptr = _Pbuf->_Current;
   _Construct(_Ptr, _Val);
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }
  return (*this);
  }

 _Temp_iterator<_Ty>& operator=(_Ty&& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ =
    ::std:: forward<_Ty>(_Val);
  else
   {
   _Pty _Ptr = _Pbuf->_Current;
   _Construct(_Ptr, ::std:: forward<_Ty>(_Val));
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }
  return (*this);
  }

 _Temp_iterator<_Ty>& operator*()
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& operator++()
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& operator++(int)
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& _Init()
  {
  _Pbuf->_Current = _Pbuf->_Begin;
  return (*this);
  }

 _Pty _First() const
  {
  return (_Pbuf->_Begin);
  }

 _Pty _Last() const
  {
  return (_Pbuf->_Current);
  }

 ptrdiff_t _Maxlen()
  {
  if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
   {
   pair<_Pty, ptrdiff_t> _Pair =
    ::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

   _Pbuf->_Begin = _Pair.first;
   _Pbuf->_Current = _Pair.first;
   _Pbuf->_Hiwater = _Pair.first;
   _Pbuf->_Size = _Pair.second;
   }
  return (_Pbuf->_Size);
  }

private:
 struct _Bufpar
  {
  _Pty _Begin;
  _Pty _Current;
  _Pty _Hiwater;
  ptrdiff_t _Size;
  };
 _Bufpar _Buf;
 _Bufpar *_Pbuf;
 };


template<class _Ty>
 class auto_ptr;

template<class _Ty>
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref(_Ty *_Right)
  : _Ref(_Right)
  {
  }

 _Ty *_Ref;
 };

template<class _Ty>
 class auto_ptr
  {
public:
 typedef auto_ptr<_Ty> _Myt;
 typedef _Ty element_type;

 explicit auto_ptr(_Ty *_Ptr = 0) noexcept
  : _Myptr(_Ptr)
  {
  }

 auto_ptr(_Myt& _Right) noexcept
  : _Myptr(_Right.release())
  {
  }

 auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  _Myptr = _Ptr;
  }

 template<class _Other>
  operator auto_ptr<_Other>() noexcept
  {
  return (auto_ptr<_Other>(*this));
  }

 template<class _Other>
  operator auto_ptr_ref<_Other>() noexcept
  {
  _Other *_Cvtptr = _Myptr;
  auto_ptr_ref<_Other> _Ans(_Cvtptr);
  _Myptr = 0;
  return (_Ans);
  }

 template<class _Other>
  _Myt& operator=(auto_ptr<_Other>& _Right) noexcept
  {
  reset(_Right.release());
  return (*this);
  }

 template<class _Other>
  auto_ptr(auto_ptr<_Other>& _Right) noexcept
  : _Myptr(_Right.release())
  {
  }

 _Myt& operator=(_Myt& _Right) noexcept
  {
  reset(_Right.release());
  return (*this);
  }

 _Myt& operator=(auto_ptr_ref<_Ty> _Right) noexcept
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  reset(_Ptr);
  return (*this);
  }

 ~auto_ptr() noexcept
  {
  delete _Myptr;
  }

 _Ty& operator*() const noexcept
  {





  return (*get());
  }

 _Ty *operator->() const noexcept
  {





  return (get());
  }

 _Ty *get() const noexcept
  {
  return (_Myptr);
  }

 _Ty *release() noexcept
  {
  _Ty *_Tmp = _Myptr;
  _Myptr = 0;
  return (_Tmp);
  }

 void reset(_Ty *_Ptr = 0)
  {
  if (_Ptr != _Myptr)
   delete _Myptr;
  _Myptr = _Ptr;
  }

private:
 _Ty *_Myptr;
 };
}


#pragma clang diagnostic pop
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 2 3




namespace std {

template<class _Mylist,
 class _Base = _Iterator_base0>
 class _List_unchecked_const_iterator
  : public _Iterator012<bidirectional_iterator_tag,
   typename _Mylist::value_type,
   typename _Mylist::difference_type,
   typename _Mylist::const_pointer,
   typename _Mylist::const_reference,
   _Base>
 {
public:
 typedef _List_unchecked_const_iterator<_Mylist, _Base> _Myiter;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::const_pointer pointer;
 typedef typename _Mylist::const_reference reference;

 _List_unchecked_const_iterator()
  : _Ptr(nullptr)
  {
  }

 _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Ptr(_Pnode)
  {
  this->_Adopt(_Plist);
  }

 reference operator*() const
  {
  return (_Mylist::_Myval(_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  _Ptr = _Mylist::_Nextnode(_Ptr);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  _Ptr = _Mylist::_Prevnode(_Ptr);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 _Nodeptr _Mynode() const
  {
  return (_Ptr);
  }

 _Nodeptr _Ptr;
 };


template<class _Mylist>
 class _List_unchecked_iterator
  : public _List_unchecked_const_iterator<_Mylist>
 {
public:
 typedef _List_unchecked_iterator<_Mylist> _Myiter;
 typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::pointer pointer;
 typedef typename _Mylist::reference reference;

 _List_unchecked_iterator()
  {
  }

 _List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };


template<class _Mylist>
 class _List_const_iterator
  : public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
 {
public:
 typedef _List_const_iterator<_Mylist> _Myiter;
 typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::const_pointer pointer;
 typedef typename _Mylist::const_reference reference;

 _List_const_iterator()
  : _Mybase()
  {
  }

 _List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
  }

 reference operator*() const
  {
# 221 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
  return (_Mylist::_Myval(this->_Ptr));
  }

 _Myiter& operator++()
  {
# 241 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
  this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 271 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
  this->_Ptr = _Mylist::_Prevnode(this->_Ptr);


  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
# 297 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }
 };

template<class _Mylist> inline
 typename _List_const_iterator<_Mylist>::_Unchecked_type
  _Unchecked(_List_const_iterator<_Mylist> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mylist> inline
 _List_const_iterator<_Mylist>&
  _Rechecked(_List_const_iterator<_Mylist>& _Iter,
   typename _List_const_iterator<_Mylist>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Mylist>
 class _List_iterator
  : public _List_const_iterator<_Mylist>
 {
public:
 typedef _List_iterator<_Mylist> _Myiter;
 typedef _List_const_iterator<_Mylist> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::pointer pointer;
 typedef typename _Mylist::reference reference;

 _List_iterator()
  {
  }

 _List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };

template<class _Mylist> inline
 typename _List_iterator<_Mylist>::_Unchecked_type
  _Unchecked(_List_iterator<_Mylist> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mylist> inline
 _List_iterator<_Mylist>&
  _Rechecked(_List_iterator<_Mylist>& _Iter,
   typename _List_iterator<_Mylist>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference,
 class _Nodeptr_type>
 struct _List_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 typedef _Nodeptr_type _Nodeptr;
 };

template<class _Value_type,
 class _Voidptr>
 struct _List_node
  {
  _Voidptr _Next;
  _Voidptr _Prev;
  _Value_type _Myval;

 private:
  _List_node& operator=(const _List_node&);
  };

template<class _Value_type>
 struct _List_node<_Value_type, void *>
  {
  typedef _List_node<_Value_type, void *> *_Nodeptr;
  _Nodeptr _Next;
  _Nodeptr _Prev;
  _Value_type _Myval;

 private:
  _List_node& operator=(const _List_node&);
  };

template<class _Ty>
 struct _List_simple_types
  : public _Simple_types<_Ty>
 {
 typedef _List_node<_Ty, void *> _Node;
 typedef _Node *_Nodeptr;
 };

template<class _Ty,
 class _Alloc0>
 struct _List_base_types
 {
# 478 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
 typedef _Alloc0 _Alloc;


 typedef _List_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
  _Voidptr;
 typedef _List_node<typename _Alty::value_type,
  _Voidptr> _Node;

 typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
 typedef typename _Alnod_type::pointer _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _List_simple_types<typename _Alty::value_type>,
  _List_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference,
   _Nodeptr> >::type
  _Val_types;
 };


template<class _Val_types>
 class _List_val
  : public _Container_base
 {
public:
 typedef _List_val<_Val_types> _Myt;

 typedef typename _Val_types::_Nodeptr _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _List_const_iterator<_Myt> const_iterator;
 typedef _List_iterator<_Myt> iterator;

 typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
 typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;

 _List_val()
  {
  this->_Myhead = 0;
  this->_Mysize = 0;
  }

 static _Nodepref _Nextnode(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Next);
  }

 static _Nodepref _Prevnode(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Prev);
  }

 static reference _Myval(_Nodeptr _Pnode)
  {
  return ((reference)_Pnode->_Myval);
  }

 _Nodeptr _Myhead;
 size_type _Mysize;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _List_alloc
  : public _List_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _List_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alnod(_Al)
  {
  this->_Myhead = _Buyheadnode();
  }

 _List_alloc(_Alloc0&& _Al)
  : _Alnod(::std:: move(_Al))
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_List_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Alnod, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Alnod, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(_Alnod, _Right._Alnod);
  }
# 676 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
 _Nodeptr _Buyheadnode()
  {
  return (_Buynode0(_Nodeptr(), _Nodeptr()));
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  _Alnod.destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  _Alnod.destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  _Alnod.deallocate(_Pnode, 1);
  }

 _Nodeptr _Buynode0(_Nodeptr _Next,
  _Nodeptr _Prev, _Nodeptr _Pnode = nullptr)
  {
  if (_Pnode == nullptr)
   _Pnode = _Alnod.allocate(1);

  if (_Next == _Nodeptr())
   {
   _Next = _Pnode;
   _Prev = _Pnode;
   }
  {{
  _Alnod.construct(
   ::std:: addressof(this->_Nextnode(_Pnode)), _Next);
  _Alnod.construct(
   ::std:: addressof(this->_Prevnode(_Pnode)), _Prev);
  } if (0) {
  _Alnod.deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 _Alty& _Getal() noexcept
  {
  return (_Alnod);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alnod);
  }

 _Alty _Alnod;
 };


template<class _Alloc_types>
 class _List_alloc<false, _Alloc_types>
  : public _List_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _List_alloc<false, _Alloc_types> _Myt;
 typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _List_alloc(const _Alloc0& = _Alloc0())
  {
  this->_Myhead = _Buyheadnode();
  }

 _List_alloc(_Alloc0&&)
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_List_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 830 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
 _Nodeptr _Buyheadnode()
  {
  return (_Buynode0(_Nodeptr(), _Nodeptr()));
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 _Nodeptr _Buynode0(_Nodeptr _Next,
  _Nodeptr _Prev, _Nodeptr _Pnode = nullptr)
  {
  if (_Pnode == nullptr)
   _Pnode = this->_Getal().allocate(1);

  if (_Next == _Nodeptr())
   {
   _Next = _Pnode;
   _Prev = _Pnode;
   }
  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Nextnode(_Pnode)), _Next);
  this->_Getal().construct(
   ::std:: addressof(this->_Prevnode(_Pnode)), _Prev);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc>
 class _List_buy
  : public _List_alloc<!is_empty<_Alloc>::value,
   _List_base_types<_Ty, _Alloc> >
 {
public:
 typedef _List_alloc<!is_empty<_Alloc>::value,
  _List_base_types<_Ty, _Alloc> > _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Nodeptr _Nodeptr;

 _List_buy(const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  }

 _List_buy(_Alloc&& _Al)
  : _Mybase(::std:: move(_Al))
  {
  }

 template<class... _Valty>
  _Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
   _Valty&&... _Val)
  {
  _Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Pnode)),
    ::std:: forward<_Valty>(_Val)...);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 void _Freenode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }
 };


template<class _Ty,
 class _Alloc = allocator<_Ty> >
 class list
  : public _List_buy<_Ty, _Alloc>
 {
public:
 typedef list<_Ty, _Alloc> _Myt;
 typedef _List_buy<_Ty, _Alloc> _Mybase;
 typedef typename _Mybase::_Node _Node;
 typedef typename _Mybase::_Nodeptr _Nodeptr;
 typedef typename _Mybase::_Alty _Alty;

 typedef _Alloc allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::value_type value_type;

 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::_Unchecked_const_iterator
  _Unchecked_const_iterator;
 typedef typename _Mybase::_Unchecked_iterator
  _Unchecked_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 list()
  : _Mybase()
  {
  }

 explicit list(const _Alloc& _Al)
  : _Mybase(_Al)
  {
  }

 explicit list(size_type _Count)
  : _Mybase()
  {
  resize(_Count);
  }


 list(size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  resize(_Count);
  }


 list(size_type _Count, const _Ty& _Val)
  : _Mybase()
  {
  _Construct_n(_Count, _Val);
  }

 list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct_n(_Count, _Val);
  }

 list(const _Myt& _Right)
  : _Mybase(_Right._Getal().select_on_container_copy_construction())
  {
  {{
  insert(begin(), _Right.begin(), _Right.end());
  } if (0) {
  _Tidy();
          ;
  }}
  }

 list(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  {{
  insert(begin(), _Right.begin(), _Right.end());
  } if (0) {
  _Tidy();
          ;
  }}
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  list(_Iter _First, _Iter _Last)
  : _Mybase()
  {
  _Construct(_First, _Last);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  list(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct(_First, _Last);
  }

 template<class _Iter>
            void _Construct(_Iter _First, _Iter _Last)
  {
  {{
  insert(begin(), _First, _Last);
  } if (0) {
  _Tidy();
          ;
  }}
  }

           void _Construct_n(size_type _Count,
  const _Ty& _Val)
  {
  {{
  _Insert_n(_Unchecked_begin(), _Count, _Val);
  } if (0) {
  _Tidy();
          ;
  }}
  }

 list(_Myt&& _Right)
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 list(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

           _Myt& operator=(_Myt&& _Right)

  {
  if (this != &_Right)
   {
   clear();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());
   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

           void _Assign_rv(_Myt&& _Right)
  {
  this->_Swap_all(_Right);
  _Swap_adl(this->_Myhead, _Right._Myhead);
  ::std:: swap(this->_Mysize, _Right._Mysize);
  }

 void push_front(_Ty&& _Val)
  {
  _Insert(_Unchecked_begin(), ::std:: forward<_Ty>(_Val));
  }

 void push_back(_Ty&& _Val)
  {
  _Insert(_Unchecked_end(), ::std:: forward<_Ty>(_Val));
  }

 iterator insert(const_iterator _Where, _Ty&& _Val)
  {
  return (emplace(_Where, ::std:: forward<_Ty>(_Val)));
  }

 template<class... _Valty>
  reference
  emplace_front(_Valty&&... _Val)
  {
  _Insert(_Unchecked_begin(), ::std:: forward<_Valty>(_Val)...);
  return (front());
  }

 template<class... _Valty>
  reference
  emplace_back(_Valty&&... _Val)
  {
  _Insert(_Unchecked_end(), ::std:: forward<_Valty>(_Val)...);
  return (back());
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {





  _Insert(_Where._Unchecked(), ::std:: forward<_Valty>(_Val)...);
  return (_Make_iter(--_Where));
  }

 template<class... _Valty>
            void _Insert(_Unchecked_const_iterator _Where,
  _Valty&&... _Val)
  {
  _Nodeptr _Pnode = _Where._Mynode();
  _Nodeptr _Newnode =
   this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
    ::std:: forward<_Valty>(_Val)...);
  _Incsize(1);
  this->_Prevnode(_Pnode) = _Newnode;
  this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
  }

 void _Insert(_Nodeptr _Ptr)
  {
  _Nodeptr _Pnode = _Unchecked_begin()._Mynode();
  _Nodeptr _Newnode = this->_Buynode0(_Pnode, this->_Prevnode(_Pnode),
     _Ptr);
  _Incsize(1);
  this->_Prevnode(_Pnode) = _Newnode;
  this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
  }

 list(::std:: initializer_list<_Ty> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  insert(begin(), _Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Ty> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<_Ty> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Ty> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~list() noexcept
  {
  _Tidy();
  }

           _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    clear();
    this->_Copy_alloc(_Right._Getal());
    }
   assign(_Right.begin(), _Right.end());
   }
  return (*this);
  }

 iterator begin() noexcept
  {
  return (iterator(this->_Nextnode(this->_Myhead), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Nextnode(this->_Myhead), this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Myhead, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Myhead, this));
  }

 _Unchecked_iterator _Unchecked_begin()
  {
  return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
   this));
  }

 _Unchecked_const_iterator _Unchecked_begin() const
  {
  return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
   this));
  }

 _Unchecked_iterator _Unchecked_end()
  {
  return (_Unchecked_iterator(this->_Myhead, this));
  }

 _Unchecked_const_iterator _Unchecked_end() const
  {
  return (_Unchecked_const_iterator(this->_Myhead, this));
  }

 iterator _Make_iter(const_iterator _Where) const noexcept
  {
  return (iterator(_Where._Ptr, this));
  }

 iterator _Make_iter(_Unchecked_const_iterator _Where) const
  {
  return (iterator(_Where._Ptr, this));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

           void resize(size_type _Newsize)
  {
  if (this->_Mysize < _Newsize)
   {
   size_type _Count = 0;
   {{
   for (; this->_Mysize < _Newsize; ++_Count)
    _Insert(_Unchecked_end());
   } if (0) {
   for (; 0 < _Count; --_Count)
    pop_back();
           ;
   }}
   }
  else
   while (_Newsize < this->_Mysize)
    pop_back();
  }

           void resize(size_type _Newsize, const _Ty& _Val)
  {
  if (this->_Mysize < _Newsize)
   _Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
  else
   while (_Newsize < this->_Mysize)
    pop_back();
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  return (this->_Getal().max_size());
  }

 bool empty() const noexcept
  {
  return (this->_Mysize == 0);
  }

 allocator_type get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(--end()));
  }

 const_reference back() const
  {
  return (*(--end()));
  }

 void push_front(const _Ty& _Val)
  {
  _Insert(_Unchecked_begin(), _Val);
  }

 void pop_front()
  {
  erase(begin());
  }

 void push_back(const _Ty& _Val)
  {
  _Insert(_Unchecked_end(), _Val);
  }

 void pop_back()
  {
  erase(--end());
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
            void assign(_Iter _First, _Iter _Last)
  {
  iterator _Old = begin();
  {{
  for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
   _Reusenode(_Old, *_First);
  for (; _First != _Last; ++_First)
   _Insert(_Unchecked_end(), *_First);
  } if (0) {
  clear();
          ;
  }}
  erase(_Old, end());
  }

 template<class _TArg>
            void _Reusenode(iterator _Where, _TArg&& _Arg)
  {
  {{
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Where._Ptr)));
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Where._Ptr)),
   ::std:: forward<_TArg>(_Arg));
  } if (0) {
  _Unlinknode(_Where);
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Where._Ptr)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Where._Ptr)));
  this->_Getal().deallocate(_Where._Ptr, 1);
          ;
  }}
  }

 void assign(size_type _Count, const _Ty& _Val)
  {
  clear();
  _Insert_n(_Unchecked_begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const _Ty& _Val)
  {





  _Insert(_Where._Unchecked(), _Val);
  return (_Make_iter(--_Where));
  }

           iterator insert(const_iterator _Where,
  size_type _Count, const _Ty& _Val)
  {





  iterator _Prev = _Make_iter(_Where);
  if (_Prev == begin())
   {
   _Insert_n(_Where._Unchecked(), _Count, _Val);
   return (begin());
   }
  else
   {
   --_Prev;
   _Insert_n(_Where._Unchecked(), _Count, _Val);
   return (++_Prev);
   }
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
            iterator insert(const_iterator _Where,
   _Iter _First, _Iter _Last)
  {





  iterator _Prev = _Make_iter(_Where);
  if (_Prev == begin())
   {
   _Insert_range(_Where._Unchecked(), _First, _Last,
    _Iter_cat(_First));
   return (begin());
   }
  else
   {
   --_Prev;
   _Insert_range(_Where._Unchecked(), _First, _Last,
    _Iter_cat(_First));
   return (++_Prev);
   }
  }

 template<class _Iter>
            void _Insert_range(_Unchecked_const_iterator _Where,
   _Iter _First, _Iter _Last, input_iterator_tag)
  {
  size_type _Num = 0;

  {{
  for (; _First != _Last; ++_First, (void)++_Num)
   _Insert(_Where, *_First);
  } if (0) {
  for (; 0 < _Num; --_Num)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

 template<class _Iter>
            void _Insert_range(_Unchecked_const_iterator _Where,
   _Iter _First, _Iter _Last, forward_iterator_tag)
  {
                             ;
  _Iter _Next = _First;

  {{
  for (; _First != _Last; ++_First)
   _Insert(_Where, *_First);
  } if (0) {
  for (; _Next != _First; ++_Next)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

           _Nodeptr _Unlinknode(const_iterator _Where)
  {
# 1533 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
  _Nodeptr _Pnode = (_Where)._Mynode();


  if (_Pnode != this->_Myhead)
   {
   this->_Nextnode(this->_Prevnode(_Pnode)) =
    this->_Nextnode(_Pnode);
   this->_Prevnode(this->_Nextnode(_Pnode)) =
    this->_Prevnode(_Pnode);

   --this->_Mysize;
   }
  return (_Pnode);
  }

           iterator erase(const_iterator _Where,
  bool _Keep = false)
  {
  _Nodeptr _Pnode = _Unlinknode(_Where++);
  if (!_Keep)
   if (_Pnode != this->_Myhead)
    this->_Freenode(_Pnode);
  return (_Make_iter(_Where));
  }

           void _Unchecked_erase(_Unchecked_const_iterator _Where)
  {
  _Nodeptr _Pnode = _Where._Mynode();

  if (_Pnode != this->_Myhead)
   {
   this->_Nextnode(this->_Prevnode(_Pnode)) =
    this->_Nextnode(_Pnode);
   this->_Prevnode(this->_Nextnode(_Pnode)) =
    this->_Prevnode(_Pnode);
   this->_Freenode(_Pnode);
   --this->_Mysize;
   }
  }

           iterator erase(const_iterator _First, const_iterator _Last)
  {
  if (_First == begin() && _Last == end())
   {
   clear();
   return (end());
   }
  else
   {
   while (_First != _Last)
    _First = erase(_First);
   return (_Make_iter(_Last));
   }
  }

           void clear() noexcept
  {




  _Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
  this->_Nextnode(this->_Myhead) = this->_Myhead;
  this->_Prevnode(this->_Myhead) = this->_Myhead;
  this->_Mysize = 0;

  for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
   {
   _Pnext = this->_Nextnode(_Pnode);
   this->_Freenode(_Pnode);
   }
  }

           void swap(_Myt& _Right)

  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else





   ::std:: terminate();

  }

 void splice(const_iterator _Where, _Myt& _Right)
  {
  if (this != ::std:: addressof(_Right) && !_Right.empty())
   {
   _Splice(_Where, _Right, _Right.begin(), _Right.end(),
    _Right._Mysize);
   }
  }

 void splice(const_iterator _Where, _Myt&& _Right)
  {
  splice(_Where, (_Myt&)_Right);
  }

           void splice(const_iterator _Where, _Myt& _Right,
  const_iterator _First)
  {






  if (_First != _Right.end())


   {
   const_iterator _Last = _First;
   ++_Last;
   if (this != ::std:: addressof(_Right)
    || (_Where != _First && _Where != _Last))
    _Splice(_Where, _Right, _First, _Last, 1);
   }
  }

 void splice(const_iterator _Where, _Myt&& _Right,
  const_iterator _First)
  {
  splice(_Where, (_Myt&)_Right, _First);
  }

           void splice(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last)
  {
  if (_First != _Last && (this != ::std:: addressof(_Right) || _Where != _Last))
   {
   size_type _Count = 0;

   if (this == ::std:: addressof(_Right))
    ;
   else if (_First == _Right.begin() && _Last == _Right.end())
    _Count = _Right._Mysize;
   else
    {
    const_iterator _Next = _First;

    for (; _Next != _Last; ++_Next, (void)++_Count)
     if (_Next == _Right.end())
      _Xlength_error("list<T> bad splice");
    }
   _Splice(_Where, _Right, _First, _Last, _Count);
   }
  }

 void splice(const_iterator _Where,
  _Myt&& _Right, const_iterator _First, const_iterator _Last)
  {
  splice(_Where, (_Myt&)_Right, _First, _Last);
  }

           void remove(const _Ty& _Val)
  {
  iterator _Val_it = end();

  for (iterator _First = begin(); _First != end(); )
   if (*_First == _Val)
    if (::std:: addressof(*_First) == ::std:: addressof(_Val))
     _Val_it = _First++;
    else
     _First = erase(_First);
   else
    ++_First;

  if (_Val_it != end())
   erase(_Val_it);
  }

 template<class _Pr1>
            void remove_if(_Pr1 _Pred)
  {
  for (iterator _First = begin(); _First != end(); )
   if (_Pred(*_First))
    _First = erase(_First);
   else
    ++_First;
  }

 void unique()
  {
  unique(equal_to<>());
  }

 template<class _Pr2>
            void unique(_Pr2 _Pred)
  {
  const _Nodeptr _Phead = this->_Myhead;
  _Nodeptr _Pprev = this->_Nextnode(_Phead);
  _Nodeptr _Pnode = this->_Nextnode(_Pprev);

  while (_Pnode != _Phead)
   if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
    {
    const _Nodeptr _Perase = _Pnode;
    _Pnode = this->_Nextnode(_Pnode);

    this->_Nextnode(_Pprev) = _Pnode;
    this->_Prevnode(_Pnode) = _Pprev;
    this->_Freenode(_Perase);

    --this->_Mysize;
    }
   else
    {
    _Pprev = _Pnode;
    _Pnode = this->_Nextnode(_Pnode);
    }
  }

 void merge(_Myt& _Right)
  {
  merge(_Right, less<>());
  }

 void merge(_Myt&& _Right)
  {
  merge((_Myt&)_Right);
  }

 template<class _Pr2>
            void merge(_Myt& _Right, _Pr2 _Pred)
  {
  if (::std:: addressof(_Right) != this)
   {
   iterator _First1 = begin(), _Last1 = end();
   iterator _First2 = _Right.begin(), _Last2 = _Right.end();
                                            ;
                                            ;

   while (_First1 != _Last1 && _First2 != _Last2)
    if (_Pred(*_First2, *_First1))
     {
     iterator _Mid2 = _First2;
     _Splice(_First1, _Right, _First2, ++_Mid2, 1);
     _First2 = _Mid2;
     }
    else
     ++_First1;

   if (_First2 != _Last2)
    _Splice(_Last1, _Right, _First2, _Last2,
     _Right._Mysize);
   }
  }

 template<class _Pr2>
  void merge(_Myt&& _Right, _Pr2 _Pred)
  {
  merge((_Myt&)_Right, _Pred);
  }

 void sort()
  {
  sort(less<>());
  }

 template<class _Pr2>
            void sort(_Pr2 _Pred)
  {
  _Sort(begin(), end(), _Pred, this->_Mysize);
  }

 template<class _Pr2>
  iterator _Sort(iterator _First, iterator _Last, _Pr2 _Pred,
   size_type _Size)
  {

  if (_Size < 2)
   return (_First);

  iterator _Mid = ::std:: next(_First, _Size / 2);
  _First = _Sort(_First, _Mid, _Pred, _Size / 2);
  _Mid = _Sort(_Mid, _Last, _Pred, _Size - _Size / 2);
  iterator _Newfirst = _First;

  for (bool _Initial_loop = true; ; _Initial_loop = false)
   {
   if (_Pred(*_Mid, *_First))
    {
    if (_Initial_loop)
     _Newfirst = _Mid;
    splice(_First, *this, _Mid++);
    if (_Mid == _Last)
     return (_Newfirst);
    }
   else
    {
    ++_First;
    if (_First == _Mid)
     return (_Newfirst);
    }
   }
  }

           void reverse() noexcept
  {
  const _Nodeptr _Phead = this->_Myhead;
  _Nodeptr _Pnode = _Phead;

  for (; ; )
   {
   const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
   this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
   this->_Prevnode(_Pnode) = _Pnext;

   if (_Pnext == _Phead)
    break;
   _Pnode = _Pnext;
   }
  }

           void _Splice(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last,
  size_type _Count)
  {
# 1924 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
  if (this->_Getal() != _Right._Getal())
   ::std:: terminate();


  _Splice_same(_Where, _Right, _First, _Last, _Count);
  }

           void _Splice_same(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last,
  size_type _Count)
  {
  if (this != ::std:: addressof(_Right))
   {
   _Incsize(_Count);
   _Right._Mysize -= _Count;
   }
  this->_Nextnode(this->_Prevnode(_First._Mynode())) =
   _Last._Mynode();
  this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
   _Where._Mynode();
  this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
   _First._Mynode();

  _Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
  this->_Prevnode(_Where._Mynode()) =
   this->_Prevnode(_Last._Mynode());
  this->_Prevnode(_Last._Mynode()) =
   this->_Prevnode(_First._Mynode());
  this->_Prevnode(_First._Mynode()) = _Pnode;
  }

           void _Unchecked_splice(_Unchecked_const_iterator _Where,
  _Unchecked_const_iterator _First,
  _Unchecked_const_iterator _Last)
  {
  this->_Nextnode(this->_Prevnode(_First._Mynode())) =
   _Last._Mynode();
  this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
   _Where._Mynode();
  this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
   _First._Mynode();

  _Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
  this->_Prevnode(_Where._Mynode()) =
   this->_Prevnode(_Last._Mynode());
  this->_Prevnode(_Last._Mynode()) =
   this->_Prevnode(_First._Mynode());
  this->_Prevnode(_First._Mynode()) = _Pnode;
  }

 void _Tidy()
  {
  clear();
  }

           void _Insert_n(_Unchecked_const_iterator _Where,
  size_type _Count, const _Ty& _Val)
  {
  size_type _Countsave = _Count;

  {{
  for (; 0 < _Count; --_Count)
   _Insert(_Where, _Val);
  } if (0) {
  for (; _Count < _Countsave; ++_Count)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

 void _Incsize(size_type _Count)
  {
  if (max_size() - this->_Mysize - 1 < _Count)
   _Xlength_error("list<T> too long");
  this->_Mysize += _Count;
  }
# 2023 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
 };
# 2038 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
template<class _Ty,
 class _Alloc> inline
 void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator==(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator!=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }
# 2122 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\list" 3
}
# 7 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/../Managed/MemoryBufferManaged.h" 2

namespace SaveData
{


 enum class BufferIntegrityChecks
 {
  BufferBegin = 0,
  BufferEnd,

  PNGBegin,
  PNGEnd,
 };

 struct MemoryBufferManaged
 {
  UInt32 length;
  void* data;
 };

 class MemoryBuffer
 {
  const static Int32 MAX_BUFFER_SIZE = 1024*1024;

  void* data;
  UInt32 defaultBufferSize;
  UInt32 maxBufferSize;
  char* pos;

  static MemoryBuffer* s_MemoryBuffer;
  static MemoryBuffer* s_NotificationBuffer;

 public:

  void CopyTo(MemoryBufferManaged* destination);

  MemoryBuffer(UInt32 defaultSize);

  static void Initialise();
  static void Shutdown();
  static MemoryBuffer& GetBuffer();
  static MemoryBuffer& GetNotificationBuffer();

  void StartResponseWrite();
  void FinishResponseWrite();

  void Reset();

  void WriteMarker(BufferIntegrityChecks value);

  void WriteBool(bool value);

  void WriteInt8(Int8 value);
  void WriteUInt8(UInt8 value);

  void WriteInt16(Int16 value);
  void WriteUInt16(UInt16 value);

  void WriteInt32(Int32 value);
  void WriteUInt32(UInt32 value);

  void WriteInt64(Int64 value);
  void WriteUInt64(UInt64 value);

  void WritePtr(void* ptr);

  void WriteDouble(double value);

  void WriteData(const char* data, UInt32 size);

  void WriteString(const char* str);
  void WriteString(const char* str, UInt32 size);

 private:
  void GrowBuffer(size_t requiredSize);
 };


}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/../Managed/ManagedResponse.h" 2

namespace SaveData
{
 class ResponseBase
 {
 public:
  static void MarshalResponseBase(int returnCode, MemoryBuffer& buffer);
 };






}
# 25 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/ErrorCodes.cpp" 2



namespace SaveData
{
 const char* LookupSceErrorCode(int errorCode)
 {
  const char* errorString = __null;

  switch(errorCode)
  {


  default:
   break;
  }

  return errorString;
 }

}
# 2 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/ErrorHandling/Errors.cpp" 1




namespace SaveData
{


 void APIResult::SetResult(APIResult* result, APIResultTypes type)
 {
  result->apiResult = type;
  result->message = "";
  result->filename = "";
  result->lineNumber = 0;
  result->sceErrorCode = 0;
 }

 void APIResult::SetResult(APIResult* result, APIResultTypes type, char const * message, char const * filename, int lineNumber)
 {
  result->apiResult = type;
  result->message = message;
  result->filename = filename;
  result->lineNumber = lineNumber;
  result->sceErrorCode = 0;
 }

 void APIResult::SetSceResult(APIResult* result, APIResultTypes type, int sceErrorCode, char const * filename, int lineNumber)
 {
  char const* message = LookupSceErrorCode(sceErrorCode);

  result->apiResult = type;

  if ( message == 0)
  {
   result->message = "";
  }
  else
  {
   result->message = message;
  }
  result->filename = filename;
  result->lineNumber = lineNumber;
  result->sceErrorCode = sceErrorCode;
 }
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Managed/ManagedRequest.cpp" 1



namespace SaveData
{

}
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Managed/ManagedResponse.cpp" 1


namespace SaveData
{
 void ResponseBase::MarshalResponseBase(int returnCode, MemoryBuffer& buffer)
 {
  buffer.WriteInt32(returnCode);
 }
}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Managed/MemoryBufferManaged.cpp" 1


namespace SaveData
{
 MemoryBuffer* MemoryBuffer::s_MemoryBuffer;
 MemoryBuffer* MemoryBuffer::s_NotificationBuffer;


 void MemoryBuffer::Initialise()
 {
  s_MemoryBuffer = new MemoryBuffer(MAX_BUFFER_SIZE);
  s_NotificationBuffer = new MemoryBuffer(MAX_BUFFER_SIZE);
 }

 void MemoryBuffer::Shutdown()
 {
  delete s_MemoryBuffer;
 }


 MemoryBuffer& MemoryBuffer::GetBuffer()
 {
  return *s_MemoryBuffer;
 }

 MemoryBuffer& MemoryBuffer::GetNotificationBuffer()
 {
  return *s_NotificationBuffer;
 }


 void MemoryBuffer::StartResponseWrite()
 {
  Reset();
  WriteMarker(BufferIntegrityChecks::BufferBegin);
 }

 void MemoryBuffer::FinishResponseWrite()
 {
  WriteMarker(BufferIntegrityChecks::BufferEnd);
 }

 MemoryBuffer::MemoryBuffer(UInt32 defaultSize)
 {
  defaultBufferSize = defaultSize;
  maxBufferSize = defaultBufferSize;
  data = new char[maxBufferSize];
 }

 void MemoryBuffer::Reset()
 {
  if (maxBufferSize != defaultBufferSize)
  {

   delete (char*)data;
   maxBufferSize = defaultBufferSize;
   data = new char[maxBufferSize];
  }

  pos = (char*)data;
 }

 void MemoryBuffer::CopyTo(MemoryBufferManaged* destination)
 {
  destination->data = data;
  destination->length = pos - (char*)data;
 }



 void MemoryBuffer::WriteMarker(BufferIntegrityChecks value)
 {
  GrowBuffer(4);

  *((char*)pos) = (unsigned char)255; pos += 1;
  *((char*)pos) = (unsigned char)254; pos += 1;
  *((char*)pos) = (unsigned char)253; pos += 1;

  *((char*)pos) = (char)value;
  pos += 1;
 }


 void MemoryBuffer::WriteBool(bool value)
 {
  GrowBuffer(1);

  if ( value == false ) *((char*)pos) = 0;
  else *((char*)pos) = 1;

  pos += 1;
 }

 void MemoryBuffer::WriteInt8(Int8 value)
 {
  GrowBuffer(sizeof(Int8));
  *((Int8*)pos) = value;
  pos += sizeof(Int8);
 }

 void MemoryBuffer::WriteUInt8(UInt8 value)
 {
  GrowBuffer(sizeof(UInt8));
  *((UInt8*)pos) = value;
  pos += sizeof(UInt8);
 }

 void MemoryBuffer::WriteInt16(Int16 value)
 {
  GrowBuffer(sizeof(Int16));
  *((Int16*)pos) = value;
  pos += sizeof(Int16);
 }

 void MemoryBuffer::WriteUInt16(UInt16 value)
 {
  GrowBuffer(sizeof(UInt16));
  *((UInt16*)pos) = value;
  pos += sizeof(UInt16);
 }

 void MemoryBuffer::WriteInt32(Int32 value)
 {
  GrowBuffer(sizeof(Int32));
  *((Int32*)pos) = value;
  pos += sizeof(Int32);
 }

 void MemoryBuffer::WriteUInt32(UInt32 value)
 {
  GrowBuffer(sizeof(UInt32));
  *((UInt32*)pos) = value;
  pos += sizeof(UInt32);
 }

 void MemoryBuffer::WriteInt64(Int64 value)
 {
  GrowBuffer(sizeof(UInt64));
  *((Int64*)pos) = value;
  pos += sizeof(Int64);
 }

 void MemoryBuffer::WriteUInt64(UInt64 value)
 {
  GrowBuffer(sizeof(UInt64));
  *((UInt64*)pos) = value;
  pos += sizeof(UInt64);
 }

 void MemoryBuffer::WritePtr(void* ptr)
 {
  GrowBuffer(sizeof(void*));

  *((UInt64*)pos) = (UInt64)ptr;
  pos += sizeof(void*);
 }

 void MemoryBuffer::WriteDouble(double value)
 {
  GrowBuffer(sizeof(double));
  *((double*)pos) = value;
  pos += sizeof(double);
 }

 void MemoryBuffer::WriteString(const char* str)
 {
  UInt32 strLen = strlen(str);

  WriteData(str, strLen);
 }

 void MemoryBuffer::WriteString(const char* str, UInt32 size)
 {
  WriteData(str, size);
 }

 void MemoryBuffer::WriteData(const char* data, UInt32 size)
 {
  GrowBuffer(size + sizeof(UInt32));

  *((UInt32*)pos) = size;
  pos += sizeof(UInt32);
  memcpy(pos, data, size);
  pos += size;
 }

 void MemoryBuffer::GrowBuffer(size_t requiredSize)
 {
  int sizeUsed = pos - (char*)data;
  if ( sizeUsed + requiredSize > maxBufferSize )
  {

   while (maxBufferSize < sizeUsed + requiredSize)
   {
    maxBufferSize *= 2;
   }
   void* extendedData = new char[maxBufferSize];
   memcpy(extendedData, data, sizeUsed);

   delete (char*)data;
   data = extendedData;


   pos = ((char*)data) + sizeUsed;
  }
 }

}
# 7 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Backup.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Backup.h" 1




# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Core.h" 1






namespace SaveData
{
 struct DirNameManaged
 {
 public:
  char data[(32)];

  void CopyTo(SceSaveDataDirName &destination);
 };

 class PNGWriter
 {
 public:
  struct PNG
  {
   char png[4];
   char crlfczlf[4];
  };

  struct IHDR
  {
   char ihdr[4];
   int ihdrlen;
   int width;
   int height;
   char bitDepth;
   char colorType;
   char compressionMethod;
   char filterMethod;
   char interlaceMethod;
  };

  static void WriteToBuffer(const void* iconData, Int32 size, MemoryBuffer& buffer);
  static void GetPNGSizes(const void* iconData, int& width, int& height);

 private:
  static void SwapBytes(short* val);
  static void SwapEndian(int* val);
 };

 class Core
 {
 public:

  static void WriteToBuffer(const SceSaveDataMountInfo& info, MemoryBuffer& buffer);
  static void WriteToBuffer(const SceSaveDataSearchInfo& info, MemoryBuffer& buffer);
  static void WriteToBuffer(const SceSaveDataParam& params, MemoryBuffer& buffer);
  static void WriteToBuffer(const SceSaveDataDirName& dirName, MemoryBuffer& buffer);

  static void InitIconForReading(SceSaveDataIcon& icon);

  static SceSaveDataDirName* GetTempDirNamesArray();
  static SceSaveDataDirName* GetTempDialogDirNamesArray();
  static SceSaveDataParam* GetTempParamsArray();
  static SceSaveDataSearchInfo* GetTempSearchInfosArray();

 private:
 };
}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Backup.h" 2

namespace SaveData
{
 class BackupRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;

  void CopyTo(SceSaveDataBackup &destination, SceSaveDataDirName& sceDirName);
 };

 class CheckBackupRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;
  bool includeParams;
  bool includeIcon;

  void CopyTo(SceSaveDataCheckBackupData &destination, SceSaveDataDirName& sceDirName);
 };

 class RestoreBackupRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;

  void CopyTo(SceSaveDataRestoreBackupData &destination, SceSaveDataDirName& sceDirName);
 };

 class Backups
 {
 public:

  static void Backup(BackupRequest* managedRequest, APIResult* result);
  static void CheckBackup(CheckBackupRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
  static void RestoreBackup(RestoreBackupRequest* managedRequest, APIResult* result);
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Backup.cpp" 2


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataBackup(BackupRequest* managedRequest, APIResult* result)
 {
  Backups::Backup(managedRequest, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataCheckBackup(CheckBackupRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Backups::CheckBackup(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataRestoreBackup(RestoreBackupRequest* managedRequest, APIResult* result)
 {
  Backups::RestoreBackup(managedRequest, result);
 }

 void BackupRequest::CopyTo(SceSaveDataBackup &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
 }

 void CheckBackupRequest::CopyTo(SceSaveDataCheckBackupData &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
 }

 void RestoreBackupRequest::CopyTo(SceSaveDataRestoreBackupData &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
 }

 void Backups::Backup(BackupRequest* managedRequest, APIResult* result)
 {
  SceSaveDataBackup del;
  SceSaveDataDirName dirName;

  managedRequest->CopyTo(del, dirName);

  int ret = sceSaveDataBackup(&del);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Backup.cpp", 60));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Backups::CheckBackup(CheckBackupRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataCheckBackupData checkBackup;
  SceSaveDataDirName dirName;

  managedRequest->CopyTo(checkBackup, dirName);

  SceSaveDataIcon icon;
  memset(&icon, 0x00, sizeof(icon));

  SceSaveDataParam params;
  memset(&params, 0x00, sizeof(params));

  if (managedRequest->includeParams == true)
  {
   checkBackup.param = &params;
  }

  if (managedRequest->includeIcon == true)
  {
   Core::InitIconForReading(icon);
   checkBackup.icon = &icon;
  }

  int ret = sceSaveDataCheckBackupData(&checkBackup);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  bool valid = (ret == 0);

  buffer.WriteBool(valid);

  if (valid == true)
  {
   bool wasIconFound = true;
   if (managedRequest->includeIcon == false || icon.dataSize == 0)
   {

    wasIconFound = false;
   }


   buffer.WriteBool(managedRequest->includeParams);
   buffer.WriteBool(wasIconFound);

   if (managedRequest->includeParams == true)
   {
    Core::WriteToBuffer(params, buffer);
   }

   if (wasIconFound == true)
   {
    PNGWriter::WriteToBuffer(icon.buf, (Int32)icon.dataSize, buffer);
   }
  }


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Backup.cpp", 131));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Backups::RestoreBackup(RestoreBackupRequest* managedRequest, APIResult* result)
 {
  SceSaveDataRestoreBackupData restore;
  SceSaveDataDirName dirName;

  managedRequest->CopyTo(restore, dirName);

  int ret = sceSaveDataRestoreBackupData(&restore);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Backup.cpp", 149));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }
}
# 9 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Core.cpp" 1




namespace SaveData
{

 void DirNameManaged::CopyTo(SceSaveDataDirName &destination)
 {
  memcpy_s(destination.data, (32), data, (32));
 }

 static char sIconBuffer[((228) * (128) * 4)];
 static SceSaveDataDirName sDirNames[(1024)];
 static SceSaveDataDirName sDialogDirNames[(1024)];
 static SceSaveDataParam sParams[(1024)];
 static SceSaveDataSearchInfo sInfos[(1024)];

 SceSaveDataDirName* Core::GetTempDirNamesArray()
 {
  return sDirNames;
 }

 SceSaveDataDirName* Core::GetTempDialogDirNamesArray()
 {
  return sDialogDirNames;
 }

 SceSaveDataParam* Core::GetTempParamsArray()
 {
  return sParams;
 }

 SceSaveDataSearchInfo* Core::GetTempSearchInfosArray()
 {
  return sInfos;
 }

 void Core::InitIconForReading(SceSaveDataIcon& icon)
 {
  memset(sIconBuffer, 0xAA, ((228) * (128) * 4));

  memset(&icon, 0x00, sizeof(icon));
  icon.buf = sIconBuffer;
  icon.bufSize = ((228) * (128) * 4);
 }

 void Core::WriteToBuffer(const SceSaveDataMountInfo& info, MemoryBuffer& buffer)
 {
  buffer.WriteUInt64(info.blocks);
  buffer.WriteUInt64(info.freeBlocks);
 }

 void Core::WriteToBuffer(const SceSaveDataSearchInfo& info, MemoryBuffer& buffer)
 {
  buffer.WriteUInt64(info.blocks);
  buffer.WriteUInt64(info.freeBlocks);
 }

 void Core::WriteToBuffer(const SceSaveDataParam& params, MemoryBuffer& buffer)
 {
  buffer.WriteString(params.title);
  buffer.WriteString(params.subTitle);
  buffer.WriteString(params.detail);
  buffer.WriteUInt32(params.userParam);
  buffer.WriteInt64(params.mtime);
 }

 void Core::WriteToBuffer(const SceSaveDataDirName& dirName, MemoryBuffer& buffer)
 {
  buffer.WriteString(dirName.data);
 }


 void PNGWriter::SwapBytes(short* val)
 {
  char* bytes = (char*)val;
  char tmp = bytes[0]; bytes[0] = bytes[1]; bytes[1] = tmp;
 }

 void PNGWriter::SwapEndian(int* val)
 {
  short* words = (short*)val;
  short tmp = words[0]; words[0] = words[1]; words[1] = tmp;
  SwapBytes(&words[0]);
  SwapBytes(&words[1]);
 }

 void PNGWriter::WriteToBuffer(const void* iconData, Int32 size, MemoryBuffer& buffer)
 {
  buffer.WriteMarker(BufferIntegrityChecks::PNGBegin);
  if (iconData == __null)
  {
   buffer.WriteBool(false);
  }
  else
  {
   buffer.WriteBool(true);
   buffer.WriteInt32(size);

   PNG* png = (PNG*)iconData;
   IHDR* header = (IHDR*)(png + 1);
   int width = header->width;
   int height = header->height;
   SwapEndian(&width);
   SwapEndian(&height);

   buffer.WriteInt32(width);
   buffer.WriteInt32(height);
   buffer.WriteData((char*)png, size);
  }

  buffer.WriteMarker(BufferIntegrityChecks::PNGEnd);
 }

 void PNGWriter::GetPNGSizes(const void* iconData, int& width, int& height)
 {
  if (iconData == __null)
  {
   return;
  }

  PNG* png = (PNG*)iconData;
  IHDR* header = (IHDR*)(png + 1);
  width = header->width;
  height = header->height;
  SwapEndian(&width);
  SwapEndian(&height);
 }
}
# 10 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Delete.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Delete.h" 1






namespace SaveData
{
 class DeleteRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;

  void CopyTo(SceSaveDataDelete &destination, SceSaveDataDirName& sceDirName);
 };

 class Deleting
 {
 public:

  static void Delete(DeleteRequest* managedRequest, APIResult* result);
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Delete.cpp" 2


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataDelete(DeleteRequest* managedRequest, APIResult* result)
 {
  Deleting::Delete(managedRequest, result);
 }

 void DeleteRequest::CopyTo(SceSaveDataDelete &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
 }

 void Deleting::Delete(DeleteRequest* managedRequest, APIResult* result)
 {
  SceSaveDataDelete del;
  SceSaveDataDirName dirName;

  managedRequest->CopyTo(del, dirName);

  int ret = sceSaveDataDelete(&del);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Delete.cpp", 32));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 11 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.h" 1






namespace SaveData
{
# 18 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.h"
 class OpenDialogSettings
 {
 public:
  SceSaveDataDialogMode mode;
  SceSaveDataDialogType dispType;

  void CopyTo(SceSaveDataDialogParam &destination);
 };

 class UserMessage
 {
 public:
  SceSaveDataDialogButtonType buttonType;
  SceSaveDataDialogUserMessageType msgType;

  char msg[(256)];

  void CopyTo(SceSaveDataDialogUserMessageParam &destination, SceSaveDataDialogParam &params);
 };

 class AnimationParam
 {
 public:
  SceSaveDataDialogAnimation userOK;
  SceSaveDataDialogAnimation userCancel;

  void CopyTo(SceSaveDataDialogAnimationParam &destination, SceSaveDataDialogParam &params);
 };

 class SystemMessage
 {
 public:
  SceSaveDataDialogSystemMessageType sysMsgType;
  UInt64 value;

  void CopyTo(SceSaveDataDialogSystemMessageParam &destination, SceSaveDataDialogParam &params);
 };

 class ErrorCode
 {
 public:
  Int32 errorCode;

  void CopyTo(SceSaveDataDialogErrorCodeParam &destination, SceSaveDataDialogParam &params);
 };

 class Items
 {
 public:

  DirNameManaged dirNames[(1024)];
  UInt32 dirNameNum;

  SceSaveDataDialogFocusPos focusPos;

  DirNameManaged focusPosDirName;

  SceSaveDataDialogItemStyle itemStyle;

  void CopyTo(SceSaveDataDialogItems &destination, SceSaveDataDialogParam &params, SceSaveDataDirName& focusDirName);
 };

 class NewItem
 {
 public:

  char iconPath[(1024)];

  char title[(128)];

  void *iconBuf;
  UInt64 iconSize;

  void CopyTo(SceSaveDataDialogNewItem &newItem, SceSaveDataDialogItems &items);
 };

 class ProgressBar
 {
 public:

  SceSaveDataDialogProgressBarType barType;
  SceSaveDataDialogProgressSystemMessageType sysMsgType;

     char msg[(256)];

  void CopyTo(SceSaveDataDialogProgressBarParam &destination, SceSaveDataDialogParam &params);
 };

 class OptionParam
 {
 public:

  SceSaveDataDialogOptionBack back;

  void CopyTo(SceSaveDataDialogOptionParam &destination, SceSaveDataDialogParam &params);
 };

 class CloseParam
 {
 public:
  SceSaveDataDialogAnimation anim;

  void CopyTo(SceSaveDataDialogCloseParam &destination);
 };

 class Dialogs
 {
 public:

  static void OpenDialog(Int32 userId, OpenDialogSettings* basicSettings, Items* itemsSettings, UserMessage* userMsgSettings, SystemMessage* sysMsgSettings,
                      ErrorCode* errorCodeSettings, ProgressBar* progressBarSettings, NewItem* newItemSettings, OptionParam* optionSettings,
                      AnimationParam* animations, APIResult* result);

  static void Close(CloseParam* close, APIResult* result);

  static int DialogUpdateStatus();
  static int DialogGetStatus();
  static int DialogIsReadyToDisplay(APIResult* result);

  static void DialogGetResult(MemoryBufferManaged* outBuffer, APIResult* result);
  static void ProgressBarInc(UInt32 delta, APIResult* result);
  static void ProgressBarSetValue(UInt32 rate, APIResult* result);
  static void InitializeDialog(APIResult* result);
  static void TerminateDialog(APIResult* result);

 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp" 2


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataOpenDialog(Int32 userId, OpenDialogSettings* basicSettings, Items* itemsSettings, UserMessage* userMsgSettings, SystemMessage* sysMsgSettings,
  ErrorCode* errorCodeSettings, ProgressBar* progressBarSettings, NewItem* newItemSettings, OptionParam* optionSettings,
  AnimationParam* animations, APIResult* result)
 {
  Dialogs::OpenDialog(userId, basicSettings, itemsSettings, userMsgSettings, sysMsgSettings, errorCodeSettings, progressBarSettings, newItemSettings, optionSettings, animations, result);
 }

 extern "C" __declspec (dllexport) int PrxSaveDataDialogUpdateStatus()
 {
  return Dialogs::DialogUpdateStatus();
 }

 extern "C" __declspec (dllexport) int PrxSaveDataDialogGetStatus()
 {
  return Dialogs::DialogGetStatus();
 }

 extern "C" __declspec (dllexport) int PrxSaveDataDialogIsReadyToDisplay(APIResult* result)
 {
  return Dialogs::DialogIsReadyToDisplay(result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataDialogGetResult(MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Dialogs::DialogGetResult(outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataDialogProgressBarInc(UInt32 delta, APIResult* result)
 {
  Dialogs::ProgressBarInc(delta, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataDialogProgressBarSetValue(UInt32 rate, APIResult* result)
 {
  Dialogs::ProgressBarSetValue(rate, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataDialogClose(CloseParam* close, APIResult* result)
 {
  Dialogs::Close(close, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataInitializeDialog(APIResult* result)
 {
  Dialogs::InitializeDialog(result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataTerminateDialog(APIResult* result)
 {
  Dialogs::TerminateDialog(result);
 }

 void Dialogs::InitializeDialog(APIResult* result)
 {
  int32_t ret = sceSaveDataDialogInitialize();

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp", 65));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Dialogs::TerminateDialog(APIResult* result)
 {
  int32_t ret = sceSaveDataDialogTerminate();

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp", 78));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 int Dialogs::DialogUpdateStatus()
 {
  SceCommonDialogStatus stat = sceSaveDataDialogUpdateStatus();
  return stat;
 }

 int Dialogs::DialogGetStatus()
 {
  SceCommonDialogStatus stat = sceSaveDataDialogGetStatus();
  return stat;
 }

 int Dialogs::DialogIsReadyToDisplay(APIResult* result)
 {
  int ret = sceSaveDataDialogIsReadyToDisplay();

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp", 103));
   return ret;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));

  return ret;
 }

 void Dialogs::DialogGetResult(MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataDialogResult dialogResult;
  SceSaveDataDirName dirName;
  SceSaveDataParam param;

  memset(&dialogResult, 0, sizeof(dialogResult));
  memset(&dirName, 0, sizeof(dirName));
  memset(&param, 0, sizeof(param));

  dialogResult.dirName = &dirName;
  dialogResult.param = &param;

  int ret = sceSaveDataDialogGetResult(&dialogResult);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp", 129));
   return;
  }


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();


  buffer.WriteInt32(dialogResult.mode);
  buffer.WriteInt32(dialogResult.result);
  buffer.WriteInt32(dialogResult.buttonId);


  Core::WriteToBuffer(*dialogResult.dirName, buffer);
  Core::WriteToBuffer(*dialogResult.param, buffer);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void OpenDialogSettings::CopyTo(SceSaveDataDialogParam &destination)
 {
  sceSaveDataDialogParamInitialize(&destination);

  destination.mode = mode;
  destination.dispType = dispType;
 }

 void UserMessage::CopyTo(SceSaveDataDialogUserMessageParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.buttonType = buttonType;
  destination.msgType = msgType;
  destination.msg = msg;

  params.userMsgParam = &destination;
 }

 void AnimationParam::CopyTo(SceSaveDataDialogAnimationParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.userOK = userOK;
  destination.userCancel = userCancel;

  params.animParam = &destination;
 }

 void SystemMessage::CopyTo(SceSaveDataDialogSystemMessageParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.sysMsgType = sysMsgType;
  destination.value = value;

  params.sysMsgParam = &destination;
 }

 void ErrorCode::CopyTo(SceSaveDataDialogErrorCodeParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.errorCode = errorCode;

  params.errorCodeParam = &destination;
 }

 void ProgressBar::CopyTo(SceSaveDataDialogProgressBarParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.barType = barType;
  destination.sysMsgType = sysMsgType;
  destination.msg = msg;

  params.progBarParam = &destination;
 }

 void OptionParam::CopyTo(SceSaveDataDialogOptionParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.back = back;

  params.optionParam = &destination;
 }

 void Items::CopyTo(SceSaveDataDialogItems& destination, SceSaveDataDialogParam &params, SceSaveDataDirName& focusDirName)
 {
  memset(&destination, 0, sizeof(destination));

  SceSaveDataDirName* nativeDirNames = Core::GetTempDialogDirNamesArray();

  destination.dirName = nativeDirNames;
  destination.dirNameNum = dirNameNum;

  for (int i = 0; i < dirNameNum; i++)
  {
   dirNames[i].CopyTo(nativeDirNames[i]);
  }

  destination.focusPos = focusPos;
  destination.itemStyle = itemStyle;

  if (focusPos == (6))
  {
   focusPosDirName.CopyTo(focusDirName);
   destination.focusPosDirName = &focusDirName;
  }

  params.items = &destination;
 }

 void NewItem::CopyTo(SceSaveDataDialogNewItem& destination, SceSaveDataDialogItems &items)
 {
  memset(&destination, 0, sizeof(destination));

  destination.title = title;
  destination.iconBuf = iconBuf;
  destination.iconSize = iconSize;

  items.newItem = &destination;
 }

 void Dialogs::ProgressBarInc(UInt32 delta, APIResult* result)
 {
  int ret = sceSaveDataDialogProgressBarInc((0), delta);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp", 264));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Dialogs::ProgressBarSetValue(UInt32 rate, APIResult* result)
 {
  int ret = sceSaveDataDialogProgressBarSetValue((0), rate);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp", 277));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void CloseParam::CopyTo(SceSaveDataDialogCloseParam &destination)
 {
  memset(&destination, 0x00, sizeof(destination));
  destination.anim = anim;
 }

 void Dialogs::Close(CloseParam* close, APIResult* result)
 {
  SceSaveDataDialogCloseParam closeParam;

  close->CopyTo(closeParam);

  int ret = sceSaveDataDialogClose(&closeParam);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp", 300));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Dialogs::OpenDialog(Int32 userId, OpenDialogSettings* basicSettings, Items* itemsSettings, UserMessage* userMsgSettings, SystemMessage* sysMsgSettings,
                       ErrorCode* errorCodeSettings, ProgressBar* progressBarSettings, NewItem* newItemSettings, OptionParam* optionSettings,
                       AnimationParam* animations, APIResult* result)
 {
  SceSaveDataDialogParam param;
  SceSaveDataDialogUserMessageParam userMsgParam;
  SceSaveDataDialogAnimationParam animParam;
  SceSaveDataDialogSystemMessageParam sysMsgParam;
  SceSaveDataDialogErrorCodeParam errorParam;
  SceSaveDataDialogProgressBarParam barParam;
  SceSaveDataDialogNewItem newItem;
  SceSaveDataDialogItems items;
  SceSaveDataDialogOptionParam optionParam;
  SceSaveDataDirName focusDirName;


  basicSettings->CopyTo(param);

  if (itemsSettings != __null)
  {
   itemsSettings->CopyTo(items, param, focusDirName);
  }
  else
  {
   memset(&items, 0, sizeof(items));
   param.items = &items;
  }

  param.items->userId = userId;

  if (animations != __null)
  {
   animations->CopyTo(animParam, param);
  }

  if (newItemSettings != __null)
  {
   newItemSettings->CopyTo(newItem, items);
  }

  if (optionSettings != __null)
  {
   optionSettings->CopyTo(optionParam, param);
  }

  if (param.mode == (2) && userMsgSettings != __null)
  {
   userMsgSettings->CopyTo(userMsgParam, param);
  }
  else if (param.mode == (3) && sysMsgSettings != __null)
  {
   sysMsgSettings->CopyTo(sysMsgParam, param);
  }
  else if (param.mode == (4) && errorCodeSettings != __null)
  {
   errorCodeSettings->CopyTo(errorParam, param);
  }
  else if (param.mode == (5) && progressBarSettings != __null)
  {
   progressBarSettings->CopyTo(barParam, param);
  }

  int ret = sceSaveDataDialogOpen(&param);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Dialogs.cpp", 373));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 12 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Info.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Info.h" 1






namespace SaveData
{
# 23 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Info.h"
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Info.cpp" 2


namespace SaveData
{
# 39 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Info.cpp"
}
# 13 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.h" 1





namespace SaveData
{
 struct InitResult
 {
 public:
  bool initialized;
  UInt32 sceSDKVersion;

  InitResult()
  {
   initialized = false;
  }
 };

 struct ThreadSettings
 {
 public:
  char name[32];
  UInt64 affinityMask;
 };

 class Main
 {
 public:

 private:

  static bool s_Initialised;


 public:

  static void Initialize(InitResult& initResult, APIResult* result);
  static void Terminate(APIResult* result);
  static void SetThreadAffinity(ThreadSettings settings, APIResult* result);

 private:

  void LoadModules();
  void UnloadModules();
  void SetupRuntimeInterfaces();
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp" 2

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\_rtc.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\_rtc.h" 2 3

typedef struct SceRtcTick {
 uint64_t tick;
} SceRtcTick;
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 2 3


extern "C" {
# 109 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 3
typedef struct SceRtcDateTime {
 unsigned short year;
 unsigned short month;
 unsigned short day;
 unsigned short hour;
 unsigned short minute;
 unsigned short second;
 unsigned int microsecond;
} SceRtcDateTime;
# 126 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 3
int sceRtcGetCurrentTick(SceRtcTick *pTick);




int sceRtcGetCurrentClock(SceRtcDateTime *pTime, int iTimeZone);



int sceRtcGetCurrentClockLocalTime(SceRtcDateTime *pTime);




int sceRtcGetCurrentNetworkTick(SceRtcTick *pTick);



int sceRtcConvertUtcToLocalTime(const SceRtcTick *pUtc, SceRtcTick *pLocalTime);



int sceRtcConvertLocalTimeToUtc(const SceRtcTick *pLocalTime, SceRtcTick *pUtc);



int sceRtcIsLeapYear(int year);



int sceRtcGetDaysInMonth(int year, int month);
# 167 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 3
int sceRtcGetDayOfWeek(int year, int month, int day);



int sceRtcCheckValid(const SceRtcDateTime *pTime);
# 181 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 3
int sceRtcSetTime_t(SceRtcDateTime *pTime, time_t llTime);




int sceRtcGetTime_t(const SceRtcDateTime *pTime, time_t *pllTime);







int sceRtcSetDosTime(SceRtcDateTime *pTime, unsigned int uiDosTime);




int sceRtcGetDosTime(const SceRtcDateTime *pTime, unsigned int *puiDosTime);




int sceRtcSetWin32FileTime(SceRtcDateTime *pTime, uint64_t ulWin32Time);




int sceRtcGetWin32FileTime(const SceRtcDateTime *pTime, uint64_t *ulWin32Time);







int sceRtcSetTick(SceRtcDateTime *pTime, const SceRtcTick *pTick);




int sceRtcGetTick(const SceRtcDateTime *pTime, SceRtcTick *pTick);



unsigned int sceRtcGetTickResolution(void);







int sceRtcTickAddTicks(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddMicroseconds(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddSeconds(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddMinutes(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddHours(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddDays(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddWeeks(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddMonths(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddYears(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);
# 267 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\rtc.h" 3
int sceRtcFormatRFC2822(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes);



int sceRtcFormatRFC2822LocalTime(char *pszDateTime, const SceRtcTick *pUtc);



int sceRtcFormatRFC3339(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes);



int sceRtcFormatRFC3339LocalTime(char *pszDateTime, const SceRtcTick *pUtc);



int sceRtcFormatRFC3339Precise(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes, unsigned int secfrac);



int sceRtcFormatRFC3339PreciseLocalTime(char *pszDateTime, const SceRtcTick *pUtc, unsigned int secfrac);



int sceRtcParseDateTime(SceRtcTick *pUtc, const char *pszDateTime);



int sceRtcParseRFC3339(SceRtcTick *pUtc, const char *pszDateTime);





static __inline__ int sceRtcSetYear(SceRtcDateTime *pTime, int year);
static __inline__ int sceRtcSetMonth(SceRtcDateTime *pTime, int month);
static __inline__ int sceRtcSetDay(SceRtcDateTime *pTime, int day);
static __inline__ int sceRtcSetHour(SceRtcDateTime *pTime, int hour);
static __inline__ int sceRtcSetMinute(SceRtcDateTime *pTime, int minute);
static __inline__ int sceRtcSetSecond(SceRtcDateTime *pTime, int second);
static __inline__ int sceRtcSetMicrosecond(SceRtcDateTime *pTime, int microsecond);

static __inline__ int sceRtcGetYear(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMonth(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetDay(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetHour(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMinute(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetSecond(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMicrosecond(const SceRtcDateTime *pTime);



static __inline__ int sceRtcSetYear(SceRtcDateTime *pTime, int year)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (year<1 || year>9999) {
  return (-2135621624);
 }

 pTime->year = static_cast<unsigned short>(year);



 return (0);
}



static __inline__ int sceRtcSetMonth(SceRtcDateTime *pTime, int month)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (month<1 || month>12) {
  return (-2135621623);
 }

 pTime->month = static_cast<unsigned short>(month);



 return (0);
}



static __inline__ int sceRtcSetDay(SceRtcDateTime *pTime, int day)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (day<1 || day>31) {
  return (-2135621622);
 }

 pTime->day = static_cast<unsigned short>(day);



 return (0);
}



static __inline__ int sceRtcSetHour(SceRtcDateTime *pTime, int hour)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (hour<0 || hour>23) {
  return (-2135621621);
 }

 pTime->hour = static_cast<unsigned short>(hour);



 return (0);
}



static __inline__ int sceRtcSetMinute(SceRtcDateTime *pTime, int minute)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (minute<0 || minute>59) {
  return (-2135621620);
 }

 pTime->minute = static_cast<unsigned short>(minute);



 return (0);
}



static __inline__ int sceRtcSetSecond(SceRtcDateTime *pTime, int second)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (second<0 || second>59) {
  return (-2135621619);
 }

 pTime->second = static_cast<unsigned short>(second);



 return (0);
}



static __inline__ int sceRtcSetMicrosecond(SceRtcDateTime *pTime, int microsecond)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (microsecond<0 || microsecond>999999) {
  return (-2135621618);
 }

 pTime->microsecond = static_cast<unsigned int>(microsecond);



 return (0);
}



static __inline__ int sceRtcGetYear(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->year);
}



static __inline__ int sceRtcGetMonth(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->month);
}



static __inline__ int sceRtcGetDay(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->day);
}



static __inline__ int sceRtcGetHour(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->hour);
}



static __inline__ int sceRtcGetMinute(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->minute);
}



static __inline__ int sceRtcGetSecond(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->second);
}



static __inline__ int sceRtcGetMicrosecond(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }

 return static_cast<int>(pTime->microsecond);



}



}
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp" 2
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\libsysmodule.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\libsysmodule.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sceerror.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sys/_defines/_sce_ok.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\sceerror.h" 2 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\libsysmodule.h" 2 3


extern "C" {
# 194 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\libsysmodule.h" 3
int sceSysmoduleLoadModule(uint16_t id);
int sceSysmoduleUnloadModule(uint16_t id);
int sceSysmoduleIsLoaded(uint16_t id);


}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp" 2



# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.h" 1






namespace SaveData
{
 struct MountPointManaged
 {
 public:
  char data[(16)];

  void CopyTo(SceSaveDataMountPoint &destination);
 };

 class MountRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;
  UInt64 blocks;
  SceSaveDataMountMode mountMode;

  void CopyTo(SceSaveDataMount2 &destination, SceSaveDataDirName& sceDirName);
 };

 class UnmountRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
  bool backup;
 };

 class GetMountInfoRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
 };

 class GetMountParamsRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
 };

 class SaveIconRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
  char iconPath[(1024)];

  void *pngData;
  UInt64 pngDataSize;
 };

 class LoadIconRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
 };
# 74 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.h"
 class SetMountParamsRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;

  char title[(128)];
  char subTitle[(128)];
  char detail[(1024)];
  UInt32 userParam;

  void CopyTo(SceSaveDataParam &destination);
 };

 class Mounting
 {
 public:

  static void Mount(MountRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
  static void Unmount(UnmountRequest* managedRequest, APIResult* result);
  static void GetMountInfo(GetMountInfoRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
  static void GetMountParams(GetMountParamsRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
  static void SetMountParams(SetMountParamsRequest* managedRequest, APIResult* result);
  static void SaveIcon(SaveIconRequest* managedRequest, APIResult* result);
  static void LoadIcon(LoadIconRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
 };
}
# 10 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp" 2

#pragma comment(lib, "SceSaveData_stub_weak")
#pragma comment(lib, "SceSaveDataDialog_stub_weak")
#pragma comment(lib, "SceUserService_stub_weak")
#pragma comment(lib, "SceSysmodule_stub_weak")
#pragma comment(lib, "SceRtc_stub_weak")

namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataInitialize(InitResult* initResult, APIResult* result)
 {
  Main::Initialize(*initResult, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataTerminate(APIResult* result)
 {
  Main::Terminate(result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataSetThreadAffinity(ThreadSettings settings, APIResult* result)
 {
  Main::SetThreadAffinity(settings, result);
 }

 bool Main::s_Initialised = false;





 void Main::Initialize(InitResult& initResult, APIResult* result)
 {
  if (s_Initialised)
  {
   (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Error, "SaveData Plugin already initialised", "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp", 44));
   return;
  }

  MemoryBuffer::Initialise();

  int32_t ret = sceSaveDataInitialize3(__null);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp", 54));
   return;
  }

  ret = sceSysmoduleLoadModule(0x00a0);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp", 62));
   return;
  }



  s_Initialised = true;

  initResult.initialized = true;
  initResult.sceSDKVersion = (0x10508021u);

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Main::Terminate(APIResult* result)
 {
  int32_t ret = sceSaveDataTerminate();

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp", 82));
   return;
  }
# 94 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp"
  ret = sceSysmoduleUnloadModule(0x00a0);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp", 98));
   return;
  }

  MemoryBuffer::Shutdown();

  s_Initialised = false;

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }


 void Main::SetThreadAffinity(ThreadSettings settings, APIResult* result)
 {
  ScePthread thread = scePthreadSelf();

  int32_t ret = scePthreadRename(thread, settings.name);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp", 118));
   return;
  }

  ret = scePthreadSetaffinity(thread, settings.affinityMask);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp", 126));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Main::LoadModules()
 {







 }

 void Main::UnloadModules()
 {







 }

 void Main::SetupRuntimeInterfaces()
 {
# 165 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp"
 }
# 179 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Main.cpp"
}
# 14 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp" 1


# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Utils.h" 1






namespace SaveData
{
 class Utils
 {
 public:

  static int32_t LoadFile(const char *mountPoint, const char *fileName, uint8_t** loadeddata, __int64_t *datasize, bool dialogEnabled);
  static int32_t LoadFile(const char *path, uint8_t** data, size_t *datasize);
 };
}
# 4 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp" 2

namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataMount(MountRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Mounting::Mount(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataUnmount(UnmountRequest* managedRequest, APIResult* result)
 {
  Mounting::Unmount(managedRequest, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataGetMountInfo(GetMountInfoRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Mounting::GetMountInfo(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataGetMountParams(GetMountParamsRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Mounting::GetMountParams(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataSetMountParams(SetMountParamsRequest* managedRequest, APIResult* result)
 {
  Mounting::SetMountParams(managedRequest, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataSaveIcon(SaveIconRequest* managedRequest, APIResult* result)
 {
  Mounting::SaveIcon(managedRequest, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataLoadIcon(LoadIconRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Mounting::LoadIcon(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataGetIconSize(void *pngData, Int32* width, Int32* height)
 {
  *width = 0;
  *height = 0;

  PNGWriter::GetPNGSizes(pngData, *width, *height);
 }

 void MountPointManaged::CopyTo(SceSaveDataMountPoint &destination)
 {
  memcpy_s(destination.data, (16), data, (16));
 }

 void MountRequest::CopyTo(SceSaveDataMount2 &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
  destination.blocks = blocks;
  destination.mountMode = mountMode;
 }

 void SetMountParamsRequest::CopyTo(SceSaveDataParam &destination)
 {
  memset(&destination, 0x00, sizeof(destination));

  memcpy_s(destination.title, (128), title, (128));
  memcpy_s(destination.subTitle, (128), subTitle, (128));
  memcpy_s(destination.detail, (1024), detail, (1024));

  destination.userParam = userParam;
 }

 void Mounting::Mount(MountRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataDirName dirName;

  SceSaveDataMount2 mount;

  managedRequest->CopyTo(mount, dirName);

  SceSaveDataMountResult mountResult;
  memset(&mountResult, 0x00, sizeof(mountResult));

  int ret = sceSaveDataMount2(&mount, &mountResult);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  buffer.WriteString(mountResult.mountPoint.data);

  buffer.WriteUInt64(mountResult.requiredBlocks);
  buffer.WriteUInt32(mountResult.mountStatus);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp", 105));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::Unmount(UnmountRequest* managedRequest, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  managedRequest->mountPoint.CopyTo(mountPoint);

  int ret = 0;

  if (managedRequest->backup == false)
  {
   ret = sceSaveDataUmount(&mountPoint);
  }
  else
  {
   ret = sceSaveDataUmountWithBackup(&mountPoint);
  }

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp", 131));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::GetMountInfo(GetMountInfoRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  managedRequest->mountPoint.CopyTo(mountPoint);

  SceSaveDataMountInfo mountInfo;
  memset(&mountInfo, 0x00, sizeof(mountInfo));

  int ret = sceSaveDataGetMountInfo(&mountPoint, &mountInfo);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  Core::WriteToBuffer(mountInfo, buffer);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp", 161));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::GetMountParams(GetMountParamsRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  managedRequest->mountPoint.CopyTo(mountPoint);

  size_t gotSize = 0;
  SceSaveDataParam params;
  memset(&params, 0x00, sizeof(params));

  int ret = sceSaveDataGetParam(&mountPoint, (0), &params, sizeof(SceSaveDataParam), &gotSize);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  Core::WriteToBuffer(params, buffer);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp", 192));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::SetMountParams(SetMountParamsRequest* managedRequest, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  SceSaveDataParam params;

  managedRequest->mountPoint.CopyTo(mountPoint);
  managedRequest->CopyTo(params);

  int ret = sceSaveDataSetParam(&mountPoint, (0), &params, sizeof(SceSaveDataParam));

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp", 212));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::SaveIcon(SaveIconRequest* managedRequest, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  managedRequest->mountPoint.CopyTo(mountPoint);

  uint8_t *data = __null;
  size_t data_size = 0;


  int ret = 0;

  if (managedRequest->pngDataSize == 0)
  {






   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, -2137063424, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp", 239));
   return;
  }
  else
  {
   data = (uint8_t*)managedRequest->pngData;
   data_size = managedRequest->pngDataSize;
  }

  SceSaveDataIcon icon;
  memset(&icon, 0x00, sizeof(icon));
  icon.buf = data;
  icon.bufSize = data_size;
  icon.dataSize = data_size;

  ret = sceSaveDataSaveIcon(&mountPoint, &icon);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp", 258));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::LoadIcon(LoadIconRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  SceSaveDataIcon icon;
  Core::InitIconForReading(icon);

  managedRequest->mountPoint.CopyTo(mountPoint);

  int ret = sceSaveDataLoadIcon(&mountPoint, &icon);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  if (ret < 0)
  {
   buffer.WriteBool(false);
  }
  else
  {
   buffer.WriteBool(true);
   PNGWriter::WriteToBuffer(icon.buf, (Int32)icon.dataSize, buffer);
  }


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Mount.cpp", 296));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 15 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Notifications.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Notifications.h" 1






namespace SaveData
{
 class Notifications
 {
 public:

  static void NotificationPoll(MemoryBufferManaged* outBuffer, APIResult* result);
 };

}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Notifications.cpp" 2

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common.h" 1 3
# 25 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common/scebase_target.h" 1 3
# 26 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common/scebase_stdint.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common/scebase_stdint.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdint.h" 1 3
# 54 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common/scebase_stdint.h" 2 3
# 27 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common/scebase_stdbool.h" 1 3
# 28 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\scebase_common.h" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_common.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_orbis.h" 1 3
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_orbis.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86intrin.h" 1 3 4
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86intrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 1 3 4
# 41 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bsfd(int __A) {
  return __builtin_ctz((unsigned int)__A);
}
# 58 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bsrd(int __A) {
  return 31 - __builtin_clz((unsigned int)__A);
}
# 74 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bswapd(int __A) {
  return (int)__builtin_bswap32((unsigned int)__A);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
_bswap(int __A) {
  return (int)__builtin_bswap32((unsigned int)__A);
}
# 100 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bsfq(long long __A) {
  return (long long)__builtin_ctzll((unsigned long long)__A);
}
# 117 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bsrq(long long __A) {
  return 63 - __builtin_clzll((unsigned long long)__A);
}
# 133 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__)) constexpr
__bswapq(long long __A) {
  return (long long)__builtin_bswap64((unsigned long long)__A);
}
# 153 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__popcntd(unsigned int __A)
{
  return __builtin_popcount(__A);
}
# 174 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__)) constexpr
__popcntq(unsigned long long __A)
{
  return __builtin_popcountll(__A);
}





static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__readeflags(void)
{
  return __builtin_ia32_readeflags_u64();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
__writeeflags(unsigned long long __f)
{
  __builtin_ia32_writeeflags_u64(__f);
}
# 220 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__)) constexpr
_castf32_u32(float __A) {
  return __builtin_bit_cast(unsigned int, __A);
}
# 235 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__)) constexpr
_castf64_u64(double __A) {
  return __builtin_bit_cast(unsigned long long, __A);
}
# 250 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ float __attribute__((__always_inline__)) constexpr
_castu32_f32(unsigned int __A) {
  return __builtin_bit_cast(float, __A);
}
# 265 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ double __attribute__((__always_inline__)) constexpr
_castu64_f64(unsigned long long __A) {
  return __builtin_bit_cast(double, __A);
}
# 285 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
__crc32b(unsigned int __C, unsigned char __D)
{
  return __builtin_ia32_crc32qi(__C, __D);
}
# 306 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
__crc32w(unsigned int __C, unsigned short __D)
{
  return __builtin_ia32_crc32hi(__C, __D);
}
# 327 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
__crc32d(unsigned int __C, unsigned int __D)
{
  return __builtin_ia32_crc32si(__C, __D);
}
# 349 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
__crc32q(unsigned long long __C, unsigned long long __D)
{
  return __builtin_ia32_crc32di(__C, __D);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdpmc(int __A) {
  return __builtin_ia32_rdpmc(__A);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdtscp(unsigned int *__A) {
  return __builtin_ia32_rdtscp(__A);
}





static __inline__ void __attribute__((__always_inline__, __nodebug__))
_wbinvd(void) {
  __builtin_ia32_wbinvd();
}

static __inline__ unsigned char __attribute__((__always_inline__, __nodebug__)) constexpr
__rolb(unsigned char __X, int __C) {
  return __builtin_rotateleft8(__X, __C);
}

static __inline__ unsigned char __attribute__((__always_inline__, __nodebug__)) constexpr
__rorb(unsigned char __X, int __C) {
  return __builtin_rotateright8(__X, __C);
}

static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__)) constexpr
__rolw(unsigned short __X, int __C) {
  return __builtin_rotateleft16(__X, __C);
}

static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__)) constexpr
__rorw(unsigned short __X, int __C) {
  return __builtin_rotateright16(__X, __C);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__)) constexpr
__rold(unsigned int __X, int __C) {
  return __builtin_rotateleft32(__X, (unsigned int)__C);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__)) constexpr
__rord(unsigned int __X, int __C) {
  return __builtin_rotateright32(__X, (unsigned int)__C);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__)) constexpr
__rolq(unsigned long long __X, int __C) {
  return __builtin_rotateleft64(__X, (unsigned long long)__C);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__)) constexpr
__rorq(unsigned long long __X, int __C) {
  return __builtin_rotateright64(__X, (unsigned long long)__C);
}
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86gprintrin.h" 1 3 4
# 25 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86gprintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\crc32intrin.h" 1 3 4
# 30 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\crc32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
_mm_crc32_u8(unsigned int __C, unsigned char __D)
{
  return __builtin_ia32_crc32qi(__C, __D);
}
# 50 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\crc32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
_mm_crc32_u16(unsigned int __C, unsigned short __D)
{
  return __builtin_ia32_crc32hi(__C, __D);
}
# 70 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\crc32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
_mm_crc32_u32(unsigned int __C, unsigned int __D)
{
  return __builtin_ia32_crc32si(__C, __D);
}
# 91 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\crc32intrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
_mm_crc32_u64(unsigned long long __C, unsigned long long __D)
{
  return __builtin_ia32_crc32di(__C, __D);
}
# 26 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86gprintrin.h" 2 3 4
# 18 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
typedef long long __m64 __attribute__((__vector_size__(8), __aligned__(8)));

typedef long long __v1di __attribute__((__vector_size__(8)));
typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));
# 36 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_empty(void)
{
    __builtin_ia32_emms();
}
# 58 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}
# 80 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}
# 101 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}
# 122 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}
# 158 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}
# 194 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}
# 230 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}
# 263 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}
# 292 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}
# 319 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}
# 352 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}
# 381 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}
# 408 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}
# 435 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}
# 462 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}
# 489 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}
# 517 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}
# 546 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}
# 574 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}
# 602 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}
# 629 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}
# 656 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}
# 683 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}
# 712 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}
# 741 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}
# 767 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}
# 793 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}
# 822 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}
# 849 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}
# 876 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}
# 905 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}
# 933 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}
# 962 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}
# 990 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}
# 1016 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq((__v1di)__m, __count);
}
# 1042 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi((__v1di)__m, __count);
}
# 1068 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}
# 1093 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}
# 1119 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}
# 1144 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}
# 1170 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}
# 1195 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}
# 1221 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}
# 1246 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}
# 1270 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq((__v1di)__m, __count);
}
# 1295 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi((__v1di)__m, __count);
}
# 1319 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand((__v1di)__m1, (__v1di)__m2);
}
# 1346 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn((__v1di)__m1, (__v1di)__m2);
}
# 1370 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por((__v1di)__m1, (__v1di)__m2);
}
# 1394 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor((__v1di)__m1, (__v1di)__m2);
}
# 1420 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}
# 1446 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}
# 1472 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}
# 1498 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}
# 1524 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}
# 1550 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}
# 1567 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setzero_si64(void)
{
    return __extension__ (__m64){ 0LL };
}
# 1594 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}
# 1625 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}
# 1668 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}
# 1694 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}
# 1718 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}
# 1741 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}
# 1768 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}
# 1799 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}
# 1842 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 22 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 1 3 4
# 19 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16), __aligned__(16)));

typedef float __m128_u __attribute__((__vector_size__(16), __aligned__(1)));


typedef unsigned int __v4su __attribute__((__vector_size__(16)));




# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mm_malloc.h" 1 3 4
# 13 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mm_malloc.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include\\stdlib.h" 1 3 4
# 14 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mm_malloc.h" 2 3 4
# 25 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\mm_malloc.h" 3 4
extern "C" int posix_memalign(void **__memptr, size_t __alignment, size_t __size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__, __alloc_size__(1),
                                       __alloc_align__(2)))
_mm_malloc(size_t __size, size_t __align) {
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{





  free(__p);

}
# 32 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 2 3 4
# 59 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}
# 85 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a + (__v4sf)__b);
}
# 113 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}
# 140 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a - (__v4sf)__b);
}
# 168 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}
# 194 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a * (__v4sf)__b);
}
# 222 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}
# 247 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a / (__v4sf)__b);
}
# 270 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sqrt_ss(__m128 __a)
{
  return (__m128)__builtin_ia32_sqrtss((__v4sf)__a);
}
# 292 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps((__v4sf)__a);
}
# 315 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rcp_ss(__m128 __a)
{
  return (__m128)__builtin_ia32_rcpss((__v4sf)__a);
}
# 337 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rcp_ps(__m128 __a)
{
  return (__m128)__builtin_ia32_rcpps((__v4sf)__a);
}
# 361 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rsqrt_ss(__m128 __a)
{
  return __builtin_ia32_rsqrtss((__v4sf)__a);
}
# 383 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps((__v4sf)__a);
}
# 412 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss((__v4sf)__a, (__v4sf)__b);
}
# 437 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps((__v4sf)__a, (__v4sf)__b);
}
# 466 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss((__v4sf)__a, (__v4sf)__b);
}
# 491 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps((__v4sf)__a, (__v4sf)__b);
}
# 515 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a & (__v4su)__b);
}
# 543 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4su)__a & (__v4su)__b);
}
# 567 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a | (__v4su)__b);
}
# 592 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a ^ (__v4su)__b);
}
# 620 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqss((__v4sf)__a, (__v4sf)__b);
}
# 644 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqps((__v4sf)__a, (__v4sf)__b);
}
# 673 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltss((__v4sf)__a, (__v4sf)__b);
}
# 698 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__a, (__v4sf)__b);
}
# 728 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpless((__v4sf)__a, (__v4sf)__b);
}
# 753 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__a, (__v4sf)__b);
}
# 782 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 809 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__b, (__v4sf)__a);
}
# 839 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 866 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__b, (__v4sf)__a);
}
# 895 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqss((__v4sf)__a, (__v4sf)__b);
}
# 920 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqps((__v4sf)__a, (__v4sf)__b);
}
# 950 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltss((__v4sf)__a, (__v4sf)__b);
}
# 976 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__a, (__v4sf)__b);
}
# 1007 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnless((__v4sf)__a, (__v4sf)__b);
}
# 1033 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__a, (__v4sf)__b);
}
# 1064 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 1092 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__b, (__v4sf)__a);
}
# 1123 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 1151 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__b, (__v4sf)__a);
}
# 1182 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordss((__v4sf)__a, (__v4sf)__b);
}
# 1208 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordps((__v4sf)__a, (__v4sf)__b);
}
# 1239 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordss((__v4sf)__a, (__v4sf)__b);
}
# 1265 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordps((__v4sf)__a, (__v4sf)__b);
}
# 1293 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq((__v4sf)__a, (__v4sf)__b);
}
# 1322 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt((__v4sf)__a, (__v4sf)__b);
}
# 1350 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile((__v4sf)__a, (__v4sf)__b);
}
# 1378 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt((__v4sf)__a, (__v4sf)__b);
}
# 1406 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige((__v4sf)__a, (__v4sf)__b);
}
# 1434 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq((__v4sf)__a, (__v4sf)__b);
}
# 1462 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq((__v4sf)__a, (__v4sf)__b);
}
# 1490 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt((__v4sf)__a, (__v4sf)__b);
}
# 1519 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile((__v4sf)__a, (__v4sf)__b);
}
# 1548 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt((__v4sf)__a, (__v4sf)__b);
}
# 1577 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige((__v4sf)__a, (__v4sf)__b);
}
# 1605 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq((__v4sf)__a, (__v4sf)__b);
}
# 1628 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si((__v4sf)__a);
}
# 1651 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}
# 1676 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64((__v4sf)__a);
}
# 1699 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi((__v4sf)__a);
}
# 1720 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}
# 1744 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvttss_si32(__m128 __a)
{
  return __builtin_ia32_cvttss2si((__v4sf)__a);
}
# 1768 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}
# 1793 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvttss_si64(__m128 __a)
{
  return __builtin_ia32_cvttss2si64((__v4sf)__a);
}
# 1817 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi((__v4sf)__a);
}
# 1839 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}
# 1867 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}
# 1896 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}
# 1926 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}
# 1958 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps((__v4sf)__a, (__v2si)__b);
}
# 1987 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}
# 2009 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}
# 2036 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((const struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}
# 2069 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((const struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}
# 2101 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((const struct __mm_load_ss_struct*)__p)->__u;
  return __extension__ (__m128){ __u, 0, 0, 0 };
}
# 2128 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((const struct __mm_load1_ps_struct*)__p)->__u;
  return __extension__ (__m128){ __u, __u, __u, __u };
}
# 2159 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load_ps(const float *__p)
{
  return *(const __m128*)__p;
}
# 2181 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_ps*)__p)->__v;
}
# 2208 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
}
# 2226 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_undefined_ps(void)
{
  return (__m128)__builtin_ia32_undef128();
}
# 2251 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ss(float __w)
{
  return __extension__ (__m128){ __w, 0, 0, 0 };
}
# 2274 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set1_ps(float __w)
{
  return __extension__ (__m128){ __w, __w, __w, __w };
}
# 2298 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}
# 2333 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return __extension__ (__m128){ __w, __x, __y, __z };
}
# 2369 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return __extension__ (__m128){ __z, __y, __x, __w };
}
# 2388 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_setzero_ps(void)
{
  return __extension__ (__m128){ 0, 0, 0, 0 };
}
# 2409 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  typedef float __mm_storeh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_storeh_pi_struct {
    __mm_storeh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pi_struct*)__p)->__u = __builtin_shufflevector(__a, __a, 2, 3);
}
# 2434 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  typedef float __mm_storeh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_storeh_pi_struct {
    __mm_storeh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pi_struct*)__p)->__u = __builtin_shufflevector(__a, __a, 0, 1);
}
# 2459 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}
# 2484 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storeu_ps(float *__p, __m128 __a)
{
  struct __storeu_ps {
    __m128_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
}
# 2509 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128*)__p = __a;
}
# 2532 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 0, 0);
  _mm_store_ps(__p, __a);
}
# 2556 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ps1(float *__p, __m128 __a)
{
  _mm_store1_ps(__p, __a);
}
# 2579 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
# 2645 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}
# 2668 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_nontemporal_store((__v4sf)__a, (__v4sf*)__p);
}


extern "C" {
# 2689 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
void _mm_sfence(void);


}
# 2781 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}
# 2806 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}
# 2831 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}
# 2856 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}
# 2879 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}
# 2904 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}
# 2978 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}
# 3003 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}
# 3028 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}
# 3056 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}


extern "C" {
# 3079 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
unsigned int _mm_getcsr(void);
# 3092 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
void _mm_setcsr(unsigned int __i);


}
# 3170 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 2, 6, 3, 7);
}
# 3198 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 4, 1, 5);
}
# 3226 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_move_ss(__m128 __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}
# 3254 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 6, 7, 2, 3);
}
# 3281 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 1, 4, 5);
}
# 3304 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 3339 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 3373 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 3403 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 3436 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}
# 3465 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}
# 3495 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}
# 3525 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps((__v4sf)__a);
}
# 3613 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 1 3 4
# 18 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 2 3 4

typedef double __m128d __attribute__((__vector_size__(16), __aligned__(16)));
typedef long long __m128i __attribute__((__vector_size__(16), __aligned__(16)));

typedef double __m128d_u __attribute__((__vector_size__(16), __aligned__(1)));
typedef long long __m128i_u
    __attribute__((__vector_size__(16), __aligned__(1)));


typedef double __v2df __attribute__((__vector_size__(16)));
typedef long long __v2di __attribute__((__vector_size__(16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));


typedef unsigned long long __v2du __attribute__((__vector_size__(16)));
typedef unsigned short __v8hu __attribute__((__vector_size__(16)));
typedef unsigned char __v16qu __attribute__((__vector_size__(16)));



typedef signed char __v16qs __attribute__((__vector_size__(16)));
# 70 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_sd(__m128d __a,
                                                        __m128d __b) {
  __a[0] += __b[0];
  return __a;
}
# 94 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2df)__a + (__v2df)__b);
}
# 122 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_sd(__m128d __a,
                                                        __m128d __b) {
  __a[0] -= __b[0];
  return __a;
}
# 146 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2df)__a - (__v2df)__b);
}
# 173 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mul_sd(__m128d __a,
                                                        __m128d __b) {
  __a[0] *= __b[0];
  return __a;
}
# 197 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mul_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2df)__a * (__v2df)__b);
}
# 225 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_div_sd(__m128d __a,
                                                        __m128d __b) {
  __a[0] /= __b[0];
  return __a;
}
# 250 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_div_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2df)__a / (__v2df)__b);
}
# 280 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sqrt_sd(__m128d __a,
                                                         __m128d __b) {
  __m128d __c = __builtin_ia32_sqrtsd((__v2df)__b);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 302 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sqrt_pd(__m128d __a) {
  return __builtin_ia32_sqrtpd((__v2df)__a);
}
# 330 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_min_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_minsd((__v2df)__a, (__v2df)__b);
}
# 355 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_min_pd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_minpd((__v2df)__a, (__v2df)__b);
}
# 384 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_max_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_maxsd((__v2df)__a, (__v2df)__b);
}
# 409 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_max_pd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_maxpd((__v2df)__a, (__v2df)__b);
}
# 432 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_and_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2du)__a & (__v2du)__b);
}
# 458 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_andnot_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)(~(__v2du)__a & (__v2du)__b);
}
# 481 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_or_pd(__m128d __a,
                                                       __m128d __b) {
  return (__m128d)((__v2du)__a | (__v2du)__b);
}
# 504 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_xor_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2du)__a ^ (__v2du)__b);
}
# 528 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpeqpd((__v2df)__a, (__v2df)__b);
}
# 553 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__a, (__v2df)__b);
}
# 577 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmple_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__a, (__v2df)__b);
}
# 601 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__b, (__v2df)__a);
}
# 625 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpge_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__b, (__v2df)__a);
}
# 649 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpord_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpordpd((__v2df)__a, (__v2df)__b);
}
# 674 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpunord_pd(__m128d __a,
                                                             __m128d __b) {
  return (__m128d)__builtin_ia32_cmpunordpd((__v2df)__a, (__v2df)__b);
}
# 698 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpneq_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpneqpd((__v2df)__a, (__v2df)__b);
}
# 722 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnlt_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__a, (__v2df)__b);
}
# 746 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnle_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__a, (__v2df)__b);
}
# 770 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpngt_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__b, (__v2df)__a);
}
# 794 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnge_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__b, (__v2df)__a);
}
# 820 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_sd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpeqsd((__v2df)__a, (__v2df)__b);
}
# 848 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_sd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpltsd((__v2df)__a, (__v2df)__b);
}
# 876 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmple_sd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmplesd((__v2df)__a, (__v2df)__b);
}
# 904 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_sd(__m128d __a,
                                                          __m128d __b) {
  __m128d __c = __builtin_ia32_cmpltsd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 933 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpge_sd(__m128d __a,
                                                          __m128d __b) {
  __m128d __c = __builtin_ia32_cmplesd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 962 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpord_sd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpordsd((__v2df)__a, (__v2df)__b);
}
# 991 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpunord_sd(__m128d __a,
                                                             __m128d __b) {
  return (__m128d)__builtin_ia32_cmpunordsd((__v2df)__a, (__v2df)__b);
}
# 1019 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpneq_sd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpneqsd((__v2df)__a, (__v2df)__b);
}
# 1047 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnlt_sd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnltsd((__v2df)__a, (__v2df)__b);
}
# 1075 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnle_sd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnlesd((__v2df)__a, (__v2df)__b);
}
# 1103 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpngt_sd(__m128d __a,
                                                           __m128d __b) {
  __m128d __c = __builtin_ia32_cmpnltsd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 1132 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnge_sd(__m128d __a,
                                                           __m128d __b) {
  __m128d __c = __builtin_ia32_cmpnlesd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 1159 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comieq_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdeq((__v2df)__a, (__v2df)__b);
}
# 1187 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comilt_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdlt((__v2df)__a, (__v2df)__b);
}
# 1215 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comile_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdle((__v2df)__a, (__v2df)__b);
}
# 1243 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comigt_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdgt((__v2df)__a, (__v2df)__b);
}
# 1271 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comige_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdge((__v2df)__a, (__v2df)__b);
}
# 1299 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comineq_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_comisdneq((__v2df)__a, (__v2df)__b);
}
# 1326 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomieq_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdeq((__v2df)__a, (__v2df)__b);
}
# 1354 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomilt_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdlt((__v2df)__a, (__v2df)__b);
}
# 1382 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomile_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdle((__v2df)__a, (__v2df)__b);
}
# 1410 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomigt_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdgt((__v2df)__a, (__v2df)__b);
}
# 1438 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomige_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdge((__v2df)__a, (__v2df)__b);
}
# 1466 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomineq_sd(__m128d __a,
                                                         __m128d __b) {
  return __builtin_ia32_ucomisdneq((__v2df)__a, (__v2df)__b);
}
# 1489 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtpd_ps(__m128d __a) {
  return __builtin_ia32_cvtpd2ps((__v2df)__a);
}
# 1512 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtps_pd(__m128 __a) {
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 1), __v2df);
}
# 1534 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtepi32_pd(__m128i __a) {
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4si)__a, (__v4si)__a, 0, 1), __v2df);
}
# 1557 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtpd_epi32(__m128d __a) {
  return __builtin_ia32_cvtpd2dq((__v2df)__a);
}
# 1577 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsd_si32(__m128d __a) {
  return __builtin_ia32_cvtsd2si((__v2df)__a);
}
# 1606 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsd_ss(__m128 __a,
                                                         __m128d __b) {
  return (__m128)__builtin_ia32_cvtsd2ss((__v4sf)__a, (__v2df)__b);
}
# 1634 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi32_sd(__m128d __a,
                                                            int __b) {
  __a[0] = __b;
  return __a;
}
# 1665 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtss_sd(__m128d __a,
                                                          __m128 __b) {
  __a[0] = __b[0];
  return __a;
}
# 1689 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvttpd_epi32(__m128d __a) {
  return (__m128i)__builtin_ia32_cvttpd2dq((__v2df)__a);
}
# 1710 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvttsd_si32(__m128d __a) {
  return __builtin_ia32_cvttsd2si((__v2df)__a);
}
# 1730 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_cvtpd_pi32(__m128d __a) {
  return (__m64)__builtin_ia32_cvtpd2pi((__v2df)__a);
}
# 1750 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_cvttpd_pi32(__m128d __a) {
  return (__m64)__builtin_ia32_cvttpd2pi((__v2df)__a);
}
# 1770 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_cvtpi32_pd(__m64 __a) {
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}
# 1790 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsd_f64(__m128d __a) {
  return __a[0];
}
# 1810 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_load_pd(double const *__dp) {
  return *(const __m128d *)__dp;
}
# 1831 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_load1_pd(double const *__dp) {
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_load1_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, __u};
}
# 1863 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadr_pd(double const *__dp) {
  __m128d __u = *(const __m128d *)__dp;
  return __builtin_shufflevector((__v2df)__u, (__v2df)__u, 1, 0);
}
# 1884 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadu_pd(double const *__dp) {
  struct __loadu_pd {
    __m128d_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_pd *)__dp)->__v;
}
# 1907 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadu_si64(void const *__a) {
  struct __loadu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  long long __u = ((const struct __loadu_si64 *)__a)->__v;
  return __extension__(__m128i)(__v2di){__u, 0LL};
}
# 1931 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadu_si32(void const *__a) {
  struct __loadu_si32 {
    int __v;
  } __attribute__((__packed__, __may_alias__));
  int __u = ((const struct __loadu_si32 *)__a)->__v;
  return __extension__(__m128i)(__v4si){__u, 0, 0, 0};
}
# 1955 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadu_si16(void const *__a) {
  struct __loadu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  short __u = ((const struct __loadu_si16 *)__a)->__v;
  return __extension__(__m128i)(__v8hi){__u, 0, 0, 0, 0, 0, 0, 0};
}
# 1979 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_load_sd(double const *__dp) {
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_load_sd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, 0};
}
# 2010 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadh_pd(__m128d __a,
                                                          double const *__dp) {
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_loadh_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__a[0], __u};
}
# 2042 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadl_pd(__m128d __a,
                                                          double const *__dp) {
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_loadl_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, __a[1]};
}
# 2066 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_undefined_pd(void) {
  return (__m128d)__builtin_ia32_undef128();
}
# 2089 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_sd(double __w) {
  return __extension__(__m128d){__w, 0};
}
# 2110 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_pd(double __w) {
  return __extension__(__m128d){__w, __w};
}
# 2131 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_pd1(double __w) {
  return _mm_set1_pd(__w);
}
# 2155 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_pd(double __w,
                                                        double __x) {
  return __extension__(__m128d){__x, __w};
}
# 2181 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setr_pd(double __w,
                                                         double __x) {
  return __extension__(__m128d){__w, __x};
}
# 2199 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setzero_pd(void) {
  return __extension__(__m128d){0, 0};
}
# 2224 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_move_sd(__m128d __a,
                                                         __m128d __b) {
  __a[0] = __b[0];
  return __a;
}
# 2245 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store_sd(double *__dp,
                                                       __m128d __a) {
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct *)__dp)->__u = __a[0];
}
# 2270 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store_pd(double *__dp,
                                                       __m128d __a) {
  *(__m128d *)__dp = __a;
}
# 2293 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store1_pd(double *__dp,
                                                        __m128d __a) {
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
  _mm_store_pd(__dp, __a);
}
# 2317 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store_pd1(double *__dp,
                                                        __m128d __a) {
  _mm_store1_pd(__dp, __a);
}
# 2338 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_pd(double *__dp,
                                                        __m128d __a) {
  struct __storeu_pd {
    __m128d_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_pd *)__dp)->__v = __a;
}
# 2364 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storer_pd(double *__dp,
                                                        __m128d __a) {
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 1, 0);
  *(__m128d *)__dp = __a;
}
# 2385 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeh_pd(double *__dp,
                                                        __m128d __a) {
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct *)__dp)->__u = __a[1];
}
# 2408 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storel_pd(double *__dp,
                                                        __m128d __a) {
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct *)__dp)->__u = __a[0];
}
# 2436 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_epi8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)((__v16qu)__a + (__v16qu)__b);
}
# 2461 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_epi16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v8hu)__a + (__v8hu)__b);
}
# 2486 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_epi32(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v4su)__a + (__v4su)__b);
}
# 2509 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_add_si64(__m64 __a,
                                                            __m64 __b) {
  return (__m64)__builtin_ia32_paddq((__v1di)__a, (__v1di)__b);
}
# 2534 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_epi64(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v2du)__a + (__v2du)__b);
}
# 2560 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_adds_epi8(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_add_sat((__v16qs)__a, (__v16qs)__b);
}
# 2587 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_adds_epi16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_elementwise_add_sat((__v8hi)__a, (__v8hi)__b);
}
# 2613 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_adds_epu8(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_add_sat((__v16qu)__a, (__v16qu)__b);
}
# 2639 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_adds_epu16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_elementwise_add_sat((__v8hu)__a, (__v8hu)__b);
}
# 2664 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_avg_epu8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}
# 2689 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_avg_epu16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}
# 2715 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_madd_epi16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}
# 2740 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_max_epi16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_max((__v8hi)__a, (__v8hi)__b);
}
# 2765 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_max_epu8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)__builtin_elementwise_max((__v16qu)__a, (__v16qu)__b);
}
# 2790 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_min_epi16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_min((__v8hi)__a, (__v8hi)__b);
}
# 2815 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_min_epu8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)__builtin_elementwise_min((__v16qu)__a, (__v16qu)__b);
}
# 2840 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mulhi_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}
# 2865 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mulhi_epu16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}
# 2890 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mullo_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v8hu)__a * (__v8hu)__b);
}
# 2914 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_mul_su32(__m64 __a,
                                                            __m64 __b) {
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}
# 2938 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mul_epu32(__m128i __a,
                                                           __m128i __b) {
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}
# 2965 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sad_epu8(__m128i __a,
                                                          __m128i __b) {
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}
# 2988 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_epi8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)((__v16qu)__a - (__v16qu)__b);
}
# 3011 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_epi16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v8hu)__a - (__v8hu)__b);
}
# 3034 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_epi32(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v4su)__a - (__v4su)__b);
}
# 3058 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_sub_si64(__m64 __a,
                                                            __m64 __b) {
  return (__m64)__builtin_ia32_psubq((__v1di)__a, (__v1di)__b);
}
# 3081 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_epi64(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v2du)__a - (__v2du)__b);
}
# 3107 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_subs_epi8(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_sub_sat((__v16qs)__a, (__v16qs)__b);
}
# 3133 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_subs_epi16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_elementwise_sub_sat((__v8hi)__a, (__v8hi)__b);
}
# 3158 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_subs_epu8(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_sub_sat((__v16qu)__a, (__v16qu)__b);
}
# 3183 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_subs_epu16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_elementwise_sub_sat((__v8hu)__a, (__v8hu)__b);
}
# 3206 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_and_si128(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v2du)__a & (__v2du)__b);
}
# 3231 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_andnot_si128(__m128i __a,
                                                              __m128i __b) {
  return (__m128i)(~(__v2du)__a & (__v2du)__b);
}
# 3253 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_or_si128(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)((__v2du)__a | (__v2du)__b);
}
# 3276 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_xor_si128(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v2du)__a ^ (__v2du)__b);
}
# 3334 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_slli_epi16(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}
# 3358 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sll_epi16(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}
# 3382 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_slli_epi32(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}
# 3406 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sll_epi32(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}
# 3430 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_slli_epi64(__m128i __a,
                                                            int __count) {
  return __builtin_ia32_psllqi128((__v2di)__a, __count);
}
# 3454 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sll_epi64(__m128i __a,
                                                           __m128i __count) {
  return __builtin_ia32_psllq128((__v2di)__a, (__v2di)__count);
}
# 3479 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srai_epi16(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}
# 3504 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sra_epi16(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}
# 3529 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srai_epi32(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}
# 3554 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sra_epi32(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
# 3612 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srli_epi16(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}
# 3636 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srl_epi16(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}
# 3660 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srli_epi32(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}
# 3684 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srl_epi32(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}
# 3708 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srli_epi64(__m128i __a,
                                                            int __count) {
  return __builtin_ia32_psrlqi128((__v2di)__a, __count);
}
# 3732 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srl_epi64(__m128i __a,
                                                           __m128i __count) {
  return __builtin_ia32_psrlq128((__v2di)__a, (__v2di)__count);
}
# 3756 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_epi8(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}
# 3780 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}
# 3804 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_epi32(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v4si)__a == (__v4si)__b);
}
# 3829 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_epi8(__m128i __a,
                                                            __m128i __b) {


  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}
# 3855 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}
# 3879 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_epi32(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v4si)__a > (__v4si)__b);
}
# 3903 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_epi8(__m128i __a,
                                                            __m128i __b) {
  return _mm_cmpgt_epi8(__b, __a);
}
# 3927 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_epi16(__m128i __a,
                                                             __m128i __b) {
  return _mm_cmpgt_epi16(__b, __a);
}
# 3951 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_epi32(__m128i __a,
                                                             __m128i __b) {
  return _mm_cmpgt_epi32(__b, __a);
}
# 3980 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi64_sd(__m128d __a,
                                                            long long __b) {
  __a[0] = __b;
  return __a;
}
# 4002 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsd_si64(__m128d __a) {
  return __builtin_ia32_cvtsd2si64((__v2df)__a);
}
# 4023 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvttsd_si64(__m128d __a) {
  return __builtin_ia32_cvttsd2si64((__v2df)__a);
}
# 4042 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtepi32_ps(__m128i __a) {
  return (__m128) __builtin_convertvector((__v4si)__a, __v4sf);
}
# 4061 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtps_epi32(__m128 __a) {
  return (__m128i)__builtin_ia32_cvtps2dq((__v4sf)__a);
}
# 4081 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvttps_epi32(__m128 __a) {
  return (__m128i)__builtin_ia32_cvttps2dq((__v4sf)__a);
}
# 4100 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi32_si128(int __a) {
  return __extension__(__m128i)(__v4si){__a, 0, 0, 0};
}
# 4120 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi64_si128(long long __a) {
  return __extension__(__m128i)(__v2di){__a, 0};
}
# 4140 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi128_si32(__m128i __a) {
  __v4si __b = (__v4si)__a;
  return __b[0];
}
# 4161 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi128_si64(__m128i __a) {
  return __a[0];
}
# 4180 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load_si128(__m128i const *__p) {
  return *__p;
}
# 4200 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si128(__m128i_u const *__p) {
  struct __loadu_si128 {
    __m128i_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_si128 *)__p)->__v;
}
# 4225 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadl_epi64(__m128i_u const *__p) {
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return __extension__(__m128i){
      ((const struct __mm_loadl_epi64_struct *)__p)->__u, 0};
}
# 4247 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_undefined_si128(void) {
  return (__m128i)__builtin_ia32_undef128();
}
# 4273 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_epi64x(long long __q1,
                                                            long long __q0) {
  return __extension__(__m128i)(__v2di){__q0, __q1};
}
# 4300 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_epi64(__m64 __q1,
                                                           __m64 __q0) {
  return _mm_set_epi64x((long long)__q1, (long long)__q0);
}
# 4335 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_epi32(int __i3, int __i2,
                                                           int __i1, int __i0) {
  return __extension__(__m128i)(__v4si){__i0, __i1, __i2, __i3};
}
# 4386 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi16(short __w7, short __w6, short __w5, short __w4, short __w3,
              short __w2, short __w1, short __w0) {
  return __extension__(__m128i)(__v8hi){__w0, __w1, __w2, __w3,
                                        __w4, __w5, __w6, __w7};
}
# 4455 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi8(char __b15, char __b14, char __b13, char __b12, char __b11,
             char __b10, char __b9, char __b8, char __b7, char __b6, char __b5,
             char __b4, char __b3, char __b2, char __b1, char __b0) {
  return __extension__(__m128i)(__v16qi){
      __b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7,
      __b8, __b9, __b10, __b11, __b12, __b13, __b14, __b15};
}
# 4482 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi64x(long long __q) {
  return _mm_set_epi64x(__q, __q);
}
# 4504 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi64(__m64 __q) {
  return _mm_set_epi64(__q, __q);
}
# 4526 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi32(int __i) {
  return _mm_set_epi32(__i, __i, __i, __i);
}
# 4548 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi16(short __w) {
  return _mm_set_epi16(__w, __w, __w, __w, __w, __w, __w, __w);
}
# 4570 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi8(char __b) {
  return _mm_set_epi8(__b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b,
                      __b, __b, __b, __b, __b);
}
# 4595 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setr_epi64(__m64 __q0,
                                                            __m64 __q1) {
  return _mm_set_epi64(__q1, __q0);
}
# 4625 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setr_epi32(int __i0, int __i1,
                                                            int __i2,
                                                            int __i3) {
  return _mm_set_epi32(__i3, __i2, __i1, __i0);
}
# 4668 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi16(short __w0, short __w1, short __w2, short __w3, short __w4,
               short __w5, short __w6, short __w7) {
  return _mm_set_epi16(__w7, __w6, __w5, __w4, __w3, __w2, __w1, __w0);
}
# 4735 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
              char __b6, char __b7, char __b8, char __b9, char __b10,
              char __b11, char __b12, char __b13, char __b14, char __b15) {
  return _mm_set_epi8(__b15, __b14, __b13, __b12, __b11, __b10, __b9, __b8,
                      __b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 4755 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setzero_si128(void) {
  return __extension__(__m128i)(__v2di){0LL, 0LL};
}
# 4775 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store_si128(__m128i *__p,
                                                          __m128i __b) {
  *__p = __b;
}
# 4794 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_si128(__m128i_u *__p,
                                                           __m128i __b) {
  struct __storeu_si128 {
    __m128i_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si128 *)__p)->__v = __b;
}
# 4818 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_si64(void *__p,
                                                          __m128i __b) {
  struct __storeu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si64 *)__p)->__v = ((__v2di)__b)[0];
}
# 4842 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_si32(void *__p,
                                                          __m128i __b) {
  struct __storeu_si32 {
    int __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si32 *)__p)->__v = ((__v4si)__b)[0];
}
# 4866 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_si16(void *__p,
                                                          __m128i __b) {
  struct __storeu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si16 *)__p)->__v = ((__v8hi)__b)[0];
}
# 4896 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_maskmoveu_si128(__m128i __d,
                                                              __m128i __n,
                                                              char *__p) {
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}
# 4919 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storel_epi64(__m128i_u *__p,
                                                           __m128i __a) {
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct *)__p)->__u = __a[0];
}
# 4942 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_stream_pd(double *__p,
                                                        __m128d __a) {
  __builtin_nontemporal_store((__v2df)__a, (__v2df *)__p);
}
# 4961 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_stream_si128(__m128i *__p,
                                                           __m128i __a) {
  __builtin_nontemporal_store((__v2di)__a, (__v2di *)__p);
}
# 4980 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void
    __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
    _mm_stream_si32(int *__p, int __a) {
  __builtin_ia32_movnti(__p, __a);
}
# 5001 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void
    __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
    _mm_stream_si64(long long *__p, long long __a) {
  __builtin_ia32_movnti64(__p, __a);
}



extern "C" {
# 5025 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
void _mm_clflush(void const *__p);
# 5038 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
void _mm_lfence(void);
# 5051 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
void _mm_mfence(void);


}
# 5085 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_packs_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}
# 5118 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_packs_epi32(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}
# 5151 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_packus_epi16(__m128i __a,
                                                              __m128i __b) {
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}
# 5244 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_movemask_epi8(__m128i __a) {
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
# 5401 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_epi8(__m128i __a,
                                                               __m128i __b) {
  return (__m128i)__builtin_shufflevector(
      (__v16qi)__a, (__v16qi)__b, 8, 16 + 8, 9, 16 + 9, 10, 16 + 10, 11,
      16 + 11, 12, 16 + 12, 13, 16 + 13, 14, 16 + 14, 15, 16 + 15);
}
# 5435 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_epi16(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8 + 4, 5,
                                          8 + 5, 6, 8 + 6, 7, 8 + 7);
}
# 5464 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_epi32(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4 + 2, 3,
                                          4 + 3);
}
# 5491 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_epi64(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 1, 2 + 1);
}
# 5531 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_epi8(__m128i __a,
                                                               __m128i __b) {
  return (__m128i)__builtin_shufflevector(
      (__v16qi)__a, (__v16qi)__b, 0, 16 + 0, 1, 16 + 1, 2, 16 + 2, 3, 16 + 3, 4,
      16 + 4, 5, 16 + 5, 6, 16 + 6, 7, 16 + 7);
}
# 5566 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_epi16(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8 + 0, 1,
                                          8 + 1, 2, 8 + 2, 3, 8 + 3);
}
# 5595 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_epi32(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4 + 0, 1,
                                          4 + 1);
}
# 5622 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_epi64(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 0, 2 + 0);
}
# 5643 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_movepi64_pi64(__m128i __a) {
  return (__m64)__a[0];
}
# 5663 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_movpi64_epi64(__m64 __a) {
  return __extension__(__m128i)(__v2di){(long long)__a, 0};
}
# 5684 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_move_epi64(__m128i __a) {
  return __builtin_shufflevector((__v2di)__a, _mm_setzero_si128(), 0, 2);
}
# 5709 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_pd(__m128d __a,
                                                             __m128d __b) {
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 1, 2 + 1);
}
# 5735 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_pd(__m128d __a,
                                                             __m128d __b) {
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 0, 2 + 0);
}
# 5758 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_movemask_pd(__m128d __a) {
  return __builtin_ia32_movmskpd((__v2df)__a);
}
# 5816 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castpd_ps(__m128d __a) {
  return (__m128)__a;
}
# 5836 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castpd_si128(__m128d __a) {
  return (__m128i)__a;
}
# 5856 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castps_pd(__m128 __a) {
  return (__m128d)__a;
}
# 5876 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castps_si128(__m128 __a) {
  return (__m128i)__a;
}
# 5896 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castsi128_ps(__m128i __a) {
  return (__m128)__a;
}
# 5916 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castsi128_pd(__m128i __a) {
  return (__m128d)__a;
}


extern "C" {
# 5933 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
void _mm_pause(void);


}
# 3614 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xmmintrin.h" 2 3 4
# 27 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 36 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 1 3 4
# 38 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_lddqu_si128(__m128i_u const *__p)
{
  return (__m128i)__builtin_ia32_lddqu((char const *)__p);
}
# 63 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_addsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_addsubps((__v4sf)__a, (__v4sf)__b);
}
# 92 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_hadd_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_haddps((__v4sf)__a, (__v4sf)__b);
}
# 121 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_hsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_hsubps((__v4sf)__a, (__v4sf)__b);
}
# 148 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_movehdup_ps(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 1, 1, 3, 3);
}
# 174 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_moveldup_ps(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 2, 2);
}
# 199 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_addsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_addsubpd((__v2df)__a, (__v2df)__b);
}
# 228 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_hadd_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_haddpd((__v2df)__a, (__v2df)__b);
}
# 257 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_hsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_hsubpd((__v2df)__a, (__v2df)__b);
}
# 303 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_movedup_pd(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
}
# 329 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_monitor(void const *__p, unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_monitor(__p, __extensions, __hints);
}
# 352 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_mwait(unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_mwait(__extensions, __hints);
}
# 37 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 1 3 4
# 40 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_abs_pi8(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsb((__v8qi)__a);
}
# 63 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_abs_epi8(__m128i __a)
{
    return (__m128i)__builtin_elementwise_abs((__v16qs)__a);
}
# 86 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_abs_pi16(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsw((__v4hi)__a);
}
# 109 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_abs_epi16(__m128i __a)
{
    return (__m128i)__builtin_elementwise_abs((__v8hi)__a);
}
# 132 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_abs_pi32(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsd((__v2si)__a);
}
# 155 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_abs_epi32(__m128i __a)
{
    return (__m128i)__builtin_elementwise_abs((__v4si)__a);
}
# 244 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hadd_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddw128((__v8hi)__a, (__v8hi)__b);
}
# 273 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hadd_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddd128((__v4si)__a, (__v4si)__b);
}
# 302 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hadd_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddw((__v4hi)__a, (__v4hi)__b);
}
# 331 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hadd_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddd((__v2si)__a, (__v2si)__b);
}
# 362 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hadds_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddsw128((__v8hi)__a, (__v8hi)__b);
}
# 393 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hadds_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddsw((__v4hi)__a, (__v4hi)__b);
}
# 422 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hsub_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubw128((__v8hi)__a, (__v8hi)__b);
}
# 451 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hsub_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubd128((__v4si)__a, (__v4si)__b);
}
# 480 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hsub_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubw((__v4hi)__a, (__v4hi)__b);
}
# 509 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hsub_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubd((__v2si)__a, (__v2si)__b);
}
# 540 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hsubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubsw128((__v8hi)__a, (__v8hi)__b);
}
# 571 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hsubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubsw((__v4hi)__a, (__v4hi)__b);
}
# 607 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_maddubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmaddubsw128((__v16qi)__a, (__v16qi)__b);
}
# 639 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_maddubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmaddubsw((__v8qi)__a, (__v8qi)__b);
}
# 665 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_mulhrs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmulhrsw128((__v8hi)__a, (__v8hi)__b);
}
# 691 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_mulhrs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmulhrsw((__v4hi)__a, (__v4hi)__b);
}
# 723 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_shuffle_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pshufb128((__v16qi)__a, (__v16qi)__b);
}
# 754 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_shuffle_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pshufb((__v8qi)__a, (__v8qi)__b);
}
# 779 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_sign_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignb128((__v16qi)__a, (__v16qi)__b);
}
# 804 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_sign_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignw128((__v8hi)__a, (__v8hi)__b);
}
# 829 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_sign_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignd128((__v4si)__a, (__v4si)__b);
}
# 854 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_sign_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignb((__v8qi)__a, (__v8qi)__b);
}
# 879 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_sign_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignw((__v4hi)__a, (__v4hi)__b);
}
# 904 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_sign_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignd((__v2si)__a, (__v2si)__b);
}
# 42 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 1 3 4
# 527 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_blendv_pd(__m128d __V1,
                                                           __m128d __V2,
                                                           __m128d __M) {
  return (__m128d)__builtin_ia32_blendvpd((__v2df)__V1, (__v2df)__V2,
                                          (__v2df)__M);
}
# 561 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_blendv_ps(__m128 __V1,
                                                          __m128 __V2,
                                                          __m128 __M) {
  return (__m128)__builtin_ia32_blendvps((__v4sf)__V1, (__v4sf)__V2,
                                         (__v4sf)__M);
}
# 595 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_blendv_epi8(__m128i __V1,
                                                             __m128i __V2,
                                                             __m128i __M) {
  return (__m128i)__builtin_ia32_pblendvb128((__v16qi)__V1, (__v16qi)__V2,
                                             (__v16qi)__M);
}
# 657 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_mullo_epi32(__m128i __V1,
                                                             __m128i __V2) {
  return (__m128i)((__v4su)__V1 * (__v4su)__V2);
}
# 682 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_mul_epi32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_ia32_pmuldq128((__v4si)__V1, (__v4si)__V2);
}
# 780 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128)))
_mm_stream_load_si128(__m128i const *__V) {
  return (__m128i)__builtin_nontemporal_load((const __v2di *)__V);
}
# 805 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_min_epi8(__m128i __V1,
                                                          __m128i __V2) {
  return (__m128i)__builtin_elementwise_min((__v16qs)__V1, (__v16qs)__V2);
}
# 829 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_max_epi8(__m128i __V1,
                                                          __m128i __V2) {
  return (__m128i)__builtin_elementwise_max((__v16qs)__V1, (__v16qs)__V2);
}
# 853 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_min_epu16(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_min((__v8hu)__V1, (__v8hu)__V2);
}
# 877 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_max_epu16(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_max((__v8hu)__V1, (__v8hu)__V2);
}
# 901 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_min_epi32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_min((__v4si)__V1, (__v4si)__V2);
}
# 925 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_max_epi32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_max((__v4si)__V1, (__v4si)__V2);
}
# 949 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_min_epu32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_min((__v4su)__V1, (__v4su)__V2);
}
# 973 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_max_epu32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_max((__v4su)__V1, (__v4su)__V2);
}
# 1335 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_testz_si128(__m128i __M,
                                                         __m128i __V) {
  return __builtin_ia32_ptestz128((__v2di)__M, (__v2di)__V);
}
# 1358 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_testc_si128(__m128i __M,
                                                         __m128i __V) {
  return __builtin_ia32_ptestc128((__v2di)__M, (__v2di)__V);
}
# 1382 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_testnzc_si128(__m128i __M,
                                                           __m128i __V) {
  return __builtin_ia32_ptestnzc128((__v2di)__M, (__v2di)__V);
}
# 1477 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cmpeq_epi64(__m128i __V1,
                                                             __m128i __V2) {
  return (__m128i)((__v2di)__V1 == (__v2di)__V2);
}
# 1501 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi8_epi16(__m128i __V) {


  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3, 4, 5, 6,
                              7),
      __v8hi);
}
# 1528 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi8_epi32(__m128i __V) {


  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3), __v4si);
}
# 1553 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi8_epi64(__m128i __V) {


  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1), __v2di);
}
# 1578 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi16_epi32(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1, 2, 3), __v4si);
}
# 1601 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi16_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1), __v2di);
}
# 1624 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi32_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v4si)__V, (__v4si)__V, 0, 1), __v2di);
}
# 1648 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu8_epi16(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3, 4, 5, 6,
                              7),
      __v8hi);
}
# 1673 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu8_epi32(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3), __v4si);
}
# 1696 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu8_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1), __v2di);
}
# 1719 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu16_epi32(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v8hu)__V, (__v8hu)__V, 0, 1, 2, 3), __v4si);
}
# 1742 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu16_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v8hu)__V, (__v8hu)__V, 0, 1), __v2di);
}
# 1765 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu32_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v4su)__V, (__v4su)__V, 0, 1), __v2di);
}
# 1799 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_packus_epi32(__m128i __V1,
                                                              __m128i __V2) {
  return (__m128i)__builtin_ia32_packusdw128((__v4si)__V1, (__v4si)__V2);
}
# 1869 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_minpos_epu16(__m128i __V) {
  return (__m128i)__builtin_ia32_phminposuw128((__v8hi)__V);
}
# 2790 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.2"))) _mm_cmpgt_epi64(__m128i __V1,
                                                             __m128i __V2) {
  return (__m128i)((__v2di)__V1 > (__v2di)__V2);
}



# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\popcntintrin.h" 1 3 4
# 37 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\popcntintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("popcnt"))) constexpr
_mm_popcnt_u32(unsigned int __A)
{
  return __builtin_popcount(__A);
}
# 59 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\popcntintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("popcnt"))) constexpr
_mm_popcnt_u64(unsigned long long __A)
{
  return __builtin_popcountll(__A);
}
# 2798 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\smmintrin.h" 2 3 4
# 47 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\wmmintrin.h" 1 3 4
# 19 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\wmmintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 1 3 4
# 40 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesenc_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenc128((__v2di)__V, (__v2di)__R);
}
# 66 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesenclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenclast128((__v2di)__V, (__v2di)__R);
}
# 92 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesdec_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdec128((__v2di)__V, (__v2di)__R);
}
# 118 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesdeclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdeclast128((__v2di)__V, (__v2di)__R);
}
# 140 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesimc_si128(__m128i __V)
{
  return (__m128i)__builtin_ia32_aesimc128((__v2di)__V);
}
# 20 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\wmmintrin.h" 2 3 4

# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\__wmmintrin_pclmul.h" 1 3 4
# 22 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\wmmintrin.h" 2 3 4
# 52 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 66 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
typedef double __v4df __attribute__ ((__vector_size__ (32)));
typedef float __v8sf __attribute__ ((__vector_size__ (32)));
typedef long long __v4di __attribute__ ((__vector_size__ (32)));
typedef int __v8si __attribute__ ((__vector_size__ (32)));
typedef short __v16hi __attribute__ ((__vector_size__ (32)));
typedef char __v32qi __attribute__ ((__vector_size__ (32)));


typedef unsigned long long __v4du __attribute__ ((__vector_size__ (32)));
typedef unsigned int __v8su __attribute__ ((__vector_size__ (32)));
typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));
typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));



typedef signed char __v32qs __attribute__((__vector_size__(32)));

typedef float __m256 __attribute__ ((__vector_size__ (32), __aligned__(32)));
typedef double __m256d __attribute__((__vector_size__(32), __aligned__(32)));
typedef long long __m256i __attribute__((__vector_size__(32), __aligned__(32)));

typedef float __m256_u __attribute__ ((__vector_size__ (32), __aligned__(1)));
typedef double __m256d_u __attribute__((__vector_size__(32), __aligned__(1)));
typedef long long __m256i_u __attribute__((__vector_size__(32), __aligned__(1)));
# 65 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_add_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a+(__v4df)__b);
}
# 89 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_add_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a+(__v8sf)__b);
}
# 113 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_sub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a-(__v4df)__b);
}
# 137 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_sub_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a-(__v8sf)__b);
}
# 162 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_addsub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_addsubpd256((__v4df)__a, (__v4df)__b);
}
# 187 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_addsub_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_addsubps256((__v8sf)__a, (__v8sf)__b);
}
# 211 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_div_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a/(__v4df)__b);
}
# 235 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_div_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a/(__v8sf)__b);
}
# 260 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_max_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_maxpd256((__v4df)__a, (__v4df)__b);
}
# 285 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_max_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_maxps256((__v8sf)__a, (__v8sf)__b);
}
# 310 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_min_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_minpd256((__v4df)__a, (__v4df)__b);
}
# 335 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_min_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_minps256((__v8sf)__a, (__v8sf)__b);
}
# 359 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_mul_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a * (__v4df)__b);
}
# 383 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_mul_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a * (__v8sf)__b);
}
# 405 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_sqrt_pd(__m256d __a)
{
  return (__m256d)__builtin_ia32_sqrtpd256((__v4df)__a);
}
# 427 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_sqrt_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_sqrtps256((__v8sf)__a);
}
# 449 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_rsqrt_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_rsqrtps256((__v8sf)__a);
}
# 471 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_rcp_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_rcpps256((__v8sf)__a);
}
# 661 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_and_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a & (__v4du)__b);
}
# 685 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_and_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a & (__v8su)__b);
}
# 712 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_andnot_pd(__m256d __a, __m256d __b)
{
  return (__m256d)(~(__v4du)__a & (__v4du)__b);
}
# 739 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_andnot_ps(__m256 __a, __m256 __b)
{
  return (__m256)(~(__v8su)__a & (__v8su)__b);
}
# 763 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_or_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a | (__v4du)__b);
}
# 787 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_or_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a | (__v8su)__b);
}
# 811 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_xor_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a ^ (__v4du)__b);
}
# 835 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_xor_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a ^ (__v8su)__b);
}
# 865 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_hadd_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_haddpd256((__v4df)__a, (__v4df)__b);
}
# 894 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_hadd_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_haddps256((__v8sf)__a, (__v8sf)__b);
}
# 923 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_hsub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_hsubpd256((__v4df)__a, (__v4df)__b);
}
# 952 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_hsub_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_hsubps256((__v8sf)__a, (__v8sf)__b);
}
# 988 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_permutevar_pd(__m128d __a, __m128i __c)
{
  return (__m128d)__builtin_ia32_vpermilvarpd((__v2df)__a, (__v2di)__c);
}
# 1033 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_permutevar_pd(__m256d __a, __m256i __c)
{
  return (__m256d)__builtin_ia32_vpermilvarpd256((__v4df)__a, (__v4di)__c);
}
# 1095 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_permutevar_ps(__m128 __a, __m128i __c)
{
  return (__m128)__builtin_ia32_vpermilvarps((__v4sf)__a, (__v4si)__c);
}
# 1192 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_permutevar_ps(__m256 __a, __m256i __c)
{
  return (__m256)__builtin_ia32_vpermilvarps256((__v8sf)__a, (__v8si)__c);
}
# 1682 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_blendv_pd(__m256d __a, __m256d __b, __m256d __c)
{
  return (__m256d)__builtin_ia32_blendvpd256(
    (__v4df)__a, (__v4df)__b, (__v4df)__c);
}
# 1717 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_blendv_ps(__m256 __a, __m256 __b, __m256 __c)
{
  return (__m256)__builtin_ia32_blendvps256(
    (__v8sf)__a, (__v8sf)__b, (__v8sf)__c);
}
# 2546 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtepi32_pd(__m128i __a)
{
  return (__m256d)__builtin_convertvector((__v4si)__a, __v4df);
}
# 2566 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtepi32_ps(__m256i __a)
{
  return (__m256)__builtin_convertvector((__v8si)__a, __v8sf);
}
# 2587 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtpd_ps(__m256d __a)
{
  return (__m128)__builtin_ia32_cvtpd2ps256((__v4df) __a);
}
# 2607 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtps_epi32(__m256 __a)
{
  return (__m256i)__builtin_ia32_cvtps2dq256((__v8sf) __a);
}
# 2628 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtps_pd(__m128 __a)
{
  return (__m256d)__builtin_convertvector((__v4sf)__a, __v4df);
}
# 2650 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvttpd_epi32(__m256d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq256((__v4df) __a);
}
# 2672 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtpd_epi32(__m256d __a)
{
  return (__m128i)__builtin_ia32_cvtpd2dq256((__v4df) __a);
}
# 2693 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvttps_epi32(__m256 __a)
{
  return (__m256i)__builtin_ia32_cvttps2dq256((__v8sf) __a);
}
# 2714 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline double __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtsd_f64(__m256d __a)
{
 return __a[0];
}
# 2735 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtsi256_si32(__m256i __a)
{
 __v8si __b = (__v8si)__a;
 return __b[0];
}
# 2757 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline float __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtss_f32(__m256 __a)
{
 return __a[0];
}
# 2788 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_movehdup_ps(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 1, 1, 3, 3, 5, 5, 7, 7);
}
# 2818 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_moveldup_ps(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 0, 0, 2, 2, 4, 4, 6, 6);
}
# 2845 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_movedup_pd(__m256d __a)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__a, 0, 0, 2, 2);
}
# 2874 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_unpackhi_pd(__m256d __a, __m256d __b)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__b, 1, 5, 1+2, 5+2);
}
# 2902 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_unpacklo_pd(__m256d __a, __m256d __b)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__b, 0, 4, 0+2, 4+2);
}
# 2935 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_unpackhi_ps(__m256 __a, __m256 __b)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__b, 2, 10, 2+1, 10+1, 6, 14, 6+1, 14+1);
}
# 2968 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_unpacklo_ps(__m256 __a, __m256 __b)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__b, 0, 8, 0+1, 8+1, 4, 12, 4+1, 12+1);
}
# 2995 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testz_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestzpd((__v2df)__a, (__v2df)__b);
}
# 3021 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testc_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestcpd((__v2df)__a, (__v2df)__b);
}
# 3048 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testnzc_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestnzcpd((__v2df)__a, (__v2df)__b);
}
# 3074 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testz_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestzps((__v4sf)__a, (__v4sf)__b);
}
# 3100 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testc_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestcps((__v4sf)__a, (__v4sf)__b);
}
# 3127 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testnzc_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestnzcps((__v4sf)__a, (__v4sf)__b);
}
# 3153 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testz_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestzpd256((__v4df)__a, (__v4df)__b);
}
# 3179 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testc_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestcpd256((__v4df)__a, (__v4df)__b);
}
# 3206 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testnzc_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestnzcpd256((__v4df)__a, (__v4df)__b);
}
# 3232 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testz_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestzps256((__v8sf)__a, (__v8sf)__b);
}
# 3258 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testc_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestcps256((__v8sf)__a, (__v8sf)__b);
}
# 3285 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testnzc_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestnzcps256((__v8sf)__a, (__v8sf)__b);
}
# 3309 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testz_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestz256((__v4di)__a, (__v4di)__b);
}
# 3333 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testc_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestc256((__v4di)__a, (__v4di)__b);
}
# 3358 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testnzc_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestnzc256((__v4di)__a, (__v4di)__b);
}
# 3382 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_movemask_pd(__m256d __a)
{
  return __builtin_ia32_movmskpd256((__v4df)__a);
}
# 3405 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_movemask_ps(__m256 __a)
{
  return __builtin_ia32_movmskps256((__v8sf)__a);
}
# 3420 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zeroall(void)
{
  __builtin_ia32_vzeroall();
}
# 3434 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zeroupper(void)
{
  __builtin_ia32_vzeroupper();
}
# 3458 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_broadcast_ss(float const *__a)
{
  float __f = *__a;
  return __extension__ (__m128)(__v4sf){ __f, __f, __f, __f };
}
# 3482 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_broadcast_sd(double const *__a)
{
  double __d = *__a;
  return __extension__ (__m256d)(__v4df){ __d, __d, __d, __d };
}
# 3506 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_broadcast_ss(float const *__a)
{
  float __f = *__a;
  return __extension__ (__m256)(__v8sf){ __f, __f, __f, __f, __f, __f, __f, __f };
}
# 3530 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_broadcast_pd(__m128d const *__a)
{
  __m128d __b = _mm_loadu_pd((const double *)__a);
  return (__m256d)__builtin_shufflevector((__v2df)__b, (__v2df)__b,
                                          0, 1, 0, 1);
}
# 3555 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_broadcast_ps(__m128 const *__a)
{
  __m128 __b = _mm_loadu_ps((const float *)__a);
  return (__m256)__builtin_shufflevector((__v4sf)__b, (__v4sf)__b,
                                         0, 1, 2, 3, 0, 1, 2, 3);
}
# 3580 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_load_pd(double const *__p)
{
  return *(const __m256d *)__p;
}
# 3601 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_load_ps(float const *__p)
{
  return *(const __m256 *)__p;
}
# 3623 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu_pd(double const *__p)
{
  struct __loadu_pd {
    __m256d_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_pd*)__p)->__v;
}
# 3648 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu_ps(float const *__p)
{
  struct __loadu_ps {
    __m256_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_ps*)__p)->__v;
}
# 3673 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_load_si256(__m256i const *__p)
{
  return *__p;
}
# 3694 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu_si256(__m256i_u const *__p)
{
  struct __loadu_si256 {
    __m256i_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_si256*)__p)->__v;
}
# 3720 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_lddqu_si256(__m256i_u const *__p)
{
  return (__m256i)__builtin_ia32_lddqu256((char const *)__p);
}
# 3744 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_store_pd(double *__p, __m256d __a)
{
  *(__m256d *)__p = __a;
}
# 3766 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_store_ps(float *__p, __m256 __a)
{
  *(__m256 *)__p = __a;
}
# 3788 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu_pd(double *__p, __m256d __a)
{
  struct __storeu_pd {
    __m256d_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_pd*)__p)->__v = __a;
}
# 3812 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu_ps(float *__p, __m256 __a)
{
  struct __storeu_ps {
    __m256_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
}
# 3837 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_store_si256(__m256i *__p, __m256i __a)
{
  *__p = __a;
}
# 3858 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu_si256(__m256i_u *__p, __m256i __a)
{
  struct __storeu_si256 {
    __m256i_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si256*)__p)->__v = __a;
}
# 3892 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_maskload_pd(double const *__p, __m128i __m)
{
  return (__m128d)__builtin_ia32_maskloadpd((const __v2df *)__p, (__v2di)__m);
}
# 3922 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_maskload_pd(double const *__p, __m256i __m)
{
  return (__m256d)__builtin_ia32_maskloadpd256((const __v4df *)__p,
                                               (__v4di)__m);
}
# 3953 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_maskload_ps(float const *__p, __m128i __m)
{
  return (__m128)__builtin_ia32_maskloadps((const __v4sf *)__p, (__v4si)__m);
}
# 3983 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_maskload_ps(float const *__p, __m256i __m)
{
  return (__m256)__builtin_ia32_maskloadps256((const __v8sf *)__p, (__v8si)__m);
}
# 4013 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_maskstore_ps(float *__p, __m256i __m, __m256 __a)
{
  __builtin_ia32_maskstoreps256((__v8sf *)__p, (__v8si)__m, (__v8sf)__a);
}
# 4042 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_maskstore_pd(double *__p, __m128i __m, __m128d __a)
{
  __builtin_ia32_maskstorepd((__v2df *)__p, (__v2di)__m, (__v2df)__a);
}
# 4071 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_maskstore_pd(double *__p, __m256i __m, __m256d __a)
{
  __builtin_ia32_maskstorepd256((__v4df *)__p, (__v4di)__m, (__v4df)__a);
}
# 4100 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_maskstore_ps(float *__p, __m128i __m, __m128 __a)
{
  __builtin_ia32_maskstoreps((__v4sf *)__p, (__v4si)__m, (__v4sf)__a);
}
# 4124 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_stream_si256(__m256i *__a, __m256i __b)
{
  typedef __v4di __v4di_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v4di_aligned)__b, (__v4di_aligned*)__a);
}
# 4148 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_stream_pd(double *__a, __m256d __b)
{
  typedef __v4df __v4df_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v4df_aligned)__b, (__v4df_aligned*)__a);
}
# 4173 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_stream_ps(float *__p, __m256 __a)
{
  typedef __v8sf __v8sf_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v8sf_aligned)__a, (__v8sf_aligned*)__p);
}
# 4192 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_undefined_pd(void)
{
  return (__m256d)__builtin_ia32_undef256();
}
# 4209 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_undefined_ps(void)
{
  return (__m256)__builtin_ia32_undef256();
}
# 4226 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_undefined_si256(void)
{
  return (__m256i)__builtin_ia32_undef256();
}
# 4261 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_pd(double __a, double __b, double __c, double __d)
{
  return __extension__ (__m256d){ __d, __c, __b, __a };
}
# 4312 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_ps(float __a, float __b, float __c, float __d,
              float __e, float __f, float __g, float __h)
{
  return __extension__ (__m256){ __h, __g, __f, __e, __d, __c, __b, __a };
}
# 4356 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_epi32(int __i0, int __i1, int __i2, int __i3,
                 int __i4, int __i5, int __i6, int __i7)
{
  return __extension__ (__m256i)(__v8si){ __i7, __i6, __i5, __i4, __i3, __i2, __i1, __i0 };
}
# 4424 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_epi16(short __w15, short __w14, short __w13, short __w12,
                 short __w11, short __w10, short __w09, short __w08,
                 short __w07, short __w06, short __w05, short __w04,
                 short __w03, short __w02, short __w01, short __w00)
{
  return __extension__ (__m256i)(__v16hi){ __w00, __w01, __w02, __w03, __w04, __w05, __w06,
    __w07, __w08, __w09, __w10, __w11, __w12, __w13, __w14, __w15 };
}
# 4543 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_epi8(char __b31, char __b30, char __b29, char __b28,
                char __b27, char __b26, char __b25, char __b24,
                char __b23, char __b22, char __b21, char __b20,
                char __b19, char __b18, char __b17, char __b16,
                char __b15, char __b14, char __b13, char __b12,
                char __b11, char __b10, char __b09, char __b08,
                char __b07, char __b06, char __b05, char __b04,
                char __b03, char __b02, char __b01, char __b00)
{
  return __extension__ (__m256i)(__v32qi){
    __b00, __b01, __b02, __b03, __b04, __b05, __b06, __b07,
    __b08, __b09, __b10, __b11, __b12, __b13, __b14, __b15,
    __b16, __b17, __b18, __b19, __b20, __b21, __b22, __b23,
    __b24, __b25, __b26, __b27, __b28, __b29, __b30, __b31
  };
}
# 4586 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_epi64x(long long __a, long long __b, long long __c, long long __d)
{
  return __extension__ (__m256i)(__v4di){ __d, __c, __b, __a };
}
# 4623 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_pd(double __a, double __b, double __c, double __d)
{
  return _mm256_set_pd(__d, __c, __b, __a);
}
# 4675 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_ps(float __a, float __b, float __c, float __d,
               float __e, float __f, float __g, float __h)
{
  return _mm256_set_ps(__h, __g, __f, __e, __d, __c, __b, __a);
}
# 4719 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_epi32(int __i0, int __i1, int __i2, int __i3,
                  int __i4, int __i5, int __i6, int __i7)
{
  return _mm256_set_epi32(__i7, __i6, __i5, __i4, __i3, __i2, __i1, __i0);
}
# 4787 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_epi16(short __w15, short __w14, short __w13, short __w12,
       short __w11, short __w10, short __w09, short __w08,
       short __w07, short __w06, short __w05, short __w04,
       short __w03, short __w02, short __w01, short __w00)
{
  return _mm256_set_epi16(__w00, __w01, __w02, __w03,
                          __w04, __w05, __w06, __w07,
                          __w08, __w09, __w10, __w11,
                          __w12, __w13, __w14, __w15);
}
# 4908 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_epi8(char __b31, char __b30, char __b29, char __b28,
                 char __b27, char __b26, char __b25, char __b24,
                 char __b23, char __b22, char __b21, char __b20,
                 char __b19, char __b18, char __b17, char __b16,
                 char __b15, char __b14, char __b13, char __b12,
                 char __b11, char __b10, char __b09, char __b08,
                 char __b07, char __b06, char __b05, char __b04,
                 char __b03, char __b02, char __b01, char __b00)
{
  return _mm256_set_epi8(__b00, __b01, __b02, __b03, __b04, __b05, __b06, __b07,
                         __b08, __b09, __b10, __b11, __b12, __b13, __b14, __b15,
                         __b16, __b17, __b18, __b19, __b20, __b21, __b22, __b23,
                         __b24, __b25, __b26, __b27, __b28, __b29, __b30, __b31);
}
# 4949 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_epi64x(long long __a, long long __b, long long __c, long long __d)
{
  return _mm256_set_epi64x(__d, __c, __b, __a);
}
# 4973 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_pd(double __w)
{
  return _mm256_set_pd(__w, __w, __w, __w);
}
# 4997 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_ps(float __w)
{
  return _mm256_set_ps(__w, __w, __w, __w, __w, __w, __w, __w);
}
# 5021 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_epi32(int __i)
{
  return _mm256_set_epi32(__i, __i, __i, __i, __i, __i, __i, __i);
}
# 5044 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_epi16(short __w)
{
  return _mm256_set_epi16(__w, __w, __w, __w, __w, __w, __w, __w,
                          __w, __w, __w, __w, __w, __w, __w, __w);
}
# 5067 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_epi8(char __b)
{
  return _mm256_set_epi8(__b, __b, __b, __b, __b, __b, __b, __b,
                         __b, __b, __b, __b, __b, __b, __b, __b,
                         __b, __b, __b, __b, __b, __b, __b, __b,
                         __b, __b, __b, __b, __b, __b, __b, __b);
}
# 5093 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_epi64x(long long __q)
{
  return _mm256_set_epi64x(__q, __q, __q, __q);
}
# 5112 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setzero_pd(void)
{
  return __extension__ (__m256d){ 0, 0, 0, 0 };
}
# 5130 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setzero_ps(void)
{
  return __extension__ (__m256){ 0, 0, 0, 0, 0, 0, 0, 0 };
}
# 5147 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setzero_si256(void)
{
  return __extension__ (__m256i)(__v4di){ 0, 0, 0, 0 };
}
# 5170 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castpd_ps(__m256d __a)
{
  return (__m256)__a;
}
# 5192 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castpd_si256(__m256d __a)
{
  return (__m256i)__a;
}
# 5214 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castps_pd(__m256 __a)
{
  return (__m256d)__a;
}
# 5236 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castps_si256(__m256 __a)
{
  return (__m256i)__a;
}
# 5258 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castsi256_ps(__m256i __a)
{
  return (__m256)__a;
}
# 5280 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castsi256_pd(__m256i __a)
{
  return (__m256d)__a;
}
# 5302 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castpd256_pd128(__m256d __a)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__a, 0, 1);
}
# 5324 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castps256_ps128(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 0, 1, 2, 3);
}
# 5345 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castsi256_si128(__m256i __a)
{
  return __builtin_shufflevector((__v4di)__a, (__v4di)__a, 0, 1);
}
# 5368 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castpd128_pd256(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 1, -1, -1);
}
# 5391 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castps128_ps256(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 1, 2, 3, -1, -1, -1, -1);
}
# 5412 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castsi128_si256(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, (__v2di)__a, 0, 1, -1, -1);
}
# 5436 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_zextpd128_pd256(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)_mm_setzero_pd(), 0, 1, 2, 3);
}
# 5459 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_zextps128_ps256(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)_mm_setzero_ps(), 0, 1, 2, 3, 4, 5, 6, 7);
}
# 5482 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_zextsi128_si256(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, (__v2di)_mm_setzero_si128(), 0, 1, 2, 3);
}
# 5735 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_m128 (__m128 __hi, __m128 __lo)
{
  return (__m256) __builtin_shufflevector((__v4sf)__lo, (__v4sf)__hi, 0, 1, 2, 3, 4, 5, 6, 7);
}
# 5762 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_m128d (__m128d __hi, __m128d __lo)
{
  return (__m256d) __builtin_shufflevector((__v2df)__lo, (__v2df)__hi, 0, 1, 2, 3);
}
# 5788 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_m128i (__m128i __hi, __m128i __lo)
{
  return (__m256i) __builtin_shufflevector((__v2di)__lo, (__v2di)__hi, 0, 1, 2, 3);
}
# 5817 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_m128 (__m128 __lo, __m128 __hi)
{
  return _mm256_set_m128(__hi, __lo);
}
# 5846 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_m128d (__m128d __lo, __m128d __hi)
{
  return (__m256d)_mm256_set_m128d(__hi, __lo);
}
# 5873 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_m128i (__m128i __lo, __m128i __hi)
{
  return (__m256i)_mm256_set_m128i(__hi, __lo);
}
# 5907 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu2_m128(float const *__addr_hi, float const *__addr_lo)
{
  return _mm256_set_m128(_mm_loadu_ps(__addr_hi), _mm_loadu_ps(__addr_lo));
}
# 5940 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu2_m128d(double const *__addr_hi, double const *__addr_lo)
{
  return _mm256_set_m128d(_mm_loadu_pd(__addr_hi), _mm_loadu_pd(__addr_lo));
}
# 5970 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu2_m128i(__m128i_u const *__addr_hi, __m128i_u const *__addr_lo)
{
   return _mm256_set_m128i(_mm_loadu_si128(__addr_hi), _mm_loadu_si128(__addr_lo));
}
# 6000 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu2_m128(float *__addr_hi, float *__addr_lo, __m256 __a)
{
  __m128 __v128;

  __v128 = _mm256_castps256_ps128(__a);
  _mm_storeu_ps(__addr_lo, __v128);
  __v128 = ((__m128)__builtin_ia32_vextractf128_ps256((__v8sf)(__m256)(__a), (int)(1)));
  _mm_storeu_ps(__addr_hi, __v128);
}
# 6034 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu2_m128d(double *__addr_hi, double *__addr_lo, __m256d __a)
{
  __m128d __v128;

  __v128 = _mm256_castpd256_pd128(__a);
  _mm_storeu_pd(__addr_lo, __v128);
  __v128 = ((__m128d)__builtin_ia32_vextractf128_pd256((__v4df)(__m256d)(__a), (int)(1)));
  _mm_storeu_pd(__addr_hi, __v128);
}
# 6068 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu2_m128i(__m128i_u *__addr_hi, __m128i_u *__addr_lo, __m256i __a)
{
  __m128i __v128;

  __v128 = _mm256_castsi256_si128(__a);
  _mm_storeu_si128(__addr_lo, __v128);
  __v128 = ((__m128i)__builtin_ia32_vextractf128_si256((__v8si)(__m256i)(__a), (int)(1)));
  _mm_storeu_si128(__addr_hi, __v128);
}
# 67 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 76 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\f16cintrin.h" 1 3 4
# 43 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\f16cintrin.h" 3 4
static inline float __attribute__((__always_inline__, __nodebug__, __target__("f16c"), __min_vector_width__(128)))
_cvtsh_ss(unsigned short __a)
{
  __v8hi __v = {(short)__a, 0, 0, 0, 0, 0, 0, 0};
  __v4sf __r = __builtin_ia32_vcvtph2ps(__v);
  return __r[0];
}
# 131 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\f16cintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("f16c"), __min_vector_width__(128)))
_mm_cvtph_ps(__m128i __a)
{
  return (__m128)__builtin_ia32_vcvtph2ps((__v8hi)__a);
}
# 186 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\f16cintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("f16c"), __min_vector_width__(256)))
_mm256_cvtph_ps(__m128i __a)
{
  return (__m256)__builtin_ia32_vcvtph2ps256((__v8hi)__a);
}
# 77 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 1 3 4
# 56 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__))
__tzcnt_u16(unsigned short __X)
{
  return __builtin_ia32_tzcnt_u16(__X);
}
# 78 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
__tzcnt_u32(unsigned int __X)
{
  return __builtin_ia32_tzcnt_u32(__X);
}
# 100 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_tzcnt_32(unsigned int __X)
{
  return (int)__builtin_ia32_tzcnt_u32(__X);
}
# 126 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__tzcnt_u64(unsigned long long __X)
{
  return __builtin_ia32_tzcnt_u64(__X);
}
# 148 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_tzcnt_64(unsigned long long __X)
{
  return (long long)__builtin_ia32_tzcnt_u64(__X);
}
# 194 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__andn_u32(unsigned int __X, unsigned int __Y)
{
  return ~__X & __Y;
}
# 223 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__bextr_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bextr_u32(__X, __Y);
}
# 255 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr_u32(unsigned int __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u32 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}
# 284 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr2_u32(unsigned int __X, unsigned int __Y) {
  return __builtin_ia32_bextr_u32(__X, __Y);
}
# 305 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsi_u32(unsigned int __X)
{
  return __X & -__X;
}
# 327 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsmsk_u32(unsigned int __X)
{
  return __X ^ (__X - 1);
}
# 349 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsr_u32(unsigned int __X)
{
  return __X & (__X - 1);
}
# 390 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__andn_u64 (unsigned long long __X, unsigned long long __Y)
{
  return ~__X & __Y;
}
# 419 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__bextr_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bextr_u64(__X, __Y);
}
# 451 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr_u64(unsigned long long __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u64 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}
# 480 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr2_u64(unsigned long long __X, unsigned long long __Y) {
  return __builtin_ia32_bextr_u64(__X, __Y);
}
# 501 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsi_u64(unsigned long long __X)
{
  return __X & -__X;
}
# 523 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsmsk_u64(unsigned long long __X)
{
  return __X ^ (__X - 1);
}
# 545 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsr_u64(unsigned long long __X)
{
  return __X & (__X - 1);
}
# 81 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\lzcntintrin.h" 1 3 4
# 59 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\lzcntintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
__lzcnt32(unsigned int __X)
{
  return __builtin_ia32_lzcnt_u32(__X);
}
# 81 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\lzcntintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
_lzcnt_u32(unsigned int __X)
{
  return __builtin_ia32_lzcnt_u32(__X);
}
# 128 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\lzcntintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
_lzcnt_u64(unsigned long long __X)
{
  return __builtin_ia32_lzcnt_u64(__X);
}
# 90 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 366 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ short __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_loadbe_i16(void const * __P) {
  struct __loadu_i16 {
    unsigned short __v;
  } __attribute__((__packed__, __may_alias__));
  return (short)__builtin_bswap16(((const struct __loadu_i16*)__P)->__v);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_storebe_i16(void * __P, short __D) {
  struct __storeu_i16 {
    unsigned short __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_i16*)__P)->__v = __builtin_bswap16((unsigned short)__D);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_loadbe_i32(void const * __P) {
  struct __loadu_i32 {
    unsigned int __v;
  } __attribute__((__packed__, __may_alias__));
  return (int)__builtin_bswap32(((const struct __loadu_i32*)__P)->__v);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_storebe_i32(void * __P, int __D) {
  struct __storeu_i32 {
    unsigned int __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_i32*)__P)->__v = __builtin_bswap32((unsigned int)__D);
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_loadbe_i64(void const * __P) {
  struct __loadu_i64 {
    unsigned long long __v;
  } __attribute__((__packed__, __may_alias__));
  return (long long)__builtin_bswap64(((const struct __loadu_i64*)__P)->__v);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_storebe_i64(void * __P, long long __D) {
  struct __storeu_i64 {
    unsigned long long __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_i64*)__P)->__v = __builtin_bswap64((unsigned long long)__D);
}
# 430 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 1 3 4
# 32 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave(void *__p)
{
  __builtin_ia32_fxsave(__p);
}
# 53 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor(void *__p)
{
  __builtin_ia32_fxrstor(__p);
}
# 73 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave64(void *__p)
{
  __builtin_ia32_fxsave64(__p);
}
# 94 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor64(void *__p)
{
  __builtin_ia32_fxrstor64(__p);
}
# 431 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xsaveintrin.h" 1 3 4
# 24 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xsaveintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave(void *__p, unsigned long long __m) {
  __builtin_ia32_xsave(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstor(__p, __m);
}
# 49 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xsaveintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsave64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor64(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstor64(__p, __m);
}
# 435 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xsaveoptintrin.h" 1 3 4
# 20 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\xsaveoptintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaveopt")))
_xsaveopt(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaveopt(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaveopt")))
_xsaveopt64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaveopt64(__p, __m);
}
# 439 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 458 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\adxintrin.h" 1 3 4
# 21 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\adxintrin.h" 3 4
static inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
               unsigned int *__p)
{
  return __builtin_ia32_addcarryx_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarryx_u64(__cf, __x, __y, __p);
}



static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_addcarryx_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u64(unsigned char __cf, unsigned long long __x,
              unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarryx_u64(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_subborrow_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_subborrow_u64(__cf, __x, __y, __p);
}
# 459 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4








# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\prfchwintrin.h" 1 3 4
# 31 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\prfchwintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_m_prefetch(void *__P)
{
  __builtin_prefetch (__P, 0, 3 );
}
# 52 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\prfchwintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_m_prefetchw(volatile const void *__P)
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wcast-qual"
  __builtin_prefetch ((const void*)__P, 1, 3 );
#pragma clang diagnostic pop
}
# 25 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ammintrin.h" 1 3 4
# 82 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ammintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4a"), __min_vector_width__(128)))
_mm_extract_si64(__m128i __x, __m128i __y)
{
  return (__m128i)__builtin_ia32_extrq((__v2di)__x, (__v16qi)__y);
}
# 166 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ammintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4a"), __min_vector_width__(128)))
_mm_insert_si64(__m128i __x, __m128i __y)
{
  return (__m128i)__builtin_ia32_insertq((__v2di)__x, (__v2di)__y);
}
# 188 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ammintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse4a"), __min_vector_width__(128)))
_mm_stream_sd(double *__p, __m128d __a)
{
  __builtin_ia32_movntsd(__p, (__v2df)__a);
}
# 210 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\ammintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse4a"), __min_vector_width__(128)))
_mm_stream_ss(float *__p, __m128 __a)
{
  __builtin_ia32_movntss(__p, (__v4sf)__a);
}
# 30 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_orbis.h" 2 3


static inline
void sceAtomicMemoryBarrier(void)
{
 _mm_mfence();
}



static inline
int32_t sceAtomicAdd32Relaxed(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_add(ptr, value, 0);
}

static inline
int32_t sceAtomicIncrement32Relaxed(volatile int32_t* ptr)
{
 return sceAtomicAdd32Relaxed(ptr, 1);
}

static inline
int32_t sceAtomicDecrement32Relaxed(volatile int32_t* ptr)
{
 return sceAtomicAdd32Relaxed(ptr, -1);
}

static inline
int32_t sceAtomicCompareAndSwap32Relaxed(volatile int32_t* ptr, int32_t compare, int32_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
int32_t sceAtomicOr32Relaxed(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_or(ptr, value, 0);
}

static inline
int32_t sceAtomicAnd32Relaxed(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_and(ptr, value, 0);
}

static inline
int32_t sceAtomicExchange32Relaxed(volatile int32_t* ptr, int32_t swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
void sceAtomicStore32Relaxed(volatile int32_t* ptr, int32_t value)
{
 sceAtomicExchange32Relaxed(ptr, value);
}

static inline
int32_t sceAtomicLoad32Relaxed(const volatile int32_t* ptr)
{
 return __atomic_load_n(ptr, 0);
}



static inline
int64_t sceAtomicAdd64Relaxed(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_add(ptr, value, 0);
}

static inline
int64_t sceAtomicIncrement64Relaxed(volatile int64_t* ptr)
{
 return sceAtomicAdd64Relaxed(ptr, 1);
}

static inline
int64_t sceAtomicDecrement64Relaxed(volatile int64_t* ptr)
{
 return sceAtomicAdd64Relaxed(ptr, -1);
}

static inline
int64_t sceAtomicCompareAndSwap64Relaxed(volatile int64_t* ptr, int64_t compare, int64_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
int64_t sceAtomicOr64Relaxed(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_or(ptr, value, 0);
}
static inline
int64_t sceAtomicAnd64Relaxed(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_and(ptr, value, 0);
}
static inline
int64_t sceAtomicExchange64Relaxed(volatile int64_t* ptr, int64_t swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
void sceAtomicStore64Relaxed(volatile int64_t* ptr, int64_t value)
{
 sceAtomicExchange64Relaxed(ptr, value);
}

static inline
int64_t sceAtomicLoad64Relaxed(const volatile int64_t* ptr)
{
 return __atomic_load_n(ptr, 0);
}



static inline
int16_t sceAtomicAdd16Relaxed(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_add(ptr, value, 0);
}

static inline
int16_t sceAtomicIncrement16Relaxed(volatile int16_t* ptr)
{
 return sceAtomicAdd16Relaxed(ptr, 1);
}

static inline
int16_t sceAtomicDecrement16Relaxed(volatile int16_t* ptr)
{
 return sceAtomicAdd16Relaxed(ptr, -1);
}

static inline
int16_t sceAtomicCompareAndSwap16Relaxed(volatile int16_t* ptr, int16_t compare, int16_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
int16_t sceAtomicOr16Relaxed(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_or(ptr, value, 0);
}

static inline
int16_t sceAtomicAnd16Relaxed(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_and(ptr, value, 0);
}

static inline
int16_t sceAtomicExchange16Relaxed(volatile int16_t* ptr, int16_t swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
void sceAtomicStore16Relaxed(volatile int16_t* ptr, int16_t value)
{
 sceAtomicExchange16Relaxed(ptr, value);
}

static inline
int16_t sceAtomicLoad16Relaxed(const volatile int16_t* ptr)
{
 return __atomic_load_n(ptr, 0);
}



static inline
int8_t sceAtomicCompareAndSwap8Relaxed(volatile int8_t* ptr, int8_t compare, int8_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
int8_t sceAtomicAdd8Relaxed(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_add(ptr, value, 0);
}

static inline
int8_t sceAtomicIncrement8Relaxed(volatile int8_t* ptr)
{
 return sceAtomicAdd8Relaxed(ptr, 1);
}

static inline
int8_t sceAtomicDecrement8Relaxed(volatile int8_t* ptr)
{
 return sceAtomicAdd8Relaxed(ptr, -1);
}

static inline
int8_t sceAtomicOr8Relaxed(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_or(ptr, value, 0);
}
static inline
int8_t sceAtomicAnd8Relaxed(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_and(ptr, value, 0);
}
static inline
int8_t sceAtomicExchange8Relaxed(volatile int8_t* ptr, int8_t swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
void sceAtomicStore8Relaxed(volatile int8_t* ptr, int8_t value)
{
 sceAtomicExchange8Relaxed(ptr, value);
}

static inline
int8_t sceAtomicLoad8Relaxed(const volatile int8_t* ptr)
{
 return __atomic_load_n(ptr, 0);
}



static inline
__int128 sceAtomicCompareAndSwap128Relaxed(volatile __int128* ptr, __int128 compare, __int128 swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
__int128 sceAtomicAdd128Relaxed(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Relaxed(ptr, oldval, oldval + value));
 return oldval;
}

static inline
__int128 sceAtomicIncrement128Relaxed(volatile __int128* ptr)
{
 return sceAtomicAdd128Relaxed(ptr, 1);
}

static inline
__int128 sceAtomicDecrement128Relaxed(volatile __int128* ptr)
{
 return sceAtomicAdd128Relaxed(ptr, -1);
}

static inline
__int128 sceAtomicOr128Relaxed(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Relaxed(ptr, oldval, oldval | value));
 return oldval;
}

static inline
__int128 sceAtomicAnd128Relaxed(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Relaxed(ptr, oldval, oldval & value));
 return oldval;
}

static inline
__int128 sceAtomicExchange128Relaxed(volatile __int128* ptr, __int128 swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
bool sceAtomicCompareAndSwap128ByPointerRelaxed(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{
 __int128 c = *(__int128_t*)compare;
 __int128 old = sceAtomicCompareAndSwap128Relaxed((volatile __int128_t*)ptr, c, *(__int128_t*)swap);
 __int128 *o =(__int128 *)oldvalue;
 *o = old;
 return old == c;
}

static inline
bool sceAtomicCompareAndSwap128_64Relaxed(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{
 __int128 c = (((__int128)compareHigh) << 64) | (((__int128)compareLow) & 0xffffffffffffffff);
 __int128 s = (((__int128)swapHigh) << 64) | (((__int128)swapLow) & 0xffffffffffffffff);
 __int128 old = sceAtomicCompareAndSwap128Relaxed((volatile __int128_t*)(intptr_t)ptr, c, s);
 oldvalue[0] = (int64_t)(0xffffffffffffffff & old);
 oldvalue[1] = (int64_t)(0xffffffffffffffff & (old >> 64));
 return old == c;
}

static inline
void sceAtomicStore128Relaxed(volatile __int128* ptr, __int128 value)
{
 __atomic_store_n(ptr, value, 0);
}

static inline
__int128 sceAtomicLoad128Relaxed(const volatile __int128* ptr)
{
 return __atomic_load_n(ptr, 0);
}

static inline
void sceAtomicStore128_64Relaxed(volatile int64_t* ptr, const int64_t *source)
{
 __int128 s = (((__int128)source[1]) << 64) | (((__int128)source[0]) & 0xffffffffffffffff);
 sceAtomicStore128Relaxed((volatile __int128* )(intptr_t)ptr, s);
}

static inline
void sceAtomicLoad128_64Relaxed(const volatile int64_t* ptr, int64_t *destination)
{
 __int128 val = sceAtomicLoad128Relaxed((const volatile __int128* )(intptr_t)ptr);
 destination[0] = (int64_t)(0xffffffffffffffff & val);
 destination[1] = (int64_t)(0xffffffffffffffff & (val >> 64));
}

static inline
void* sceAtomicExchangePointerRelaxed(volatile void** ptr, void* swap)
{
 return (void*)(intptr_t)sceAtomicExchange64Relaxed((volatile int64_t*)(intptr_t)ptr, (int64_t)swap);
}
# 371 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_orbis.h" 3
static inline int8_t sceAtomicAdd8Acquire(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int8_t sceAtomicOr8Acquire(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int8_t sceAtomicAnd8Acquire(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int8_t sceAtomicIncrement8Acquire(volatile int8_t* ptr)
{
 return sceAtomicAdd8Acquire(ptr, 1);
}

static inline int8_t sceAtomicDecrement8Acquire(volatile int8_t* ptr)
{
 return sceAtomicAdd8Acquire(ptr, -1);
}

static inline int8_t sceAtomicCompareAndSwap8Acquire(volatile int8_t* ptr, int8_t compare, int8_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int8_t sceAtomicExchange8Acquire(volatile int8_t* ptr, int8_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore8Acquire(volatile int8_t* ptr, int8_t value)
{
 sceAtomicExchange8Acquire(ptr, value);
}

static inline
int8_t sceAtomicLoad8Acquire(const volatile int8_t* ptr)
{
 int8_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int16_t sceAtomicAdd16Acquire(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int16_t sceAtomicOr16Acquire(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int16_t sceAtomicAnd16Acquire(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int16_t sceAtomicIncrement16Acquire(volatile int16_t* ptr)
{
 return sceAtomicAdd16Acquire(ptr, 1);
}

static inline int16_t sceAtomicDecrement16Acquire(volatile int16_t* ptr)
{
 return sceAtomicAdd16Acquire(ptr, -1);
}

static inline int16_t sceAtomicCompareAndSwap16Acquire(volatile int16_t* ptr, int16_t compare, int16_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int16_t sceAtomicExchange16Acquire(volatile int16_t* ptr, int16_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore16Acquire(volatile int16_t* ptr, int16_t value)
{
 sceAtomicExchange16Acquire(ptr, value);
}

static inline
int16_t sceAtomicLoad16Acquire(const volatile int16_t* ptr)
{
 int16_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int32_t sceAtomicAdd32Acquire(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int32_t sceAtomicOr32Acquire(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int32_t sceAtomicAnd32Acquire(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int32_t sceAtomicIncrement32Acquire(volatile int32_t* ptr)
{
 return sceAtomicAdd32Acquire(ptr, 1);
}

static inline int32_t sceAtomicDecrement32Acquire(volatile int32_t* ptr)
{
 return sceAtomicAdd32Acquire(ptr, -1);
}

static inline int32_t sceAtomicCompareAndSwap32Acquire(volatile int32_t* ptr, int32_t compare, int32_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int32_t sceAtomicExchange32Acquire(volatile int32_t* ptr, int32_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore32Acquire(volatile int32_t* ptr, int32_t value)
{
 sceAtomicExchange32Acquire(ptr, value);
}

static inline
int32_t sceAtomicLoad32Acquire(const volatile int32_t* ptr)
{
 int32_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
int64_t sceAtomicAdd64Acquire(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int64_t sceAtomicOr64Acquire(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int64_t sceAtomicAnd64Acquire(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int64_t sceAtomicIncrement64Acquire(volatile int64_t* ptr)
{
 return sceAtomicAdd64Acquire(ptr, 1);
}

static inline int64_t sceAtomicDecrement64Acquire(volatile int64_t* ptr)
{
 return sceAtomicAdd64Acquire(ptr, -1);
}

static inline int64_t sceAtomicCompareAndSwap64Acquire(volatile int64_t* ptr, int64_t compare, int64_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int64_t sceAtomicExchange64Acquire(volatile int64_t* ptr, int64_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore64Acquire(volatile int64_t* ptr, int64_t value)
{
 sceAtomicExchange64Acquire(ptr, value);
}

static inline
int64_t sceAtomicLoad64Acquire(const volatile int64_t* ptr)
{
 int64_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
__int128 sceAtomicCompareAndSwap128Acquire(volatile __int128* ptr, __int128 compare, __int128 swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline
__int128 sceAtomicAdd128Acquire(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Acquire(ptr, oldval, oldval + value));
 return oldval;
}

static inline
__int128 sceAtomicIncrement128Acquire(volatile __int128* ptr)
{
 return sceAtomicAdd128Acquire(ptr, 1);
}

static inline
__int128 sceAtomicDecrement128Acquire(volatile __int128* ptr)
{
 return sceAtomicAdd128Acquire(ptr, -1);
}

static inline
__int128 sceAtomicOr128Acquire(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Acquire(ptr, oldval, oldval | value));
 return oldval;
}

static inline
__int128 sceAtomicAnd128Acquire(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Acquire(ptr, oldval, oldval & value));
 return oldval;
}

static inline
__int128 sceAtomicExchange128Acquire(volatile __int128* ptr, __int128 swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
bool sceAtomicCompareAndSwap128ByPointerAcquire(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{
 __int128 c = *(__int128_t*)compare;
 __int128 old = sceAtomicCompareAndSwap128Acquire((volatile __int128_t*)ptr, c, *(__int128_t*)swap);
 __int128 *o =(__int128 *)oldvalue;
 *o = old;
 return old == c;
}

static inline
bool sceAtomicCompareAndSwap128_64Acquire(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{
 __int128 c = (((__int128)compareHigh) << 64) | (((__int128)compareLow) & 0xffffffffffffffff);
 __int128 s = (((__int128)swapHigh) << 64) | (((__int128)swapLow) & 0xffffffffffffffff);
 __int128 old = sceAtomicCompareAndSwap128Acquire((volatile __int128_t*)(intptr_t)ptr, c, s);
 oldvalue[0] = (int64_t)(0xffffffffffffffff & old);
 oldvalue[1] = (int64_t)(0xffffffffffffffff & (old >> 64));
 return old == c;
}

static inline
void sceAtomicStore128Acquire(volatile __int128* ptr, __int128 value)
{
 __atomic_store_n(ptr, value, 5);
}

static inline
__int128 sceAtomicLoad128Acquire(const volatile __int128* ptr)
{
 __int128 ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
void sceAtomicStore128_64Acquire(volatile int64_t* ptr, const int64_t *source)
{
 __int128 s = (((__int128)source[1]) << 64) | (((__int128)source[0]) & 0xffffffffffffffff);
 sceAtomicStore128Acquire((volatile __int128* )(intptr_t)ptr, s);
}

static inline
void sceAtomicLoad128_64Acquire(const volatile int64_t* ptr, int64_t *destination)
{
 __int128 val = sceAtomicLoad128Acquire((const volatile __int128* )(intptr_t)ptr);
 destination[0] = (int64_t)(0xffffffffffffffff & val);
 destination[1] = (int64_t)(0xffffffffffffffff & (val >> 64));
 sceAtomicMemoryBarrier();
}

static inline
void* sceAtomicExchangePointerAcquire(volatile void** ptr, void* swap)
{
   return (void*)(intptr_t)sceAtomicExchange64Acquire((volatile int64_t*)(intptr_t)ptr, (int64_t)swap);
}
# 695 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_orbis.h" 3
static inline
int8_t sceAtomicAdd8Release(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline
int8_t sceAtomicOr8Release(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline
int8_t sceAtomicAnd8Release(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline
int8_t sceAtomicIncrement8Release(volatile int8_t* ptr)
{
 return sceAtomicAdd8Release(ptr, 1);
}

static inline
int8_t sceAtomicDecrement8Release(volatile int8_t* ptr)
{
 return sceAtomicAdd8Release(ptr, -1);
}

static inline
int8_t sceAtomicCompareAndSwap8Release(volatile int8_t* ptr, int8_t compare, int8_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline
int8_t sceAtomicExchange8Release(volatile int8_t* ptr, int8_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore8Release(volatile int8_t* ptr, int8_t value)
{
 sceAtomicExchange8Release(ptr, value);
}

static inline
int8_t sceAtomicLoad8Release(const volatile int8_t* ptr)
{
 sceAtomicMemoryBarrier();
 return __atomic_load_n(ptr, 5);
}

static inline int16_t sceAtomicAdd16Release(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int16_t sceAtomicOr16Release(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int16_t sceAtomicAnd16Release(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int16_t sceAtomicIncrement16Release(volatile int16_t* ptr)
{
 return sceAtomicAdd16Release(ptr, 1);
}

static inline int16_t sceAtomicDecrement16Release(volatile int16_t* ptr)
{
 return sceAtomicAdd16Release(ptr, -1);
}

static inline int16_t sceAtomicCompareAndSwap16Release(volatile int16_t* ptr, int16_t compare, int16_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int16_t sceAtomicExchange16Release(volatile int16_t* ptr, int16_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore16Release(volatile int16_t* ptr, int16_t value)
{
 sceAtomicExchange16Release(ptr, value);
}

static inline
int16_t sceAtomicLoad16Release(const volatile int16_t* ptr)
{
 sceAtomicMemoryBarrier();
 return __atomic_load_n(ptr, 5);
}

static inline int32_t sceAtomicAdd32Release(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int32_t sceAtomicOr32Release(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int32_t sceAtomicAnd32Release(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int32_t sceAtomicIncrement32Release(volatile int32_t* ptr)
{
 return sceAtomicAdd32Release(ptr, 1);
}

static inline int32_t sceAtomicDecrement32Release(volatile int32_t* ptr)
{
 return sceAtomicAdd32Release(ptr, -1);
}

static inline int32_t sceAtomicCompareAndSwap32Release(volatile int32_t* ptr, int32_t compare, int32_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int32_t sceAtomicExchange32Release(volatile int32_t* ptr, int32_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore32Release(volatile int32_t* ptr, int32_t value)
{
 sceAtomicExchange32Release(ptr, value);
}

static inline
int32_t sceAtomicLoad32Release(const volatile int32_t* ptr)
{
 sceAtomicMemoryBarrier();
 return __atomic_load_n(ptr, 5);
}

static inline int64_t sceAtomicAdd64Release(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int64_t sceAtomicOr64Release(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int64_t sceAtomicAnd64Release(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int64_t sceAtomicIncrement64Release(volatile int64_t* ptr)
{
 return sceAtomicAdd64Release(ptr, 1);
}

static inline int64_t sceAtomicDecrement64Release(volatile int64_t* ptr)
{
 return sceAtomicAdd64Release(ptr, -1);
}

static inline int64_t sceAtomicCompareAndSwap64Release(volatile int64_t* ptr, int64_t compare, int64_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int64_t sceAtomicExchange64Release(volatile int64_t* ptr, int64_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore64Release(volatile int64_t* ptr, int64_t value)
{
 sceAtomicExchange64Release(ptr, value);
}

static inline
int64_t sceAtomicLoad64Release(const volatile int64_t* ptr)
{
 sceAtomicMemoryBarrier();
 return __atomic_load_n(ptr, 5);
}

static inline
__int128 sceAtomicCompareAndSwap128Release(volatile __int128* ptr, __int128 compare, __int128 swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline
__int128 sceAtomicAdd128Release(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Release(ptr, oldval, oldval + value));
 return oldval;
}

static inline
__int128 sceAtomicIncrement128Release(volatile __int128* ptr)
{
 return sceAtomicAdd128Release(ptr, 1);
}

static inline
__int128 sceAtomicDecrement128Release(volatile __int128* ptr)
{
 return sceAtomicAdd128Release(ptr, -1);
}

static inline
__int128 sceAtomicOr128Release(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Release(ptr, oldval, oldval | value));
 return oldval;
}

static inline
__int128 sceAtomicAnd128Release(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Release(ptr, oldval, oldval & value));
 return oldval;
}

static inline
__int128 sceAtomicExchange128Release(volatile __int128* ptr, __int128 swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
bool sceAtomicCompareAndSwap128ByPointerRelease(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{
 __int128 c = *(__int128_t*)compare;
 __int128 old = sceAtomicCompareAndSwap128Release((volatile __int128_t*)ptr, c, *(__int128_t*)swap);
 __int128 *o =(__int128 *)oldvalue;
 *o = old;
 return old == c;
}

static inline
bool sceAtomicCompareAndSwap128_64Release(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{
 __int128 c = (((__int128)compareHigh) << 64) | (((__int128)compareLow) & 0xffffffffffffffff);
 __int128 s = (((__int128)swapHigh) << 64) | (((__int128)swapLow) & 0xffffffffffffffff);
 __int128 old = sceAtomicCompareAndSwap128Release((volatile __int128_t*)(intptr_t)ptr, c, s);
 oldvalue[0] = (int64_t)(0xffffffffffffffff & old);
 oldvalue[1] = (int64_t)(0xffffffffffffffff & (old >> 64));
 return old == c;
}

static inline
void sceAtomicStore128Release(volatile __int128* ptr, __int128 value)
{
 __atomic_store_n(ptr, value, 5);
}

static inline
__int128 sceAtomicLoad128Release(const volatile __int128* ptr)
{
 sceAtomicMemoryBarrier();
 __int128 ret = __atomic_load_n(ptr, 5);
 return ret;
}

static inline
void sceAtomicStore128_64Release(volatile int64_t* ptr, const int64_t *source)
{
 __int128 s = (((__int128)source[1]) << 64) | (((__int128)source[0]) & 0xffffffffffffffff);
 sceAtomicStore128Release((volatile __int128* )(intptr_t)ptr, s);
}

static inline
void sceAtomicLoad128_64Release(const volatile int64_t* ptr, int64_t *destination)
{
 sceAtomicMemoryBarrier();
 __int128 val = sceAtomicLoad128Release((const volatile __int128* )(intptr_t)ptr);
 destination[0] = (int64_t)(0xffffffffffffffff & val);
 destination[1] = (int64_t)(0xffffffffffffffff & (val >> 64));
}

static inline
void* sceAtomicExchangePointerRelease(volatile void** ptr, void* swap)
{
 return (void*)(intptr_t)sceAtomicExchange64Release((volatile int64_t*)(intptr_t)ptr, (int64_t)swap);
}
# 1020 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_orbis.h" 3
static inline int8_t sceAtomicAdd8AcqRel(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int8_t sceAtomicOr8AcqRel(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int8_t sceAtomicAnd8AcqRel(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int8_t sceAtomicIncrement8AcqRel(volatile int8_t* ptr)
{
 return sceAtomicAdd8AcqRel(ptr, 1);
}

static inline int8_t sceAtomicDecrement8AcqRel(volatile int8_t* ptr)
{
 return sceAtomicAdd8AcqRel(ptr, -1);
}

static inline int8_t sceAtomicCompareAndSwap8AcqRel(volatile int8_t* ptr, int8_t compare, int8_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int8_t sceAtomicExchange8AcqRel(volatile int8_t* ptr, int8_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore8AcqRel(volatile int8_t* ptr, int8_t value)
{
 sceAtomicExchange8AcqRel(ptr, value);
}

static inline
int8_t sceAtomicLoad8AcqRel(const volatile int8_t* ptr)
{
 sceAtomicMemoryBarrier();
 int8_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int16_t sceAtomicAdd16AcqRel(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int16_t sceAtomicOr16AcqRel(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int16_t sceAtomicAnd16AcqRel(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int16_t sceAtomicIncrement16AcqRel(volatile int16_t* ptr)
{
 return sceAtomicAdd16AcqRel(ptr, 1);
}

static inline int16_t sceAtomicDecrement16AcqRel(volatile int16_t* ptr)
{
 return sceAtomicAdd16AcqRel(ptr, -1);
}

static inline int16_t sceAtomicCompareAndSwap16AcqRel(volatile int16_t* ptr, int16_t compare, int16_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int16_t sceAtomicExchange16AcqRel(volatile int16_t* ptr, int16_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore16AcqRel(volatile int16_t* ptr, int16_t value)
{
 sceAtomicExchange16AcqRel(ptr, value);
}

static inline
int16_t sceAtomicLoad16AcqRel(const volatile int16_t* ptr)
{
 sceAtomicMemoryBarrier();
 int16_t ret = sceAtomicLoad16Relaxed(ptr);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int32_t sceAtomicAdd32AcqRel(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int32_t sceAtomicOr32AcqRel(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int32_t sceAtomicAnd32AcqRel(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int32_t sceAtomicIncrement32AcqRel(volatile int32_t* ptr)
{
 return sceAtomicAdd32AcqRel(ptr, 1);
}

static inline int32_t sceAtomicDecrement32AcqRel(volatile int32_t* ptr)
{
 return sceAtomicAdd32AcqRel(ptr, -1);
}

static inline int32_t sceAtomicCompareAndSwap32AcqRel(volatile int32_t* ptr, int32_t compare, int32_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int32_t sceAtomicExchange32AcqRel(volatile int32_t* ptr, int32_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore32AcqRel(volatile int32_t* ptr, int32_t value)
{
 sceAtomicExchange32AcqRel(ptr, value);
}

static inline
int32_t sceAtomicLoad32AcqRel(const volatile int32_t* ptr)
{
 sceAtomicMemoryBarrier();
 int32_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int64_t sceAtomicAdd64AcqRel(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int64_t sceAtomicOr64AcqRel(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int64_t sceAtomicAnd64AcqRel(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int64_t sceAtomicIncrement64AcqRel(volatile int64_t* ptr)
{
 return sceAtomicAdd64AcqRel(ptr, 1);
}

static inline int64_t sceAtomicDecrement64AcqRel(volatile int64_t* ptr)
{
 return sceAtomicAdd64AcqRel(ptr, -1);
}

static inline int64_t sceAtomicCompareAndSwap64AcqRel(volatile int64_t* ptr, int64_t compare, int64_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int64_t sceAtomicExchange64AcqRel(volatile int64_t* ptr, int64_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore64AcqRel(volatile int64_t* ptr, int64_t value)
{
 sceAtomicExchange64AcqRel(ptr, value);
}

static inline
int64_t sceAtomicLoad64AcqRel(const volatile int64_t* ptr)
{
 sceAtomicMemoryBarrier();
 int64_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
__int128 sceAtomicCompareAndSwap128AcqRel(volatile __int128* ptr, __int128 compare, __int128 swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline
__int128 sceAtomicAdd128AcqRel(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128AcqRel(ptr, oldval, oldval + value));
 return oldval;
}

static inline
__int128 sceAtomicIncrement128AcqRel(volatile __int128* ptr)
{
 return sceAtomicAdd128AcqRel(ptr, 1);
}

static inline
__int128 sceAtomicDecrement128AcqRel(volatile __int128* ptr)
{
 return sceAtomicAdd128AcqRel(ptr, -1);
}


static inline
__int128 sceAtomicOr128AcqRel(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128AcqRel(ptr, oldval, oldval | value));
 return oldval;
}

static inline
__int128 sceAtomicAnd128AcqRel(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128AcqRel(ptr, oldval, oldval & value));
 return oldval;
}

static inline
__int128 sceAtomicExchange128AcqRel(volatile __int128* ptr, __int128 swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
bool sceAtomicCompareAndSwap128ByPointerAcqRel(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{
 __int128 c = *(__int128_t*)compare;
 __int128 old = sceAtomicCompareAndSwap128AcqRel((volatile __int128_t*)ptr, c, *(__int128_t*)swap);
 __int128 *o =(__int128 *)oldvalue;
 *o = old;
 return old == c;
}

static inline
bool sceAtomicCompareAndSwap128_64AcqRel(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{
 __int128 c = (((__int128)compareHigh) << 64) | (((__int128)compareLow) & 0xffffffffffffffff);
 __int128 s = (((__int128)swapHigh) << 64) | (((__int128)swapLow) & 0xffffffffffffffff);
 __int128 old = sceAtomicCompareAndSwap128AcqRel((volatile __int128_t*)(intptr_t)ptr, c, s);
 oldvalue[0] = (int64_t)(0xffffffffffffffff & old);
 oldvalue[1] = (int64_t)(0xffffffffffffffff & (old >> 64));
 return old == c;
}

static inline
void sceAtomicStore128AcqRel(volatile __int128* ptr, __int128 value)
{
 __atomic_store_n(ptr, value, 5);
}

static inline
__int128 sceAtomicLoad128AcqRel(const volatile __int128* ptr)
{
 sceAtomicMemoryBarrier();
 __int128 ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
void sceAtomicStore128_64AcqRel(volatile int64_t* ptr, const int64_t *source)
{
 __int128 s = (((__int128)source[1]) << 64) | (((__int128)source[0]) & 0xffffffffffffffff);
 sceAtomicStore128AcqRel((volatile __int128* )(intptr_t)ptr, s);
}

static inline
void sceAtomicLoad128_64AcqRel(const volatile int64_t* ptr, int64_t *destination)
{
 sceAtomicMemoryBarrier();
 __int128 val = sceAtomicLoad128AcqRel((const volatile __int128* )(intptr_t)ptr);
 destination[0] = (int64_t)(0xffffffffffffffff & val);
 destination[1] = (int64_t)(0xffffffffffffffff & (val >> 64));
 sceAtomicMemoryBarrier();
}

static inline
void* sceAtomicExchangePointerAcqRel(volatile void** ptr, void* swap)
{
     return (void*)(intptr_t)sceAtomicExchange64AcqRel((volatile int64_t*)(intptr_t)ptr, (int64_t)swap);
}
# 1350 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_orbis.h" 3
static inline int8_t sceAtomicAdd8(volatile int8_t* ptr, int8_t value)
{



 return sceAtomicAdd8Relaxed(ptr, value);

}

static inline int8_t sceAtomicOr8(volatile int8_t* ptr, int8_t value)
{



 return sceAtomicOr8Relaxed(ptr, value);

}

static inline int8_t sceAtomicAnd8(volatile int8_t* ptr, int8_t value)
{



 return sceAtomicAnd8Relaxed(ptr, value);

}

static inline int8_t sceAtomicIncrement8(volatile int8_t* ptr)
{



 return sceAtomicIncrement8Relaxed(ptr);

}

static inline int8_t sceAtomicDecrement8(volatile int8_t* ptr)
{



 return sceAtomicDecrement8Relaxed(ptr);

}

static inline int8_t sceAtomicCompareAndSwap8(volatile int8_t* ptr, int8_t compare, int8_t swap)
{



 return sceAtomicCompareAndSwap8Relaxed(ptr, compare, swap);

}

static inline int8_t sceAtomicExchange8(volatile int8_t* ptr, int8_t swap)
{



 return sceAtomicExchange8Relaxed(ptr, swap);

}

static inline
void sceAtomicStore8(volatile int8_t* ptr, int8_t value)
{



 sceAtomicStore8Relaxed(ptr, value);

}

static inline
int8_t sceAtomicLoad8(const volatile int8_t* ptr)
{



 return sceAtomicLoad8Relaxed(ptr);

}

static inline int16_t sceAtomicAdd16(volatile int16_t* ptr, int16_t value)
{



 return sceAtomicAdd16Relaxed(ptr, value);

}

static inline int16_t sceAtomicOr16(volatile int16_t* ptr, int16_t value)
{



 return sceAtomicOr16Relaxed(ptr, value);

}

static inline int16_t sceAtomicAnd16(volatile int16_t* ptr, int16_t value)
{



 return sceAtomicAnd16Relaxed(ptr, value);

}

static inline int16_t sceAtomicIncrement16(volatile int16_t* ptr)
{



 return sceAtomicIncrement16Relaxed(ptr);

}

static inline int16_t sceAtomicDecrement16(volatile int16_t* ptr)
{



 return sceAtomicDecrement16Relaxed(ptr);

}

static inline int16_t sceAtomicCompareAndSwap16(volatile int16_t* ptr, int16_t compare, int16_t swap)
{



 return sceAtomicCompareAndSwap16Relaxed(ptr, compare, swap);

}

static inline int16_t sceAtomicExchange16(volatile int16_t* ptr, int16_t swap)
{



 return sceAtomicExchange16Relaxed(ptr, swap);

}

static inline
void sceAtomicStore16(volatile int16_t* ptr, int16_t value)
{



 sceAtomicStore16Relaxed(ptr, value);

}

static inline
int16_t sceAtomicLoad16(const volatile int16_t* ptr)
{



 return sceAtomicLoad16Relaxed(ptr);

}

static inline int32_t sceAtomicAdd32(volatile int32_t* ptr, int32_t value)
{



 return sceAtomicAdd32Relaxed(ptr, value);

}

static inline int32_t sceAtomicOr32(volatile int32_t* ptr, int32_t value)
{



 return sceAtomicOr32Relaxed(ptr, value);

}

static inline int32_t sceAtomicAnd32(volatile int32_t* ptr, int32_t value)
{



 return sceAtomicAnd32Relaxed(ptr, value);

}

static inline int32_t sceAtomicIncrement32(volatile int32_t* ptr)
{



 return sceAtomicIncrement32Relaxed(ptr);

}

static inline int32_t sceAtomicDecrement32(volatile int32_t* ptr)
{



 return sceAtomicDecrement32Relaxed(ptr);

}

static inline int32_t sceAtomicCompareAndSwap32(volatile int32_t* ptr, int32_t compare, int32_t swap)
{



 return sceAtomicCompareAndSwap32Relaxed(ptr, compare, swap);

}

static inline int32_t sceAtomicExchange32(volatile int32_t* ptr, int32_t swap)
{



 return sceAtomicExchange32Relaxed(ptr, swap);

}

static inline
void sceAtomicStore32(volatile int32_t* ptr, int32_t value)
{



 sceAtomicStore32Relaxed(ptr, value);

}

static inline
int32_t sceAtomicLoad32(const volatile int32_t* ptr)
{



 return sceAtomicLoad32Relaxed(ptr);

}

static inline int64_t sceAtomicAdd64(volatile int64_t* ptr, int64_t value)
{



 return sceAtomicAdd64Relaxed(ptr, value);

}

static inline int64_t sceAtomicOr64(volatile int64_t* ptr, int64_t value)
{



 return sceAtomicOr64Relaxed(ptr, value);

}

static inline int64_t sceAtomicAnd64(volatile int64_t* ptr, int64_t value)
{



 return sceAtomicAnd64Relaxed(ptr, value);

}

static inline int64_t sceAtomicIncrement64(volatile int64_t* ptr)
{



 return sceAtomicIncrement64Relaxed(ptr);

}

static inline int64_t sceAtomicDecrement64(volatile int64_t* ptr)
{



 return sceAtomicDecrement64Relaxed(ptr);

}

static inline int64_t sceAtomicCompareAndSwap64(volatile int64_t* ptr, int64_t compare, int64_t swap)
{



 return sceAtomicCompareAndSwap64Relaxed(ptr, compare, swap);

}

static inline int64_t sceAtomicExchange64(volatile int64_t* ptr, int64_t swap)
{



 return sceAtomicExchange64Relaxed(ptr, swap);

}

static inline
void sceAtomicStore64(volatile int64_t* ptr, int64_t value)
{



 sceAtomicStore64Relaxed(ptr, value);

}

static inline
int64_t sceAtomicLoad64(const volatile int64_t* ptr)
{



 return sceAtomicLoad64Relaxed(ptr);

}

static inline
__int128 sceAtomicAdd128(volatile __int128* ptr, __int128 value)
{



 __int128 ret = sceAtomicAdd128Relaxed(ptr, value);

 return ret;
}

static inline
__int128 sceAtomicIncrement128(volatile __int128* ptr)
{



 __int128 ret = sceAtomicIncrement128Relaxed(ptr);

 return ret;
}

static inline
__int128 sceAtomicDecrement128(volatile __int128* ptr)
{



 __int128 ret = sceAtomicDecrement128Relaxed(ptr);

 return ret;
}

static inline
__int128 sceAtomicCompareAndSwap128(volatile __int128* ptr, __int128 compare, __int128 swap)
{



 __int128 ret = sceAtomicCompareAndSwap128Relaxed(ptr,compare, swap);

 return ret;
}

static inline
__int128 sceAtomicOr128(volatile __int128* ptr, __int128 value)
{



 __int128 ret = sceAtomicOr128Relaxed(ptr, value);

 return ret;
}

static inline
__int128 sceAtomicAnd128(volatile __int128* ptr, __int128 value)
{



 __int128 ret = sceAtomicAnd128Relaxed(ptr, value);

 return ret;
}

static inline
__int128 sceAtomicExchange128(volatile __int128* ptr, __int128 swap)
{



 __int128 ret = sceAtomicExchange128Relaxed(ptr, swap);

 return ret;
}

static inline
void sceAtomicStore128(volatile __int128* ptr, __int128 value)
{



 sceAtomicStore128Relaxed(ptr, value);

}

static inline
__int128 sceAtomicLoad128(const volatile __int128* ptr)
{



 return sceAtomicLoad128Relaxed(ptr);

}

static inline
bool sceAtomicCompareAndSwap128ByPointer(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{



 bool ret = sceAtomicCompareAndSwap128ByPointerRelaxed(ptr, compare, swap, oldvalue);

 return ret;
}

static inline
bool sceAtomicCompareAndSwap128_64(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{



 bool ret = sceAtomicCompareAndSwap128_64Relaxed(ptr, compareHigh, compareLow, swapHigh, swapLow, oldvalue);

 return ret;
}

static inline
void sceAtomicStore128_64(volatile int64_t* ptr, const int64_t *source)
{



 sceAtomicStore128_64Relaxed(ptr, source);

}

static inline
void sceAtomicLoad128_64(volatile int64_t* ptr, int64_t *destination)
{



 sceAtomicLoad128_64Relaxed(ptr, destination);

}

static inline
void* sceAtomicExchangePointer(volatile void** ptr, void* swap)
{



 return sceAtomicExchangePointerRelaxed(ptr, swap);

}
# 16 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_psp2.h" 1 3
# 17 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_win.h" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic/sce_atomic_acqrel.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\ORBIS SDKs\\10.500/target/include_common\\sce_atomic.h" 2 3
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Notifications.cpp" 2

namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxNotificationPoll(MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Notifications::NotificationPoll(outBuffer, result);
 }

 void Notifications::NotificationPoll(MemoryBufferManaged* outBuffer, APIResult* result)
 {
  MemoryBuffer buffer = MemoryBuffer::GetNotificationBuffer();
  buffer.StartResponseWrite();


  SceSaveDataEvent event;
  memset(&event, 0x00, sizeof(event));

  int ret = sceSaveDataGetEventResult(__null, &event);


  buffer.WriteInt32(ret);

  if (ret == 0)
  {

   buffer.WriteInt32(event.type);
   buffer.WriteInt32(event.userId);
   buffer.WriteInt32(event.errorCode);

   Core::WriteToBuffer(event.dirName, buffer);

  }

  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 16 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Progress.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Progress.h" 1






namespace SaveData
{
 class Progress
 {
 public:
  static void ClearProgress(APIResult* result);
  static float GetProgress(APIResult* result);
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Progress.cpp" 2


namespace SaveData
{

 extern "C" __declspec (dllexport) float PrxSaveDataGetProgress(APIResult* result)
 {
  return Progress::GetProgress(result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataClearProgress(APIResult* result)
 {
  Progress::ClearProgress(result);
 }

 void Progress::ClearProgress(APIResult* result)
 {
  int ret = sceSaveDataClearProgress();

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Progress.cpp", 24));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 float Progress::GetProgress(APIResult* result)
 {
  float progress;
  int ret = sceSaveDataGetProgress(&progress);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Progress.cpp", 38));
   return 0.0f;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));

  return progress;
 }

}
# 17 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Search.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Search.h" 1






namespace SaveData
{
 class DirNameSearchRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;
  UInt32 maxSaveDataCount;
  SceSaveDataSortKey key;
  SceSaveDataSortOrder order;

  bool includeParams;
  bool includeBlockInfo;

  void CopyTo(SceSaveDataDirNameSearchCond &destination, SceSaveDataDirName& sceDirName);
 };

 class Searching
 {
 public:

  static void DirNameSearch(DirNameSearchRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Search.cpp" 2


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataDirNameSearch(DirNameSearchRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Searching::DirNameSearch(managedRequest, outBuffer, result);
 }

 void DirNameSearchRequest::CopyTo(SceSaveDataDirNameSearchCond &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));

  destination.userId = userId;

  if (strlen(dirName.data) > 0)
  {
   destination.dirName = &sceDirName;
  }
  else
  {
   destination.dirName = __null;
  }

  destination.key = key;
  destination.order = order;
 }

 void Searching::DirNameSearch(DirNameSearchRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataDirName dirName;
  SceSaveDataDirNameSearchCond cond;

  managedRequest->CopyTo(cond, dirName);

  SceSaveDataDirNameSearchResult searchResult;
  memset(&searchResult, 0x00, sizeof(searchResult));

  searchResult.dirNames = Core::GetTempDirNamesArray();
  searchResult.dirNamesNum = managedRequest->maxSaveDataCount;

  if (managedRequest->includeParams == true)
  {
   searchResult.params = Core::GetTempParamsArray();
  }

  if (managedRequest->includeBlockInfo == true)
  {
   searchResult.infos = Core::GetTempSearchInfosArray();
  }

  int ret = sceSaveDataDirNameSearch(&cond, &searchResult);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();


  buffer.WriteUInt32(searchResult.setNum);
  buffer.WriteBool(managedRequest->includeParams);
  buffer.WriteBool(managedRequest->includeBlockInfo);

  for (int i = 0; i < searchResult.setNum; i++)
  {

   Core::WriteToBuffer(searchResult.dirNames[i], buffer);

   if (searchResult.params != __null)
   {
    Core::WriteToBuffer(searchResult.params[i], buffer);
   }

   if (searchResult.infos != __null)
   {
    Core::WriteToBuffer(searchResult.infos[i], buffer);
   }
  }


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Search.cpp", 89));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 18 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Utils.cpp" 1







namespace SaveData
{
# 71 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~/Source/Utils.cpp"
 int32_t Utils::LoadFile(const char *path, uint8_t** data, size_t *datasize)
 {
  int32_t ret = 0;

  SceKernelStat st;
  ret = sceKernelStat(path, &st);
  if (ret < 0)
  {
   return ret;
  }



  *data = new uint8_t[st.st_size];

  if (*data == __null)
  {
   return -1;
  }


  int fd = sceKernelOpen(path, 0x0000, 0000000);
  if (fd < 0)
  {
   delete[] data;
   return fd;
  }

  ret = static_cast<int32_t>(sceKernelRead(fd, *data, static_cast<size_t>(st.st_size)));
  if (ret < 0)
  {
   sceKernelClose(fd);
   return ret;
  }

  *datasize = st.st_size;

  sceKernelClose(fd);

  return ret;
 }
}
# 18 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps4@1.0.2\\Source~\\savedata_lump.cpp" 2

