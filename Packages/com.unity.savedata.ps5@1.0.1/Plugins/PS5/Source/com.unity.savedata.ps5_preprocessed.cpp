//0x8000045 sdk
//tland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 458 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling\\ErrorCodes.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 1






# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 1 3
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cdefs.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 2 3
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 1 3
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_null.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 1 3
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_limits.h" 1 3
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 2 3
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 2 3






typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;





typedef long __int64_t;
typedef unsigned long __uint64_t;
# 91 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __int32_t __clock_t;
typedef __int64_t __critical_t;
typedef double __double_t;
typedef float __float_t;
typedef __int64_t __intfptr_t;
typedef __int64_t __intptr_t;
# 105 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __int64_t __intmax_t;
typedef __int32_t __int_fast8_t;
typedef __int32_t __int_fast16_t;
typedef __int32_t __int_fast32_t;
typedef __int64_t __int_fast64_t;
typedef __int8_t __int_least8_t;
typedef __int16_t __int_least16_t;
typedef __int32_t __int_least32_t;
typedef __int64_t __int_least64_t;

typedef __int64_t __ptrdiff_t;
typedef __int64_t __register_t;
typedef __int64_t __segsz_t;
typedef __uint64_t __size_t;
typedef __int64_t __ssize_t;
typedef __int64_t __time_t;
typedef __uint64_t __uintfptr_t;
typedef __uint64_t __uintptr_t;
# 133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __uint64_t __uintmax_t;
typedef __uint32_t __uint_fast8_t;
typedef __uint32_t __uint_fast16_t;
typedef __uint32_t __uint_fast32_t;
typedef __uint64_t __uint_fast64_t;
typedef __uint8_t __uint_least8_t;
typedef __uint16_t __uint_least16_t;
typedef __uint32_t __uint_least32_t;
typedef __uint64_t __uint_least64_t;

typedef __uint64_t __u_register_t;
typedef __uint64_t __vm_offset_t;
typedef __uint64_t __vm_paddr_t;
typedef __uint64_t __vm_size_t;
# 157 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __int64_t __vm_ooffset_t;
typedef __uint64_t __vm_pindex_t;
typedef int ___wchar_t;
# 168 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __builtin_va_list __va_list;
# 183 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_types.h" 3
typedef __va_list __gnuc_va_list;
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 2 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 2 3




typedef __int32_t __blksize_t;
typedef __int64_t __blkcnt_t;
typedef __int32_t __clockid_t;
typedef __uint32_t __fflags_t;
typedef __uint64_t __fsblkcnt_t;
typedef __uint64_t __fsfilcnt_t;
typedef __uint32_t __gid_t;
typedef __int64_t __id_t;
typedef __uint32_t __ino_t;
typedef long __key_t;
typedef __int32_t __lwpid_t;
typedef __uint16_t __mode_t;
typedef int __accmode_t;
typedef int __nl_item;
typedef __uint16_t __nlink_t;
typedef __int64_t __off_t;
typedef __int64_t __off64_t;
typedef __int32_t __pid_t;
typedef __int64_t __rlim_t;


typedef __uint8_t __sa_family_t;
typedef __uint32_t __socklen_t;
typedef long __suseconds_t;
typedef struct __timer *__timer_t;
typedef struct __mq *__mqd_t;
typedef __uint32_t __uid_t;
typedef unsigned int __useconds_t;
typedef int __cpuwhich_t;
typedef int __cpulevel_t;
typedef int __cpusetid_t;
# 95 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 3
typedef int __ct_rune_t;
typedef __ct_rune_t __rune_t;







typedef unsigned short __wchar_t;






typedef __ct_rune_t __wint_t;
# 124 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types.h" 3
typedef __uint32_t __dev_t;

typedef __uint32_t __fixpt_t;





typedef union {
 char __mbstate8[128];
 __int64_t _mbstateL;
} __mbstate_t;

typedef __uintmax_t __rman_res_t;
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 532 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef int _Int32t;
typedef unsigned int _Uint32t;







typedef long _Ptrdifft;







typedef unsigned long _Sizet;
# 1286 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
namespace std {}
# 1411 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
namespace std {
typedef bool _Bool;
}
# 1442 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\stdarg.h" 1 3 4
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 1443 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 2 3
# 1577 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef long long _Longlong;
typedef unsigned long long _ULonglong;
# 1615 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef wchar_t _Wchart;
typedef int _Wintt;
# 1712 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef va_list _Va_list;
# 1755 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
typedef char _Sysch_t;
# 1779 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
extern "C" {
void _Locksyslock(int);
void _Unlocksyslock(int);
}
# 1812 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
namespace std {
enum _Uninitialized
 {
 _Noinit
 };

extern "C++" {

class _Lockit
 {
public:
# 1837 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
 _Lockit()
  : _Locktype(1)
  {

   _Locksyslock(_Locktype);
  }

 explicit _Lockit(int _Kind)
  : _Locktype(_Kind)
  {

   _Locksyslock(_Locktype);
  }

 ~_Lockit() noexcept
  {

   _Unlocksyslock(_Locktype);
  }



 _Lockit(const _Lockit&);
 _Lockit& operator=(const _Lockit&);

private:
 int _Locktype;
 };
# 1888 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 3
class _Mutex
 {
public:
 _Mutex(_Uninitialized)
  {
  }

 _Mutex();
 ~_Mutex() noexcept;
 void _Lock();
 void _Unlock();

private:
 _Mutex(const _Mutex&);
 _Mutex& operator=(const _Mutex&);
 void *_Mtx;
 };

}
}
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_errno_t.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_errno_t.h" 2 3


extern "C" {



typedef int errno_t;


}
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_size_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_size_t.h" 2 3





typedef __size_t size_t;




typedef size_t rsize_t;
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/__Mbstatet.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/__Mbstatet.h" 2 3





typedef struct _Mbstatet
 {
 unsigned long _Wchar;
 unsigned short _Byte, _State;
 int :32;


 _Mbstatet()
  : _Wchar(0), _Byte(0), _State(0)
  {
  }

 _Mbstatet(const _Mbstatet& _Right)
  : _Wchar(_Right._Wchar), _Byte(_Right._Byte),
   _State(_Right._State)
  {
  }

 _Mbstatet& operator=(const _Mbstatet& _Right)
  {
  _Wchar = _Right._Wchar;
  _Byte = _Right._Byte;
  _State = _Right._State;
  return (*this);
  }

 } _Mbstatet;
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_off_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_off_t.h" 3
typedef __off_t off_t;
# 56 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_ssize_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_ssize_t.h" 3
typedef __ssize_t ssize_t;
# 57 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_filet.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_filet.h" 2 3





typedef struct __sFILE _Filet;
# 58 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_eof.h" 1 3
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_seek.h" 1 3
# 60 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 2 3




typedef struct fpos_t
 {
 long _Off;
 _Mbstatet _Wstate;
 } fpos_t;
# 82 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 146 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
typedef struct __sFILE {



 unsigned short _Mode;
 unsigned char _Idx;
 signed int _Handle;

 unsigned char *_Buf, *_Bend, *_Next;
 unsigned char *_Rend, *_Wend, *_Rback;

 _Wchart *_WRback, _WBack[2];
 unsigned char *_Rsave, *_WRend, *_WWend;

 _Mbstatet _Wstate;
 char *_Tmpnam;
 unsigned char _Back[6], _Cbuf;
 void *_Mutex;


 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read)(void *, char *, int);
 fpos_t (*_seek)(void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 unsigned char *_up;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;

 struct pthread_mutex *_fl_mutex;
 struct pthread *_fl_owner;
 int _fl_count;
 int _orientation;
 __mbstate_t _mbstate;
} FILE;
# 248 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
extern "C" {
extern FILE _Stdin, _Stdout, _Stderr;

void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);
FILE *fopen(const char *, const char *);





int fprintf(FILE *, const char *, ...);
int fputc(int, FILE *);
int fputs(const char *, FILE *);
size_t fread(void *, size_t, size_t, FILE *);
FILE *freopen(const char *, const char *,
 FILE *);





int fscanf(FILE * , const char *, ...);
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void *, size_t, size_t,
 FILE *);
char *gets(char *);
void perror(const char *);





int printf(const char *, ...);
int puts(const char *);






int remove(const char *);
int rename(const char *, const char *);


void rewind(FILE *);





int scanf(const char *, ...);
void setbuf(FILE * , char *);
int setvbuf(FILE * , char *, int, size_t);





int sprintf(char *, const char *, ...);





int sscanf(const char *, const char *, ...);
int ungetc(int, FILE *);
int vfprintf(FILE *, const char *, _Va_list);
int vprintf(const char *, _Va_list);
int vsprintf(char *, const char *, _Va_list);


FILE *fdopen(signed int, const char *);
int fileno(FILE *);

int getw(FILE *);
int putw(int, FILE *);


long _Fgpos(FILE *, fpos_t *);
int _Flocale(FILE *, const char *, int);
void _Fsetlocale(FILE *, int);
int _Fspos(FILE *, const fpos_t *, long, int);


void _Lockfilelock(_Filet *);
void _Unlockfilelock(_Filet *);


extern FILE *_Files[256];







int snprintf(char *, size_t,
 const char *, ...);
int vsnprintf(char *, size_t,
 const char *, _Va_list);
int vfscanf(FILE *,
 const char *, _Va_list);
int vscanf(const char *, _Va_list);
int vsscanf(const char *,
 const char *, _Va_list);
# 378 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
}



extern "C" {
int getc(FILE *);
int getchar(void);
int putc(int, FILE *);
int putchar(int);
}
# 452 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdio.h" 3
extern "C" {

errno_t fopen_s(FILE * *,
 const char *, const char *);
errno_t freopen_s(FILE * *,
 const char *, const char *, FILE *);

int fprintf_s(FILE *, const char *, ...) __attribute__((format(printf, 2, 3)));
int fscanf_s(FILE *, const char *, ...);
int printf_s(const char *, ...) __attribute__((format(printf, 1, 2)));
int scanf_s(const char *, ...);
int snprintf_s(char *, rsize_t,
 const char *, ...) __attribute__((format(printf, 3, 4)));
int sscanf_s(const char *,
 const char *, ...);
int sprintf_s(char *, rsize_t,
 const char *, ...) __attribute__((format(printf, 3, 4)));
int vfprintf_s(FILE *,
 const char *,
 _Va_list);
int vfscanf_s(FILE *,
 const char *,
 _Va_list);
int vprintf_s(const char *,
 _Va_list);
int vscanf_s(const char *,
 _Va_list);
int vsnprintf_s(char *, rsize_t,
 const char *,
 _Va_list);
int vsprintf_s(char *, rsize_t,
 const char *,
 _Va_list);
int vsscanf_s(const char *,
 const char *,
 _Va_list);

char *gets_s(char *, rsize_t);
}



extern "C++" {

template<rsize_t _Size>
char *gets_s(char (&_Buf)[_Size])
 {
 return gets_s(_Buf, _Size);
 }

template<rsize_t _Size>
__attribute__((format(printf, 2, 3))) int sprintf_s(char (&_Buf)[_Size], const char *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vsnprintf_s(char (&_Buf)[_Size], const char *_Fmt, va_list _Ap)
 {
 return vsnprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
int vsprintf_s(char (&_Buf)[_Size], const char *_Fmt, va_list _Ap)
 {
 return vsprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
__attribute__((format(printf, 2, 3))) int snprintf_s(char (&_Buf)[_Size], const char *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

}
# 66 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 2 3
# 90 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 3
extern "C" {
void _Assert(const char *, const char *) __attribute__((__noreturn__));
}
# 8 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 1 3
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_weof.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int8_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int8_t.h" 3
typedef __int8_t int8_t;
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int16_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int16_t.h" 3
typedef short int16_t;
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int32_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int32_t.h" 3
typedef __int32_t int32_t;
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint8_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint8_t.h" 3
typedef __uint8_t uint8_t;
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint16_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint16_t.h" 3
typedef __uint16_t uint16_t;
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint32_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint32_t.h" 3
typedef __uint32_t uint32_t;
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_intptr_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_intptr_t.h" 3
typedef __intptr_t intptr_t;
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uintptr_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uintptr_t.h" 3
typedef __uintptr_t uintptr_t;
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int64_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int64_t.h" 3
typedef __int64_t int64_t;
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint64_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_uint64_t.h" 3
typedef __uint64_t uint64_t;
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 2 3
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef long _SceInt64t;
typedef unsigned long _SceUint64t;
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef _Int32t int_least32_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef _Uint32t uint_least32_t;
# 88 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef _Int32t int_fast8_t;
typedef _Int32t int_fast16_t;




typedef _Int32t int_fast32_t;


typedef _Uint32t uint_fast8_t;
typedef _Uint32t uint_fast16_t;




typedef _Uint32t uint_fast32_t;
# 155 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef _SceInt64t int_least64_t;
typedef _SceUint64t uint_least64_t;
# 167 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 3
typedef _SceInt64t int_fast64_t;
typedef _SceUint64t uint_fast64_t;




typedef _SceInt64t intmax_t;
typedef _SceUint64t uintmax_t;
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 2 3
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef char SceChar8;
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef unsigned char SceUChar8;
# 57 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int8_t SceInt8;
# 67 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint8_t SceUInt8;
# 77 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int16_t SceShort16;
# 87 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint16_t SceUShort16;
# 97 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int16_t SceInt16;
# 107 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint16_t SceUInt16;
# 117 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int32_t SceInt32;
# 127 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint32_t SceUInt32;
# 137 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int SceInt;
# 147 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef unsigned int SceUInt;
# 203 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int64_t SceInt64;
typedef uint64_t SceUInt64;
typedef long SceLong;
typedef unsigned long SceULong;
typedef int64_t SceLong64;
typedef uint64_t SceULong64;
# 218 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef float SceFloat;
# 227 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef float SceFloat32;
# 236 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef double SceDouble;
# 245 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef double SceDouble64;
# 255 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef signed char SceSByte;
# 265 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef signed char SceSByte8;
# 275 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef unsigned char SceByte;
# 285 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef unsigned char SceByte8;
# 295 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint16_t SceWChar16;
# 305 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uint32_t SceWChar32;
# 328 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int SceBool;
# 341 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef intptr_t SceIntPtr;
# 351 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uintptr_t SceUIntPtr;
# 361 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef void SceVoid;
# 371 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef void* ScePVoid;






typedef struct SceIVector2 {
 int x, y;
} SceIVector2;





typedef struct SceFVector2 {
 float x, y;
} SceFVector2;





typedef union SceUVector2 {
 SceIVector2 iv;
 SceFVector2 fv;
} SceUVector2;





typedef struct SceIVector3 {
 int x, y, z;
} SceIVector3;





typedef struct SceFVector3 {
 float x, y, z;
} SceFVector3;





typedef union SceUVector3 {
 SceIVector3 iv;
 SceFVector3 fv;
} SceUVector3;





typedef struct SceIVector4 {
 int x, y, z, w;
} SceIVector4;





typedef struct SceFVector4 {
 float x, y, z, w;
} SceFVector4;





typedef union SceUVector4 {
 SceIVector4 iv;
 SceFVector4 fv;
} SceUVector4;





typedef struct SceIMatrix2{
 SceIVector2 x, y;
} SceIMatrix2;





typedef struct SceFMatrix2{
 SceFVector2 x, y;
} SceFMatrix2;

typedef union SceUMatrix2 {
 SceFMatrix2 fm;
 SceIMatrix2 im;
 SceFVector2 fv[2];
 SceIVector2 iv[2];
 SceUVector2 uv[2];
 float f[2][2];
 int i[2][2];
# 483 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
} SceUMatrix2;






typedef struct SceIMatrix3 {
 SceIVector3 x, y, z;
} SceIMatrix3;





typedef struct SceFMatrix3 {
 SceFVector3 x, y, z;
} SceFMatrix3;





typedef union SceUMatrix3 {
 SceFMatrix3 fm;
 SceIMatrix3 im;
 SceFVector3 fv[3];
 SceIVector3 iv[3];
 SceUVector3 uv[3];
 float f[3][3];
 int i[3][3];
# 526 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
} SceUMatrix3;





typedef struct SceIMatrix4 {
 SceIVector4 x, y, z, w;
} SceIMatrix4;





typedef struct SceFMatrix4 {
 SceFVector4 x, y, z, w;
} SceFMatrix4;





typedef union SceUMatrix4 {
 SceFMatrix4 fm;
 SceIMatrix4 im;
 SceFVector4 fv[4];
 SceIVector4 iv[4];
 SceUVector4 uv[4];
 float f[4][4];
 int i[4][4];
# 570 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
} SceUMatrix4;






typedef struct SceFQuaternion {
 float x, y, z, w;
} SceFQuaternion;





typedef struct SceFColor {
 float r, g, b, a;
} SceFColor;
# 597 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef union SceUnion32 {
 unsigned int ui;
 int i;
 unsigned short us[2];
 short s[2];
 unsigned char uc[4];
 char c[4];
 float f;
} SceUnion32;
# 616 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef union SceUnion64 {
 SceULong64 ull;
 SceLong64 ll;
 unsigned int ui[2];
 int i[2];
 unsigned short us[4];
 short s[4];
 unsigned char uc[8];
 char c[8];
 float f[2];

 SceFVector2 fv;
 SceIVector2 iv;
 void *p;
} SceUnion64;
# 641 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef union SceUnion128 {

 SceULong64 ull[2];
 SceLong64 ll[2];
 unsigned int ui[4];
 int i[4];
 unsigned short us[8];
 short s[8];
 unsigned char uc[16];
 char c[16];
 float f[4];

 SceFVector4 fv;
 SceFQuaternion fq;
 SceFColor fc;
 SceIVector4 iv;
} SceUnion128;
# 668 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef union SceUnion512 {
 SceUnion32 un32[16];
 SceUnion64 un64[8];

 SceULong64 ull[8];
 SceLong64 ll[8];
 unsigned int ui[16];
 int i[16];
 unsigned short us[32];
 short s[32];
 unsigned char uc[64];
 char c[64];
 float f[16];

 SceFMatrix4 fm;
 SceIMatrix4 im;
 SceUMatrix4 um;

} SceUnion512;
# 697 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef struct SceDateTime {
 unsigned short year;
 unsigned short month;
 unsigned short day;
 unsigned short hour;
 unsigned short minute;
 unsigned short second;
 unsigned int microsecond;
} SceDateTime;
# 716 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef size_t SceSize;
# 726 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef SceSize ScePSize;
# 736 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef SceSize SceVSize;
# 746 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef ssize_t SceSSize;
# 756 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef SceSSize ScePSSize;
# 766 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef SceSSize SceVSSize;
# 777 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef uintptr_t SceUIntVAddr;
# 794 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef int SceUID;
# 816 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef char* SceName;
# 828 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\scetypes.h" 3
typedef off_t SceOff;




typedef SceUID ScePID;
# 10 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_error.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/endian.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/endian.h" 1 3
# 91 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/endian.h" 3
static inline __uint16_t
__bswap16_var(__uint16_t _x)
{

 return ((__uint16_t)((_x) << 8 | (_x) >> 8));
}

static inline __uint32_t
__bswap32_var(__uint32_t _x)
{


 __asm("bswap %0" : "+r" (_x));
 return (_x);



}

static inline __uint64_t
__bswap64_var(__uint64_t _x)
{


 __asm("bswap %0" : "+r" (_x));
 return (_x);







}
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/endian.h" 2 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_pthreadtypes.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_pthreadtypes.h" 3
struct pthread;
struct pthread_attr;
struct pthread_cond;
struct pthread_cond_attr;
struct pthread_mutex;
struct pthread_mutex_attr;
struct pthread_once;
struct pthread_rwlock;
struct pthread_rwlockattr;
struct pthread_barrier;
struct pthread_barrier_attr;
struct pthread_spinlock;
# 69 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_pthreadtypes.h" 3
typedef struct pthread *pthread_t;
typedef struct pthread_attr *pthread_attr_t;
typedef struct pthread_mutex *pthread_mutex_t;
typedef struct pthread_mutex_attr *pthread_mutexattr_t;
typedef struct pthread_cond *pthread_cond_t;
typedef struct pthread_cond_attr *pthread_condattr_t;
typedef int pthread_key_t;
typedef struct pthread_once pthread_once_t;
typedef struct pthread_rwlock *pthread_rwlock_t;
typedef struct pthread_rwlockattr *pthread_rwlockattr_t;
typedef struct pthread_barrier *pthread_barrier_t;
typedef struct pthread_barrierattr *pthread_barrierattr_t;
typedef struct pthread_spinlock *pthread_spinlock_t;







typedef void *pthread_addr_t;
typedef void *(*pthread_startroutine_t)(void *);




struct pthread_once {
 int state;
 pthread_mutex_t mutex;
};
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 2 3


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef unsigned short ushort;
typedef unsigned int uint;






# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_stdint.h" 1 3
# 64 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 2 3

typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;

typedef __uint64_t u_quad_t;
typedef __int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t;
typedef const char * c_caddr_t;


typedef __blksize_t blksize_t;



typedef __cpuwhich_t cpuwhich_t;
typedef __cpulevel_t cpulevel_t;
typedef __cpusetid_t cpusetid_t;


typedef __blkcnt_t blkcnt_t;




typedef __clock_t clock_t;




typedef __clockid_t clockid_t;



typedef __critical_t critical_t;
typedef __int64_t daddr_t;


typedef __dev_t dev_t;




typedef __fflags_t fflags_t;



typedef __fixpt_t fixpt_t;


typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;




typedef __gid_t gid_t;




typedef __uint32_t in_addr_t;




typedef __uint16_t in_port_t;




typedef __id_t id_t;




typedef __ino_t ino_t;




typedef __key_t key_t;




typedef __lwpid_t lwpid_t;




typedef __mode_t mode_t;




typedef __accmode_t accmode_t;




typedef __nlink_t nlink_t;
# 178 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 3
typedef __off64_t off64_t;




typedef __pid_t pid_t;



typedef __register_t register_t;


typedef __rlim_t rlim_t;



typedef __int64_t sbintime_t;

typedef __segsz_t segsz_t;
# 209 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 3
typedef __suseconds_t suseconds_t;




typedef __time_t time_t;




typedef __timer_t timer_t;




typedef __mqd_t mqd_t;



typedef __u_register_t u_register_t;


typedef __uid_t uid_t;




typedef __useconds_t useconds_t;





typedef unsigned long cap_ioctl_t;




struct cap_rights;

typedef struct cap_rights cap_rights_t;


typedef __vm_offset_t vm_offset_t;
typedef __vm_ooffset_t vm_ooffset_t;
typedef __vm_paddr_t vm_paddr_t;
typedef __vm_pindex_t vm_pindex_t;
typedef __vm_size_t vm_size_t;

typedef __rman_res_t rman_res_t;
# 365 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_sigset.h" 1 3
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_sigset.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 1 3
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_sigset.h" 2 3
# 58 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_sigset.h" 3
typedef struct __sigset {
 __uint32_t __bits[4];
} __sigset_t;
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timeval.h" 1 3
# 38 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timeval.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_suseconds_t.h" 1 3
# 39 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timeval.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_time_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_time_t.h" 2 3
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timeval.h" 2 3




struct timeval {
 time_t tv_sec;
 suseconds_t tv_usec;
};
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/timespec.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/timespec.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timespec.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timespec.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_timespec.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_timespec.h" 2 3





struct timespec {
 time_t tv_sec;
 long tv_nsec;
};
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_timespec.h" 2 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/timespec.h" 2 3
# 63 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/timespec.h" 3
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_sigset_t.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_sigset_t.h" 3
typedef __sigset_t sigset_t;
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 2 3

typedef unsigned long __fd_mask;

typedef __fd_mask fd_mask;
# 72 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 3
typedef struct fd_set {
 __fd_mask __fds_bits[(((1024) + (((sizeof(__fd_mask) * 8)) - 1)) / ((sizeof(__fd_mask) * 8)))];
} fd_set;
# 98 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/select.h" 3
extern "C" {
int pselect(int, fd_set *__restrict, fd_set *__restrict, fd_set *__restrict,
 const struct timespec *__restrict, const sigset_t *__restrict);




int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);


}
# 366 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 2 3
# 382 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/types.h" 3
extern "C" {


int ftruncate(int, off_t);



off_t lseek(int, off_t, int);



void * mmap(void *, size_t, int, int, int, off_t);



int truncate(const char *, off_t);

}
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_types.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_types.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 1 3
# 38 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/queue.h" 1 3
# 39 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 2 3
# 83 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 3
struct kevent {
 uintptr_t ident;
 short filter;
 u_short flags;
 u_int fflags;
 intptr_t data;
 void *udata;
};
# 187 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 3
struct knote;
struct klist { struct knote *slh_first; };
struct kqueue;
struct kqlist { struct kqueue *tqh_first; struct kqueue **tqh_last; };
struct knlist {
 struct klist kl_list;
 void (*kl_lock)(void *);
 void (*kl_unlock)(void *);
 void (*kl_assert_locked)(void *);
 void (*kl_assert_unlocked)(void *);
 void *kl_lockarg;
 int kl_autodestroy;
};
# 326 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/event.h" 3
struct timespec;

extern "C" {
int kqueue(void);
int kevent(int kq, const struct kevent *changelist, int nchanges,
     struct kevent *eventlist, int nevents,
     const struct timespec *timeout);
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cpuset.h" 1 3
# 35 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cpuset.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_cpuset.h" 1 3
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_cpuset.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_bitset.h" 1 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_cpuset.h" 2 3
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_cpuset.h" 3
struct _cpuset { long __bits[(((((128)) + (((sizeof(long) * 8)) - 1)) / ((sizeof(long) * 8))))]; };
typedef struct _cpuset cpuset_t;
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cpuset.h" 2 3
# 322 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/cpuset.h" 3
extern "C" {
int cpuset(cpusetid_t *);
int cpuset_setid(cpuwhich_t, id_t, cpusetid_t);
int cpuset_getid(cpulevel_t, cpuwhich_t, id_t, cpusetid_t *);
int cpuset_getaffinity(cpulevel_t, cpuwhich_t, id_t, size_t, cpuset_t *);
int cpuset_setaffinity(cpulevel_t, cpuwhich_t, id_t, size_t, const cpuset_t *);
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sched.h" 1 3
# 233 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sched.h" 3
struct sched_param {
        int sched_priority;
};
# 244 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sched.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_pid_t.h" 1 3
# 245 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sched.h" 2 3

extern "C" {
int sched_get_priority_max(int);
int sched_get_priority_min(int);
int sched_getparam(pid_t, struct sched_param *);
int sched_getscheduler(pid_t);
int sched_rr_get_interval(pid_t, struct timespec *);
int sched_setparam(pid_t, const struct sched_param *);
int sched_setscheduler(pid_t, int, const struct sched_param *);
int sched_yield(void);
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_types.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 1 3
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/syslimits.h" 1 3
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 2 3
# 133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/signal.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 1 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/trap.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/trap.h" 1 3
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/trap.h" 2 3
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 2 3
# 103 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 3
typedef long sig_atomic_t;
# 116 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/signal.h" 3
struct sigcontext {
 struct __sigset sc_mask;
 long sc_onstack;
 long sc_rdi;
 long sc_rsi;
 long sc_rdx;
 long sc_rcx;
 long sc_r8;
 long sc_r9;
 long sc_rax;
 long sc_rbx;
 long sc_rbp;
 long sc_r10;
 long sc_r11;
 long sc_r12;
 long sc_r13;
 long sc_r14;
 long sc_r15;
 int sc_trapno;
 short sc_fs;
 short sc_gs;
 long sc_addr;
 int sc_flags;
 short sc_es;
 short sc_ds;
 long sc_err;
 long sc_rip;
 long sc_cs;
 long sc_rflags;
 long sc_rsp;
 long sc_ss;
 long sc_len;




 long sc_fpformat;
 long sc_ownedfp;
 long sc_lbrfrom;
 long sc_lbrto;
 long sc_aux1;
 long sc_aux2;
 long sc_fpstate[104] __attribute__((__aligned__(16)));

 long sc_fsbase;
 long sc_gsbase;

 long sc_xfpustate;
 long sc_xfpustate_len;

 long sc_spare[4];
};
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/signal.h" 2 3
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 2 3
# 165 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
typedef void __sighandler_t(int);


union sigval {

 int sival_int;
 void *sival_ptr;

 int sigval_int;
 void *sigval_ptr;
};




struct pthread_attr;

struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 union {
  __lwpid_t _threadid;
  struct {
   void (*_function)(union sigval);
   struct pthread_attr **_attribute;
  } _sigev_thread;
  unsigned short _kevent_flags;
  long __spare__[8];
 } _sigev_un;
};
# 216 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
typedef struct __siginfo {
 int si_signo;
 int si_errno;






 int si_code;
 __pid_t si_pid;
 __uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 union {
  struct {
   int _trapno;
  } _fault;
  struct {
   int _timerid;
   int _overrun;
  } _timer;
  struct {
   int _mqd;
  } _mesgq;
  struct {
   long _band;
  } _poll;
  struct {
   long __spare1__;
   int __spare2__[7];
  } __spare__;
 } _reason;
} siginfo_t;
# 315 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
struct __siginfo;




struct sigaction {
 union {
  void (*__sa_handler)(int);
  void (*__sa_sigaction)(int, struct __siginfo *, void *);
 } __sigaction_u;
 int sa_flags;
 sigset_t sa_mask;
};
# 372 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
typedef __sighandler_t *sig_t;
typedef void __siginfohandler_t(int, struct __siginfo *, void *);






typedef struct sigaltstack stack_t;
# 393 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
struct sigaltstack {
 void *ss_sp;
 __size_t ss_size;
 int ss_flags;
};






struct sigvec {
 __sighandler_t *sv_handler;
 int sv_mask;
 int sv_flags;
};
# 431 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
struct sigstack {
 void *ss_sp;
 int ss_onstack;
};
# 462 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/signal.h" 3
extern "C" {
__sighandler_t *signal(int, __sighandler_t *);
}
# 134 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 2 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/param.h" 1 3
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/param.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_align.h" 1 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\x86/_align.h" 1 3
# 7 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_align.h" 2 3
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/param.h" 2 3
# 138 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/limits.h" 1 3
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/limits.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/limits.h" 2 3
# 140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/param.h" 2 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_types.h" 2 3

typedef struct kevent SceKernelKevent;
typedef struct timespec SceKernelTimespec;
typedef struct timeval SceKernelTimeval;
typedef clockid_t SceKernelClockid;
typedef struct sched_param SceKernelSchedParam;
typedef uint64_t SceKernelCpumask;
typedef unsigned int SceKernelUseconds;
typedef int32_t SceKernelModule;
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_clock.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_clock_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_clock_t.h" 2 3
# 56 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_clockid_t.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_clockid_t.h" 2 3
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 2 3
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 3
struct tm
 {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 };
# 135 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 3
extern "C" {
time_t time(time_t *);
}

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void);
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *);
size_t strftime(char *, size_t,
 const char *, const struct tm *);
int timespec_get(struct timespec *, int);


int clock_getres(clockid_t, struct timespec *);
int clock_gettime(clockid_t, struct timespec *);
int nanosleep(const struct timespec *, struct timespec *);


}


extern "C" {

errno_t asctime_s(char *, rsize_t, const struct tm *);
errno_t ctime_s(char *, rsize_t, const time_t *);
struct tm *gmtime_s(const time_t *,
 struct tm *);
struct tm *localtime_s(const time_t *,
 struct tm *);
}



extern "C++" {

template<rsize_t _Size>
errno_t asctime_s(char (&_Str)[_Size], const struct tm *_Tptr)
 {
 return asctime_s(_Str, _Size, _Tptr);
 }

template<rsize_t _Size>
errno_t ctime_s(char (&_Str)[_Size], const time_t *_Tod)
 {
 return ctime_s(_Str, _Size, _Tod);
 }

}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_defs.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_lldiv.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_lldiv.h" 2 3



typedef struct
{
 _Longlong quot;
 _Longlong rem;
} _Lldiv_t;
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int.h" 3
extern "C" {



typedef struct
{
 long quot;
 long rem;
} ldiv_t;

typedef _Lldiv_t lldiv_t;


extern long labs(long);
extern _Longlong llabs(_Longlong);
extern ldiv_t ldiv(long, long);
extern lldiv_t lldiv(_Longlong, _Longlong);


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int_cpp.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_int_cpp.h" 3
extern "C" {

extern "C++" {





  inline long abs(long _Left)
  {
    return (labs(_Left));
  }

  inline ldiv_t div(long _Left, long _Right)
  {
    return (ldiv(_Left, _Right));
  }




  inline _Longlong abs(_Longlong _Left)
  {
    return (llabs(_Left));
  }

  inline _Lldiv_t div(_Longlong _Left, _Longlong _Right)
  {
    return (lldiv(_Left, _Right));
  }


}

}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 2 3
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 3
extern "C" {




typedef struct
 {
 intmax_t quot;
 intmax_t rem;
 } imaxdiv_t;





intmax_t imaxabs(intmax_t);
imaxdiv_t imaxdiv(intmax_t, intmax_t);

intmax_t strtoimax(const char *,
 char **, int);
uintmax_t strtoumax(const char *,
 char **, int);
intmax_t wcstoimax(const _Wchart *,
 _Wchart **, int);
uintmax_t wcstoumax(const _Wchart *,
 _Wchart **, int);
}
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_defs.h" 2 3



typedef int32_t SceUserServiceUserId;
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 1 3
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
struct bintime {
 time_t sec;
 uint64_t frac;
};

static inline void
bintime_addx(struct bintime *_bt, uint64_t _x)
{
 uint64_t _u;

 _u = _bt->frac;
 _bt->frac += _x;
 if (_u > _bt->frac)
  _bt->sec++;
}

static inline void
bintime_add(struct bintime *_bt, const struct bintime *_bt2)
{
 uint64_t _u;

 _u = _bt->frac;
 _bt->frac += _bt2->frac;
 if (_u > _bt->frac)
  _bt->sec++;
 _bt->sec += _bt2->sec;
}

static inline void
bintime_sub(struct bintime *_bt, const struct bintime *_bt2)
{
 uint64_t _u;

 _u = _bt->frac;
 _bt->frac -= _bt2->frac;
 if (_u < _bt->frac)
  _bt->sec--;
 _bt->sec -= _bt2->sec;
}

static inline void
bintime_mul(struct bintime *_bt, u_int _x)
{
 uint64_t _p1, _p2;

 _p1 = (_bt->frac & 0xffffffffull) * _x;
 _p2 = (_bt->frac >> 32) * _x + (_p1 >> 32);
 _bt->sec *= _x;
 _bt->sec += (_p2 >> 32);
 _bt->frac = (_p2 << 32) | (_p1 & 0xffffffffull);
}

static inline void
bintime_shift(struct bintime *_bt, int _exp)
{

 if (_exp > 0) {
  _bt->sec <<= _exp;
  _bt->sec |= _bt->frac >> (64 - _exp);
  _bt->frac <<= _exp;
 } else if (_exp < 0) {
  _bt->frac >>= -_exp;
  _bt->frac |= (uint64_t)_bt->sec << (64 + _exp);
  _bt->sec >>= -_exp;
 }
}
# 140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
static inline int
sbintime_getsec(sbintime_t _sbt)
{

 return (_sbt >> 32);
}

static inline sbintime_t
bttosbt(const struct bintime _bt)
{

 return (((sbintime_t)_bt.sec << 32) + (_bt.frac >> 32));
}

static inline struct bintime
sbttobt(sbintime_t _sbt)
{
 struct bintime _bt;

 _bt.sec = _sbt >> 32;
 _bt.frac = _sbt << 32;
 return (_bt);
}
# 178 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
static inline void
bintime2timespec(const struct bintime *_bt, struct timespec *_ts)
{

 _ts->tv_sec = _bt->sec;
 _ts->tv_nsec = ((uint64_t)1000000000 *
     (uint32_t)(_bt->frac >> 32)) >> 32;
}

static inline void
timespec2bintime(const struct timespec *_ts, struct bintime *_bt)
{

 _bt->sec = _ts->tv_sec;

 _bt->frac = (uint64_t)_ts->tv_nsec * (uint64_t)18446744073LL;
}

static inline void
bintime2timeval(const struct bintime *_bt, struct timeval *_tv)
{

 _tv->tv_sec = _bt->sec;
 _tv->tv_usec = ((uint64_t)1000000 * (uint32_t)(_bt->frac >> 32)) >> 32;
}

static inline void
timeval2bintime(const struct timeval *_tv, struct bintime *_bt)
{

 _bt->sec = _tv->tv_sec;

 _bt->frac = (uint64_t)_tv->tv_usec * (uint64_t)18446744073709LL;
}

static inline struct timespec
sbttots(sbintime_t _sbt)
{
 struct timespec _ts;

 _ts.tv_sec = _sbt >> 32;
 _ts.tv_nsec = ((uint64_t)1000000000 * (uint32_t)_sbt) >> 32;
 return (_ts);
}

static inline sbintime_t
tstosbt(struct timespec _ts)
{

 return (((sbintime_t)_ts.tv_sec << 32) +
     (_ts.tv_nsec * (((uint64_t)1 << 63) / 500000000) >> 32));
}

static inline struct timeval
sbttotv(sbintime_t _sbt)
{
 struct timeval _tv;

 _tv.tv_sec = _sbt >> 32;
 _tv.tv_usec = ((uint64_t)1000000 * (uint32_t)_sbt) >> 32;
 return (_tv);
}

static inline sbintime_t
tvtosbt(struct timeval _tv)
{

 return (((sbintime_t)_tv.tv_sec << 32) +
     (_tv.tv_usec * (((uint64_t)1 << 63) / 500000) >> 32));
}
# 327 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};




struct clockinfo {
 int hz;
 int tick;
 int spare;
 int stathz;
 int profhz;
};
# 469 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 470 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/time.h" 2 3




extern "C" {
int setitimer(int, const struct itimerval *, struct itimerval *);
int utimes(const char *, const struct timeval *);


int adjtime(const struct timeval *, struct timeval *);
int clock_getcpuclockid2(id_t, int, clockid_t *);
int futimes(int, const struct timeval *);
int futimesat(int, const char *, const struct timeval [2]);
int lutimes(const char *, const struct timeval *);
int settimeofday(const struct timeval *, const struct timezone *);



int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval *, struct timezone *);



}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 3
typedef enum {
  SCE_KERNEL_MTYPE_C = 11,
  SCE_KERNEL_MTYPE_C_SHARED,

  SCE_KERNEL_MEMORY_TYPE_END = 21
} SceKernelMemoryType;






enum {

 __SCE_KERNEL_MAIN_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x0000000000L,
 __SCE_KERNEL_DMEM_END
  __attribute__ ((deprecated)) = 0x5000000000L,
 __SCE_KERNEL_GPU_SHARED_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x1000000000L,
 __SCE_KERNEL_GPU_PRIVATE_DMEM_OFFSET
  __attribute__ ((deprecated)) = 0x2000000000L,
 __SCE_KERNEL_GPU_SHARED_DMEM_SIZE
  __attribute__ ((deprecated)) = 0x0d000000L,
 __SCE_KERNEL_GPU_PRIVATE_DMEM_SIZE
  __attribute__ ((deprecated)) = 0x80000000L
};
# 81 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 3
enum {

 __SCE_KERNEL_FIXED_PRT_APERTURE_START_ADDR
  __attribute__ ((deprecated)) = 0x0f00000000UL,
 __SCE_KERNEL_FIXED_PRT_APERTURE_SIZE
  __attribute__ ((deprecated)) = 0x0010000000UL,
 __SCE_KERNEL_FIXED_PRT_APERTURE_END_ADDR
  __attribute__ ((deprecated)) = 0x0f00000000UL + 0x0010000000UL
};
# 106 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 3
extern "C" {

typedef enum {
  SCE_KERNEL_MAP_OP_MAP_DIRECT,
  SCE_KERNEL_MAP_OP_UNMAP,
  SCE_KERNEL_MAP_OP_PROTECT,
  SCE_KERNEL_MAP_OP_MAP_FLEXIBLE,
  SCE_KERNEL_MAP_OP_TYPE_PROTECT,
} SceKernelMapEntryOperation;

typedef struct
{
 void *start;
 off_t offset;
   size_t length;
 char protection;
 char type;
 short pad1;
 int operation;
} SceKernelBatchMapEntry;



typedef struct
{
 void *start;
 void *end;
 off_t offset;
 int protection;
 int memoryType;
 unsigned isFlexibleMemory:1;
 unsigned isDirectMemory:1;
 unsigned isStack:1;
 unsigned isPooledMemory:1;
 unsigned isCommitted:1;
   unsigned isGpuPrt:1;
 unsigned ammUsage:1;
 unsigned __reserved:1;
 char name[32];
 uint8_t gpuMaskId;
 uint8_t __reserved2;
} SceKernelVirtualQueryInfo;



typedef struct
{
 off_t start;
 off_t end;
 int memoryType;
} SceKernelDirectMemoryQueryInfo;
# 166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dmem.h" 3
typedef struct
{
 unsigned op;
 unsigned flags;
 union {
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
   unsigned char type;
  } commit;
  struct {
   void *addr;
   size_t len;
  } decommit;
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
  } protect;
  struct {
   void *addr;
   size_t len;
   unsigned char prot;
   unsigned char type;
  } typeProtect;
  struct {
   void *dst;
   void *src;
   size_t len;
  } move;
  uintptr_t padding[3];
 };
} SceKernelMemoryPoolBatchEntry;

typedef struct
{
 int availableFlushedBlocks;
 int availableCachedBlocks;
 int allocatedFlushedBlocks;
 int allocatedCachedBlocks;
} SceKernelMemoryPoolBlockStats;

size_t sceKernelGetDirectMemorySize();

int32_t sceKernelMapFlexibleMemory(void** addrInOut, size_t len,
       int prot, int flags);
int32_t sceKernelReleaseFlexibleMemory(void* addr, size_t len);
int32_t sceKernelSetPrtAperture(int index, void *addr, size_t len);
int32_t sceKernelGetPrtAperture(int index, void **addr, size_t *len);

int32_t sceKernelAllocateDirectMemory(off_t searchStart, off_t searchEnd,
          size_t len, size_t alignment,
          int memoryType,
          off_t *physAddrOut);
int32_t sceKernelAllocateDirectMemory2(off_t _searchStart, off_t _searchEnd,
     size_t _len, size_t _alignment, int _memoryType, int _flags,
     off_t *_physAddrOut);
int32_t sceKernelAllocateMainDirectMemory(size_t len, size_t alignment,
       int memoryType,
       off_t *physAddrOut);
int32_t sceKernelReleaseDirectMemory(off_t start, size_t len);
int32_t sceKernelCheckedReleaseDirectMemory(off_t start, size_t len);
int32_t sceKernelMapDirectMemory(void **addr, size_t len,
     int prot, int flags, off_t directMemoryStart,
     size_t alignment);
int32_t sceKernelMapDirectMemory2(void **addr, size_t len,
      int type, int prot,
      int flags, off_t directMemoryStart,
     size_t alignment);
int32_t sceKernelGetDirectMemoryType(off_t start,
         int *memoryType,
         off_t *regionStartOut,
         off_t *regionEndOut);

int32_t sceKernelBatchMap(SceKernelBatchMapEntry* entries,
     int numberOfEntries,
     int* numberOfEntriesOut);
int32_t sceKernelBatchMap2(SceKernelBatchMapEntry* entries,
      int numberOfEntries,
      int* numberOfEntriesOut,
      int flags);

int32_t
sceKernelJitCreateSharedMemory(const char *name, size_t len, int maxProt,
          int *fdOut);
int32_t sceKernelJitCreateAliasOfSharedMemory(int fd, int maxProt, int *fdOut);
int32_t sceKernelJitMapSharedMemory(int fd, int prot, void **startOut);
int32_t sceKernelJitGetSharedMemoryInfo(int fd, char* name, int nameBufferSize,
     void **startOut, size_t *lenOut,
     int *maxProtOut);

int32_t sceKernelQueryMemoryProtection(void* addr,
           void** start, void** end, int* prot);
int32_t sceKernelIsStack(void* addr, void** start, void** end);
int32_t sceKernelVirtualQuery(const void *addr, int flags,
         SceKernelVirtualQueryInfo *info,
         size_t infoSize);
int32_t sceKernelSetVirtualRangeName(void* start, size_t len,
    const char *name);
int32_t sceKernelClearVirtualRangeName(void *addr, size_t len);

int32_t sceKernelMapNamedFlexibleMemory(void** addrInOut, size_t len,
     int prot, int flags, const char *name);
int32_t sceKernelMapNamedDirectMemory(void **addr, size_t len,
          int prot, int flags,
          off_t directMemoryStart,
          size_t alignment, const char *name);
int sceKernelReserveVirtualRange(void **addr, size_t len, int flags,
     size_t alignment);

int32_t sceKernelDirectMemoryQuery(off_t offset,
       int flags,
       void *info,
       size_t infoSize);
int32_t sceKernelMtypeprotect(const void *addr, size_t size, int type,
    int prot);

int32_t sceKernelAvailableDirectMemorySize(off_t start,
        off_t end,
        size_t alignment,
        off_t *startOut,
        size_t *sizeOut);
int32_t sceKernelGetPageTableStats(int* cpuTotal, int* cpuAvailable,
       int* gpuTotal, int* gpuAvailable);


int32_t sceKernelMemoryPoolBatch(const SceKernelMemoryPoolBatchEntry *entries,
    int n, int *indexOut, int flags);
int32_t sceKernelMemoryPoolCommit(void *addr, size_t len, int type, int prot,
    int flags);
int32_t sceKernelMemoryPoolDecommit(void *addr, size_t len, int flags);
int32_t sceKernelMemoryPoolExpand(off_t searchStart, off_t searchEnd,
    size_t len, size_t alignment, off_t *physAddrOut);
int32_t sceKernelMemoryPoolGetBlockStats(SceKernelMemoryPoolBlockStats *output,
    size_t outputSize);
int32_t sceKernelMemoryPoolMove(void *dst, void *src, size_t len, int flags);
int32_t sceKernelMemoryPoolReserve(void *addrIn, size_t len, size_t alignment,
    int flags, void **addrOut);

}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sce_errno.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sce_errno.h" 3
extern "C" {
# 768 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/sce_errno.h" 3
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sched.h" 1 3
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 2 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_kernel.h" 3
extern "C" {

typedef struct
{
 size_t size;
} SceKernelLoadModuleOpt;

typedef struct
{
 size_t size;
} SceKernelUnloadModuleOpt;


int sceKernelMlock(const void *addr, size_t len);
int sceKernelMunlock(const void *addr, size_t len);
int sceKernelMprotect(const void *addr, size_t len, int prot);
int sceKernelMsync(void *addr, size_t len, int flags);
int sceKernelMunmap(void *addr, size_t len);
int sceKernelMlockall(int flags);
int sceKernelMunlockall(void);
unsigned int sceKernelSleep(unsigned int seconds);
int sceKernelUsleep(SceKernelUseconds microseconds);
int sceKernelNanosleep(const SceKernelTimespec *rqtp, SceKernelTimespec *rmtp);
int sceKernelClockGetres(SceKernelClockid clockId, SceKernelTimespec *tp);
int sceKernelClockGettime(SceKernelClockid clockId, SceKernelTimespec *tp);
int sceKernelGettimeofday(SceKernelTimeval *tp);

uint64_t sceKernelGetTscFrequency(void);
uint64_t sceKernelReadTsc(void);
uint64_t sceKernelGetProcessTime(void);
uint64_t sceKernelGetProcessTimeCounter(void);
uint64_t sceKernelGetProcessTimeCounterFrequency(void);
int sceKernelGetCurrentCpu(void);

SceKernelModule sceKernelLoadStartModule(const char *moduleFileName,
        size_t args, const void *argp, uint32_t flags,
        const SceKernelLoadModuleOpt *pOpt, int *pRes);
int sceKernelStopUnloadModule(SceKernelModule handle, size_t args,
        const void *argp, uint32_t flags, const SceKernelUnloadModuleOpt *pOpt,
        int *pRes);
int sceKernelDlsym(SceKernelModule handle, const char *symbol, void **addrp) __attribute__((noinline));


int __attribute__((visibility ("hidden"))) module_start(size_t args, const void *argp);
int __attribute__((visibility ("hidden"))) module_stop(size_t args, const void *argp);

void sceKernelSetGPO(uint32_t uiBits);
uint64_t sceKernelGetGPI(void);

}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 1 3
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sched.h" 1 3
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 55 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_limits.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\machine/_types.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sched.h" 1 3
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 1 3
# 55 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 2 3
# 128 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 3
enum pthread_mutextype {
 PTHREAD_MUTEX_ERRORCHECK = 1,
 PTHREAD_MUTEX_RECURSIVE = 2,
 PTHREAD_MUTEX_NORMAL = 3,
 PTHREAD_MUTEX_ADAPTIVE_NP = 4,
 PTHREAD_MUTEX_TYPE_MAX
};



struct _pthread_cleanup_info {
 __uintptr_t pthread_cleanup_pad[8];
};




extern "C" {
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getstack(const pthread_attr_t * __restrict,
   void ** __restrict, size_t * __restrict);
int pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
int pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
int pthread_attr_getstackaddr(const pthread_attr_t *, void **);
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t);
int pthread_attr_setguardsize(pthread_attr_t *, size_t);
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
int pthread_attr_setstackaddr(pthread_attr_t *, void *);
int pthread_attr_setdetachstate(pthread_attr_t *, int);
int pthread_barrier_destroy(pthread_barrier_t *);
int pthread_barrier_init(pthread_barrier_t *,
   const pthread_barrierattr_t *, unsigned);
int pthread_barrier_wait(pthread_barrier_t *);
int pthread_barrierattr_destroy(pthread_barrierattr_t *);
int pthread_barrierattr_getpshared(const pthread_barrierattr_t *,
   int *);
int pthread_barrierattr_init(pthread_barrierattr_t *);
int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
# 181 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\pthread.h" 3
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_getclock(const pthread_condattr_t *,
   clockid_t *);
int pthread_condattr_getpshared(const pthread_condattr_t *, int *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
int pthread_condattr_setpshared(pthread_condattr_t *, int);
int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t *,
   const pthread_condattr_t *);
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t *,
   pthread_mutex_t *, const struct timespec *);
int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
int pthread_create(pthread_t *, const pthread_attr_t *,
   void *(*) (void *), void *);
int pthread_detach(pthread_t);
int pthread_equal(pthread_t, pthread_t);
void pthread_exit(void *) __attribute__((__noreturn__));
void *pthread_getspecific(pthread_key_t);
int pthread_getcpuclockid(pthread_t, clockid_t *);
int pthread_join(pthread_t, void **);
int pthread_key_create(pthread_key_t *,
   void (*) (void *));
int pthread_key_delete(pthread_key_t);
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,
   int *);
int pthread_mutexattr_gettype(pthread_mutexattr_t *, int *);
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_init(pthread_mutex_t *,
   const pthread_mutexattr_t *);
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_timedlock(pthread_mutex_t *,
   const struct timespec *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_once(pthread_once_t *, void (*) (void));
int pthread_rwlock_destroy(pthread_rwlock_t *);
int pthread_rwlock_init(pthread_rwlock_t *,
   const pthread_rwlockattr_t *);
int pthread_rwlock_rdlock(pthread_rwlock_t *);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *,
   const struct timespec *);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *,
   const struct timespec *);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int pthread_rwlock_trywrlock(pthread_rwlock_t *);
int pthread_rwlock_unlock(pthread_rwlock_t *);
int pthread_rwlock_wrlock(pthread_rwlock_t *);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *,
   int *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,
   int *);
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *, int);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
pthread_t pthread_self(void);
int pthread_setspecific(pthread_key_t, const void *);

int pthread_cancel(pthread_t);
int pthread_setcancelstate(int, int *);
int pthread_setcanceltype(int, int *);
void pthread_testcancel(void);


int pthread_getprio(pthread_t);
int pthread_setprio(pthread_t, int);
void pthread_yield(void);


int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *,
   int *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,
   int);
int pthread_mutex_getprioceiling(pthread_mutex_t *, int *);
int pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);

int pthread_mutexattr_getprotocol(pthread_mutexattr_t *, int *);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

int pthread_attr_getinheritsched(const pthread_attr_t *, int *);
int pthread_attr_getschedparam(const pthread_attr_t *,
   struct sched_param *);
int pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
int pthread_attr_getscope(const pthread_attr_t *, int *);
int pthread_attr_setinheritsched(pthread_attr_t *, int);
int pthread_attr_setschedparam(pthread_attr_t *,
   const struct sched_param *);
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_getschedparam(pthread_t pthread, int *,
   struct sched_param *);
int pthread_setschedparam(pthread_t, int,
   const struct sched_param *);

int pthread_getconcurrency(void);
int pthread_setconcurrency(int);


void __pthread_cleanup_push_imp(void (*)(void *), void *,
   struct _pthread_cleanup_info *);
void __pthread_cleanup_pop_imp(int);
}
# 58 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\semaphore.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\semaphore.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_umtx.h" 1 3
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_umtx.h" 3
struct umutex {
 volatile __lwpid_t m_owner;
 __uint32_t m_flags;
 __uint32_t m_ceilings[2];
 __uintptr_t m_rb_lnk;



 __uint32_t m_spare[2];
};

struct ucond {
 volatile __uint32_t c_has_waiters;
 __uint32_t c_flags;
 __uint32_t c_clockid;
 __uint32_t c_spare[1];
};

struct urwlock {
 volatile __int32_t rw_state;
 __uint32_t rw_flags;
 __uint32_t rw_blocked_readers;
 __uint32_t rw_blocked_writers;
 __uint32_t rw_spare[4];
};

struct _usem {
 volatile __uint32_t _has_waiters;
 volatile __uint32_t _count;
 __uint32_t _flags;
};

struct _usem2 {
 volatile __uint32_t _count;
 __uint32_t _flags;
};

struct _umtx_time {
 struct timespec _timeout;
 __uint32_t _flags;
 __uint32_t _clockid;
};
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\semaphore.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_useconds_t.h" 1 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\semaphore.h" 2 3

struct _sem {
 __uint16_t _magic;
 __uint16_t _nameid;
 struct _usem _kern;
};

typedef struct _sem sem_t;




struct timespec;

extern "C" {
int sem_destroy(sem_t *);
int sem_getvalue(sem_t * __restrict, int * __restrict);
int sem_init(sem_t *, int, unsigned int);
int sem_post(sem_t *);
int sem_reltimedwait_np(sem_t *, useconds_t);
int sem_timedwait(sem_t * __restrict, const struct timespec * __restrict);
int sem_trywait(sem_t *);
int sem_unlink(const char *);
int sem_wait(sem_t *);
}
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 2 3
# 140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 3
typedef enum ScePthreadMutextype {
 SCE_PTHREAD_MUTEX_ERRORCHECK = 1,
 SCE_PTHREAD_MUTEX_RECURSIVE = 2,
 SCE_PTHREAD_MUTEX_NORMAL = 3,
 SCE_PTHREAD_MUTEX_ADAPTIVE = 4,
 SCE_PTHREAD_MUTEX_TYPE_MAX
} ScePthreadMutextype;

typedef enum ScePthreadRwlocktype {
 SCE_PTHREAD_RWLOCK_NORMAL = 1,
 SCE_PTHREAD_RWLOCK_PREFER_READER = 2,
 SCE_PTHREAD_RWLOCK_TYPE_MAX
} ScePthreadRwlocktype;
# 166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 3
typedef pthread_attr_t ScePthreadAttr;
typedef pthread_barrier_t ScePthreadBarrier;
typedef pthread_barrierattr_t ScePthreadBarrierattr;
typedef pthread_condattr_t ScePthreadCondattr;
typedef pthread_cond_t ScePthreadCond;
typedef pthread_t ScePthread;
typedef pthread_key_t ScePthreadKey;
typedef pthread_mutex_t ScePthreadMutex;
typedef pthread_mutexattr_t ScePthreadMutexattr;
typedef pthread_once_t ScePthreadOnce;
typedef pthread_rwlock_t ScePthreadRwlock;
typedef pthread_rwlockattr_t ScePthreadRwlockattr;
typedef sem_t ScePthreadSem;





extern "C" {
int scePthreadAttrDestroy(ScePthreadAttr *attr);
int scePthreadAttrGetstack(const ScePthreadAttr * __restrict attr,
   void ** __restrict stackAddr, size_t * __restrict stackSize);
int scePthreadAttrGetstacksize(const ScePthreadAttr *attr, size_t *stackSize);
int scePthreadAttrGetguardsize(const ScePthreadAttr *attr, size_t *guardSize);
int scePthreadAttrGetstackaddr(const ScePthreadAttr *attr, void **stackAddr);
int scePthreadAttrGetdetachstate(const ScePthreadAttr *attr, int *state);
int scePthreadAttrInit(ScePthreadAttr *attr);
int scePthreadAttrSetstacksize(ScePthreadAttr *attr, size_t stackSize);
int scePthreadAttrSetguardsize(ScePthreadAttr *attr, size_t guardSize);
int scePthreadAttrSetstack(ScePthreadAttr *attr, void *addr, size_t size);
int scePthreadAttrSetstackaddr(ScePthreadAttr *attr, void *addr);
int scePthreadAttrSetdetachstate(ScePthreadAttr *attr, int state);
int scePthreadBarrierDestroy(ScePthreadBarrier *barrier);
int scePthreadBarrierInit(ScePthreadBarrier *barrier,
   const ScePthreadBarrierattr *attr, unsigned count, const char *name);
int scePthreadBarrierWait(ScePthreadBarrier *barrier);
int scePthreadBarrierattrDestroy(ScePthreadBarrierattr *barrier);
int scePthreadBarrierattrInit(ScePthreadBarrierattr *barrier);
# 217 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_pthread.h" 3
int scePthreadCondattrDestroy(ScePthreadCondattr *attr);
int scePthreadCondattrInit(ScePthreadCondattr *attr);
int scePthreadCondBroadcast(ScePthreadCond *cond);
int scePthreadCondDestroy(ScePthreadCond *cond);
int scePthreadCondInit(ScePthreadCond *cond,
   const ScePthreadCondattr *attr, const char *name);
int scePthreadCondSignal(ScePthreadCond *cond);
int scePthreadCondSignalto(ScePthreadCond *cond, ScePthread thread);
int scePthreadCondTimedwait(ScePthreadCond *cond, ScePthreadMutex *mutex,
                        SceKernelUseconds usec);
int scePthreadCondWait(ScePthreadCond *cond, ScePthreadMutex *mutex);
int scePthreadCreate(ScePthread *thread, const ScePthreadAttr *attr,
                        void *(*entry) (void *), void *arg, const char *name);
int scePthreadDetach(ScePthread thread);
int scePthreadEqual(ScePthread thraed1, ScePthread thread2);
void scePthreadExit(void *value) __attribute__((__noreturn__));
void *scePthreadGetspecific(ScePthreadKey key);
int scePthreadGetcpuclockid(ScePthread thread, clockid_t *clock);
int scePthreadJoin(ScePthread thread, void **value);
int scePthreadKeyCreate(ScePthreadKey *key,
   void (*destructor) (void *));
int scePthreadKeyDelete(ScePthreadKey key);
int scePthreadMutexattrInit(ScePthreadMutexattr *attr);
int scePthreadMutexattrDestroy(ScePthreadMutexattr *attr);
int scePthreadMutexattrGettype(ScePthreadMutexattr *attr, int *type);
int scePthreadMutexattrSettype(ScePthreadMutexattr *attr, int type);
int scePthreadMutexDestroy(ScePthreadMutex *mutex);
int scePthreadMutexInit(ScePthreadMutex *mutex,
   const ScePthreadMutexattr *attr, const char *name);
int scePthreadMutexLock(ScePthreadMutex *mutex);
int scePthreadMutexTrylock(ScePthreadMutex *mutex);
int scePthreadMutexTimedlock(ScePthreadMutex *mutex, SceKernelUseconds usec);
int scePthreadMutexUnlock(ScePthreadMutex *mutex);
int scePthreadOnce(ScePthreadOnce *once, void (*init) (void));
int scePthreadRwlockDestroy(ScePthreadRwlock *rwlock);
int scePthreadRwlockInit(ScePthreadRwlock *rwlock,
   const ScePthreadRwlockattr *attr, const char *name);
int scePthreadRwlockRdlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockTimedrdlock(ScePthreadRwlock *rwlock, SceKernelUseconds usec);
int scePthreadRwlockTimedwrlock(ScePthreadRwlock *rwlock, SceKernelUseconds usec);
int scePthreadRwlockTryrdlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockTrywrlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockUnlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockWrlock(ScePthreadRwlock *rwlock);
int scePthreadRwlockattrDestroy(ScePthreadRwlockattr *attr);
int scePthreadRwlockattrInit(ScePthreadRwlockattr *attr);
int scePthreadRwlockattrGettype(ScePthreadRwlockattr *attr, int *type);
int scePthreadRwlockattrSettype(ScePthreadRwlockattr *attr, int type);
ScePthread scePthreadSelf(void);
int scePthreadSetspecific(ScePthreadKey key, const void *value);

int scePthreadCancel(ScePthread thread);
int scePthreadSetcancelstate(int state, int *oldState);
int scePthreadSetcanceltype(int type, int *oldType);
void scePthreadTestcancel(void);

int scePthreadGetprio(ScePthread thread, int *prio);
int scePthreadSetprio(ScePthread thread, int prio);
void scePthreadYield(void);

int scePthreadMutexattrGetprioceiling(ScePthreadMutexattr *attr,
   int *prio);
int scePthreadMutexattrSetprioceiling(ScePthreadMutexattr *attr,
   int prio);
int scePthreadMutexGetprioceiling(ScePthreadMutex *mutex, int *prio);
int scePthreadMutexSetprioceiling(ScePthreadMutex *mutex, int prio, int *oldPrio);

int scePthreadMutexattrGetprotocol(ScePthreadMutexattr *attr, int *protocol);
int scePthreadMutexattrSetprotocol(ScePthreadMutexattr *attr, int protocol);

int scePthreadAttrGetinheritsched(const ScePthreadAttr *attr, int *inheritSched);
int scePthreadAttrGetschedparam(const ScePthreadAttr *attr,
   SceKernelSchedParam *param);
int scePthreadAttrGetschedpolicy(const ScePthreadAttr *attr, int *policy);
int scePthreadAttrSetinheritsched(ScePthreadAttr *attr, int inheritSched);
int scePthreadAttrSetschedparam(ScePthreadAttr *attr,
   const SceKernelSchedParam *param);
int scePthreadAttrSetschedpolicy(ScePthreadAttr *attr, int policy);
int scePthreadGetschedparam(ScePthread thread, int *policy,
     SceKernelSchedParam *param);
int scePthreadSetschedparam(ScePthread thread, int policy,
     const SceKernelSchedParam *param);

int scePthreadSemInit(ScePthreadSem *sem, int flag, unsigned int value,
    const char *name);
int scePthreadSemDestroy(ScePthreadSem *sem);
int scePthreadSemTimedwait(ScePthreadSem *sem, SceKernelUseconds usec);
int scePthreadSemGetvalue(ScePthreadSem * __restrict sem, int * __restrict sval);
int scePthreadSemPost(ScePthreadSem *sem);
int scePthreadSemTrywait(ScePthreadSem *sem);
int scePthreadSemWait(ScePthreadSem *sem);


int scePthreadAttrGet(ScePthread thread, ScePthreadAttr *attr);
int scePthreadAttrGetaffinity(const ScePthreadAttr *attr, SceKernelCpumask *mask);
int scePthreadAttrSetaffinity(ScePthreadAttr *attr, const SceKernelCpumask mask);
int scePthreadGetaffinity(ScePthread thread, SceKernelCpumask *mask);
int scePthreadSetaffinity(ScePthread thread, const SceKernelCpumask mask);
int scePthreadGetthreadid(void);
int scePthreadRename(ScePthread thread, const char *name);
int scePthreadGetname(ScePthread thread, char *name);
int scePthreadAttrGetsolosched(const ScePthreadAttr *attr, int *solosched);
int scePthreadAttrSetsolosched(ScePthreadAttr *attr, int solosched);

}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_iovec.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_iovec.h" 3
struct iovec {
 void *iov_base;
 size_t iov_len;
};
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 2 3




enum uio_rw { UIO_READ, UIO_WRITE };


enum uio_seg {
 UIO_USERSPACE,
 UIO_SYSSPACE,
 UIO_NOCOPY
};
# 112 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/uio.h" 3
extern "C" {
ssize_t readv(int, const struct iovec *, int);
ssize_t writev(int, const struct iovec *, int);

ssize_t preadv(int, const struct iovec *, int, off_t);
ssize_t pwritev(int, const struct iovec *, int, off_t);

}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/stat.h" 1 3
# 122 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/stat.h" 3
struct stat {
 __dev_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 uid_t st_uid;
 gid_t st_gid;
 __dev_t st_rdev;
 struct timespec st_atim;
 struct timespec st_mtim;
 struct timespec st_ctim;
 off_t st_size;
 blkcnt_t st_blocks;
 blksize_t st_blksize;
 fflags_t st_flags;
 __uint32_t st_gen;
 __int32_t st_lspare;
 struct timespec st_birthtim;
# 148 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/stat.h" 3
 unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
 unsigned int :(8 / 2) * (16 - (int)sizeof(struct timespec));
};
# 329 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/stat.h" 3
extern "C" {

int chflags(const char *, unsigned long);
int chflagsat(int, const char *, unsigned long, int);

int chmod(const char *, mode_t);

int fchflags(int, unsigned long);


int fchmod(int, mode_t);


int fchmodat(int, const char *, mode_t, int);
int futimens(int fd, const struct timespec times[2]);
int utimensat(int fd, const char *path, const struct timespec times[2],
  int flag);

int fstat(int, struct stat *);

int lchflags(const char *, unsigned long);
int lchmod(const char *, mode_t);


int lstat(const char * __restrict, struct stat * __restrict);

int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);

int mknod(const char *, mode_t, dev_t);


int stat(const char * __restrict, struct stat * __restrict);
mode_t umask(mode_t);

int fstatat(int, const char *, struct stat *, int);
int mkdirat(int, const char *, mode_t);
int mkfifoat(int, const char *, mode_t);


int mknodat(int, const char *, mode_t, dev_t);

}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dirent.h" 1 3
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/dirent.h" 3
struct dirent {
 __uint32_t d_fileno;
 __uint16_t d_reclen;
 __uint8_t d_type;
 __uint8_t d_namlen;


 char d_name[255 + 1];



};
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 1 3
# 38 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/fcntl.h" 1 3
# 281 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/fcntl.h" 3
struct flock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
 int l_sysid;
};






struct __oflock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
};
# 325 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/fcntl.h" 3
extern "C" {
int open(const char *, int, ...);
int creat(const char *, mode_t);
int fcntl(int, int, ...);

int flock(int, int);


int openat(int, const char *, int, ...);


int posix_fadvise(int, off_t, off_t, int);
int posix_fallocate(int, off_t, off_t);

}
# 39 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/unistd.h" 1 3
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 2 3
# 224 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/file.h" 3
struct xfile {
 size_t xf_size;
 pid_t xf_pid;
 uid_t xf_uid;
 int xf_fd;
 void *xf_file;
 short xf_type;
 int xf_count;
 int xf_msgcount;
 off_t xf_offset;
 void *xf_data;
 void *xf_vnode;
 u_int xf_flag;
};
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/mman.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/mman.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/ioccom.h" 1 3
# 71 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/ioccom.h" 3
enum {
    SCE_SYS_DEV_IOCTL_BASE = (127),
    SCE_SYS_DMEM_IOCTL_BASE,
    SCE_SYS_GC_IOCTL_BASE,
    SCE_SYS_DCE_IOCTL_BASE,
    SCE_SYS_UVD_IOCTL_BASE,
    SCE_SYS_VCE_IOCTL_BASE,
    SCE_SYS_DBGGC_IOCTL_BASE,
    SCE_SYS_TWSI_IOCTL_BASE,
    SCE_SYS_MDBG_IOCTL_BASE,
    SCE_SYS_DEVENV_IOCTL_BASE,
    SCE_SYS_AJM_IOCTL_BASE,
    SCE_SYS_TRACE_IOCTL_BASE,
    SCE_SYS_IBS_IOCTL_BASE,
    SCE_SYS_MBUS_IOCTL_BASE,
    SCE_SYS_HDMI_IOCTL_BASE,
    SCE_SYS_CAMERA_IOCTL_BASE,
    SCE_SYS_FAN_IOCTL_BASE,
    SCE_SYS_THERMAL_IOCTL_BASE,
 SCE_SYS_PFS_IOCTL_BASE,
    SCE_SYS_ICC_CONFIG_IOCTL_BASE,
    SCE_SYS_IPC_IOCTL_BASE,
    SCE_SYS_IOSCHED_IOCTL_BASE,
    SCE_SYS_ICC_INDICATOR_IOCTL_BASE,
    SCE_SYS_EXFATFS_IOCTL_BASE,
    SCE_SYS_ICC_NVS_IOCTL_BASE,
    SCE_SYS_DVE_IOCTL_BASE,
    SCE_SYS_ICC_POWER_IOCTL_BASE,
    SCE_SYS_AV_CONTROL_IOCTL_BASE,
    SCE_SYS_ICC_SC_CONFIGURATION_IOCTL_BASE,
    SCE_SYS_ICC_DEVICE_POWER_IOCTL_BASE,
    SCE_SYS_SSHOT_IOCTL_BASE,
    SCE_SYS_DCE_SCANIN_IOCTL_BASE,
    SCE_SYS_FSCTRL_IOCTL_BASE,
    SCE_SYS_HMD_IOCTL_BASE,
    SCE_SYS_SHM_IOCTL_BASE,
    SCE_SYS_PHYSHM_IOCTL_BASE,
    SCE_SYS_HMDDFU_IOCTL_BASE,
    SCE_SYS_BLUETOOTH_HID_IOCTL_BASE,
    SCE_SYS_SBI_IOCTL_BASE,
    SCE_SYS_S3DA_IOCTL_BASE,
    SCE_SYS_SPM_IOCTL_BASE,
    SCE_SYS_BLOCKPOOL_IOCTL_BASE,
    SCE_SYS_SDK_EVENTLOG_IOCTL_BASE,
    SCE_SYS_DRFS_IOCTL_BASE,
    SCE_SYS_ACM_IOCTL_BASE,
    SCE_SYS_A53MM_IOCTL_BASE,
    SCE_SYS_AMM_TRACE_IOCTL_BASE,
    SCE_SYS_MP1_IOCTL_BASE,
    SCE_SYS_CPUKNOB_IOCTL_BASE,
    SCE_SYS_DEVPFS_IOCTL_BASE,
    SCE_SYS_DBGGC_WFDEBUG_IOCTL_BASE,
    SCE_SYS_GBASE_IOCTL_BASE,
    SCE_SYS_IOCONTROLLER_TRACE_IOCTL_BASE,
    SCE_SYS_MP3_IOCTL_BASE,
    SCE_SYS_A53MMSYS_IOCTL_BASE,
    SCE_SYS_SWAPDEV_IOCTL_BASE,
    SCE_SYS_ICC_FLOYD_IOCTL_BASE,
    SCE_SYS_PM_TRACE_IOCTL_BASE,
    SCE_SYS_USBC_IOCTL_BASE,
    SCE_SYS_GVMLOG_IOCTL_BASE,
    SCE_SYS_NAPR_TRACE_IOCTL_BASE,
    SCE_SYS_HMD2_IOCTL_BASE,
    SCE_SYS_APR_IOCTL_BASE,
    SCE_SYS_MP4_MDBG_IOCTL_BASE,
    SCE_SYS_WORKSPACE_IOCTL_BASE,
    SCE_SYS_MP1_BAPMLOG_IOCTL_BASE,
    SCE_SYS_ICC_CRASH_REPORT_IOCTL_BASE,
    SCE_SYS_ICC_CPBOX_IOCTL_BASE,
    SCE_SYS_ICC_HDMI_IOCTL_BASE,
    SCE_SYS_ICC_BDDRIVE_IOCTL_BASE,
    SCE_SYS_DFSPM_IOCTL_BASE,
 SCE_SYS_CORESPM_IOCTL_BASE,

};
# 158 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/ioccom.h" 3
extern "C" {
int ioctl(int, unsigned long, ...);
}
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/mman.h" 2 3
# 386 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/mman.h" 3
extern "C" {





int getpagesizes(size_t *, int);
int madvise(void *, size_t, int);
int mincore(const void *, size_t, char *);
int minherit(void *, size_t, int);

int mlock(const void *, size_t);




int mprotect(const void *, size_t, int);
int msync(void *, size_t, int);
int munlock(const void *, size_t);
int munmap(void *, size_t);

int posix_madvise(void *, size_t, int);


int mlockall(int);
int munlockall(void);
int shm_open(const char *, int, mode_t);
int shm_unlink(const char *);

int physhm_open(const char *, int, mode_t, int);
int physhm_unlink(const char *);
void *mmap_dmem(void *, size_t, int, int, int, off_t);
void *mmap2(void *, size_t, int, int, long, int, off_t);

}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\fcntl.h" 1 3
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 2 3
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 3
typedef struct iovec SceKernelIovec;
typedef struct stat SceKernelStat;
typedef struct dirent SceKernelDirent;
typedef mode_t SceKernelMode;

extern "C" {

ssize_t sceKernelRead(int d, void *buf, size_t nbytes);
ssize_t sceKernelWrite(int d, const void *buf, size_t nbytes);
int sceKernelOpen(const char *path, int flags, SceKernelMode mode);
int sceKernelClose(int d);
int sceKernelUnlink(const char *path);
int sceKernelChmod(const char *path, SceKernelMode mode);
int sceKernelCheckReachability(const char *path);
void sceKernelSync(void);
int sceKernelFsync(int fd);
int sceKernelFdatasync(int fd);
int sceKernelFcntl(int fd, int cmd, ...);
ssize_t sceKernelReadv(int d, const SceKernelIovec *iov, int iovcnt);
ssize_t sceKernelWritev(int d, const SceKernelIovec *iov, int iovcnt);
int sceKernelFchmod(int fd, SceKernelMode mode);
int sceKernelRename(const char *from, const char *to);
int sceKernelMkdir(const char *path, SceKernelMode mode);
int sceKernelRmdir(const char *path);
int sceKernelUtimes(const char *path, const SceKernelTimeval *times);
int sceKernelStat(const char *path, SceKernelStat *sb);
int sceKernelFstat(int fd, SceKernelStat *sb);
int sceKernelFutimes(int fd, const SceKernelTimeval *times);
int sceKernelGetdirentries(int fd, char *buf, int nbytes, long *basep);
int sceKernelGetdents(int fd, char *buf, int nbytes);
ssize_t sceKernelPreadv(int d, const SceKernelIovec *iov, int iovcnt, off_t offset);
ssize_t sceKernelPwritev(int d, const SceKernelIovec *iov, int iovcnt, off_t offset);
ssize_t sceKernelPread(int d, void *buf, size_t nbytes, off_t offset);
ssize_t sceKernelPwrite(int d, const void *buf, size_t nbytes, off_t offset);
int sceKernelMmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset,
        void **res);
off_t sceKernelLseek(int fildes, off_t offset, int whence);
int sceKernelTruncate(const char *path, off_t length);
int sceKernelFtruncate(int fd, off_t length);
int sceKernelSetCompressionAttribute(int fd, int flag);
int sceKernelLwfsSetAttribute(int fd, int flags);
int sceKernelLwfsAllocateBlock(int fd, off_t size);
int sceKernelLwfsTrimBlock(int fd, off_t size);
off_t sceKernelLwfsLseek(int fd, off_t offset, int whence);
ssize_t sceKernelLwfsWrite(int fd, const void *buf, size_t nbytes);
# 160 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 3
typedef struct SceKernelAioResult {
 int64_t returnValue;
 uint32_t state;
} SceKernelAioResult;
# 189 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/_fs.h" 3
typedef struct SceKernelAioSchedulingParam {
 int schedulingWindowSize;
 int delayedCountLimit;
 uint32_t enableSplit;
 uint32_t splitSize;
 uint32_t splitChunkSize;
} SceKernelAioSchedulingParam;

typedef struct SceKernelAioParam {
 SceKernelAioSchedulingParam low;
 SceKernelAioSchedulingParam mid;
 SceKernelAioSchedulingParam high;
} SceKernelAioParam;

typedef int SceKernelAioSubmitId;

int sceKernelAioDeleteRequests(SceKernelAioSubmitId id[], int num, int ret[]);

int sceKernelAioDeleteRequest(SceKernelAioSubmitId id, int *ret);

int sceKernelAioWaitRequests(SceKernelAioSubmitId id[],
        int num,
        int state[],
        uint32_t mode,
        SceKernelUseconds *usec);

int sceKernelAioWaitRequest(SceKernelAioSubmitId id,
       int *state,
       SceKernelUseconds *usec);

int sceKernelAioInitialize(SceKernelAioParam* param);

int sceKernelAioInitializeImpl(void* p, int size);


int sceKernelAioCancelRequests(SceKernelAioSubmitId id[], int num, int state[]);

int sceKernelAioCancelRequest(SceKernelAioSubmitId id, int *state);

int sceKernelAioPollRequest(SceKernelAioSubmitId id,
       int *state);

int sceKernelAioPollRequests(SceKernelAioSubmitId id[],
        int num,
        int state[]);



typedef struct SceKernelAioRWRequest {
 off_t offset;
 size_t nbyte;
 void* buf;
 struct SceKernelAioResult *result;
 int fd;
} SceKernelAioRWRequest;

int sceKernelAioSubmitReadCommands(SceKernelAioRWRequest req[],
           int size,
           int prio,
           SceKernelAioSubmitId *id);

int sceKernelAioSubmitReadCommandsMultiple(SceKernelAioRWRequest req[],
             int size,
             int prio,
             SceKernelAioSubmitId id[]);

int sceKernelAioSubmitWriteCommands(SceKernelAioRWRequest req[],
         int size,
         int prio,
         SceKernelAioSubmitId *id);

int sceKernelAioSubmitWriteCommandsMultiple(SceKernelAioRWRequest req[],
           int size,
           int prio,
           SceKernelAioSubmitId id[]);


void sceKernelAioInitializeParam(SceKernelAioParam* param);

int sceKernelAioSetParam(SceKernelAioSchedulingParam* param,
       int schedulingWindowSize,
       int delayedCountLimit,
       uint32_t enableSplit,
       uint32_t splitSize,
       uint32_t splitChunkSize);


int apr_submit(void* buf,
      size_t nelem, int prio, int type,
      void *res,
      uint32_t *sidp);
int apr_resolve(void *pre, void *path,
  size_t len, void *ids, void *size, uint32_t *erridx,
  int *results, int *nresolved);
int apr_stat(void *id, size_t idlen, void *st);
int apr_wait(void *ids, size_t idlen);
int apr_ctrl(int cmd, void* arg, size_t size, void* rsv1, int rsv2);
int sceKernelAprCtrl(int cmd, void* arg, size_t size, void* rsv1, int rsv2);

int ampr_ctrl_debug(int cmd, void* arg, size_t size, void* rsv1, int rsv2);

int sceKernelStreamWriteCreate(size_t size, int *stream_id);
int sceKernelStreamWriteDelete(int stream_id);
typedef struct SceKernelStreamWriteStatus {
 int64_t size;
 int64_t reserved0;
 int64_t tail_offset;
 int64_t stored_size;
 int64_t reserved1[4];
} SceKernelStreamWriteStatus;
int sceKernelStreamWriteStat(int stream_id, SceKernelStreamWriteStatus *status);
int sceKernelStreamWriteActivate(int stream_id, int flags);
int sceKernelStreamWriteWrite(int stream_id,
         const void *buf, size_t size, int flags,
         off_t *written_offset, size_t *stored_size);
int sceKernelStreamWriteRead(int stream_id,
        void *buf, size_t size, off_t offset, int flags);
int sceKernelStreamWriteDeactivate(int stream_id, int flags);

int workspace_ctrl(int cmd, void* arg, size_t size, void* rsv1, int rsv2);

typedef struct SceKernelAioRequestInfo {
 int fd;
 size_t size;
 off_t offset;
} SceKernelAioRequestInfo;

typedef struct SceKernelAioSubmitInfo {
 SceKernelAioSubmitId id;
 int status;
 int priority;
 int cmd;
} SceKernelAioSubmitInfo;

int sceKernelGetAioDebugRequestInfo(
 pid_t pid,
 SceKernelAioSubmitId id,
 SceKernelAioRequestInfo *info,
 int num,
 int *stored_num
);

int sceKernelGetAioDebugSubmitInfo(
 pid_t pid,
 SceKernelAioSubmitInfo *info,
 int num,
 int *stored_num
);

int get_aio_debug_submit_info(int pid, SceKernelAioSubmitInfo* info, int num, int *stored_num);
int get_aio_debug_request_info(int pid, int id, SceKernelAioRequestInfo* info, int num, int *stored_num);

}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/eventflag.h" 1 3
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/eventflag.h" 3
typedef struct _SceKernelEventFlagOptParam {
 size_t size;
} SceKernelEventFlagOptParam;

typedef struct _SceKernelEventFlag* SceKernelEventFlag;




extern "C" {

int sceKernelCreateEventFlag(SceKernelEventFlag *ef, const char *pName,
        uint32_t attr, uint64_t initPattern,
        const SceKernelEventFlagOptParam *pOptParam);
int sceKernelDeleteEventFlag(SceKernelEventFlag ef);
int sceKernelWaitEventFlag(SceKernelEventFlag ef, uint64_t bitPattern,
      uint32_t waitMode, uint64_t *pResultPat,
      SceKernelUseconds *pTimeout);
int sceKernelPollEventFlag(SceKernelEventFlag ef, uint64_t bitPattern,
      uint32_t waitMode, uint64_t *pResultPat);
int sceKernelSetEventFlag(SceKernelEventFlag ef, uint64_t bitPattern);
int sceKernelClearEventFlag(SceKernelEventFlag ef, uint64_t bitPattern);
int sceKernelCancelEventFlag(SceKernelEventFlag ef, uint64_t setPattern,
        int *pNumWaitThreads);

}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/semaphore.h" 1 3
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/semaphore.h" 3
typedef struct _SceKernelSemaOptParam {
 size_t size;
} SceKernelSemaOptParam;

typedef struct _SceKernelSema* SceKernelSema;




extern "C" {

int sceKernelCreateSema(SceKernelSema *sem, const char *name, uint32_t attr,
   int init, int max, const SceKernelSemaOptParam *opt);
int sceKernelDeleteSema(SceKernelSema sem);
int sceKernelWaitSema(SceKernelSema sem, int need, SceKernelUseconds *timo);
int sceKernelPollSema(SceKernelSema sem, int need);
int sceKernelSignalSema(SceKernelSema sem, int count);
int sceKernelCancelSema(SceKernelSema sem, int count, int *threads);

}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/equeue.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/equeue.h" 3
extern "C" {

typedef struct _SceKernelEqueue* SceKernelEqueue;
typedef struct kevent SceKernelEvent;
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/equeue.h" 3
int sceKernelGetEventFilter(const SceKernelEvent *ev);
uintptr_t sceKernelGetEventId(const SceKernelEvent *ev);
intptr_t sceKernelGetEventData(const SceKernelEvent *ev);
unsigned int sceKernelGetEventFflags(const SceKernelEvent *ev);
int sceKernelGetEventError(const SceKernelEvent *ev);
void * sceKernelGetEventUserData(const SceKernelEvent *ev);

int sceKernelCreateEqueue(SceKernelEqueue *eq, const char *name);
int sceKernelDeleteEqueue(SceKernelEqueue eq);
int sceKernelWaitEqueue(SceKernelEqueue eq, SceKernelEvent *ev, int num,
   int *out, SceKernelUseconds *timo);

int sceKernelAddTimerEvent(SceKernelEqueue eq, int id, SceKernelUseconds usec, void *udata);
int sceKernelDeleteTimerEvent(SceKernelEqueue eq, int id);
int sceKernelAddReadEvent(SceKernelEqueue eq, int fd, size_t size, void *udata);
int sceKernelDeleteReadEvent(SceKernelEqueue eq, int fd);
int sceKernelAddWriteEvent(SceKernelEqueue eq, int fd, size_t size, void *udata);
int sceKernelDeleteWriteEvent(SceKernelEqueue eq, int fd);
int sceKernelAddFileEvent(SceKernelEqueue eq, int fd, int watch, void *udata);
int sceKernelDeleteFileEvent(SceKernelEqueue eq, int fd);
int sceKernelAddUserEvent(SceKernelEqueue eq, int id);
int sceKernelAddUserEventEdge(SceKernelEqueue eq, int id);
int sceKernelDeleteUserEvent(SceKernelEqueue eq, int id);
int sceKernelTriggerUserEvent(SceKernelEqueue eq, int id, void *udata);
int sceKernelAddHRTimerEvent(SceKernelEqueue eq, int id, SceKernelTimespec *ts, void *udata);
int sceKernelDeleteHRTimerEvent(SceKernelEqueue eq, int id);
int sceKernelAddAmprEvent(SceKernelEqueue eq, int id, void *udata);
int sceKernelDeleteAmprEvent(SceKernelEqueue eq, int id);
int sceKernelAddAmprSystemEvent(SceKernelEqueue eq, int id, int watch, void *udata);
int sceKernelDeleteAmprSystemEvent(SceKernelEqueue eq, int id);

}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/uuid.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/uuid.h" 3
extern "C" {

typedef struct {
    uint32_t timeLow;
    uint16_t timeMid;
    uint16_t timeHiAndVersion;
    uint8_t clockSeqHiAndReserved;
    uint8_t clockSeqLow;
    uint8_t node[6];
} SceKernelUuid;

int sceKernelUuidCreate(SceKernelUuid* outUuid);

}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/memory.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include/kernel/memory.h" 3
extern "C" {

int32_t sceKernelAvailableFlexibleMemorySize(size_t *sizeOut);
int32_t sceKernelConfiguredFlexibleMemorySize(size_t *sizeOut);

}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\kernel.h" 2 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\inttypes.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 2 3
# 45 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 3
typedef _Ptrdifft ptrdiff_t;
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 3
typedef decltype(nullptr) nullptr_t;





typedef float max_align_t __attribute__((__vector_size__ (32) ));
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 2 3






# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\strings.h" 1 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\strings.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 42 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\strings.h" 2 3
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\strings.h" 3
extern "C" {

int bcmp(const void *, const void *, size_t) __attribute__((__pure__));
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);

}
# 56 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 2 3
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
extern "C" {
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
int strcmp(const char *, const char *);
char *strcpy(char *, const char *);
size_t strlen(const char *);

void *memmove(void *, const void *, size_t);
int strcoll(const char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int);
int strerror_r(int, char *, size_t);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
size_t strspn(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);


char *strdup(const char *);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
char *strtok_r(char *, const char *, char **);


}





extern "C" {
const char *strchr(const char *, int);
const char *strpbrk(const char *, const char *);
const char *strrchr(const char *, int);
const char *strstr(const char *, const char *);
}

extern "C++" {
inline char *strchr(char *_Str, int _Ch)
 {
 return ((char *):: strchr((const char *)_Str, _Ch));
 }

inline char *strpbrk(char *_Str1, const char *_Str2)
 {
 return ((char *):: strpbrk((const char *)_Str1, _Str2));
 }

inline char *strrchr(char *_Str, int _Ch)
 {
 return ((char *):: strrchr((const char *)_Str, _Ch));
 }

inline char *strstr(char *_Str1, const char *_Str2)
 {
 return ((char *):: strstr((const char *)_Str1, _Str2));
 }
}
# 143 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
extern "C" {
const void *memchr(const void *, int, size_t);
}

extern "C++" {
inline void *memchr(void *_Str, int _Ch, size_t _Num)
 {
 return ((void *):: memchr((const void *)_Str, _Ch, _Num));
 }
}
# 163 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
extern "C" {

errno_t memcpy_s(void *, rsize_t,
 const void *, rsize_t);
errno_t memmove_s(void *, rsize_t,
 const void *, rsize_t);
errno_t memset_s(void *, rsize_t, int, rsize_t);

errno_t strcpy_s(char *, rsize_t,
 const char *);
errno_t strncpy_s(char *, rsize_t,
 const char *, rsize_t);
errno_t strcat_s(char *, rsize_t,
 const char *);
errno_t strncat_s(char *, rsize_t,
 const char *, rsize_t);
char *strtok_s(char *, rsize_t *,
 const char *, char **);

errno_t strerror_s(char *, rsize_t, errno_t);
size_t strerrorlen_s(errno_t);

size_t strnlen_s(const char *, size_t);
}



extern "C++" {

template<rsize_t _Size>
errno_t strcat_s(char (&_Str1)[_Size], const char *_Str2)
 {
 return strcat_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t strcpy_s(char (&_Str1)[_Size], const char *_Str2)
 {
 return strcpy_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t strerror_s(char (&_Str)[_Size], errno_t _Errcode)
 {
 return strerror_s(_Str, _Size, _Errcode);
 }

template<rsize_t _Size>
errno_t strncat_s(char (&_Str1)[_Size], const char *_Str2, rsize_t _Num)
 {
 return strncat_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t strncpy_s(char (&_Str1)[_Size], const char *_Str2, rsize_t _Num)
 {
 return strncpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t memcpy_s(char (&_Dst)[_Size], const char *_Src, rsize_t _Num)
 {
 return memcpy_s(_Dst, _Size, _Src, _Num);
 }

template<rsize_t _Size>
errno_t memmove_s(char (&_Dst)[_Size], const char *_Src, rsize_t _Num)
 {
 return memmove_s(_Dst, _Size, _Src, _Num);
 }

template<size_t _Size>
size_t strnlen_s(const char (&_Str)[_Size])
 {
 return strnlen_s(_Str, _Size);
 }

}
# 292 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string.h" 3
extern "C" {

size_t strlcat(char * __restrict, const char * __restrict, size_t);
size_t strlcpy(char * __restrict, const char * __restrict, size_t);


char *strndup(const char *, size_t) __attribute__((__malloc__));
size_t strnlen(const char *, size_t) __attribute__((__pure__));


char *strnstr(const char *, const char *, size_t) __attribute__((__pure__));

}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_api.h" 2 3




typedef struct SceUserServiceInitializeParams {
 int32_t priority;
} SceUserServiceInitializeParams;



typedef enum SceUserServiceEventType {
 SCE_USER_SERVICE_EVENT_TYPE_LOGIN = 0,
 SCE_USER_SERVICE_EVENT_TYPE_LOGOUT
} SceUserServiceEventType;



typedef struct SceUserServiceEvent {
 SceUserServiceEventType eventType;
 SceUserServiceUserId userId;
} SceUserServiceEvent;



typedef struct SceUserServiceLoginUserIdList {
    SceUserServiceUserId userId[(4)];
} SceUserServiceLoginUserIdList;



typedef struct SceUserServiceGamePresets {
 size_t thisSize;
 uint32_t difficulty;
 uint32_t priority;
 uint32_t invertVerticalViewFor1stPersonView;
 uint32_t invertHorizontalViewFor1stPersonView;
 uint32_t invertVerticalViewFor3rdPersonView;
 uint32_t invertHorizontalViewFor3rdPersonView;
 uint32_t displaySubTitles;
 uint32_t audioLanguage;
 uint32_t joinableUserType;
 uint32_t invitableUserType;
} SceUserServiceGamePresets;



extern "C" {




int32_t sceUserServiceInitialize(const SceUserServiceInitializeParams *initParams);



int32_t sceUserServiceInitialize2(int threadPriority, SceKernelCpumask cpuAffinityMask);



int32_t sceUserServiceTerminate();



int32_t sceUserServiceGetLoginUserIdList(SceUserServiceLoginUserIdList *userIdList);



int32_t sceUserServiceGetEvent(SceUserServiceEvent *event);



int32_t sceUserServiceGetInitialUser(SceUserServiceUserId *userId);



int32_t sceUserServiceGetUserName(const SceUserServiceUserId userId, char *userName, const size_t size);



int32_t sceUserServiceGetUserNumber(const SceUserServiceUserId userId, int32_t *number);



static inline
void sceUserServiceGamePresetsInitialize(SceUserServiceGamePresets *presets)
{
 memset(presets, 0x0, sizeof(SceUserServiceGamePresets));
 presets->thisSize = sizeof(SceUserServiceGamePresets);
}



int32_t sceUserServiceGetGamePresets(SceUserServiceUserId userId, SceUserServiceGamePresets *presets);



int32_t sceUserServiceGetAgeLevel(SceUserServiceUserId userId, uint32_t *ageLevel);



int32_t sceUserServiceGetAccessibilityChatTranscription(SceUserServiceUserId userId, int32_t *chatTranscription);



int32_t sceUserServiceGetAccessibilityPressAndHoldDelay(SceUserServiceUserId userId, int32_t *pressAndHoldDelay);



int32_t sceUserServiceGetAccessibilityTriggerEffect(SceUserServiceUserId userId, int32_t *triggerEffect);



int32_t sceUserServiceGetAccessibilityVibration(SceUserServiceUserId userId, int32_t *vibration);



int32_t sceUserServiceGetAccessibilityZoomEnabled(SceUserServiceUserId userId, int32_t *zoomEnabled);



int32_t sceUserServiceGetAccessibilityZoomFollowFocus(SceUserServiceUserId userId, int32_t *zoomFollowFocus);


}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service/user_service_error.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\user_service.h" 2 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 2 3
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef int32_t SceSaveDataTransactionResourceId;







typedef uint32_t SceSaveDataMountMode;
# 73 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataMountStatus;






typedef uint32_t SceSaveDataUmountMode;
# 92 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataPrepareMode;
# 106 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataCommitMode;







typedef uint32_t SceSaveDataParamType;
# 131 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataSortKey;
# 146 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataSortOrder;
# 171 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint64_t SceSaveDataBlocks;
# 198 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataSaveDataMemoryOption;
# 207 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataMemorySyncOption;
# 233 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef uint32_t SceSaveDataEventType;
# 260 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_defs.h" 3
typedef struct SceSaveDataTitleId {
 char data[(10)];

 char padding[6];

} SceSaveDataTitleId;




typedef struct SceSaveDataDirName {
 char data[(32)];

} SceSaveDataDirName;




typedef struct SceSaveDataMountPoint {
 char data[(16)];

} SceSaveDataMountPoint;




typedef struct SceSaveDataFingerprint {
 char data[(65)];

 char padding[15];

} SceSaveDataFingerprint;




typedef struct _SceSaveDataInitParams3 SceSaveDataInitParams3;




typedef struct SceSaveDataMount3 {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataDirName *dirName;

 SceSaveDataBlocks blocks;

 SceSaveDataBlocks systemBlocks;

 SceSaveDataMountMode mountMode;

 int :32;

 SceSaveDataTransactionResourceId resource;

 uint8_t reserved[32];

} SceSaveDataMount3;




typedef struct SceSaveDataTransferringMount {
 SceUserServiceUserId userId;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 const SceSaveDataFingerprint *fingerprint;

 uint8_t reserved[32];

} SceSaveDataTransferringMount;




typedef struct SceSaveDataMountResult {
 SceSaveDataMountPoint mountPoint;

 SceSaveDataBlocks requiredBlocks;

 uint32_t unused;

 SceSaveDataMountStatus mountStatus;

 uint8_t reserved[28];

 int :32;

} SceSaveDataMountResult;




typedef struct SceSaveDataPrepareParam {
 SceSaveDataTransactionResourceId resource;

 SceSaveDataPrepareMode prepareMode;

 uint8_t reserved[32];

} SceSaveDataPrepareParam;




typedef struct SceSaveDataCommitParam {
 SceSaveDataTransactionResourceId resource;

 SceSaveDataCommitMode commitMode;

 uint8_t reserved[32];

} SceSaveDataCommitParam;




typedef struct SceSaveDataMountInfo {
 SceSaveDataBlocks blocks;

 SceSaveDataBlocks freeBlocks;

 uint8_t reserved[32];

} SceSaveDataMountInfo;




typedef struct SceSaveDataIcon {
 void *buf;

 size_t bufSize;

 size_t dataSize;

 uint8_t reserved[32];

} SceSaveDataIcon;




typedef struct SceSaveDataParam {
 char title[(128)];

 char subTitle[(128)];


 char detail[(1024)];


 uint32_t userParam;

 int :32;

 time_t mtime;

 uint8_t reserved[32];

} SceSaveDataParam;




typedef struct SceSaveDataDelete {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 uint32_t unused;

 uint8_t reserved[32];

 int :32;

} SceSaveDataDelete;




typedef struct SceSaveDataSearchInfo {
 SceSaveDataBlocks blocks;

 SceSaveDataBlocks freeBlocks;

 uint8_t reserved[32];

} SceSaveDataSearchInfo;




typedef struct SceSaveDataDirNameSearchCond {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 SceSaveDataSortKey key;

 SceSaveDataSortOrder order;

 uint8_t reserved[32];

} SceSaveDataDirNameSearchCond;




typedef struct SceSaveDataDirNameSearchResult {
 uint32_t hitNum;

 int :32;

 SceSaveDataDirName *dirNames;

 uint32_t dirNamesNum;

 uint32_t setNum;

 SceSaveDataParam *params;

 SceSaveDataSearchInfo *infos;

 uint8_t reserved[12];

 int :32;

} SceSaveDataDirNameSearchResult;




typedef struct SceSaveDataConvert {
 SceUserServiceUserId userId;

 int : 32;

 const SceSaveDataDirName *srcDirName;

 const SceSaveDataDirName *dstDirName;

 uint8_t reserved[32];

} SceSaveDataConvert;



typedef struct SceSaveDataMemorySync {
 SceUserServiceUserId userId;

 uint32_t slotId;

 SceSaveDataMemorySyncOption option;

 uint8_t reserved[28];

} SceSaveDataMemorySync;




typedef struct SceSaveDataMemoryData
{
 void *buf;

 size_t bufSize;

 off_t offset;

 uint8_t reserved[40];

} SceSaveDataMemoryData;




typedef struct SceSaveDataMemorySetup2
{
 SceSaveDataSaveDataMemoryOption option;

 SceUserServiceUserId userId;

 size_t memorySize;

 size_t iconMemorySize;

 const SceSaveDataParam *initParam;

 const SceSaveDataIcon *initIcon;

 uint32_t slotId;

 uint8_t reserved[20];

} SceSaveDataMemorySetup2;



typedef struct SceSaveDataMemorySetupResult
{
 size_t existedMemorySize;

 uint8_t reserved[16];

} SceSaveDataMemorySetupResult;




typedef struct SceSaveDataMemoryGet2
{
 SceUserServiceUserId userId;

 uint8_t padding[4];

 SceSaveDataMemoryData *data;

 SceSaveDataParam *param;

 SceSaveDataIcon *icon;

 uint32_t slotId;

 uint8_t reserved[28];

} SceSaveDataMemoryGet2;




typedef struct SceSaveDataMemorySet2
{
 SceUserServiceUserId userId;

 uint8_t padding[4];

 const SceSaveDataMemoryData *data;

 const SceSaveDataParam *param;

 const SceSaveDataIcon *icon;

 uint32_t dataNum;

 uint32_t slotId;

 uint8_t reserved[24];

} SceSaveDataMemorySet2;




typedef struct _SceSaveDataEventParam SceSaveDataEventParam;




typedef struct SceSaveDataEvent {
 SceSaveDataEventType type;

 int32_t errorCode;

 SceUserServiceUserId userId;

 uint8_t padding[4];

 SceSaveDataTitleId titleId;

 SceSaveDataDirName dirName;

 uint8_t reserved[40];

} SceSaveDataEvent;




typedef struct SceSaveDataBackup {
 SceUserServiceUserId userId;

 int :32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 const SceSaveDataFingerprint *fingerprint;

 uint8_t reserved[32];

} SceSaveDataBackup;
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_api.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_api.h" 3
extern "C" {
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data/save_data_api.h" 3
int32_t sceSaveDataInitialize3(const SceSaveDataInitParams3 *initParam);



int32_t sceSaveDataTerminate();



int32_t sceSaveDataCreateTransactionResource(uint32_t size);



int32_t sceSaveDataDeleteTransactionResource(SceSaveDataTransactionResourceId resource);



int32_t sceSaveDataMount3(const SceSaveDataMount3 *mount, SceSaveDataMountResult *mountResult);



int32_t sceSaveDataTransferringMount(const SceSaveDataTransferringMount *mount, SceSaveDataMountResult *mountResult);



int32_t sceSaveDataUmount2(SceSaveDataUmountMode mode, const SceSaveDataMountPoint *mountPoint);



int32_t sceSaveDataPrepare(const SceSaveDataMountPoint *mountPoint, const SceSaveDataPrepareParam *param);



int32_t sceSaveDataCommit(const SceSaveDataCommitParam *param);



int32_t sceSaveDataCancel(SceSaveDataTransactionResourceId resource);



int32_t sceSaveDataGetMountInfo(const SceSaveDataMountPoint *mountPoint, SceSaveDataMountInfo *info);



int32_t sceSaveDataDelete(const SceSaveDataDelete *del);



int32_t sceSaveDataDirNameSearch(const SceSaveDataDirNameSearchCond *cond, SceSaveDataDirNameSearchResult *result);



int32_t sceSaveDataDirNameSearch2(const SceSaveDataDirNameSearchCond *cond, SceSaveDataDirNameSearchResult *result);



int32_t sceSaveDataSetParam(const SceSaveDataMountPoint *mountPoint,
       SceSaveDataParamType paramType,
       const void *paramBuf, size_t paramBufSize);



int32_t sceSaveDataGetParam(const SceSaveDataMountPoint *mountPoint,
       SceSaveDataParamType paramType,
       void *paramBuf, size_t paramBufSize, size_t *gotSize);



int32_t sceSaveDataSaveIcon(const SceSaveDataMountPoint *mountPoint, const SceSaveDataIcon *icon);



int32_t sceSaveDataSaveIconByPath(const SceSaveDataMountPoint *mountPoint, const char *path);



int32_t sceSaveDataLoadIcon(const SceSaveDataMountPoint *mountPoint, SceSaveDataIcon *icon);



int32_t sceSaveDataSyncSaveDataMemory(const SceSaveDataMemorySync *syncParam);



int32_t sceSaveDataSetupSaveDataMemory2(const SceSaveDataMemorySetup2 *setupParam, SceSaveDataMemorySetupResult *result);



int32_t sceSaveDataGetSaveDataMemory2(SceSaveDataMemoryGet2 *getParam);



int32_t sceSaveDataSetSaveDataMemory2(const SceSaveDataMemorySet2 *setParam);



int32_t sceSaveDataGetEventResult(const SceSaveDataEventParam *eventParam, SceSaveDataEvent *event);



int32_t sceSaveDataBackup(const SceSaveDataBackup *backup);



int32_t sceSaveDataTransferringMountPs4(const SceSaveDataTransferringMount *mount, SceSaveDataMountResult *mountResult);



int32_t sceSaveDataDirNameSearchPs4(const SceSaveDataDirNameSearchCond *cond, SceSaveDataDirNameSearchResult *result);



int32_t sceSaveDataConvert(const SceSaveDataConvert* convert);



int32_t sceSaveDataGetConvertProgress(float* progress);


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data.h" 2 3
# 11 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/common_api.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/common_api.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sdk_version.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/common_api.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/types.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/types.h" 3
typedef enum SceCommonDialogStatus {
 SCE_COMMON_DIALOG_STATUS_NONE = 0,
 SCE_COMMON_DIALOG_STATUS_INITIALIZED = 1,
 SCE_COMMON_DIALOG_STATUS_RUNNING = 2,
 SCE_COMMON_DIALOG_STATUS_FINISHED = 3
} SceCommonDialogStatus;

typedef enum SceCommonDialogResult {
 SCE_COMMON_DIALOG_RESULT_OK = 0,
 SCE_COMMON_DIALOG_RESULT_USER_CANCELED = 1,
} SceCommonDialogResult;

typedef struct SceCommonDialogBaseParam {
 size_t size;
 uint8_t reserved[36];
 uint32_t magic;
} SceCommonDialogBaseParam __attribute__ ((__aligned__(8)));
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/common_api.h" 2 3


extern "C" {


int32_t sceCommonDialogInitialize();
bool sceCommonDialogIsUsed();

static inline
void _sceCommonDialogSetMagicNumber( uint32_t* magic, const SceCommonDialogBaseParam* param )
{
 *magic = (uint32_t)( 0xC0D1A109 + (uint64_t)param );
}

static inline
void _sceCommonDialogBaseParamInit(SceCommonDialogBaseParam *param)
{
 memset(param, 0x0, sizeof(SceCommonDialogBaseParam));
 param->size = (uint32_t)sizeof(SceCommonDialogBaseParam);
 _sceCommonDialogSetMagicNumber( &(param->magic), param );
}


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\common_dialog/error.h" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 2 3







extern "C" {
# 39 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogMode;
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogType;







typedef int32_t SceSaveDataDialogFocusPos;
# 70 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogSystemMessageType;
# 87 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogWizardOption;
# 96 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogButtonType;
# 105 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogButtonId;
# 114 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
typedef int32_t SceSaveDataDialogOptionBack;






typedef int32_t SceSaveDataDialogOptionFlag;






typedef int32_t SceSaveDataDialogProgressBarType;




typedef int32_t SceSaveDataDialogProgressBarTarget;





typedef int32_t SceSaveDataDialogItemStyle;







typedef int32_t SceSaveDataDialogAnimation;






typedef int32_t SceSaveDataDialogUserMessageType;






typedef int32_t SceSaveDataDialogProgressSystemMessageType;
# 173 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\save_data_dialog.h" 3
typedef struct SceSaveDataDialogAnimationParam {
 SceSaveDataDialogAnimation userOK;

 SceSaveDataDialogAnimation userCancel;

 uint8_t reserved[32];

} SceSaveDataDialogAnimationParam;




typedef struct SceSaveDataDialogNewItem {
 const char *title;

 void *iconBuf;

 size_t iconSize;

 uint8_t reserved[32];

} SceSaveDataDialogNewItem;




typedef struct SceSaveDataDialogItems {
 SceUserServiceUserId userId;

 int32_t : 32;

 const SceSaveDataTitleId *titleId;

 const SceSaveDataDirName *dirName;

 uint32_t dirNameNum;

 int32_t : 32;

 const SceSaveDataDialogNewItem *newItem;

 SceSaveDataDialogFocusPos focusPos;

 int32_t : 32;

 const SceSaveDataDirName *focusPosDirName;


 SceSaveDataDialogItemStyle itemStyle;


 uint8_t reserved[36];

} SceSaveDataDialogItems;




typedef struct SceSaveDataDialogUserMessageParam {
 SceSaveDataDialogButtonType buttonType;

 SceSaveDataDialogUserMessageType msgType;

 const char *msg;

 uint8_t reserved[32];

} SceSaveDataDialogUserMessageParam;




typedef struct SceSaveDataDialogSystemMessageParam {
 SceSaveDataDialogSystemMessageType sysMsgType;

 int32_t : 32;

 uint64_t value;

 uint8_t reserved[32];

} SceSaveDataDialogSystemMessageParam;




typedef struct SceSaveDataDialogErrorCodeParam {
 int32_t errorCode;

 uint8_t reserved[32];

} SceSaveDataDialogErrorCodeParam;




typedef struct SceSaveDataDialogProgressBarParam {
 SceSaveDataDialogProgressBarType barType;

 int32_t : 32;

 const char *msg;

 SceSaveDataDialogProgressSystemMessageType sysMsgType;

 uint8_t reserved[28];

} SceSaveDataDialogProgressBarParam;



typedef struct SceSaveDataDialogWizardParam {

 SceSaveDataDialogWizardOption option;


 int32_t reserved1;


 const SceSaveDataFingerprint *fingerprint;


 uint8_t reserved2[32];

} SceSaveDataDialogWizardParam;



typedef struct SceSaveDataDialogOptionParam {
 SceSaveDataDialogOptionBack back;

 SceSaveDataDialogOptionFlag flag;

 uint8_t reserved[28];

} SceSaveDataDialogOptionParam;




typedef struct SceSaveDataDialogParam {
 SceCommonDialogBaseParam baseParam;

 int32_t size;


 SceSaveDataDialogMode mode;

 SceSaveDataDialogType dispType;

 int32_t : 32;

 SceSaveDataDialogAnimationParam *animParam;

 SceSaveDataDialogItems *items;


 SceSaveDataDialogUserMessageParam *userMsgParam;

 SceSaveDataDialogSystemMessageParam *sysMsgParam;

 SceSaveDataDialogErrorCodeParam *errorCodeParam;

 SceSaveDataDialogProgressBarParam *progBarParam;


 void *userData;


 SceSaveDataDialogOptionParam *optionParam;


 SceSaveDataDialogWizardParam *wizardParam;


 uint8_t reserved[16];

} SceSaveDataDialogParam;


typedef struct SceSaveDataDialogCloseParam {
 SceSaveDataDialogAnimation anim;

 uint8_t reserved[32];

} SceSaveDataDialogCloseParam;




typedef struct SceSaveDataDialogResult {
 SceSaveDataDialogMode mode;

 int32_t result;

 SceSaveDataDialogButtonId buttonId;

 int32_t : 32;

 SceSaveDataDirName *dirName;


 SceSaveDataParam *param;


 void *userData;

 uint8_t reserved[32];

} SceSaveDataDialogResult;






static inline
void sceSaveDataDialogParamInitialize( SceSaveDataDialogParam *param )
{
 memset(param, 0x0, sizeof(SceSaveDataDialogParam));

 _sceCommonDialogBaseParamInit(&param->baseParam);
 param->size = sizeof(SceSaveDataDialogParam);
}



int32_t sceSaveDataDialogInitialize();



int32_t sceSaveDataDialogTerminate( void );



SceCommonDialogStatus sceSaveDataDialogUpdateStatus(void);



SceCommonDialogStatus sceSaveDataDialogGetStatus(void);



int32_t sceSaveDataDialogGetResult(SceSaveDataDialogResult* result);



int32_t sceSaveDataDialogOpen(const SceSaveDataDialogParam *param);



int32_t sceSaveDataDialogClose(const SceSaveDataDialogCloseParam *closeParam);



int32_t sceSaveDataDialogProgressBarInc(SceSaveDataDialogProgressBarTarget target,
          uint32_t delta);



int32_t sceSaveDataDialogProgressBarSetValue(SceSaveDataDialogProgressBarTarget target,
            uint32_t rate);



int32_t sceSaveDataDialogIsReadyToDisplay();




}
# 12 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2




# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/PrxPluginInterface.h" 1



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/PrxPluginInterface.h" 2
# 16 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/PrxPluginInterface.h"
typedef int(*fnPrxPluginQueryInterface)(int, void**);






struct PrxPluginArgsV2
{
 static bool Validate(PrxPluginArgsV2* arg, size_t argSize)
 {
  if( (argSize < sizeof(PrxPluginArgsV2)) || (arg->m_Size != sizeof(PrxPluginArgsV2)) || (arg->m_Version != s_Version) )
  {
   return false;
  }

  return true;
 }

 PrxPluginArgsV2() : m_Size(0) ,m_Version(0), m_QueryInterface(__null) {}
 static const uint32_t s_Version = 0x0200;
 static const size_t s_LegacySize = 52;
 uint32_t m_Size;
 uint32_t m_Version;
 fnPrxPluginQueryInterface m_QueryInterface;
};
# 17 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/UnityPrxPlugin.h" 1
# 15 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/UnityPrxPlugin.h"
struct PrxPluginArgs
{
 static bool Validate(PrxPluginArgs* arg)
 {
  if ((arg->m_Size != sizeof(PrxPluginArgs)) || (arg->m_Version != s_Version) )
  {
   return false;
  }

  return true;
 }

 PrxPluginArgs() : m_Size(0) ,m_Version(0) {}
 static const uint32_t s_Version = 0x0103;
 uint32_t m_Size;
 uint32_t m_Version;
 const void* m_NpCommunicationId;
 const void* m_NpCommunicationSignature;
 const void* m_NpCommunicationPassphrase;
 bool m_NpHasTrophyPack;
 const char* m_NpServiceID;
 const char* m_TitleID;
 int m_NpAgeRating;
 bool m_Trial;
 bool m_bDevelopment;
 void* m_TitleSecret;
 int m_PushNotifcations;
 fnPrxPluginQueryInterface m_QueryInterface;
};

bool ProcessPrxPluginArgs(unsigned int sz, const void* arg, const char* pluginName);

extern fnPrxPluginQueryInterface g_QueryInterface;
extern PrxPluginArgs g_AppInfo;

template<typename T> T* GetRuntimeInterface(int interfaceID)
{
 if (g_QueryInterface)
 {
  void* interfacePtr = __null;
  int queryStatus = g_QueryInterface(interfaceID, &interfacePtr);
  if (queryStatus == 0x00000000)
  {
   return (T*)interfacePtr;
  }
 }
 return __null;
}
# 18 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginUnity.h" 1
# 12 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginUnity.h"
class IPluginUnity
{
public:
 virtual ~IPluginUnity() {}


 virtual int UnityIntVersion() const = 0;


 virtual const char* UnityVersion() const = 0;


 virtual bool IsDevelopmentBuild() const = 0;


 virtual bool IsDebugBuild() const = 0;
};
# 19 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginSceAppParams.h" 1
# 13 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginSceAppParams.h"
class IPluginSceAppParams
{
public:
 virtual ~IPluginSceAppParams() {}


 virtual bool IsTrialApp() const = 0;


 virtual const char* ServiceID() const = 0;


 virtual const char* TitleID() const = 0;
};
# 20 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginSceNpParams.h" 1
# 12 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../PlayerInterface/IPluginSceNpParams.h"
class IPluginSceNpParams
{
public:
 virtual ~IPluginSceNpParams() {}


 virtual const void* NpCommunicationsID() const = 0;


 virtual const void* NpCommunicationsSignature() const = 0;


 virtual const void* NpCommunicationsPassphrase() const = 0;


 virtual const char* NpServiceID() const = 0;


 virtual int NpAgeRating() const = 0;


 virtual bool NpHasTrophyPack() const = 0;


 virtual const void* NpTitleSecret() const = 0;


 virtual int NpPushNotifications() const = 0;
};
# 21 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/SonyCommonIncludes.h" 1
# 23 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2


# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/ManagedRequest.h" 1



# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/../Includes/CommonTypes.h" 1



typedef unsigned char UInt8;
typedef unsigned short UInt16;
typedef unsigned int UInt32;
typedef unsigned long long UInt64;
typedef char Int8;
typedef short Int16;
typedef int Int32;
typedef long long Int64;

typedef void (*ManagedEventCallback)();
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/ManagedRequest.h" 2

namespace SaveData
{

 class RequestBaseManaged
 {
 public:
  UInt32 functionType;
  Int32 userId;
  bool async;
  bool locked;
  bool ignoreCallback;
  UInt32 padding;
 };

}
# 26 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/ManagedResponse.h" 1



# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/../ErrorHandling/Errors.h" 1





namespace SaveData
{

 const char* LookupSceErrorCode(int errorCode);

 enum APIResultTypes
 {
  Success = 0,
  Warning = 1,
  Error = 2,
 };

 struct APIResult
 {
 public:
  APIResultTypes apiResult;
  char const * message;
  char const * filename;
  Int32 lineNumber;
  Int32 sceErrorCode;

  static void SetResult(APIResult* result, APIResultTypes type);
  static void SetResult(APIResult* result, APIResultTypes type, char const * message, char const * filename, Int32 lineNumber);
  static void SetSceResult(APIResult* result, APIResultTypes type, Int32 sceErrorCode, char const * filename, Int32 lineNumber);
 };
}
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/ManagedResponse.h" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/../Managed/MemoryBufferManaged.h" 1





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 1 3
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 2 3



namespace std {
using :: ptrdiff_t;
using :: size_t;
using :: max_align_t;
}




namespace std {

template<class _Ty,
 _Ty _Val>
 struct integral_constant
 {
 static constexpr _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant<_Ty, _Val> type;

 constexpr operator value_type() const noexcept
  {
  return (value);
  }


 constexpr value_type operator()() const noexcept
  {
  return (value);
  }

 };


template<class _Ty,
 _Ty _Val>
 constexpr _Ty integral_constant<_Ty, _Val>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;


template<bool _Val>
        struct _Cat_base
  : integral_constant<bool, _Val>
 {
 };


template<class _Ty>
 struct remove_const
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty[]>
 {
 typedef _Ty type[];
 };

template<class _Ty, size_t _Nx>
 struct remove_const<const _Ty[_Nx]>
 {
 typedef _Ty type[_Nx];
 };


template<class _Ty>
 struct remove_volatile
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty[]>
 {
 typedef _Ty type[];
 };

template<class _Ty, size_t _Nx>
 struct remove_volatile<volatile _Ty[_Nx]>
 {
 typedef _Ty type[_Nx];
 };


template<class _Ty>
 struct remove_cv
 {
 typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
  type;
 };



template<class _Ty>
 struct is_integral
  : _Cat_base<__is_integral(_Ty)>
 {
 };
# 261 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 3
template<bool _Test,
 class _Ty = void>
 struct enable_if
 {
 };

template<class _Ty>
 struct enable_if<true, _Ty>
 {
 typedef _Ty type;
 };

template<bool _Test,
 class _Ty = void>
 using enable_if_t = typename enable_if<_Test, _Ty>::type;

using nullptr_t = decltype(nullptr);
# 363 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstddef" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 1 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 2 3





# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_malloc.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_malloc.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_malloc.h" 2 3

extern "C" {



typedef struct SceLibcMallocManagedSize {
  unsigned short size;
  unsigned short version;
  unsigned int reserved1;
  size_t maxSystemSize;
  size_t currentSystemSize;
  size_t maxInuseSize;
  size_t currentInuseSize;
} SceLibcMallocManagedSize;


}
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 2 3
# 79 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
typedef struct
 {
 int quot;
 int rem;
 } div_t;


extern "C" {
void exit(int) __attribute__((__noreturn__));

void _Exit(int) noexcept __attribute__((__noreturn__));
}

extern "C" {
int abs(int);
long labs(long);





void abort(void) noexcept __attribute__((__noreturn__));
void *calloc(size_t, size_t);
void *malloc(size_t);

void *(memalign)(size_t boundary, size_t size_arg);

void free(void *);
void *realloc(void *, size_t);

void *aligned_alloc(size_t, size_t);


div_t div(int, int);
ldiv_t ldiv(long, long);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t *,
 const char *, size_t);
int mbtowc(wchar_t *, const char *, size_t);
int rand(void);
void srand(unsigned int);
long strtol(const char *, char **, int);
size_t wcstombs(char *,
 const wchar_t *, size_t);
int wctomb(char *, wchar_t);


void *reallocalign(void *ptr, size_t size, size_t boundary);
size_t malloc_usable_size(void *ptr);
int malloc_stats(SceLibcMallocManagedSize *);
int malloc_stats_fast(SceLibcMallocManagedSize *);



void lcong48(unsigned short [7]);
unsigned short *seed48(unsigned short [3]);
void srand48(long);

double drand48(void);
long lrand48(void);
long mrand48(void);

double erand48(unsigned short [3]);
long nrand48(unsigned short [3]);
long jrand48(unsigned short [3]);

int getopt(int, char *const *, const char *);
void *memalign(size_t, size_t);
int rand_r(unsigned *);

extern char *optarg;
extern int optind, opterr, optopt;



extern "C" {
extern float _Stofx(const char *, char **,
 long, int *);
extern double _Stodx(const char *, char **,
 long, int *);
extern long double _Stoldx(const char *, char **,
 long, int *);
extern long _Stolx(const char *, char **,
 int, int *);
extern unsigned long _Stoulx(const char *, char **,
 int, int *);
extern long long _Stollx(const char *, char **,
 int, int *);
extern unsigned long long _Stoullx(const char *, char **,
 int, int *);
}


unsigned long _Stoul(const char *, char **, int);
float _Stof(const char *, char **, long);
double _Stod(const char *, char **, long);
long double _Stold(const char *, char **, long);
_Longlong _Stoll(const char *, char **, int);
_ULonglong _Stoull(const char *, char **, int);

float _Stofx(const char *, char **, long, int *);
double _Stodx(const char *, char **, long, int *);
long double _Stoldx(const char *, char **, long, int *);
long _Stolx(const char *, char **, int, int *);
unsigned long _Stoulx(const char *, char **, int, int *);
_Longlong _Stollx(const char *, char **, int, int *);
_ULonglong _Stoullx(const char *, char **, int, int *);

size_t _Getmbcurmax(void);


_Longlong llabs(_Longlong);
lldiv_t lldiv(_Longlong, _Longlong);
_Longlong strtoll(const char *,
 char **, int);
_ULonglong strtoull(const char *,
 char **, int);


int at_quick_exit(void (*)(void)) noexcept;
void quick_exit(int) noexcept __attribute__((__noreturn__));


int getargc(void);
char **getargv(void);


}


extern "C" {
typedef void _Atexfun(void);
typedef int _Cmpfun(const void *, const void *);

int atexit(void (*)(void)) noexcept;
void *bsearch(const void *, const void *,
 size_t, size_t, _Cmpfun *);
void qsort(void *, size_t, size_t, _Cmpfun *);

}

extern "C++" {
# 248 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {

double atof(const char *_Str);

inline int atoi(const char *_Str)
 {
 return ((int):: _Stoul(_Str, 0, 10));
 }

inline long atol(const char *_Str)
 {
 return ((long):: _Stoul(_Str, 0, 10));
 }
# 269 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
double strtod(const char * _Str,
 char ** _Endptr);

inline unsigned long strtoul(const char * _Str,
 char ** _Endptr, int _Base)
 {
 return (:: _Stoul(_Str, _Endptr, _Base));
 }



inline _Longlong atoll(const char *_Str)
 {
 return ((_Longlong):: _Stoull(_Str, 0, 10));
 }

float strtof(const char * _Str,
 char ** _Endptr);

inline long double strtold(const char * _Str,
 char ** _Endptr)
 {
 return (:: _Stold(_Str, _Endptr, 0));
 }


}

}
# 338 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {


int (_Fail_s)(const char *, size_t);

typedef void (*constraint_handler_t)(const char *,
 void *, errno_t);

constraint_handler_t set_constraint_handler_s(
 constraint_handler_t);
void abort_handler_s(const char *,
 void *, errno_t);
void ignore_handler_s(const char *,
 void *, errno_t);

}


extern "C" {
typedef int _Cmpfun_s(const void *, const void *, void *);

void *bsearch_s(const void *, const void *,
 rsize_t, rsize_t, _Cmpfun_s *, void *);
errno_t qsort_s(void *,
 rsize_t, rsize_t, _Cmpfun_s *, void *);
}

extern "C++" {
# 382 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
}
# 395 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {
errno_t wctomb_s(int *,
 char *, rsize_t,
 wchar_t);
errno_t mbstowcs_s(size_t *,
 wchar_t *, rsize_t,
 const char *, rsize_t);
errno_t wcstombs_s(size_t *,
 char *, rsize_t,
 const wchar_t *, rsize_t);
}



extern "C++" {

template<rsize_t _Size>
errno_t mbstowcs_s(size_t *_Psize, wchar_t (&_Wcs)[_Size], const char *_Str, rsize_t _Num)
 {
 return mbstowcs_s(_Psize, _Wcs, _Size, _Str, _Num);
 }

template<rsize_t _Size>
errno_t wcstombs_s(size_t *_Psize, char (&_Str)[_Size], const wchar_t *_Wcs, rsize_t _Num)
 {
 return wcstombs_s(_Psize, _Str, _Size, _Wcs, _Num);
 }

template<rsize_t _Size>
errno_t wctomb_s(int *_Pstat, char (&_Str)[_Size], wchar_t _Wc)
 {
 return wctomb_s(_Pstat, _Str, _Size, _Wc);
 }

}
# 440 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {

extern size_t sceLibcHeapSize;
extern unsigned int sceLibcHeapDelayedAlloc;
extern unsigned int sceLibcHeapExtendedAlloc;
extern size_t sceLibcHeapInitialSize;
extern size_t sceLibcHeapHighAddressAlloc;
extern unsigned int sceLibcHeapMemoryLock;
extern unsigned int sceLibcHeapDebugFlags;

}
# 543 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
extern "C" {






int posix_memalign(void **, size_t, size_t);
# 572 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 3
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 2 3



namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;

using :: abort; using :: abs;
using :: at_quick_exit; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: quick_exit;
using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;
# 68 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdlib" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\initializer_list" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\initializer_list" 3
namespace std {

template<class _Elem>
 class initializer_list
 {
public:
 typedef _Elem value_type;
 typedef const _Elem& reference;
 typedef const _Elem& const_reference;
 typedef size_t size_type;

 typedef const _Elem *iterator;
 typedef const _Elem *const_iterator;

 constexpr initializer_list() noexcept
  : _First(0), _Last(0)
  {
  }

 constexpr initializer_list(const _Elem *_First_arg,
  const _Elem *_Last_arg) noexcept
  : _First(_First_arg), _Last(_Last_arg)
  {
  }

 constexpr initializer_list(const _Elem *_First_arg, size_t _Size_arg)
  : _First(_First_arg), _Last(_First_arg + _Size_arg)
  {
  }

 constexpr const _Elem *begin() const noexcept
  {
  return (_First);
  }

 constexpr const _Elem *end() const noexcept
  {
  return (_Last);
  }

 constexpr size_t size() const noexcept
  {
  return ((size_t)(_Last - _First));
  }

private:
 const _Elem *_First;
 const _Elem *_Last;
 };
}
namespace std {

template<class _Elem> inline
 constexpr const _Elem *begin(
  ::std:: initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.begin());
 }


template<class _Elem> inline
 constexpr const _Elem *end(
  ::std:: initializer_list<_Elem> _Ilist) noexcept
 {
 return (_Ilist.end());
 }
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 3
namespace std {

struct _Nil
 {
 };
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 3
template<bool _Test,
 class _Ty1,
 class _Ty2>
 struct conditional
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct conditional<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };


template<class _Ty1,
 class _Ty2>
 struct is_same
  : false_type
 {
 };

template<class _Ty1>
 struct is_same<_Ty1, _Ty1>
  : true_type
 {
 };



template<class _Ty>
 struct is_floating_point
  : _Cat_base<__is_floating_point(_Ty)>
 {
 };
# 96 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 3
template<class _Ty>
 struct is_arithmetic
  : _Cat_base<is_integral<_Ty>::value
   || is_floating_point<_Ty>::value>
 {
 };


template<class _Ty>
 struct remove_reference
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 using remove_reference_t = typename remove_reference<_Ty>::type;


struct _Wrap_int
 {
 _Wrap_int(int)
  {
  }
 };

template<class _Ty>
 struct _Identity
 {
 typedef _Ty type;
 };
# 152 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtr1common" 3
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 2 3
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
namespace std {
# 117 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<bool,
 class _Ty1,
 class _Ty2>
 struct _If
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct _If<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };

template<class _Ty>
 struct _Always_false
  : false_type
 {
 };
# 156 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<class _Arg,
 class _Result>
 struct unary_function
 {
 typedef _Arg argument_type;
 typedef _Result result_type;
 };


template<class _Arg1,
 class _Arg2,
 class _Result>
 struct binary_function
 {
 typedef _Arg1 first_argument_type;
 typedef _Arg2 second_argument_type;
 typedef _Result result_type;
 };


template<class _Ty = void>
 struct plus
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left + _Right);
  }
 };


template<class _Ty = void>
 struct minus
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left - _Right);
  }
 };


template<class _Ty = void>
 struct multiplies
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef _Ty result_type ;

 constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left * _Right);
  }
 };


template<class _Ty = void>
 struct equal_to
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef bool result_type ;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left == _Right);
  }
 };


template<class _Ty = void>
 struct less
 {
 typedef _Ty first_argument_type ;
 typedef _Ty second_argument_type ;
 typedef bool result_type ;

 constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left < _Right);
  }
 };



typedef int _Is_trans;


template<>
 struct plus<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct minus<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct multiplies<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct equal_to<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct less<void>
 {
 typedef _Is_trans is_transparent;

 template<class _Ty1,
  class _Ty2>
  constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right));
  }
 };





}



namespace std {

__attribute__((no_sanitize("unsigned-integer-overflow")))
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
 {

 static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
 const size_t _FNV_offset_basis = 14695981039346656037ULL;
 const size_t _FNV_prime = 1099511628211ULL;







 size_t _Val = _FNV_offset_basis;
 for (size_t _Next = 0; _Next < _Count; ++_Next)
  {
  _Val ^= (size_t)_First[_Next];
  _Val *= _FNV_prime;
  }
 return (_Val);
 }


template<class _Kty>
 struct _Bitwise_hash
 {
 typedef _Kty argument_type ;
 typedef size_t result_type ;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
  }
 };

template<class _Kty, bool = __is_enum(_Kty)>
 struct _Enum_hash : _Bitwise_hash<_Kty>
 {
 };

template<class _Kty>
 struct _Enum_hash<_Kty, false>
 {
 _Enum_hash() = delete;
 _Enum_hash(const _Enum_hash&) = delete;
 _Enum_hash& operator=(const _Enum_hash&) = delete;
 };



template<class _Kty>
 struct hash
  : public _Enum_hash<_Kty>
 {
 };





template<>
 struct hash<bool>
  : public _Bitwise_hash<bool>
 {
 };

template<>
 struct hash<char>
  : public _Bitwise_hash<char>
 {
 };

template<>
 struct hash<signed char>
  : public _Bitwise_hash<signed char>
 {
 };

template<>
 struct hash<unsigned char>
  : public _Bitwise_hash<unsigned char>
 {
 };

template<>
 struct hash<char16_t>
  : public _Bitwise_hash<char16_t>
 {
 };

template<>
 struct hash<char32_t>
  : public _Bitwise_hash<char32_t>
 {
 };

template<>
 struct hash<wchar_t>
  : public _Bitwise_hash<wchar_t>
 {
 };

template<>
 struct hash<short>
  : public _Bitwise_hash<short>
 {
 };

template<>
 struct hash<unsigned short>
  : public _Bitwise_hash<unsigned short>
 {
 };

template<>
 struct hash<int>
  : public _Bitwise_hash<int>
 {
 };

template<>
 struct hash<unsigned int>
  : public _Bitwise_hash<unsigned int>
 {
 };

template<>
 struct hash<long>
  : public _Bitwise_hash<long>
 {
 };

template<>
 struct hash<unsigned long>
  : public _Bitwise_hash<unsigned long>
 {
 };

template<>
 struct hash<long long>
  : public _Bitwise_hash<long long>
 {
 };

template<>
 struct hash<unsigned long long>
  : public _Bitwise_hash<unsigned long long>
 {
 };

template<>
 struct hash<float>
  : public _Bitwise_hash<float>
 {
 typedef float _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<double>
  : public _Bitwise_hash<double>
 {
 typedef double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<long double>
  : public _Bitwise_hash<long double>
 {
 typedef long double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  _Kty _Temp = _Keyval == 0 ? 0 : _Keyval;


  unsigned char *_Pyt = (unsigned char *)&_Temp;
  for (size_t _Idx = 10; _Idx < sizeof (long double); ++_Idx)
   _Pyt[_Idx] = 0;


  return (_Mybase::operator()(_Temp));
  }
 };

template<class _Ty>
 struct hash<_Ty *>
  : public _Bitwise_hash<_Ty *>
 {
 };

template<>
 struct hash<nullptr_t>
 {
 using result_type = size_t;
 using argument_type = nullptr_t;

 size_t operator()(nullptr_t) const
  {
  return size_t(0);
  }
 };

}
# 781 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
namespace std {

template<class... _Types>
 struct _Arg_types
 {
 };

template<class _Ty1>
 struct _Arg_types<_Ty1>
 {
 typedef _Ty1 argument_type ;
 };

template<class _Ty1,
 class _Ty2>
 struct _Arg_types<_Ty1, _Ty2>
 {
 typedef _Ty1 first_argument_type ;
 typedef _Ty2 second_argument_type ;
 };


template<class _Ty>
 struct _Is_function
 {
 typedef false_type _Bool_type;
 };
# 820 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types...) const volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };
# 832 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile & > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile && > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };
# 858 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
template<class _Ty>
 struct is_function
  : _Is_function<_Ty>::_Bool_type
 {
 };


template<class _Ty> inline
 _Ty *_Addressof(_Ty& _Val, true_type) noexcept
 {
 return (_Val);
 }


template<class _Ty> inline
 _Ty *_Addressof(_Ty& _Val, false_type) noexcept
 {
 return __builtin_addressof(_Val);
 }

template<class _Ty> inline
 _Ty *addressof(_Ty& _Val) noexcept
 {
 return (_Addressof(_Val, is_function<_Ty>()));
 }
# 899 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstddef" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 2 3

namespace std {

class exception;
typedef void (*_Prhand)(const exception&);
extern _Prhand _Raise_handler;
         void _Throw(const exception&);
# 84 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
class exception
 {
public:
 static _Prhand _Set_raise_handler(_Prhand _Pnew);

 exception() noexcept
  {
  }

 explicit exception(const char *) noexcept
  {
  }

 virtual ~exception() noexcept;


 virtual const char *what() const;
# 110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
 void _Raise() const;

protected:
 virtual void _Doraise() const;

 };


class bad_exception
 : public exception
 {
public:
 bad_exception() noexcept
  {
  }


 virtual ~bad_exception() noexcept;
# 138 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
protected:
 virtual void _Doraise() const;

 };



typedef void (*terminate_handler)();
typedef void (*unexpected_handler )();


         terminate_handler get_terminate() noexcept;
         terminate_handler set_terminate(terminate_handler) noexcept;
                                   unexpected_handler get_unexpected() noexcept;
                                   unexpected_handler set_unexpected(unexpected_handler) noexcept;
                        bool uncaught_exception() noexcept;
# 162 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
         void terminate() noexcept __attribute__((__noreturn__));
                                   void unexpected() __attribute__((__noreturn__));
# 180 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 3
}

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xxexception" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xxexception" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 2 3
# 234 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
namespace std {

template<class _Ty>
 struct _Ptr_traits
 {
 };

template<class _Ty>
 struct _Ptr_traits<_Ty *>
 {
 static const bool _Is_const = false;
 static const bool _Is_volatile = false;
 };

template<class _Ty>
 struct _Ptr_traits<const _Ty *>
 {
 static const bool _Is_const = true;
 static const bool _Is_volatile = false;
 };

template<class _Ty>
 struct _Ptr_traits<volatile _Ty *>
 {
 static const bool _Is_const = false;
 static const bool _Is_volatile = true;
 };

template<class _Ty>
 struct _Ptr_traits<const volatile _Ty *>
 {
 static const bool _Is_const = true;
 static const bool _Is_volatile = true;
 };

template<class _Ty>
 struct _Is_memfunptr
 {
 typedef false_type _Bool_type;
 };
# 287 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) & > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) && > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret ( _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };
# 301 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile & > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile && > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };



template<class _Ty>
 struct _Has_cv_ref_qual
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) &>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) &&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const&&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) volatile&&>
  : true_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Has_cv_ref_qual<_Ty(_Types...) const volatile&&>
  : true_type
 {
 };


template<class _Ty>
 struct add_const
 {
 typedef const _Ty type;
 };


template<class _Ty>
 struct add_volatile
 {
 typedef volatile _Ty type;
 };


template<class _Ty>
 struct add_cv
 {
 typedef const volatile _Ty type;
 };


template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_lvalue_reference
 {
 typedef _Ty& type;
 };

template<class _Ty>
 struct _Do_add_lvalue_reference<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_lvalue_reference
  : _Do_add_lvalue_reference<_Ty,
   _Has_cv_ref_qual<_Ty>::value>
 {
 };
# 437 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<> struct add_lvalue_reference< void> { typedef void type; }; template<> struct add_lvalue_reference<const void> { typedef const void type; }; template<> struct add_lvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_lvalue_reference<const volatile void> { typedef const volatile void type; };



template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_rvalue_reference
 {
 typedef typename remove_reference<_Ty>::type&& type;
 };

template<class _Ty>
 struct _Do_add_rvalue_reference<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_rvalue_reference
  : _Do_add_rvalue_reference<_Ty,
   _Has_cv_ref_qual<_Ty>::value>
 {
 };

template<class _Ty>
 struct add_rvalue_reference<_Ty&>
 {
 typedef _Ty& type;
 };
# 474 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<> struct add_rvalue_reference< void> { typedef void type; }; template<> struct add_rvalue_reference<const void> { typedef const void type; }; template<> struct add_rvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_rvalue_reference<const volatile void> { typedef const volatile void type; };



template<class _Ty>
 typename add_rvalue_reference<_Ty>::type
  declval() noexcept;


template<class _Ty>
 struct remove_extent
 {
 typedef _Ty type;
 };

template<class _Ty,
 size_t _Ix>
 struct remove_extent<_Ty[_Ix]>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_extent<_Ty[]>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_all_extents
 {
 typedef _Ty type;
 };

template<class _Ty,
 size_t _Ix>
 struct remove_all_extents<_Ty[_Ix]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };

template<class _Ty>
 struct remove_all_extents<_Ty[]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };


template<class _Ty>
 struct remove_pointer
 {
 typedef _Ty type;
 };
# 536 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };



template<class _Ty,
 bool _Is_identity = false>
 struct _Do_add_pointer
 {
 typedef typename remove_reference<_Ty>::type *type;
 };

template<class _Ty>
 struct _Do_add_pointer<_Ty, true>
  : _Identity<_Ty>
 {
 };

template<class _Ty>
 struct add_pointer
  : _Do_add_pointer<_Ty, _Has_cv_ref_qual<_Ty>::value>
 {
 };



template<class _Ty>
 struct _Is_void
  : false_type
 {
 };

template<>
 struct _Is_void<void>
  : true_type
 {
 };

template<class _Ty>
 struct is_void
  : _Is_void<typename remove_cv<_Ty>::type>
 {
 };


template<class _Ty>
 struct is_array
  : false_type
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_array<_Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_array<_Ty[]>
  : true_type
 {
 };


template<class _Ty>
 struct is_lvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_lvalue_reference<_Ty&>
  : true_type
 {
 };


template<class _Ty>
 struct is_rvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_rvalue_reference<_Ty&&>
  : true_type
 {
 };


template<class _Ty>
 struct is_reference
  : _Cat_base<is_lvalue_reference<_Ty>::value
  || is_rvalue_reference<_Ty>::value>
 {
 };


template<class _Ty,
 bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
 struct _Is_member_object_pointer
  : false_type
 {
 };

template<class _Ty1,
 class _Ty2>
 struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
  : true_type
 {
 typedef _Ty2 _Class_type;
 };

template<class _Ty>
 struct is_member_object_pointer
  : _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
 {
 };


template<class _Ty>
 struct is_member_function_pointer
  : _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
 {
 };


template<class _Ty>
 struct _Is_pointer
  : false_type
 {
 };

template<class _Ty>
 struct _Is_pointer<_Ty *>
  : _Cat_base<!is_member_object_pointer<_Ty *>::value
  && !is_member_function_pointer<_Ty *>::value>
 {
 };

template<class _Ty>
 struct is_pointer
  : _Is_pointer<typename remove_cv<_Ty>::type>
 {
 };



template<class _Ty>
 struct _Is_nullptr_t
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };
# 700 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_null_pointer
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };
# 716 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_union
  : _Cat_base<__is_union(_Ty)>
 {
 };


template<class _Ty>
 struct is_class
  : _Cat_base<__is_class(_Ty)>
 {
 };


template<class _Ty>
 struct is_fundamental
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_void<_Ty>::value
  || _Is_nullptr_t<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_object
  : _Cat_base<!is_function<_Ty>::value
  && !is_reference<_Ty>::value
  && !is_void<_Ty>::value>
 {
 };


template<class _Ty,
 bool = is_object<_Ty>::value || is_reference<_Ty>::value>
 struct _Is_referenceable
  : true_type
 {
 };

template<class _Ty>
 struct _Is_referenceable<_Ty, false>
  : false_type
 {
 };
# 769 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ret, class... _Types> struct _Is_referenceable<_Ret (_Types...) , false> : true_type { };
# 780 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ret, class... _Types> struct _Is_referenceable<_Ret (_Types..., ...) , false> : true_type { };
# 819 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _From,
 class _To>
 struct is_convertible


  : _Cat_base<is_void<typename remove_volatile<_From>::type>::value && is_void<typename remove_volatile<_To>::type>::value || __is_convertible_to(typename remove_volatile<_From>::type, typename remove_volatile<_To>::type)>






 {
 };
# 871 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_enum
  : _Cat_base<__is_enum(_Ty)>
 {
 };


template<class _Ty>
 struct is_compound
  : _Cat_base<!is_fundamental<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_member_pointer
  : _Cat_base<is_member_object_pointer<_Ty>::value
  || is_member_function_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_scalar
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_enum<_Ty>::value
  || is_pointer<_Ty>::value
  || is_member_pointer<_Ty>::value
  || _Is_nullptr_t<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_const
  : _Cat_base<_Ptr_traits<_Ty *>::_Is_const
  && !is_function<_Ty>::value>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_const<_Ty[_Nx]>
  : false_type
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_const<const _Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_const<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_const<_Ty&&>
  : false_type
 {
 };


template<class _Ty>
 struct is_volatile
  : _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
  && !is_function<_Ty>::value>
 {
 };

template<class _Ty>
 struct is_volatile<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_volatile<_Ty&&>
  : false_type
 {
 };


template<class _Ty1,
 class _Ty2>
 struct _Copy_cv
 {
 typedef conditional<is_const<_Ty1>::value,
  typename add_const<_Ty2>::type,
  _Ty2> _Tx;
 typedef conditional<is_volatile<_Ty1>::value,
  typename add_volatile<_Tx>::type,
  _Tx> type;
 };

template<class _Ty1,
 class _Ty2>
 using _Copy_cv_t = typename _Copy_cv<_Ty1, _Ty2>::type;

template<class _Ty1,
 class _Ty2>
 struct _Composite_ptr
 {
 typedef
  typename conditional<is_same<_Ty1 *, nullptr_t>::value,
   _Ty2 *,
  typename conditional<is_same<_Ty2 *, nullptr_t>::value,
   _Ty1 *,
  typename conditional<is_same<typename remove_cv<_Ty1>::type,
   void>::value,
   _Copy_cv_t<_Ty1, _Ty2> *,
   _Copy_cv_t<_Ty2, _Ty1> *
   >::type >::type >::type type;
 };

template<class _Ty1,
 class _Ty2>
 using _Composite_ptr_t = typename _Composite_ptr<_Ty1, _Ty2>::type;


template<class _Ty>
 struct _Is_pod
  : _Cat_base<is_scalar<_Ty>::value || __is_pod(_Ty)>
 {
 };

template<class _Ty>
 struct is_pod
  : _Is_pod<typename remove_all_extents<_Ty>::type>
 {
 };


template<class _Ty>
 struct is_empty
  : _Cat_base<__is_empty(_Ty)>
 {
 };


template<class _Ty>
 struct is_polymorphic
  : _Cat_base<__is_polymorphic(_Ty)>
 {
 };


template<class _Ty>
 struct is_abstract
  : _Cat_base<__is_abstract(_Ty)>
 {
 };


template<class _Ty>
 struct is_standard_layout : _Cat_base<__is_standard_layout(_Ty)>
 {
 };


template<class _Ty>
 struct is_literal_type
  : _Cat_base<__is_literal_type(_Ty)>
 {
 };


template<class _Ty>
 struct is_trivial
  : _Cat_base<__is_trivial(_Ty)>
 {
 };


template<class _Ty>
 struct has_virtual_destructor
  : _Cat_base<__has_virtual_destructor(_Ty)>
 {
 };



template<bool,
 class _Ty,
 class... _Types>
 struct _Is_constructible
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Is_constructible<true, _Ty, _Types...>
 {
 template<class _Uty>
  static auto _Fn(int)
   -> decltype((void)_Uty(::std:: declval<_Types>()...), true_type());
 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_Ty>(0)) type;
 };


template<class _Ty,
 class... _Types>
 struct is_constructible
  : _Cat_base<__is_constructible(_Ty, _Types...)>
 {
 };
# 1100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<bool,
 class _Ty>
 struct _Is_cc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_cc<true, _Ty>
  : is_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct _Is_cc<true, _Ty&>
  : is_constructible<_Ty&, _Ty&>
 {
 };

template<class _Ty>
 struct is_copy_constructible
  : _Is_cc<!is_void<_Ty>::value && !is_array<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_default_constructible
  : is_constructible<_Ty>::type
 {
 };


template<bool,
 class _Ty>
 struct _Is_mc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_mc<true, _Ty>
  : is_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct _Is_mc<true, _Ty&>
  : is_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_move_constructible
  : _Is_mc<!is_void<_Ty>::value && !is_array<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _To,
 class _From>
 struct _Is_assignable
  : false_type
 {
 };

template<class _To,
 class _From>
 struct _Is_assignable<true, _To, _From>
 {
 template<class _Uty>
  static auto _Fn(int)
   -> decltype((void)(::std:: declval<_Uty>() = ::std:: declval<_From>()),
    true_type());

 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_To>(0)) type;
 };

template<class _To,
 class _From>
 struct is_assignable
  : _Is_assignable<
   is_object<typename remove_reference<_To>::type>::value
   && !is_array<typename remove_reference<_To>::type>::value
   && is_object<typename remove_reference<_From>::type>::value
   && !is_array<typename remove_reference<_From>::type>::value,
   _To, _From>::type

 {
 };


template<bool,
 class _Ty>
 struct _Is_ca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ca<false, _Ty>
  : is_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_copy_assignable
  : _Is_ca<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ma
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ma<false, _Ty>
  : is_assignable<_Ty&, _Ty&&>
 {
 };

template<class _Ty>
 struct is_move_assignable
  : _Is_ma<is_void<_Ty>::value, _Ty>
 {
 };







template<class _Ty, unsigned int _Nx>
 struct extent;

template<class _Ty>
 struct __is_array_unknown_bounds
  : public _Cat_base<__is_array(_Ty) && !extent<_Ty, 0>::value>
 {
 };

struct __is_destructible_concrete_sub
 {
 template<class _Uty>
  struct __w { _Uty __u; };

 template<class _Ty, class = decltype(declval<__w<_Ty>&>().~__w<_Ty>())>
  static true_type __test(int);

 template<class>
  static false_type __test(...);
 };

template<class _Ty>
 struct __is_destructible_concrete
  : public __is_destructible_concrete_sub
 {
 typedef decltype(__test<_Ty>(0)) type;
 };

struct __is_destructible_abstract_sub
 {
 template<class _Ty, class = decltype(declval<_Ty&>().~_Ty())>
  static true_type __test(int);

 template<class>
  static false_type __test(...);
 };

template<class _Ty>
 struct __is_destructible_abstract
  : public __is_destructible_abstract_sub
 {
 typedef decltype(__test<_Ty>(0)) type;
 };


template<class _Ty,
 bool __b1 = is_void<_Ty>::value || __is_array_unknown_bounds<_Ty>::value || is_function<_Ty>::value,
 bool __b2 = is_reference<_Ty>::value>
 struct __is_destructible_sub;







template<class _Ty>
 struct __is_destructible_sub<_Ty, false, false>
  : public _If<is_abstract<_Ty>::value,
   __is_destructible_abstract<_Ty>,
   __is_destructible_concrete<_Ty>>::type::type
 {
 };

template<class _Ty>
 struct __is_destructible_sub<_Ty, true, false>
  : public false_type
 {
 };

template<class _Ty>
 struct __is_destructible_sub<_Ty, false, true>
  : public true_type
 {
 };

template<class _Ty>
 struct is_destructible
  : _Cat_base<__is_destructible_sub<_Ty>::value>
 {
 };





template<class _Ty,
 class... _Types>
 struct is_trivially_constructible
  : _Cat_base<__is_trivially_constructible(_Ty, _Types...)>
 {
 };
# 1358 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<bool,
 class _Ty>
 struct _Is_tcc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tcc<false, _Ty>
  : is_trivially_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct is_trivially_copy_constructible
  : _Is_tcc<is_void<_Ty>::value || is_array<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_trivially_default_constructible
  : is_trivially_constructible<_Ty>::type
 {
 };


template<bool,
 class _Ty>
 struct _Is_tmc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tmc<false, _Ty>
  : is_trivially_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_trivially_move_constructible
  : _Is_tmc<is_void<_Ty>::value || is_array<_Ty>::value, _Ty>
 {
 };


template<class _To,
 class _From>
 struct is_trivially_assignable
  : _Cat_base<__is_trivially_assignable(_To, _From)>
 {
 };


template<bool,
 class _Ty>
 struct _Is_tca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_tca<false, _Ty>
  : is_trivially_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_trivially_copy_assignable
  : _Is_tca<is_void<_Ty>::value
   || has_virtual_destructor<_Ty>::value, _Ty>
 {
 };


template<class _Ty>
 struct is_trivially_copyable
  : _Cat_base<__is_trivially_copyable(_Ty)>
 {
 };
# 1450 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_trivially_move_assignable
  : is_trivially_assignable<typename add_lvalue_reference< typename remove_volatile<_Ty>::type>::type, typename add_rvalue_reference< typename remove_volatile<_Ty>::type>::type>::type
 {
 };


template<class _Ty>
 struct is_trivially_destructible
  : _Cat_base<is_pod<_Ty>::value || __has_trivial_destructor(_Ty)>
 {
 };


template<bool,
 class _Ty,
 class... _Types>
 struct _Is_ntc
  : false_type
 {
 };

template<class _Ty,
 class... _Types>
 struct _Is_ntc<true, _Ty, _Types...>
  : _Cat_base<noexcept(_Ty(declval<_Types>()...))>
 {
 };

template<class _Ty,
 class _Type>
 struct _Is_ntc<true, _Ty, _Type>
  : _Cat_base<noexcept(static_cast<_Ty>(declval<_Type>()))>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct _Is_ntc<true, _Ty[_Nx]>
  : _Cat_base<noexcept(_Ty())>
 {
 };

template<class _Ty>
 struct _Is_ntc<true, _Ty>
  : _Cat_base<noexcept(_Ty())>
 {
 };
# 1511 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty,
 class... _Types>
 struct is_nothrow_constructible
  : _Is_ntc<is_constructible<_Ty, _Types...>::value,
   _Ty, _Types...>
 {
 };


template<class _Ty,
 size_t _Nx>
 struct is_nothrow_constructible<_Ty[_Nx]>
  : is_nothrow_constructible<_Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntcc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntcc<true, _Ty>
  : is_nothrow_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct _Is_ntcc<true, _Ty&>
  : is_nothrow_constructible<_Ty, const _Ty&>
 {
 };

template<class _Ty>
 struct is_nothrow_copy_constructible
  : _Is_ntcc<!is_void<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_copy_constructible<_Ty[_Nx]>
  : false_type
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntdc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntdc<true, _Ty>
  : _Cat_base<noexcept(_Ty())>
 {
 };

template<class _Ty>
 struct is_nothrow_default_constructible
  : _Is_ntdc<is_default_constructible<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_default_constructible<_Ty[_Nx]>
  : is_nothrow_default_constructible<_Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntmc
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntmc<true, _Ty>
  : is_nothrow_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct _Is_ntmc<true, _Ty&>
  : is_nothrow_constructible<_Ty, _Ty&&>
 {
 };

template<class _Ty>
 struct is_nothrow_move_constructible
  : _Is_ntmc<!is_void<_Ty>::value, _Ty>
 {
 };

template<class _Ty,
 size_t _Nx>
 struct is_nothrow_move_constructible<_Ty[_Nx]>
  : false_type
 {
 };


template<bool,
 class _To,
 class _From>
 struct _Is_nta
  : false_type
 {
 };

template<class _To,
 class _From>
 struct _Is_nta<true, _To, _From>
  : _Cat_base<





  noexcept(::std:: declval<_To>() = ::std:: declval<_From>())>
 {
 };

template<class _To,
 class _From>
 struct is_nothrow_assignable
  : _Is_nta<is_assignable<_To, _From>::value, _To, _From>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntca
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntca<false, _Ty>
  : is_nothrow_assignable<_Ty&, const _Ty&>
 {
 };

template<class _Ty>
 struct is_nothrow_copy_assignable
  : _Is_ntca<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntma
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntma<false, _Ty>
  : is_nothrow_assignable<_Ty&, _Ty&&>
 {
 };

template<class _Ty>
 struct is_nothrow_move_assignable
  : _Is_ntma<is_void<_Ty>::value, _Ty>
 {
 };


template<bool,
 class _Ty>
 struct _Is_ntd
  : false_type
 {
 };

template<class _Ty>
 struct _Is_ntd<true, _Ty>
  : _Cat_base<noexcept(::std:: declval<_Ty>().~_Ty())>
 {
 };

template<class _Ty>
 struct is_nothrow_destructible
  : _Is_ntd<is_destructible<_Ty>::value, _Ty>
 {
 };

template<class _Ty, size_t _Nx>
 struct is_nothrow_destructible<_Ty[_Nx]>
  : is_nothrow_destructible<_Ty>
 {
 };

template<class _Ty>
 struct is_nothrow_destructible<_Ty&>
  : true_type
 {
 };



template<class _Ty>
 struct add_reference
 {
 typedef typename remove_reference<_Ty>::type& type;
 };
# 1736 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<> struct add_reference< void> { typedef void type; }; template<> struct add_reference<const void> { typedef const void type; }; template<> struct add_reference<volatile void> { typedef volatile void type; }; template<> struct add_reference<const volatile void> { typedef const volatile void type; };





template<class _Ty>
 struct has_copy_constructor
  : is_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_default_constructor
  : is_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_move_constructor
  : is_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_copy_assign
  : is_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_move_assign
  : is_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_copy_constructor
  : is_trivially_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_default_constructor
  : is_trivially_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_move_constructor
  : is_trivially_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_copy_assign
  : is_trivially_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_move_assign
  : is_trivially_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_copy_constructor
  : is_nothrow_copy_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_default_constructor
  : is_nothrow_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_move_constructor
  : is_nothrow_move_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_copy_assign
  : is_nothrow_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_move_assign
  : is_nothrow_move_assignable<_Ty>::type
 {
 };



template<class _Ty>
 struct has_trivial_constructor
  : _Cat_base<is_pod<_Ty>::value || !is_array<_Ty>::value && __has_trivial_constructor(_Ty)>
 {
 };


template<class _Ty>
 struct has_trivial_copy
  : _Cat_base<!is_array<_Ty>::value && __has_trivial_copy(_Ty)>
 {
 };


template<class _Ty>
 struct has_trivial_assign
  : _Cat_base<!is_array<_Ty>::value && (is_pod<typename remove_reference<_Ty>::type>::value || __has_trivial_assign(typename remove_reference<_Ty>::type))>
 {
 };


template<class _Ty>
 struct has_trivial_destructor
  : _Cat_base<is_pod<_Ty>::value || __has_trivial_destructor(_Ty)>
 {
 };


template<class _Ty>
 struct has_nothrow_constructor
  : is_nothrow_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_copy
  : is_nothrow_copy_constructible<_Ty>
 {
 };


template<class _Ty>
 struct has_nothrow_assign
  : is_nothrow_copy_assignable<_Ty>::type
 {
 };




template<class _Ty,
 bool = is_integral<_Ty>::value>
 struct _Sign_base
 {
 typedef typename remove_cv<_Ty>::type _Uty;
 typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
 typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
 };

template<class _Ty>
 struct _Sign_base<_Ty, false>
 {

 typedef is_floating_point<_Ty> _Signed;
 typedef false_type _Unsigned;
 };

template<class _Ty>
 struct is_signed
  : _Sign_base<_Ty>::_Signed
 {
 };


template<class _Ty>
 struct is_unsigned
  : _Sign_base<_Ty>::_Unsigned
 {
 };


template<class _Ty>
 struct _Change_sign
 {
 _Change_sign()
  {
 static_assert(((is_integral<_Ty>::value || is_enum<_Ty>::value) && !is_same<_Ty, bool>::value), "make_signed<T>/make_unsigned<T> require that T shall be a (possibly " "cv-qualified) integral type or enumeration but not a bool type.");




  }

 typedef
  typename _If<is_same<_Ty, signed char>::value
   || is_same<_Ty, unsigned char >::value, signed char,
  typename _If<is_same<_Ty, short >::value
   || is_same<_Ty, unsigned short >::value, short,
  typename _If<is_same<_Ty, int >::value
   || is_same<_Ty, unsigned int >::value, int,
  typename _If<is_same<_Ty, long >::value
   || is_same<_Ty, unsigned long >::value, long,
  typename _If<is_same<_Ty, long long >::value
   || is_same<_Ty, unsigned long long>::value, long long,
  typename _If<is_same<_Ty, __int128_t >::value
   || is_same<_Ty, __uint128_t >::value, __int128_t,
  typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
  typename _If<sizeof (_Ty) == sizeof (short ), short,
  typename _If<sizeof (_Ty) == sizeof (int ), int,
  typename _If<sizeof (_Ty) == sizeof (long ), long,
  typename _If<sizeof (_Ty) == sizeof (long long ), long long,
   __int128_t
  >::type>::type>::type>::type>::type>::type>::type>::type>::type>::type>::type
   _Signed;

 typedef
  typename _If<is_same<_Signed, signed char>::value, unsigned char,
  typename _If<is_same<_Signed, short >::value, unsigned short,
  typename _If<is_same<_Signed, int >::value, unsigned int,
  typename _If<is_same<_Signed, long >::value, unsigned long,
  typename _If<is_same<_Signed, long long >::value, unsigned long long,
   __uint128_t
  >::type>::type>::type>::type>::type
   _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const _Ty>
 {
 typedef const typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<volatile _Ty>
 {
 typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const volatile _Ty>
 {
 typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };


template<class _Ty>
 struct make_signed
 {
 typedef typename _Change_sign<_Ty>::_Signed type;
 };


template<class _Ty>
 struct make_unsigned
 {
 typedef typename _Change_sign<_Ty>::_Unsigned type;
 };
# 2026 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct alignment_of
  : integral_constant<size_t, __alignof__(_Ty)>
 {
 };






template<size_t _Len,
 class _Ty,
 bool _Ok>
 struct _Aligned;

template<size_t _Len,
 class _Ty>
 struct _Aligned<_Len, _Ty, true>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = __alignof__(_Ty);
 };

template<size_t _Len>
 struct _Aligned<_Len, short, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, char, __alignof__(char) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, int, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, short, __alignof__(short) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, long, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, int, __alignof__(int) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, long double, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, long, __alignof__(long) <= _Len>::value;
 };

template<size_t _Len>
 struct _Aligned<_Len, max_align_t, false>
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 static const size_t value = _Aligned<_Len, long double, __alignof__(long double) <= _Len>::value;
 };

template<size_t _Len,
 size_t _Align = _Aligned<_Len, max_align_t, __alignof__(max_align_t) <= _Len>::value>
 struct aligned_storage
 {
 static_assert(_Len != 0, "_Len shell not be zero.");
 typedef struct {
  alignas(_Align) unsigned char __data[_Len];
 } type;
 };


template<size_t _Len,
 class... _Types>
 struct aligned_union;

template<size_t _Len>
 struct aligned_union<_Len>
 {
 typedef typename aligned_storage<(_Len > sizeof(char)) ? _Len : sizeof(char), __alignof__(char)>::type type;
 };

template<size_t _Len,
 class _Ty,
 class... _Rest>
 struct aligned_union<_Len, _Ty, _Rest...>
 {
 typedef union
  {
  typename aligned_storage<(_Len > sizeof(_Ty)) ? _Len : sizeof(_Ty), __alignof__(_Ty)>::type _Ty1;
  typename aligned_union<_Len, _Rest...>::type _Ty2;
  } type;
 static const size_t alignment_value = alignment_of<type>::value;
 };


template<class _Ty>
 struct underlying_type
 {
 typedef __underlying_type(_Ty) type;
 };


template<class _Ty>
 struct rank
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty,
 size_t _Ix>
 struct rank<_Ty[_Ix]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };

template<class _Ty>
 struct rank<_Ty[]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };


template<class _Ty, unsigned int _Nx>
 struct _Extent
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty,
 size_t _Ix>
 struct _Extent<_Ty[_Ix], 0>
  : integral_constant<size_t, _Ix>
 {
 };

template<class _Ty,
 unsigned int _Nx,
 size_t _Ix>
 struct _Extent<_Ty[_Ix], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx>
 struct _Extent<_Ty[], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx = 0>
 struct extent
  : _Extent<_Ty, _Nx>
 {
 };


template<class _Base,
 class _Der>
 struct is_base_of
  : _Cat_base<__is_base_of(_Base, _Der)>
 {
 };


template<class _Ty>
 struct decay
 {
 template<class _Ty2>
 struct _Remove_extent_ptr
  {
  typedef typename remove_extent<_Ty2>::type *type;
  };

 typedef typename remove_reference<_Ty>::type _Ty1;

 typedef
  typename _If<is_array<_Ty1>::value,
   _Remove_extent_ptr<_Ty1>,
   typename _If<is_function<_Ty1>::value,
    add_pointer<_Ty1>,
    remove_cv<_Ty1>
   >::type
  >::type::type type;
 };


template<class _Ty>
 using decay_t = typename decay<_Ty>::type;





template<class...>
 using __void_t = void;
# 2290 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct _Common_type_success
 {
 using type = _Ty;
 };

struct _Common_type_fail
 {
 };

template<class... _Ty>
 struct common_type;

template<>
 struct common_type<>
 {
 };

template<class _Ty>
 struct common_type<_Ty>



 : decay<_Ty>

 {
 };

template<class _Ty1,
 class _Ty2,
 class _Dty1 = decay_t<_Ty1>,
 class _Dty2 = decay_t<_Ty2>,
 bool _Already_decayed = is_same<_Ty1, _Dty1>::value && is_same<_Ty2, _Dty2>::value>
 struct _Common_type2
 {
 using type = common_type<_Dty1, _Dty2>;
 };

template<class _Ty1,
 class _Ty2,
 class _Dty1,
 class _Dty2>
 struct _Common_type2<_Ty1, _Ty2, _Dty1, _Dty2, true>
 {
 template<class _Uty1, class _Uty2>
 static auto _Fn(int) -> _Common_type_success<
   decay_t<decltype(false ? declval<_Uty1>() : declval<_Uty2>())>
  >;

 template<class _Uty1, class _Uty2>
 static auto _Fn(_Wrap_int) -> _Common_type_fail;

 using type = decltype(_Fn<_Dty1, _Dty2>(0));
 };

template<class _Ty1,
 class _Ty2>
 struct common_type<_Ty1, _Ty2>





 {
 using type = decay_t<decltype(true ? declval<_Ty1>() : declval<_Ty2>())>;
 };


template<class _Ty1,
 class _Ty2,
 class... _Ty>
 struct _Common_type_rec
 {
 template<class _Uty1, class _Uty2, class... _Uty>
 static auto _Fn(int) -> _Common_type_success<
   typename common_type<typename common_type<_Uty1, _Uty2>::type, _Uty...>::type
  >;

 template<class _Uty1, class _Uty2, class... _Uty>
 static auto _Fn(_Wrap_int) -> _Common_type_fail;

 using type = decltype(_Fn<_Ty1, _Ty2, _Ty...>(0));
 };

template<class _Ty1,
 class _Ty2,
 class... _Ty>
 struct common_type<_Ty1, _Ty2, _Ty...>
 : _Common_type_rec<_Ty1, _Ty2, _Ty...>::type
 {
 };




template<class _Ty,
 _Ty... _Vals>
 struct integer_sequence
 {
 static_assert(is_integral<_Ty>::value, "integer_sequence<T, I...> requires T to be an integral type.");


 typedef integer_sequence<_Ty, _Vals...> type;
 typedef _Ty value_type;

 static constexpr size_t size() noexcept
  {
  return (sizeof...(_Vals));
  }
 };


template<bool _Negative,
 bool _Zero,
 class _Int_con,
 class _Int_seq>
 struct _Make_seq
 {
 static_assert(!_Negative, "make_integer_sequence<T, N> requires N to be non-negative.");

 };

template<class _Ty,
 _Ty... _Vals>
 struct _Make_seq<false, true,
  integral_constant<_Ty, 0>,
  integer_sequence<_Ty, _Vals...> >
  : integer_sequence<_Ty, _Vals...>
 {
 };

template<class _Ty,
 _Ty _Ix,
 _Ty... _Vals>
 struct _Make_seq<false, false,
  integral_constant<_Ty, _Ix>,
  integer_sequence<_Ty, _Vals...> >
  : _Make_seq<false, _Ix == 1,
   integral_constant<_Ty, _Ix - 1>,
   integer_sequence<_Ty, _Ix - 1, _Vals...> >
 {
 };


template<class _Ty,
 _Ty _Size>
 using make_integer_sequence = typename _Make_seq<_Size < 0, _Size == 0,
  integral_constant<_Ty, _Size>, integer_sequence<_Ty> >::type;

template<size_t... _Vals>
 using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
 using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
 using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 2480 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct identity
 {
 typedef _Ty type;

 const _Ty& operator()(const _Ty& _Left) const
  {
  return (_Left);
  }
 };


template<class _Ty> inline
 constexpr _Ty&& forward(
  remove_reference_t<_Ty>& _Arg) noexcept
 {
 return (static_cast<_Ty&&>(_Arg));
 }

template<class _Ty> inline
 constexpr _Ty&& forward(
  remove_reference_t<_Ty>&& _Arg) noexcept
 {
 static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
 return (static_cast<_Ty&&>(_Arg));
 }


template<class _Ty> inline
 constexpr remove_reference_t<_Ty>&&
  move(_Ty&& _Arg) noexcept
 {
 return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename remove_reference<_Ty>::type&&
  _Move(_Ty&& _Arg) noexcept
 {
 return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
 }


template<class _Ty> inline
 constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
  && is_copy_constructible<_Ty>::value,
   const _Ty&, _Ty&&>::type
 move_if_noexcept(_Ty& _Arg) noexcept
 {
 return (::std:: move(_Arg));
 }


template<class _Ty> inline
 decay_t<_Ty> _Decay_copy(_Ty&& _Arg)
 {
 return (::std:: forward<_Ty>(_Arg));
 }


template<class...>
 struct _Param_tester
 {
 typedef void type;
 };

template<class _Ty>
 class reference_wrapper;

template<class _Ty>
 struct _Is_reference_wrapper
  : false_type
 {
 };

template<class _Ty>
 struct _Is_reference_wrapper<reference_wrapper<_Ty>>
  : true_type
 {
 };


struct _Invoker_pmf_object
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmf_pointer
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmf_reference_wrapper
 {
 template<class _Decayed,
  class _Ty1,
  class... _Types2>
  static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
  noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)( ::std:: forward<_Types2>(_Args2)...)))

  -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...))
  {
  return ((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(
   ::std:: forward<_Types2>(_Args2)...));
  }
 };

struct _Invoker_pmd_object
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd))
  -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd)
  {
  return (::std:: forward<_Ty1>(_Arg1).*_Pmd);
  }
 };

struct _Invoker_pmd_pointer
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd))
  -> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)
  {
  return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd);
  }
 };

struct _Invoker_pmd_reference_wrapper
 {
 template<class _Decayed,
  class _Ty1>
  static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
  noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd))
  -> decltype(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)
  {
  return (::std:: forward<_Ty1>(_Arg1).get().*_Pmd);
  }
 };

struct _Invoker_functor
 {
 template<class _Callable,
  class... _Types>
  static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args)
  noexcept(noexcept(::std:: forward<_Callable>(_Obj)( ::std:: forward<_Types>(_Args)...)))

  -> decltype(::std:: forward<_Callable>(_Obj)(
   ::std:: forward<_Types>(_Args)...))
  {
  return (::std:: forward<_Callable>(_Obj)(
   ::std:: forward<_Types>(_Args)...));
  }
 };

template<class _Callable,
 class _Ty1,
 class _Decayed = decay_t<_Callable>,
 bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
 bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
 struct _Invoker1;

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
  : _If<is_base_of<
   typename _Is_memfunptr<_Decayed>::_Class_type,
   decay_t<_Ty1> >::value,
  _Invoker_pmf_object,
  typename _If<_Is_reference_wrapper<decay_t<_Ty1>>::value,
  _Invoker_pmf_reference_wrapper,
  _Invoker_pmf_pointer>::type>::type
 {
 };

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
  : _If<is_base_of<
   typename _Is_member_object_pointer<_Decayed>::_Class_type,
   decay_t<_Ty1> >::value,
  _Invoker_pmd_object,
  typename _If<_Is_reference_wrapper<decay_t<_Ty1>>::value,
  _Invoker_pmd_reference_wrapper,
  _Invoker_pmd_pointer>::type>::type
 {
 };

template<class _Callable,
 class _Ty1,
 class _Decayed>
 struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
  : _Invoker_functor
 {
 };

template<class _Callable,
 class... _Types>
 struct _Invoker;

template<class _Callable>
 struct _Invoker<_Callable>
  : _Invoker_functor
 {
 };

template<class _Callable,
 class _Ty1,
 class... _Types2>
 struct _Invoker<_Callable, _Ty1, _Types2...>
  : _Invoker1<_Callable, _Ty1>
 {
 };
# 2740 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Callable,
 class... _Types> inline
 constexpr auto _Invoke1(_Callable&& _Obj, _Types&&... _Args)
 noexcept(noexcept((_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))))

 -> decltype(_Invoker<_Callable, _Types...>::_Call(
  ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))
 {
 return (_Invoker<_Callable, _Types...>::_Call(
  ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));
 }

template<class _Rx,
 bool = is_void<_Rx>::value>
 struct _Forced
 {
 };

struct _Unforced
 {
 };

template<class _Cv_void,
 class... _Valtys> inline
 void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
 {
 ::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...);
 }

template<class _Rx,
 class... _Valtys> inline
 _Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
 {
 return (::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...));
 }

template<class... _Valtys> inline
 auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
 -> decltype(::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...))
 {
 return (::std:: _Invoke1(::std:: forward<_Valtys>(_Vals)...));
 }


template<class _Void,
 class _Func,
 class... _Types>
 struct _Invoke_result
 {
 };

template<class _Func,
 class... _Types>
 struct _Invoke_result<decltype(void(_Invoker<_Func, _Types...>::_Call(::std:: declval<_Func>(),
  ::std:: declval<_Types>()...))), _Func, _Types...>
 {
 typedef decltype(_Invoker<_Func, _Types...>::_Call(::std:: declval<_Func>(),
  ::std:: declval<_Types>()...)) type;
 };
# 2810 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty,
 class = void>
 struct _Weak_result_type
 {
 };

template<class _Ty>
 struct _Weak_result_type<_Ty, typename _Param_tester<
  typename _Ty::result_type>::type>
 {
 typedef typename _Ty::result_type result_type ;
 };

template<class _Ty,
 class = void>
 struct _Weak_argument_type
  : _Weak_result_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_argument_type<_Ty, typename _Param_tester<
  typename _Ty::argument_type>::type>
  : _Weak_result_type<_Ty>
 {
 typedef typename _Ty::argument_type argument_type ;
 };

template<class _Ty,
 class = void>
 struct _Weak_binary_args
  : _Weak_argument_type<_Ty>
 {
 };

template<class _Ty>
 struct _Weak_binary_args<_Ty, typename _Param_tester<
  typename _Ty::first_argument_type,
  typename _Ty::second_argument_type>::type>
  : _Weak_argument_type<_Ty>
 {
 typedef typename _Ty::first_argument_type first_argument_type ;
 typedef typename _Ty::second_argument_type second_argument_type ;
 };

template<class _Ty>
 struct _Weak_types
 {
 typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
 typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
 typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
  typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
  _Weak_binary_args<_Ty> >::type>::type type;
 };


template<class _Ty>
 class reference_wrapper
  : public _Weak_types<_Ty>::type
 {
public:
 static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
  "reference_wrapper<T> requires T to be an object type "
  "or a function type.");

 typedef _Ty type;

 reference_wrapper(_Ty& _Val) noexcept
  : _Ptr(::std:: addressof(_Val))
  {
  }

 operator _Ty&() const noexcept
  {
  return (*_Ptr);
  }

 _Ty& get() const noexcept
  {
  return (*_Ptr);
  }

 template<class... _Types>
  auto operator()(_Types&&... _Args) const
  -> decltype(_Invoke1(this->get(), ::std:: forward<_Types>(_Args)...))
  {
  return (_Invoke1(get(), ::std:: forward<_Types>(_Args)...));
  }

 reference_wrapper(_Ty&&) = delete;

private:
 _Ty *_Ptr;
 };


template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(_Ty& _Val) noexcept
 {
 return (reference_wrapper<_Ty>(_Val));
 }

template<class _Ty>
 void ref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<_Ty>
  ref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: ref(_Val.get()));
 }

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(const _Ty& _Val) noexcept
 {
 return (reference_wrapper<const _Ty>(_Val));
 }

template<class _Ty>
 void cref(const _Ty&&) = delete;

template<class _Ty> inline
 reference_wrapper<const _Ty>
  cref(reference_wrapper<_Ty> _Val) noexcept
 {
 return (::std:: cref(_Val.get()));
 }


template<class _Ty>
 struct _Unrefwrap_helper
 {
 typedef _Ty type;
 static const bool _Is_refwrap = false;
 };

template<class _Ty>
 struct _Unrefwrap_helper<reference_wrapper<_Ty> >
 {
 typedef _Ty& type;
 static const bool _Is_refwrap = true;
 };

template<class _Ty>
 struct _Unrefwrap
 {
 typedef decay_t<_Ty> _Ty1;
 typedef typename _Unrefwrap_helper<_Ty1>::type type;
 static const bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
 };


template<bool _Is_ref,
 class _Ty>
 struct _Rerefwrap
 {
 static _Ty _Apply(_Ty _Arg)
  {
  return (_Arg);
  }
 };

template<class _Ty>
 struct _Rerefwrap<true, _Ty>
 {
 static auto _Apply(_Ty _Arg) -> decltype(::std:: ref(_Arg))
  {
  return (::std:: ref(_Arg));
  }
 };


template<class _Ty>
 struct _Result_of_success
 {
 typedef _Ty type;
 };

struct _Result_of_fail
 {
 };

template<class _Ty0,
 class _Ty1>
 struct _Is_same_or_base_of;

template<class _Ret,
 class _Ty0,
 class _Ty1>
 struct _Is_same_or_base_of<_Ret _Ty0::*, _Ty1>
  : public integral_constant<bool, is_same<_Ty0, _Ty1>::value || is_base_of<_Ty0, _Ty1>::value>
 {
 };

template<bool,
 bool,
 class _Fty,
 class... _Args>
 struct _Result_of
 {
 typedef _Result_of_fail type;
 };

template<bool,
 class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf;

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf<true, _Fty, _Arg0, _Args...>
 {
 private:
 template<class _Ufty, class _Uarg0, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype((declval<_Uarg0>().*declval<_Ufty>())(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0, _Args...>(0)) type;
 };

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of_pmf<false, _Fty, _Arg0, _Args...>
 {
 private:
 template<class _Ufty, class _Uarg0, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype(((*declval<_Uarg0>()).*declval<_Ufty>())(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0, _Args...>(0)) type;
 };

template<class _Fty,
 class _Arg0,
 class... _Args>
 struct _Result_of<true, false, _Fty, _Arg0, _Args...>
 {
 typedef typename _Result_of_pmf<
  _Is_same_or_base_of<typename decay<_Fty>::type,
   typename remove_cv<typename remove_reference<_Arg0>::type>::type>::value,
  _Fty, _Arg0, _Args...>::type type;
 };

template<bool,
 class _Fty,
 class _Arg0>
 struct _Result_of_pmd;

template<class _Fty,
 class _Arg0>
 struct _Result_of_pmd<true, _Fty, _Arg0>
 {
 private:
 template<class _Ufty, class _Uarg0>
 static auto _Fn(int) -> _Result_of_success<decltype(declval<_Uarg0>().*declval<_Ufty>())>;

 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0>(0)) type;
 };

template<class _Fty,
 class _Arg0>
 struct _Result_of_pmd<false, _Fty, _Arg0>
 {
 private:
 template<class _Ufty, class _Uarg0>
 static auto _Fn(int) -> _Result_of_success<decltype((*declval<_Uarg0>()).*declval<_Ufty>())>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;

 public:
 typedef decltype(_Fn<_Fty, _Arg0>(0)) type;
 };

template<class _Fty,
 class _Arg0>
 struct _Result_of<false, true, _Fty, _Arg0>
 {
 typedef typename _Result_of_pmd<
  _Is_same_or_base_of<typename decay<_Fty>::type,
   typename remove_cv<typename remove_reference<_Arg0>::type>::type>::value,
  _Fty, _Arg0>::type type;
 };

template<class _Fty,
 class... _Args>
 struct _Result_of<false, false, _Fty, _Args...>
 {
 private:
 template<class _Ufty, class... _Uargs>
 static auto _Fn(int) -> _Result_of_success<decltype(declval<_Ufty>()(declval<_Uargs>()...))>;
 template<class...>
 static auto _Fn(_Wrap_int) -> _Result_of_fail;
 public:
 typedef decltype(_Fn<_Fty, _Args...>(0)) type;
 };

template<class _Fty>
 struct result_of;
# 3131 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Fty,
 class... _Args>
 struct result_of<_Fty(_Args...)>
 : public _Result_of<
  is_member_function_pointer<typename remove_reference<_Fty>::type>::value,
  is_member_object_pointer<typename remove_reference<_Fty>::type>::value,
  _Fty, _Args...>::type
 {
 };

template<class _Fty,
 class... _Args>
 struct result_of<reference_wrapper<_Fty>(_Args...)>
 : public _Result_of<
  is_member_function_pointer<typename remove_reference<_Fty>::type>::value,
  is_member_object_pointer<typename remove_reference<_Fty>::type>::value,
  _Fty, _Args...>::type
 {
 };
# 3487 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 struct is_final
  : _Cat_base<__is_final(_Ty)>
 {
 };
# 3538 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
template<class _Ty>
 using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
 using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
 using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
 using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
 using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
 using add_cv_t = typename add_cv<_Ty>::type;




template<class _Ty>
 using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
 using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
 using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
 using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
 using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
 using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
 using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
 using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
 size_t _Align = _Aligned<_Len, max_align_t, __alignof__(max_align_t) <= _Len>::value>
 using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
 class... _Types>
 using aligned_union_t = typename aligned_union<_Len, _Types...>::type;





template<bool _Test,
 class _Ty1,
 class _Ty2>
 using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
 using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
 using underlying_type_t = typename underlying_type<_Ty>::type;







template<class _Ty>
 using result_of_t = typename result_of<_Ty>::type;
# 3879 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\type_traits" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xxexception" 2 3

namespace std {

extern "C" {
 void *__cxa_current_primary_exception(void) throw();
 void __cxa_rethrow_primary_exception(void *);
 void __cxa_increment_exception_refcount(void *) throw();
 void __cxa_decrement_exception_refcount(void *) throw();
}






class exception_ptr {
 void *_exptr_;

 friend void rethrow_exception(exception_ptr e);
 friend exception_ptr current_exception() noexcept;
public:
 exception_ptr(void *p = nullptr) noexcept
  : _exptr_(p)
 {
 }

 exception_ptr(const exception_ptr& rhs) noexcept
  : _exptr_(rhs._exptr_)
 {
  __cxa_increment_exception_refcount(_exptr_);
 }

 ~exception_ptr()
 {
  __cxa_decrement_exception_refcount(_exptr_);
 }

 exception_ptr& operator=(const exception_ptr& rhs)
 {
  __cxa_increment_exception_refcount(rhs._exptr_);
  __cxa_decrement_exception_refcount(_exptr_);
  _exptr_ = rhs._exptr_;
  return *this;
 }

 friend bool operator==(const exception_ptr& lhs, const exception_ptr& rhs)
 {
  return lhs._exptr_ == rhs._exptr_;
 }

 friend bool operator!=(const exception_ptr& lhs, const exception_ptr& rhs)
 {
  return lhs._exptr_ != rhs._exptr_;
 }

 explicit operator bool() const
 {
  return _exptr_ != nullptr;
 }
};


inline exception_ptr current_exception() noexcept
 {
 exception_ptr e;
 e._exptr_ = __cxa_current_primary_exception();
 return e;
 }

inline void rethrow_exception(exception_ptr e) __attribute__((__noreturn__));
inline void rethrow_exception(exception_ptr e)
 {
 __cxa_rethrow_primary_exception(e._exptr_);
 terminate();
 }
}

namespace std {

template<class _Excep> inline
 exception_ptr make_exception_ptr(_Excep _Ex) noexcept
 {
 {{
 ::std:: _Throw(_Ex);
 } if (0) {
 return (current_exception());
 }}
 return (exception_ptr());
 }


class nested_exception
 {
public:
 nested_exception() noexcept
  : _Myptr(current_exception())
  {
  }

 nested_exception(const nested_exception& _Right) = default;

 nested_exception& operator=(
  const nested_exception& _Right) = default;

 virtual ~nested_exception() noexcept;

 exception_ptr nested_ptr() const noexcept
  {
  return (_Myptr);
  }

 __attribute__((__noreturn__)) void rethrow_nested() const
  {
  rethrow_exception(_Myptr);
  }

private:
 exception_ptr _Myptr;
 };


template<class _Ty>
 struct _Wrapped_with_nested
  : _Ty, nested_exception
 {
 explicit _Wrapped_with_nested(const _Ty& _Val)
  : _Ty((_Val))
  {
  }
 };

template<class _Ty> inline
 void _Throw_with_nested(_Ty&& _Val,
  typename enable_if<is_class<typename remove_reference<_Ty>::type>::value
   && !is_base_of<nested_exception, typename remove_reference<_Ty>::type>::value
   >::type* = 0)
 {
                                                                                        ;
 }

template<class _Ty> inline
 void _Throw_with_nested(_Ty&& _Val,
  typename enable_if<!is_class<typename remove_reference<_Ty>::type>::value
   || is_base_of<nested_exception, typename remove_reference<_Ty>::type>::value
   >::type* = 0)
 {
                            ;
 }

template<class _Ty> inline
 void throw_with_nested(_Ty&& _Val) __attribute__((__noreturn__));
template<class _Ty> inline
 void throw_with_nested(_Ty&& _Val)
 {
 _Throw_with_nested(_Val);
 }


template<class _Ex> inline
 void _Rethrow_if_nested(const _Ex& _Val,
  typename enable_if<is_polymorphic<_Ex>::value>::type* = 0)
 {
 const nested_exception *e = dynamic_cast<const nested_exception *>(&_Val);
 if (e)
  e->rethrow_nested();
 }

template<class _Ex> inline
 void _Rethrow_if_nested(const _Ex& _Val,
  typename enable_if<!is_polymorphic<_Ex>::value>::type* = 0)
 {
 }

template<class _Ex> inline
 void rethrow_if_nested(const _Ex& _Val)
 {
 _Rethrow_if_nested(_Val);
 }
}
# 183 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\exception" 2 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 1 3
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 2 3
# 35 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 3
namespace std {
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 3
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t; using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t; using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;


using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
# 112 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdint" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 2 3

 extern "C" {
# 132 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 3
void _Feraise(int);

typedef union
 {
 unsigned short _Word[8];
 float _Float;
 double _Double;
 long double _Long_double;
 } _Dconst;


double _Cosh(double, double);
short _Dtest(double *);
double _Sinh(double, double);
double _Divide(double, double);
short _Exp(double *, double, long);
double _Log(double, int);
double _Recip(double);
double _Sinx(double, unsigned int);
double _Sin(double, unsigned int, int);
int __fpclassifyd(double);
int __isfinite(double);
int __isinf(double);
int __isnan(double);
int __isnormal(double);
int __signbit(double);

extern const _Dconst _Denorm, _Hugeval, _Inf,
 _Nan, _Snan;


float _FCosh(float, float);
short _FDtest(float *);
float _FSinh(float, float);
float _FDivide(float, float);
short _FExp(float *, float, long);
float _FLog(float, int);
float _FRecip(float);
float _FSinx(float, unsigned int);
float _FSin(float, unsigned int, int);
int __fpclassifyf(float);
int __isfinitef(float);
int __isinff(float);
int __isnanf(float);
int __isnormalf(float);
int __signbitf(float);

extern const _Dconst _FDenorm, _FInf, _FNan, _FSnan;


long double _LCosh(long double, long double);
short _LDtest(long double *);
long double _LSinh(long double, long double);
long double _LDivide(long double, long double);
short _LExp(long double *, long double, long);
long double _LLog(long double, int);
long double _LRecip(long double);
long double _LSinx(long double, unsigned int);
long double _LSin(long double, unsigned int, int);
int __fpclassifyl(long double);
int __isfinitel(long double);
int __isinfl(long double);
int __isnanl(long double);
int __isnormall(long double);
int __signbitl(long double);

extern const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
# 210 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ymath.h" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cfloat" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cfloat" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\float.h" 1 3
# 48 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\float.h" 3
typedef struct
 {
 int _Ddig, _Dmdig, _Dmax10e, _Dmaxe, _Dmin10e, _Dmine;
 union
  {
  unsigned short _Us[8];
  float _Float;
  double _Double;
  long double _Long_double;
  } _Deps, _Dmax, _Dmin;
 } _Dvals;



extern "C" {
int _Fltrounds(void);
extern const _Dvals _Dbl, _Flt, _Hlf, _Ldbl;
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cfloat" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\climits" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 1 3
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtgmath.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtgmath.h" 3
namespace std {
template<class _Ty>
 struct _Promote_to_float
 {
 typedef typename conditional<is_same<_Ty, long double>::value,
 long double,
 typename conditional<is_same<_Ty, double>::value
  || is_integral<_Ty>::value, double,
  float>::type>::type type;
 };

template<class _Ty1,
 class _Ty2>
 struct _Common_float_type
 {
 typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
 typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
 typedef typename conditional<is_same<_Ty1f, long double>::value
  || is_same<_Ty2f, long double>::value, long double,
  typename conditional<is_same<_Ty1f, double>::value
   || is_same<_Ty2f, double>::value, double,
   float>::type>::type type;
 };
}
# 81 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtgmath.h" 3
extern "C" double pow(double, double);
float pow(float, float);
long double pow(long double, long double);

template<class _Ty1,
 class _Ty2> inline
 typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
  && ::std:: is_arithmetic<_Ty2>::value,
  typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
 pow(const _Ty1 _Left, const _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: pow(type(_Left), type(_Right)));
 }


extern "C" double acos(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C" double asin(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C" double atan(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C" double atan2( double, double); float atan2(float, float); long double atan2(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" double ceil(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C" double cos(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C" double cosh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C" double exp(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }
extern "C" double fabs(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }
extern "C" double floor(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C" double fmod( double, double); float fmod(float, float); long double fmod(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" double frexp(double, int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left, int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" double ldexp(double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left, int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C" double log(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C" double log10(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C" double sin(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C" double sinh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C" double sqrt(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C" double tan(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C" double tanh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }
# 130 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtgmath.h" 3
extern "C" double fma(double, double, double);
float fma(float, float, float);
long double fma(long double, long double, long double);




template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (:: fma((type)_Left, (type)_Middle, (type)_Right));
 }

template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 hypot3(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (:: hypot3((type)_Left, (type)_Middle, (type)_Right));
 }

extern "C" double remquo(double, double, int *);
float remquo(float, float, int *);
long double remquo(long double, long double, int *);



template<class _Ty1,
 class _Ty2> inline
 typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
 remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: remquo((type)_Left, (type)_Right, _Pquo));
 }

extern "C" double acosh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C" double asinh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C" double atanh(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C" double cbrt(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C" double copysign( double, double); float copysign(float, float); long double copysign(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C" double erf(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C" double erfc(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C" double expm1(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C" double exp2(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C" double fdim( double, double); float fdim(float, float); long double fdim(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C" double fmax( double, double); float fmax(float, float); long double fmax(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C" double fmin( double, double); float fmin(float, float); long double fmin(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C" double hypot( double, double); float hypot(float, float); long double hypot(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }

extern "C" int ilogb(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C" double lgamma(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C" long long llrint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C" long long llround(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C" double log1p(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C" double log2(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C" double logb(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C" long lrint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C" long lround(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C" double nearbyint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C" double nextafter( double, double); float nextafter(float, float); long double nextafter(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C" double nexttoward(double, long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left, long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C" double remainder( double, double); float remainder(float, float); long double remainder(long double, long double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C" double rint(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C" double round(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C" double scalbln(double, long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left, long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C" double scalbn(double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left, int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C" double tgamma(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C" double trunc(double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 2 3
# 62 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
typedef float float_t;
typedef double double_t;
# 110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
extern "C" {
int _FFpcomp(float, float);
int _Fpcomp(double, double);
int _LFpcomp(long double, long double);

int _FDclass(float);
int _Dclass(double);
int _LDclass(long double);

int _FDsign(float);
int _Dsign(double);
int _LDsign(long double);
}



inline int _FPCOMP(float _Left, float _Right)
 {
 return (_FFpcomp(_Left, _Right));
 }

inline int _FPCOMP(double _Left, double _Right)
 {
 return (_Fpcomp(_Left, _Right));
 }

inline int _FPCOMP(long double _Left, long double _Right)
 {
 return (_LFpcomp(_Left, _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 int _FPCOMP(_Ty1 _Left, _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (_FPCOMP((type)_Left, (type)_Right));
 }


inline int fpclassify(float _Left)
 {
 return (__fpclassifyf(_Left));
 }

inline int fpclassify(double _Left)
 {
 return (__fpclassifyd(_Left));
 }

inline int fpclassify(long double _Left)
 {
 return (__fpclassifyl(_Left));
 }

template<class _Ty> inline
 int fpclassify(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: fpclassify((type)_Left));
 }


inline bool signbit(float _Left)
 {
 return (__signbitf(_Left) != 0);
 }

inline bool signbit(double _Left)
 {
 return (__signbit(_Left) != 0);
 }

inline bool signbit(long double _Left)
 {
 return (__signbitl(_Left) != 0);
 }

template<class _Ty> inline
 bool signbit(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: signbit((type)_Left));
 }


inline bool isfinite(float _Left)
 {
 return (__isfinitef(_Left) != 0);
 }

inline bool isfinite(double _Left)
 {
 return (__isfinite(_Left) != 0);
 }

inline bool isfinite(long double _Left)
 {
 return (__isfinitel(_Left) != 0);
 }

template<class _Ty> inline
 bool isfinite(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isfinite((type)_Left));
 }


inline bool isinf(float _Left)
 {
 return (__isinff(_Left) != 0);
 }

inline bool isinf(double _Left)
 {
 return (__isinf(_Left) != 0);
 }

inline bool isinf(long double _Left)
 {
 return (__isinfl(_Left) != 0);
 }

template<class _Ty> inline
 bool isinf(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isinf((type)_Left));
 }


inline bool isnan(float _Left)
 {
 return (__isnanf(_Left) != 0);
 }

inline bool isnan(double _Left)
 {
 return (__isnan(_Left) != 0);
 }

inline bool isnan(long double _Left)
 {
 return (__isnanl(_Left) != 0);
 }

template<class _Ty> inline
 bool isnan(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isnan((type)_Left));
 }


inline bool isnormal(float _Left)
 {
 return (__isnormalf(_Left) != 0);
 }

inline bool isnormal(double _Left)
 {
 return (__isnormal(_Left) != 0);
 }

inline bool isnormal(long double _Left)
 {
 return (__isnormall(_Left) != 0);
 }

template<class _Ty> inline
 bool isnormal(_Ty _Left)
 {
 typedef typename ::std:: _Promote_to_float<_Ty>::type type;
 return (:: isnormal((type)_Left));
 }


template<class _Ty1, class _Ty2> inline
 bool isgreater(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & 4) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isgreaterequal(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (2 | 4)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isless(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & 1) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool islessequal(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (1 | 2)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool islessgreater(_Ty1 _Left, _Ty2 _Right)
 {
 return ((_FPCOMP(_Left, _Right) & (1 | 4)) != 0);
 }

template<class _Ty1, class _Ty2> inline
 bool isunordered(_Ty1 _Left, _Ty2 _Right)
 {
 return (_FPCOMP(_Left, _Right) == 0);
 }
# 528 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
extern "C" {

double acos(double);
double asin(double);
double atan(double);
double atan2(double, double);
double ceil(double);
double cos(double);
double exp(double);
double fabs(double);
double floor(double);
double fmod(double, double);
double frexp(double, int *);
double ldexp(double, int);
double log(double);
double log10(double);
double modf(double, double *);
double pow(double, double);
double sin(double);
void sincos(double, double *, double *);
double sqrt(double);
double tan(double);
double tanh(double);


double acosh(double);
double asinh(double);
double atanh(double);
double cbrt(double);
double copysign(double, double);
double erf(double);
double erfc(double);
double exp2(double);
double expm1(double);
double fdim(double, double);
double fma(double, double, double);
double fmax(double, double);
double fmin(double, double);
double hypot(double, double);
double hypot3(double, double, double);
int ilogb(double);
double lgamma(double);
long long llrint(double);
long long llround(double);
double log1p(double);
double log2(double);
double logb(double);
long lrint(double);
long lround(double);
double nan(const char *);
double nearbyint(double);
double nextafter(double, double);
double nexttoward(double, long double);
double remainder(double, double);
double remquo(double, double, int *);
double rint(double);
double round(double);
double scalbn(double, int);
double scalbln(double, long);
double tgamma(double);
double trunc(double);
# 635 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
double gamma(double x);
double gamma_r(double x, int *signgamp);
double j0(double x);
double y0(double x);
double j1(double x);
double y1(double x);
double jn(int n, double x);
double yn(int n, double x);
double lgamma_r(double x, int *signgamp);
double scalb(double x, int fn);
double drem(double x, double y);




float acosf(float);
float asinf(float);
float atanf(float);
float atan2f(float, float);
float ceilf(float);
float cosf(float);
float expf(float);
float fabsf(float);
float floorf(float);
float fmodf(float, float);
float frexpf(float, int *);
float ldexpf(float, int);
float logf(float);
float log10f(float);
float modff(float, float *);
float powf(float, float);
void sincosf(float, float *, float *);
float sinf(float);
float sqrtf(float);
float tanf(float);
float tanhf(float);


float acoshf(float);
float asinhf(float);
float atanhf(float);
float cbrtf(float);
float copysignf(float, float);
float erff(float);
float erfcf(float);
float expm1f(float);
float exp2f(float);
float fdimf(float, float);
float fmaf(float, float, float);
float fmaxf(float, float);
float fminf(float, float);
float hypotf(float, float);
float hypot3f(float, float, float);
int ilogbf(float);
float lgammaf(float);
long long llrintf(float);
long long llroundf(float);
float log1pf(float);
float log2f(float);
float logbf(float);
long lrintf(float);
long lroundf(float);
float nanf(const char *);
float nearbyintf(float);
float nextafterf(float, float);
float nexttowardf(float, long double);
float remainderf(float, float);
float remquof(float, float, int *);
float rintf(float);
float roundf(float);
float scalbnf(float, int);
float scalblnf(float, long);
float tgammaf(float);
float truncf(float);
# 755 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
float gammaf(float x);
float gammaf_r(float x, int *signgamp);
float j0f(float x);
float y0f(float x);
float j1f(float x);
float y1f(float x);
float jnf(int n, float x);
float ynf(int n, float x);
float lgammaf_r(float x, int *signgamp);
float scalbf(float x, int fn);
float dremf(float x, float y);




long double acosl(long double);
long double asinl(long double);
long double atanl(long double);
long double atan2l(long double, long double);
long double ceill(long double);
long double cosl(long double);
long double expl(long double);
long double fabsl(long double);
long double floorl(long double);
long double fmodl(long double, long double);
long double frexpl(long double, int *);
long double ldexpl(long double, int);
long double logl(long double);
long double log10l(long double);
long double modfl(long double, long double *);
long double powl(long double, long double);
long double sinl(long double);
long double sqrtl(long double);
long double tanl(long double);
long double tanhl(long double);


long double acoshl(long double);
long double asinhl(long double);
long double atanhl(long double);
long double cbrtl(long double);
long double copysignl(long double, long double);
long double erfl(long double);
long double erfcl(long double);
long double exp2l(long double);
long double expm1l(long double);
long double fdiml(long double, long double);
long double fmal(long double, long double, long double);
long double fmaxl(long double, long double);
long double fminl(long double, long double);
long double hypotl(long double, long double);
long double hypot3l(long double, long double, long double);
int ilogbl(long double);
long double lgammal(long double);
long long llrintl(long double);
long long llroundl(long double);
long double log1pl(long double);
long double log2l(long double);
long double logbl(long double);
long lrintl(long double);
long lroundl(long double);
long double nanl(const char *);
long double nearbyintl(long double);
long double nextafterl(long double, long double);
long double nexttowardl(long double, long double);
long double remainderl(long double, long double);
long double remquol(long double, long double, int *);
long double rintl(long double);
long double roundl(long double);
long double scalbnl(long double, int);
long double scalblnl(long double, long);
long double tgammal(long double);
long double truncl(long double);
# 873 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
inline double cosh(double _Left)
 {
 return (:: _Cosh(_Left, 1.0));
 }

inline double sinh(double _Left)
 {
 return (:: _Sinh(_Left, 1.0));
 }


}



inline double abs(double _Left)
 {
 return (fabs(_Left));
 }


extern "C" {

inline float coshf(float _Left)
 {
 return (:: _FCosh(_Left, 1.0F));
 }

inline float sinhf(float _Left)
 {
 return (:: _FSinh(_Left, 1.0F));
 }

}

inline float abs(float _Left)
 {
 return (fabsf(_Left));
 }

inline float acos(float _Left)
 {
 return (acosf(_Left));
 }

inline float asin(float _Left)
 {
 return (asinf(_Left));
 }

inline float atan(float _Left)
 {
 return (atanf(_Left));
 }

inline float atan2(float _Left, float _Right)
 {
 return (atan2f(_Left, _Right));
 }

inline float ceil(float _Left)
 {
 return (ceilf(_Left));
 }

inline float cos(float _Left)
 {
 return (cosf(_Left));
 }

inline float cosh(float _Left)
 {
 return (:: _FCosh(_Left, 1.0F));
 }

inline float exp(float _Left)
 {
 return (expf(_Left));
 }

inline float fabs(float _Left)
 {
 return (fabsf(_Left));
 }

inline float floor(float _Left)
 {
 return (floorf(_Left));
 }

inline float fmod(float _Left, float _Right)
 {
 return (fmodf(_Left, _Right));
 }

inline float frexp(float _Left, int *_Right)
 {
 return (frexpf(_Left, _Right));
 }

inline float ldexp(float _Left, int _Right)
 {
 return (ldexpf(_Left, _Right));
 }

inline float log(float _Left)
 {
 return (logf(_Left));
 }

inline float log10(float _Left)
 {
 return (log10f(_Left));
 }

inline float modf(float _Left, float *_Right)
 {
 return (modff(_Left, _Right));
 }

inline float pow(float _Left, float _Right)
 {
 return (powf(_Left, _Right));
 }

inline float sin(float _Left)
 {
 return (sinf(_Left));
 }

inline float sinh(float _Left)
 {
 return (:: _FSinh(_Left, 1.0F));
 }

inline float sqrt(float _Left)
 {
 return (sqrtf(_Left));
 }

inline float tan(float _Left)
 {
 return (tanf(_Left));
 }

inline float tanh(float _Left)
 {
 return (tanhf(_Left));
 }


inline float acosh(float _Left)
 {
 return (acoshf(_Left));
 }

inline float asinh(float _Left)
 {
 return (asinhf(_Left));
 }

inline float atanh(float _Left)
 {
 return (atanhf(_Left));
 }

inline float cbrt(float _Left)
 {
 return (cbrtf(_Left));
 }

inline float copysign(float _Left, float _Right)
 {
 return (copysignf(_Left, _Right));
 }

inline float erf(float _Left)
 {
 return (erff(_Left));
 }

inline float erfc(float _Left)
 {
 return (erfcf(_Left));
 }

inline float exp2(float _Left)
 {
 return (exp2f(_Left));
 }

inline float expm1(float _Left)
 {
 return (expm1f(_Left));
 }

inline float fdim(float _Left, float _Right)
 {
 return (fdimf(_Left, _Right));
 }

inline float fma(float _Left, float _Right, float _Addend)
 {
 return (fmaf(_Left, _Right, _Addend));
 }

inline float fmax(float _Left, float _Right)
 {
 return (fmaxf(_Left, _Right));
 }

inline float fmin(float _Left, float _Right)
 {
 return (fminf(_Left, _Right));
 }

inline float hypot(float _Left, float _Right)
 {
 return (hypotf(_Left, _Right));
 }

inline float hypot3(float _Left, float _Mid, float _Right)
 {
 return (hypot3f(_Left, _Mid, _Right));
 }

inline int ilogb(float _Left)
 {
 return (ilogbf(_Left));
 }

inline float lgamma(float _Left)
 {
 return (lgammaf(_Left));
 }

inline long long llrint(float _Left)
 {
 return (llrintf(_Left));
 }

inline long long llround(float _Left)
 {
 return (llroundf(_Left));
 }

inline float log1p(float _Left)
 {
 return (log1pf(_Left));
 }

inline float log2(float _Left)
 {
 return (log2f(_Left));
 }

inline float logb(float _Left)
 {
 return (logbf(_Left));
 }

inline long lrint(float _Left)
 {
 return (lrintf(_Left));
 }

inline long lround(float _Left)
 {
 return (lroundf(_Left));
 }

inline float nearbyint(float _Left)
 {
 return (nearbyintf(_Left));
 }

inline float nextafter(float _Left, float _Right)
 {
 return (nextafterf(_Left, _Right));
 }

inline float nexttoward(float _Left, long double _Right)
 {
 return (nexttowardf(_Left, _Right));
 }

inline float remainder(float _Left, float _Right)
 {
 return (remainderf(_Left, _Right));
 }

inline float remquo(float _Left, float _Right, int *_Pval)
 {
 return (remquof(_Left, _Right, _Pval));
 }

inline float rint(float _Left)
 {
 return (rintf(_Left));
 }

inline float round(float _Left)
 {
 return (roundf(_Left));
 }

inline float scalbn(float _Left, int _Right)
 {
 return (scalbnf(_Left, _Right));
 }

inline float scalbln(float _Left, long _Right)
 {
 return (scalblnf(_Left, _Right));
 }

inline float tgamma(float _Left)
 {
 return (tgammaf(_Left));
 }

inline float trunc(float _Left)
 {
 return (truncf(_Left));
 }
# 1353 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\math.h" 3
inline float gamma(float x)
{
  return gammaf(x);
}

inline float gamma_r(float x, int *signgamp)
{
  return gammaf_r(x, signgamp);
}

inline float j0(float x)
{
  return j0f(x);
}

inline float y0(float x)
{
  return y0f(x);
}

inline float j1(float x)
{
  return j1f(x);
}

inline float y1(float x)
{
  return y1f(x);
}

inline float jn(int n, float x)
{
  return jnf(n, x);
}

inline float yn(int n, float x)
{
  return ynf(n, x);
}

inline float lgamma_r(float x, int *signgamp)
{
  return lgammaf_r(x, signgamp);
}

inline float scalb(float x, int fn)
{
  return scalbf(x, fn);
}

inline float drem(float x, float y)
{
  return dremf(x, y);
}

inline void sincos(float _Left, float *_Psin, float *_Pcos)
{
  sincosf(_Left, _Psin, _Pcos);
}



extern "C" {

inline long double coshl(long double _Left)
 {
 return (:: _LCosh(_Left, 1.0L));
 }

inline long double sinhl(long double _Left)
 {
 return (:: _LSinh(_Left, 1.0L));
 }

}

inline long double abs(long double _Left)
 {
 return (fabsl(_Left));
 }

inline long double acos(long double _Left)
 {
 return (acosl(_Left));
 }

inline long double asin(long double _Left)
 {
 return (asinl(_Left));
 }

inline long double atan(long double _Left)
 {
 return (atanl(_Left));
 }

inline long double atan2(long double _Left, long double _Right)
 {
 return (atan2l(_Left, _Right));
 }

inline long double ceil(long double _Left)
 {
 return (ceill(_Left));
 }

inline long double cos(long double _Left)
 {
 return (cosl(_Left));
 }

inline long double cosh(long double _Left)
 {
 return (:: _LCosh(_Left, 1.0L));
 }

inline long double exp(long double _Left)
 {
 return (expl(_Left));
 }

inline long double fabs(long double _Left)
 {
 return (fabsl(_Left));
 }

inline long double floor(long double _Left)
 {
 return (floorl(_Left));
 }

inline long double fmod(long double _Left, long double _Right)
 {
 return (fmodl(_Left, _Right));
 }

inline long double frexp(long double _Left, int *_Right)
 {
 return (frexpl(_Left, _Right));
 }

inline long double ldexp(long double _Left, int _Right)
 {
 return (ldexpl(_Left, _Right));
 }

inline long double log(long double _Left)
 {
 return (logl(_Left));
 }

inline long double log10(long double _Left)
 {
 return (log10l(_Left));
 }

inline long double modf(long double _Left, long double *_Right)
 {
 return (modfl(_Left, _Right));
 }

inline long double pow(long double _Left, long double _Right)
 {
 return (powl(_Left, _Right));
 }

inline long double sin(long double _Left)
 {
 return (sinl(_Left));
 }

inline long double sinh(long double _Left)
 {
 return (:: _LSinh(_Left, 1.0L));
 }

inline long double sqrt(long double _Left)
 {
 return (sqrtl(_Left));
 }

inline long double tan(long double _Left)
 {
 return (tanl(_Left));
 }

inline long double tanh(long double _Left)
 {
 return (tanhl(_Left));
 }


inline long double acosh(long double _Left)
 {
 return (acoshl(_Left));
 }

inline long double asinh(long double _Left)
 {
 return (asinhl(_Left));
 }

inline long double atanh(long double _Left)
 {
 return (atanhl(_Left));
 }

inline long double cbrt(long double _Left)
 {
 return (cbrtl(_Left));
 }

inline long double copysign(long double _Left, long double _Right)
 {
 return (copysignl(_Left, _Right));
 }

inline long double erf(long double _Left)
 {
 return (erfl(_Left));
 }

inline long double erfc(long double _Left)
 {
 return (erfcl(_Left));
 }

inline long double exp2(long double _Left)
 {
 return (exp2l(_Left));
 }

inline long double expm1(long double _Left)
 {
 return (expm1l(_Left));
 }

inline long double fdim(long double _Left, long double _Right)
 {
 return (fdiml(_Left, _Right));
 }

inline long double fma(long double _Left, long double _Right,
 long double _Addend)
 {
 return (fmal(_Left, _Right, _Addend));
 }

inline long double fmax(long double _Left, long double _Right)
 {
 return (fmaxl(_Left, _Right));
 }

inline long double fmin(long double _Left, long double _Right)
 {
 return (fminl(_Left, _Right));
 }

inline long double hypot(long double _Left, long double _Right)
 {
 return (hypotl(_Left, _Right));
 }

inline long double hypot3(long double _Left, long double _Mid,
 long double _Right)
 {
 return (hypot3l(_Left, _Mid, _Right));
 }

inline int ilogb(long double _Left)
 {
 return (ilogbl(_Left));
 }

inline long double lgamma(long double _Left)
 {
 return (lgammal(_Left));
 }

inline long long llrint(long double _Left)
 {
 return (llrintl(_Left));
 }

inline long long llround(long double _Left)
 {
 return (llroundl(_Left));
 }

inline long double log1p(long double _Left)
 {
 return (log1pl(_Left));
 }

inline long double log2(long double _Left)
 {
 return (log2l(_Left));
 }

inline long double logb(long double _Left)
 {
 return (logbl(_Left));
 }

inline long lrint(long double _Left)
 {
 return (lrintl(_Left));
 }

inline long lround(long double _Left)
 {
 return (lroundl(_Left));
 }

inline long double nearbyint(long double _Left)
 {
 return (nearbyintl(_Left));
 }

inline long double nextafter(long double _Left, long double _Right)
 {
 return (nextafterl(_Left, _Right));
 }

inline long double nexttoward(long double _Left, long double _Right)
 {
 return (nexttowardl(_Left, _Right));
 }

inline long double remainder(long double _Left, long double _Right)
 {
 return (remainderl(_Left, _Right));
 }

inline long double remquo(long double _Left, long double _Right,
 int *_Pval)
 {
 return (remquol(_Left, _Right, _Pval));
 }

inline long double rint(long double _Left)
 {
 return (rintl(_Left));
 }

inline long double round(long double _Left)
 {
 return (roundl(_Left));
 }

inline long double scalbn(long double _Left, int _Right)
 {
 return (scalbnl(_Left, _Right));
 }

inline long double scalbln(long double _Left, long _Right)
 {
 return (scalblnl(_Left, _Right));
 }

inline long double tgamma(long double _Left)
 {
 return (tgammal(_Left));
 }

inline long double trunc(long double _Left)
 {
 return (truncl(_Left));
 }
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 2 3



namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2; using :: hypot;
using :: hypot3; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f; using :: hypotf;
using :: hypot3f; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l; using :: hypotl;
using :: hypot3l; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
# 191 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cmath" 3
using :: gamma;
using :: gamma_r;
using :: j0;
using :: y0;
using :: j1;
using :: y1;
using :: jn;
using :: yn;
using :: lgamma_r;
using :: scalb;
using :: drem;
using :: sincos;

using :: gammaf;
using :: gammaf_r;
using :: j0f;
using :: y0f;
using :: j1f;
using :: y1f;
using :: jnf;
using :: ynf;
using :: lgammaf_r;
using :: scalbf;
using :: dremf;
using :: sincosf;


}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 2 3
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_mbstate_t.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_mbstate_t.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_mbstate_t.h" 2 3





typedef _Mbstatet mbstate_t;
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_wc.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_types/_wc.h" 2 3





typedef _Sizet wctype_t;




typedef _Wintt wint_t;
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3
# 33 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 3
struct tm;
struct _Dnk_filet;







extern "C" {

wint_t fgetwc(_Filet *);
wchar_t *fgetws(wchar_t *, int,
 _Filet *);
wint_t fputwc(wchar_t, _Filet *);
int fputws(const wchar_t *,
 _Filet *);
int fwide(_Filet *, int);
int fwprintf(_Filet *,
 const wchar_t *, ...);
int fwscanf(_Filet *,
 const wchar_t *, ...);
wint_t getwc(_Filet *);
wint_t getwchar(void);
wint_t putwc(wchar_t, _Filet *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t *, size_t,
 const wchar_t *, ...);
int swscanf(const wchar_t *,
 const wchar_t *, ...);
wint_t ungetwc(wint_t, _Filet *);
int vfwprintf(_Filet *,
 const wchar_t *, _Va_list);
int vswprintf(wchar_t *, size_t,
 const wchar_t *, _Va_list);
int vwprintf(const wchar_t *, _Va_list);
int wprintf(const wchar_t *, ...);
int wscanf(const wchar_t *, ...);


int vfwscanf(_Filet *,
 const wchar_t *, _Va_list);
int vswscanf(const wchar_t *,
 const wchar_t *, _Va_list);
int vwscanf(const wchar_t *, _Va_list);



size_t mbrlen(const char *,
 size_t, mbstate_t *);
size_t mbrtowc(wchar_t *, const char *,
 size_t, mbstate_t *);
size_t mbsrtowcs(wchar_t *,
 const char **, size_t, mbstate_t *);
int mbsinit(const mbstate_t *);
size_t wcrtomb(char *,
 wchar_t, mbstate_t *);
size_t wcsrtombs(char *,
 const wchar_t **, size_t, mbstate_t *);
long wcstol(const wchar_t *,
 wchar_t **, int);


_Longlong wcstoll(const wchar_t *,
 wchar_t **, int);
_ULonglong wcstoull(const wchar_t *,
 wchar_t **, int);



wchar_t *wcscat(wchar_t *, const wchar_t *);
int wcscmp(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t *, const wchar_t *);
size_t wcslen(const wchar_t *);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t *,
 const wchar_t *, size_t);

int wcscoll(const wchar_t *, const wchar_t *);
size_t wcscspn(const wchar_t *, const wchar_t *);
wchar_t *wcsncat(wchar_t *,
 const wchar_t *, size_t);
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcstok(wchar_t *, const wchar_t *,
 wchar_t **);
size_t wcsxfrm(wchar_t *,
 const wchar_t *, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t *,
 const wchar_t *, size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);


size_t wcsftime(wchar_t *, size_t,
 const wchar_t *, const struct tm *);

wint_t _Btowc(int);
int _Wctob(wint_t);
double _WStod(const wchar_t *, wchar_t **, long);
float _WStof(const wchar_t *, wchar_t **, long);
long double _WStold(const wchar_t *, wchar_t **, long);
unsigned long _WStoul(const wchar_t *, wchar_t **, int);
}







extern "C" {
const wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
}

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_Str, wchar_t _Ch, size_t _Num)
 {
 return ((wchar_t *)wmemchr((const wchar_t *)_Str, _Ch, _Num));
 }
}
# 165 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcstod.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcstod.h" 3
extern "C" {
double wcstod(const wchar_t *, wchar_t **);

inline unsigned long wcstoul(const wchar_t * _Str,
 wchar_t ** _Endptr, int _Base)
 {return (:: _WStoul(_Str, _Endptr, _Base));
 }
}
# 166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwstr.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwstr.h" 3
extern "C" {
const wchar_t *wcschr(const wchar_t *, wchar_t);
const wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
const wchar_t *wcsrchr(const wchar_t *, wchar_t);
const wchar_t *wcsstr(const wchar_t *, const wchar_t *);
}

extern "C++" {
inline wchar_t *wcschr(wchar_t *_Str, wchar_t _Ch)
 {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch));
 }

inline wchar_t *wcspbrk(wchar_t *_Str1, const wchar_t *_Str2)
 {return ((wchar_t *)wcspbrk((const wchar_t *)_Str1, _Str2));
 }

inline wchar_t *wcsrchr(wchar_t *_Str, wchar_t _Ch)
 {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch));
 }

inline wchar_t *wcsstr(wchar_t *_Str1, const wchar_t *_Str2)
 {return ((wchar_t *)wcsstr((const wchar_t *)_Str1, _Str2));
 }
}

extern "C" {
inline wint_t btowc(int _By)
 {
 return (:: _Btowc(_By));
 }

inline int wctob(wint_t _Wc)
 {
 return (:: _Wctob(_Wc));
 }


float wcstof(const wchar_t *,
 wchar_t **);

inline long double wcstold(const wchar_t * _Str,
 wchar_t ** _Endptr)
 {
 return (:: _WStold(_Str, _Endptr, 0));
 }


}
# 167 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 2 3


extern "C" {

int fwprintf_s(_Filet *,
 const wchar_t *, ...);
int fwscanf_s(_Filet *,
 const wchar_t *, ...);
int snwprintf_s(wchar_t *, rsize_t,
 const wchar_t *, ...);
int swprintf_s(wchar_t *, rsize_t,
 const wchar_t *, ...);
int swscanf_s(const wchar_t *,
 const wchar_t *, ...);
int vfwprintf_s(_Filet *,
 const wchar_t *,
 _Va_list);
int vfwscanf_s(_Filet *,
 const wchar_t *,
 _Va_list);
int vsnwprintf_s(wchar_t *, rsize_t,
 const wchar_t *,
 _Va_list);
int vswprintf_s(wchar_t *, rsize_t,
 const wchar_t *,
 _Va_list);
int vswscanf_s(const wchar_t *,
 const wchar_t *,
 _Va_list);
int vwprintf_s(const wchar_t *,
 _Va_list);
int vwscanf_s(const wchar_t *,
 _Va_list);
int wprintf_s(const wchar_t *, ...);
int wscanf_s(const wchar_t *, ...);

errno_t wcscpy_s(wchar_t *, rsize_t,
 const wchar_t *);
errno_t wcsncpy_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wmemcpy_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wmemmove_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
errno_t wcscat_s(wchar_t *, rsize_t,
 const wchar_t *);
errno_t wcsncat_s(wchar_t *, rsize_t,
 const wchar_t *, rsize_t);
wchar_t *wcstok_s(wchar_t *, rsize_t *,
 const wchar_t *, wchar_t **);

size_t wcsnlen_s(const wchar_t *, size_t);

errno_t wcrtomb_s(size_t *,
 char *, rsize_t,
 wchar_t,
 mbstate_t *);
errno_t mbsrtowcs_s(size_t *,
 wchar_t *, rsize_t,
 const char **, rsize_t,
 mbstate_t *);
errno_t wcsrtombs_s(size_t *,
 char *, rsize_t,
 const wchar_t **, rsize_t,
 mbstate_t *);
}



extern "C++" {

template<rsize_t _Size>
errno_t mbsrtowcs_s(size_t *_Psize, wchar_t (&_Dst)[_Size], const char **_Src, rsize_t _Len, mbstate_t *_Ps)
 {
 return mbsrtowcs_s(_Psize, _Dst, _Size, _Src, _Len, _Ps);
 }

template<rsize_t _Size>
int swprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vswprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, va_list _Ap)
 {
 return vswprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<rsize_t _Size>
errno_t wcrtomb_s(size_t *_Psize, char (&_Str)[_Size], wchar_t _Wc, mbstate_t *_Ps)
 {
 return wcrtomb_s(_Psize, _Str, _Size, _Wc, _Ps);
 }

template<rsize_t _Size>
errno_t wcscat_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2)
 {
 return wcscat_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t wcscpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2)
 {
 return wcscpy_s(_Str1, _Size, _Str2);
 }

template<rsize_t _Size>
errno_t wcsncat_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wcsncat_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wcsncpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wcsncpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wcsrtombs_s(size_t *_Psize, char (&_Dst)[_Size], const wchar_t **_Src, rsize_t _Len, mbstate_t *_Ps)
 {
 return wcsrtombs_s(_Psize, _Dst, _Size, _Src, _Len, _Ps);
 }

template<rsize_t _Size>
int snwprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, ...)
 {
 int _Res;
 va_list _Ap;

 __builtin_va_start(_Ap, _Fmt);
 _Res = vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 __builtin_va_end(_Ap);

 return _Res;
 }

template<rsize_t _Size>
int vsnwprintf_s(wchar_t (&_Buf)[_Size], const wchar_t *_Fmt, va_list _Ap)
 {
 return vsnwprintf_s(_Buf, _Size, _Fmt, _Ap);
 }

template<size_t _Size>
size_t wcsnlen_s(const wchar_t (&_Str)[_Size])
 {
 return wcsnlen_s(_Str, _Size);
 }

template<rsize_t _Size>
errno_t wmemcpy_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wmemcpy_s(_Str1, _Size, _Str2, _Num);
 }

template<rsize_t _Size>
errno_t wmemmove_s(wchar_t (&_Str1)[_Size], const wchar_t *_Str2, rsize_t _Num)
 {
 return wmemmove_s(_Str1, _Size, _Str2, _Num);
 }

}
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 2 3





namespace std {
using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
# 75 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cwchar" 3
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 2 3


namespace std {
# 78 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 3
typedef enum
 {
 denorm_indeterminate = -1,
 denorm_absent = 0,
 denorm_present = 1}
  float_denorm_style;


typedef enum
 {
 round_indeterminate = -1,
 round_toward_zero = 0,
 round_to_nearest = 1,
 round_toward_infinity = 2,
 round_toward_neg_infinity = 3}
  float_round_style;


struct _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static constexpr bool has_denorm_loss = (bool)(false);
 static constexpr bool has_infinity = (bool)(false);
 static constexpr bool has_quiet_NaN = (bool)(false);
 static constexpr bool has_signaling_NaN = (bool)(false);
 static constexpr bool is_bounded = (bool)(false);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(false);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr bool is_specialized = (bool)(false);
 static constexpr bool tinyness_before = (bool)(false);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
 static constexpr int digits = (int)(0);
 static constexpr int digits10 = (int)(0);
 static constexpr int max_digits10 = (int)(0);

 static constexpr int max_exponent = (int)(0);
 static constexpr int max_exponent10 = (int)(0);
 static constexpr int min_exponent = (int)(0);
 static constexpr int min_exponent10 = (int)(0);
 static constexpr int radix = (int)(0);
 };


template<class _Ty>
 class numeric_limits
  : public _Num_base
 {
public:
 static constexpr _Ty (min)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty (max)() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty lowest() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty round_error() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty infinity() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (_Ty());
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (_Ty());
  }
 };

template<class _Ty>
 class numeric_limits<const _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<const volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };


struct _Num_int_base
 : public _Num_base
 {
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(true);
 static constexpr bool is_integer = (bool)(true);
 static constexpr bool is_modulo = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr int radix = (int)(2);
 };


struct _Num_float_base
 : public _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static constexpr bool has_denorm_loss = (bool)(false);
 static constexpr bool has_infinity = (bool)(true);
 static constexpr bool has_quiet_NaN = (bool)(true);
 static constexpr bool has_signaling_NaN = (bool)(true);
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(true);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr bool tinyness_before = (bool)(true);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
 static constexpr int radix = (int)(2);
 };


struct _Num_ldbl_base
 : public _Num_base
 {
 static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
 static constexpr bool has_denorm_loss = (bool)(true);
 static constexpr bool has_infinity = (bool)(true);
 static constexpr bool has_quiet_NaN = (bool)(true);
 static constexpr bool has_signaling_NaN = (bool)(true);
 static constexpr bool is_bounded = (bool)(true);
 static constexpr bool is_exact = (bool)(false);
 static constexpr bool is_iec559 = (bool)(true);
 static constexpr bool is_integer = (bool)(false);
 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(true);
 static constexpr bool is_specialized = (bool)(true);
 static constexpr bool tinyness_before = (bool)(true);
 static constexpr bool traps = (bool)(false);
 static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
 static constexpr int radix = (int)(2);
 };


template<> class numeric_limits<char>
 : public _Num_int_base
 {
public:
 typedef char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7f - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7f);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)((-0x7f - 1) != 0);
 static constexpr int digits = (int)(8 - ((-0x7f - 1) != 0 ? 1 : 0));
 static constexpr int digits10 = (int)((8 - ((-0x7f - 1) != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<wchar_t>
 : public _Num_int_base
 {
public:
 typedef wchar_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((_Ty)0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return ((_Ty)0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(0 != 0);
 static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0 != 0 ? 1 : 0));

 static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0 != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<bool>
 : public _Num_int_base
 {
public:
 typedef bool _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (false);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (true);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_modulo = (bool)(false);
 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(1);
 static constexpr int digits10 = (int)(0);
 };


template<> class numeric_limits<signed char>
 : public _Num_int_base
 {
public:
 typedef signed char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7f - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7f);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 - 1);
 static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
 };


template<> class numeric_limits<unsigned char>
 : public _Num_int_base
 {
public:
 typedef unsigned char _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8);
 static constexpr int digits10 = (int)(8 * 301L / 1000);
 };


template<> class numeric_limits<short>
 : public _Num_int_base
 {
public:
 typedef short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (short) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned short>
 : public _Num_int_base
 {
public:
 typedef unsigned short _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned short));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);

 };


template<> class numeric_limits<char16_t>
 : public _Num_int_base
 {
public:
 typedef char16_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char16_t));
 static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);

 };


template<> class numeric_limits<int>
 : public _Num_int_base
 {
public:
 typedef int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fffffff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (int) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned int>
 : public _Num_int_base
 {
public:
 typedef unsigned int _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned int));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);

 };


template<> class numeric_limits<long>
 : public _Num_int_base
 {
public:
 typedef long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return ((-0x7fffffffffffffff - 1));
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffffffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long>
 : public _Num_int_base
 {
public:
 typedef unsigned long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);

 };


template<> class numeric_limits<char32_t>
 : public _Num_int_base
 {
public:
 typedef char32_t _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffff);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (char32_t));
 static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);

 };



template<> class numeric_limits<long long>
 : public _Num_int_base
 {
public:
 typedef long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (-0x7fffffffffffffffLL - 1);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0x7fffffffffffffffLL);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(true);
 static constexpr int digits = (int)(8 * sizeof (long long) - 1);
 static constexpr int digits10 = (int)((8 * sizeof (long long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long long>
 : public _Num_int_base
 {
public:
 typedef unsigned long long _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (0);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (0xffffffffffffffffULL);
  }

 static constexpr _Ty lowest() noexcept
  {
  return ((min)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (0);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (0);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (0);
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (0);
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (0);
  }

 static constexpr bool is_signed = (bool)(false);
 static constexpr int digits = (int)(8 * sizeof (unsigned long long));
 static constexpr int digits10 = (int)(8 * sizeof (unsigned long long) * 301L / 1000);

 };



template<> class numeric_limits<float>
 : public _Num_float_base
 {
public:
 typedef float _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (1.175494351E-38F);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (3.402823466E+38F);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (1.192092896E-07F);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5F);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (1.175494351E-38F);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_valf());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nanf(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nansf(""));
  }

 static constexpr int digits = (int)(24);
 static constexpr int digits10 = (int)(6);
 static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)128);
 static constexpr int max_exponent10 = (int)((int)38);
 static constexpr int min_exponent = (int)((int)-125);
 static constexpr int min_exponent10 = (int)((int)-37);
 };


template<> class numeric_limits<double>
 : public _Num_float_base
 {
public:
 typedef double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (2.2250738585072014E-308);
  }

 static constexpr _Ty (max)() noexcept
  {
  return (1.7976931348623157E+308);
  }

 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (2.2204460492503131E-016);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (2.2250738585072014E-308);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_val());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nan(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nans(""));
  }

 static constexpr int digits = (int)(53);
 static constexpr int digits10 = (int)(15);
 static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)1024);
 static constexpr int max_exponent10 = (int)((int)308);
 static constexpr int min_exponent = (int)((int)-1021);
 static constexpr int min_exponent10 = (int)((int)-307);
 };


template<> class numeric_limits<long double>
 : public _Num_ldbl_base
 {
public:
 typedef long double _Ty;

 static constexpr _Ty (min)() noexcept
  {
  return (3.362103143112093506263E-4932L);
  }


 static constexpr _Ty (max)() noexcept
  {
  return (1.189731495357231765021E+4932L);
  }


 static constexpr _Ty lowest() noexcept
  {
  return (-(max)());
  }

 static constexpr _Ty epsilon() noexcept
  {
  return (1.084202172485504434007E-19L);
  }

 static constexpr _Ty round_error() noexcept
  {
  return (0.5L);
  }

 static constexpr _Ty denorm_min() noexcept
  {
  return (3.645199531882474602528E-4951L);
  }

 static constexpr _Ty infinity() noexcept
  {
  return (__builtin_huge_vall());
  }

 static constexpr _Ty quiet_NaN() noexcept
  {
  return (__builtin_nanl(""));
  }

 static constexpr _Ty signaling_NaN() noexcept
  {
  return (__builtin_nansl(""));
  }

 static constexpr int digits = (int)(64);
 static constexpr int digits10 = (int)(18);
 static constexpr int max_digits10 = (int)(2 + 64 * 301L / 1000);

 static constexpr int max_exponent = (int)((int)16384);
 static constexpr int max_exponent10 = (int)((int)4932);
 static constexpr int min_exponent = (int)((int)-16381);
 static constexpr int min_exponent10 = (int)((int)-4931);
 };
# 1326 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\limits" 3
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
namespace std {

class bad_alloc
 : public ::std:: exception
 {
public:
 bad_alloc(const char *_Message = "bad allocation") noexcept
  : exception(_Message)
  {
  }

 virtual const char *what() const noexcept;


 virtual ~bad_alloc() noexcept;
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
protected:
 virtual void _Doraise() const;

 };


class bad_array_new_length
 : public bad_alloc
 {
public:
 bad_array_new_length() noexcept
  : bad_alloc("bad array new length")
  {
  }


 virtual ~bad_array_new_length() noexcept;


 };
# 70 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
struct nothrow_t
 {



 };
extern const nothrow_t nothrow;
typedef void (*new_handler)();

new_handler get_new_handler() noexcept;
new_handler set_new_handler(new_handler) noexcept;
}


void *operator new(::std:: size_t);
inline void *operator new(::std:: size_t, void *_Ptr) noexcept { return (_Ptr); }
void *operator new(::std:: size_t, const ::std:: nothrow_t&) noexcept;
# 95 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
inline void operator delete(void *, void *) noexcept { }


void operator delete(void *) noexcept;
void operator delete(void *, const ::std:: nothrow_t&) noexcept;

void operator delete(void *, ::std:: size_t) noexcept;
void operator delete(void *, :: size_t, const ::std:: nothrow_t&) noexcept;
# 112 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
void *operator new[](::std:: size_t);
inline void *operator new[](::std:: size_t, void *_Ptr) noexcept { return (_Ptr); }
void *operator new[](::std:: size_t, const ::std:: nothrow_t&) noexcept;
# 123 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\new" 3
inline void operator delete[](void *, void *) noexcept { }


void operator delete[](void *) noexcept;
void operator delete[](void *, const ::std:: nothrow_t&) noexcept;

void operator delete[](void *, ::std:: size_t) noexcept;
void operator delete[](void *, :: size_t, const ::std:: nothrow_t&) noexcept;
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 2 3
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 3
namespace std {
using :: _Filet; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: gets; using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstdio" 3
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstring" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstring" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstring" 2 3
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cstring" 3
namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strerror_r;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 2 3



namespace std {





typedef long streamoff;
typedef int streamsize;
# 33 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
extern fpos_t _Fpz;
extern const streamoff _BADOFF;


template<class _Statetype>
 class fpos
 {
 typedef fpos<_Statetype> _Myt;

public:
 fpos(streamoff _Off = 0)
  : _Myoff(_Off), _Fpos(_Fpz), _Mystate()
  {
  }

 fpos(_Statetype _State, fpos_t _Fileposition)
  : _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
  {
  }

 _Statetype state() const
  {
  return (_Mystate);
  }

 void state(_Statetype _State)
  {
  _Mystate = _State;
  }

 fpos_t seekpos() const
  {
  return (_Fpos);
  }

 operator streamoff() const
  {
  return ((streamoff)(_Myoff + ((_Fpos)._Off)));
  }

 streamoff operator-(const _Myt& _Right) const
  {
  return ((streamoff)*this - (streamoff)_Right);
  }

 _Myt& operator+=(streamoff _Off)
  {
  _Myoff += _Off;
  return (*this);
  }

 _Myt& operator-=(streamoff _Off)
  {
  _Myoff -= _Off;
  return (*this);
  }

 _Myt operator+(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt operator-(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }

private:
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };

template<class _Statetype>
 bool operator==(const fpos<_Statetype>& _Left,
  const fpos<_Statetype>& _Right)
 {
 return ((streamoff)_Left == (streamoff)_Right);
 }

template<class _Statetype>
 bool operator!=(const fpos<_Statetype>& _Left,
  const fpos<_Statetype>& _Right)
 {
 return (!(_Left == _Right));
 }
# 138 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
typedef fpos<_Mbstatet> streampos;


typedef streampos wstreampos;


template<class _Elem,
 class _Int_type>
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

           static int compare(
  const _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  for (; 0 < _Count; --_Count, ++_First1, ++_First2)
   if (!eq(*_First1, *_First2))
    return (lt(*_First1, *_First2) ? -1 : +1);
  return (0);
  }

           static size_t
  length(const _Elem *_First)
  {
  size_t _Count = 0;
  for (; !eq(*_First, _Elem()); ++_First)
   ++_Count;
  return (_Count);
  }

           static _Elem *copy(
  _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  for (; 0 < _Count; --_Count, ++_Next, ++_First2)
   assign(*_Next, *_First2);
  return (_First1);
  }

           static const _Elem *find(
  const _Elem *_First,
  size_t _Count, const _Elem& _Ch)
  {
  for (; 0 < _Count; --_Count, ++_First)
   if (eq(*_First, _Ch))
    return (_First);
  return (0);
  }

           static _Elem *move(
  _Elem *_First1,
  const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  if (_First2 < _Next && _Next < _First2 + _Count)
   for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
    assign(*--_Next, *--_First2);
  else
   for (; 0 < _Count; --_Count, ++_Next, ++_First2)
    assign(*_Next, *_First2);
  return (_First1);
  }

           static _Elem *assign(
  _Elem *_First,
  size_t _Count, _Elem _Ch)
  {
  _Elem *_Next = _First;
  for (; 0 < _Count; --_Count, ++_Next)
   assign(*_Next, _Ch);
  return (_First);
  }

 static void
  assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return ((int_type)_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
  }
# 297 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return ((int_type)(-1));
  }
 };


template<class _Elem>
 struct char_traits
  : public _Char_traits<_Elem, long>
 {
 };


template<>
 struct char_traits<char16_t>
 : public _Char_traits<char16_t, unsigned short>
 {
 };

typedef streampos u16streampos;


template<>
 struct char_traits<char32_t>
 : public _Char_traits<char32_t, unsigned int>
 {
 };

typedef streampos u32streampos;


template<>
 struct char_traits<wchar_t>
 {
 typedef wchar_t _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;


 static int compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : __builtin_wmemcmp(_First1, _First2, _Count));
  }
# 356 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static size_t length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : __builtin_wcslen(_First));
  }
# 369 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static _Elem *copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemcpy(_First1, _First2, _Count));
  }


 static const _Elem *find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *)__builtin_wmemchr(_First, _Ch, _Count));
  }
# 392 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static _Elem *move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemmove(_First1, _First2, _Count));
  }

 static _Elem *assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: wmemset(_First, _Ch, _Count));
  }

 static void assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left < _Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return (_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }
# 484 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return (((:: wint_t)(-1)));
  }
 };


template<> struct char_traits<char>
 {
 typedef char _Elem;
 typedef _Elem char_type;
 typedef int int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;


 static int compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : __builtin_memcmp(_First1, _First2, _Count));
  }
# 517 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static size_t length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : __builtin_strlen(_First));
  }
# 530 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static _Elem *copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memcpy(_First1, _First2, _Count));
  }


 static const _Elem *find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *)__builtin_memchr(_First, _Ch, _Count));
  }
# 553 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static _Elem *move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memmove(_First1, _First2, _Count));
  }

 static _Elem *assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: memset(_First, _Ch, _Count));
  }

 static void assign(_Elem& _Left, const _Elem& _Right) noexcept
  {
  _Left = _Right;
  }


 static constexpr bool eq(_Elem _Left,
  _Elem _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr bool lt(_Elem _Left,
  _Elem _Right) noexcept
  {
  return ((unsigned char)_Left < (unsigned char)_Right);
  }

 static constexpr _Elem to_char_type(
  int_type _Meta) noexcept
  {
  return ((_Elem)_Meta);
  }

 static constexpr int_type to_int_type(
  _Elem _Ch) noexcept
  {
  return ((unsigned char)_Ch);
  }

 static constexpr bool eq_int_type(int_type _Left,
  int_type _Right) noexcept
  {
  return (_Left == _Right);
  }

 static constexpr int_type not_eof(
  int_type _Meta) noexcept
  {
  return (_Meta != eof() ? _Meta : !eof());
  }
# 645 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iosfwd" 3
 static constexpr int_type eof() noexcept
  {
  return ((-1));
  }
 };


template<class _Ty>
 class allocator;
class ios_base;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ios;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class istreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class ostreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_streambuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_istream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ostream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_iostream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringbuf;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_istringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_ostringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_filebuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ifstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ofstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_fstream;


typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
 allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
 allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
 allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
 allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;


typedef basic_filebuf<char, char_traits<char> > stdiobuf;
typedef basic_fstream<char, char_traits<char> > stdiostream;



typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
 wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
}


using ::std:: ios;
using ::std:: streambuf;
using ::std:: istream;
using ::std:: ostream;
using ::std:: iostream;

using ::std:: filebuf;
using ::std:: ifstream;
using ::std:: ofstream;
using ::std:: fstream;

using ::std:: stdiobuf;
using ::std:: stdiostream;
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 2 3


namespace std {





template<class _Ty> inline

 void swap(_Ty& _Left, _Ty& _Right)
  noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)

 {
 _Ty _Tmp = _Move(_Left);
 _Left = _Move(_Right);
 _Right = _Move(_Tmp);
 }






template<class _Ty,
 size_t _Size> inline

 void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])



  noexcept(noexcept(swap(*_Left, *_Right)))

 {
 if (&_Left != &_Right)
  {
  _Ty *_First1 = _Left;
  _Ty *_Last1 = _First1 + _Size;
  _Ty *_First2 = _Right;
  for (; _First1 != _Last1; ++_First1, ++_First2)
   swap(*_First1, *_First2);
  }
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
 {
 swap(*_Left, *_Right);
 }


template<class _Ty> inline
 bool _Swap_adl(_Ty& _Left, _Ty& _Right)
  noexcept(noexcept((swap(_Left, _Right), true)))
 {
 swap(_Left, _Right);
 return (true);
 }


struct piecewise_construct_t
 {



 };



constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


template<class...>
 class tuple;

template<class _Ty1,
 class _Ty2>
 struct pair
 {
 typedef pair<_Ty1, _Ty2> _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;
# 104 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 constexpr pair()
  : first(), second()
  {
  }

 constexpr pair(const pair&) = default;
 constexpr pair(pair&&) = default;
# 121 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<const _Other1&, _Ty1>::value
   && is_convertible<const _Other2&, _Ty2>::value,
   void> >

  constexpr pair(const pair<_Other1, _Other2>& _Right)
   : first(_Right.first), second(_Right.second)
  {
  }
# 155 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<_Other1, _Ty1>::value
   && is_convertible<_Other2, _Ty2>::value,
   void> >

  constexpr pair(pair<_Other1, _Other2>&& _Right)
   : first(::std:: forward<_Other1>(_Right.first)),
    second(::std:: forward<_Other2>(_Right.second))
  {
  }
# 191 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
  constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
   : first(_Val1), second(_Val2)
  {
  }
# 219 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2,
  class = enable_if_t<is_convertible<_Other1, first_type>::value
   && is_convertible<_Other2, second_type>::value,
   void> >

  constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
   : first(::std:: forward<_Other1>(_Val1)),
    second(::std:: forward<_Other2>(_Val2))
  {
  }
# 247 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   integer_sequence<size_t, _Indexes1...>,
   integer_sequence<size_t, _Indexes2...>);
# 264 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class... _Types1,
  class... _Types2> inline
  pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2);

 struct _Deleted {};





 _Myt& operator=(const _Myt& _Right)

  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }
# 291 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2>

  _Myt& operator=(const pair<_Other1, _Other2>& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }





 _Myt& operator=(_Myt&& _Right)

   noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))

  {
  first = ::std:: forward<_Ty1>(_Right.first);
  second = ::std:: forward<_Ty2>(_Right.second);
  return (*this);
  }
# 322 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
 template<class _Other1,
  class _Other2>

  _Myt& operator=(pair<_Other1, _Other2>&& _Right)
  {
  first = ::std:: forward<_Other1>(_Right.first);
  second = ::std:: forward<_Other2>(_Right.second);
  return (*this);
  }

 void swap(_Myt& _Right)




  noexcept(noexcept((_Swap_adl(this->first, _Right.first))) && noexcept((_Swap_adl(this->second, _Right.second))))


  {
  if (this != &_Right)
   {
   _Swap_adl(first, _Right.first);
   _Swap_adl(second, _Right.second);
   }
  }

 _Ty1 first;
 _Ty2 second;
 };
# 365 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<class _Ty1,
 class _Ty2> inline

 void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)




  noexcept(noexcept(_Left.swap(_Right)))

 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first == _Right.first && _Left.second == _Right.second);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first < _Right.first
  || (!(_Right.first < _Left.first) && _Left.second < _Right.second));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty1,
 class _Ty2> inline
 constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type>
  make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
 {
 typedef pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type> _Mypair;
 return (_Mypair(::std:: forward<_Ty1>(_Val1),
  ::std:: forward<_Ty2>(_Val2)));
 }


 namespace rel_ops
  {
template<class _Ty> inline
 bool operator!=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty> inline
 bool operator>(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty> inline
 bool operator<=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty> inline
 bool operator>=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left < _Right));
 }
  }
}

namespace std {
template<class _Ty,
 size_t _Size>
 class array;


template<class _Tuple>
 struct tuple_size;


template<class _Ty,
 size_t _Size>
 struct tuple_size<array<_Ty, _Size> >

  : integral_constant<int, _Size>



 {
 };
# 505 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<class _Ty1,
 class _Ty2>
 struct tuple_size<pair<_Ty1, _Ty2> >

 : integral_constant<int, 2>



 {
 };
# 528 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<class... _Types>
 struct tuple_size<tuple<_Types...> >
 : integral_constant<size_t, sizeof...(_Types)>
 {
 };



template<class _Tuple, size_t>
 using _Tuple_size_sfinae = _Tuple;

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<const _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<volatile _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };

template<class _Tuple>
 struct tuple_size<_Tuple_size_sfinae<const volatile _Tuple, sizeof(tuple_size<_Tuple>)>>
 : integral_constant<size_t, tuple_size<_Tuple>::value>
 {
 };
# 584 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<size_t _Index,
 class _Tuple>
 struct tuple_element;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 struct tuple_element<_Idx, array<_Ty, _Size> >
 {
 tuple_element()
  {
  static_assert(_Idx < _Size, "array index out of bounds");
  }

 typedef _Ty type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<0, pair<_Ty1, _Ty2> >
 {
 typedef _Ty1 type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<1, pair<_Ty1, _Ty2> >
 {
 typedef _Ty2 type;
 };

template<size_t _Index>
 struct tuple_element<_Index, tuple<> >
 {
 static_assert(_Always_false<integral_constant<size_t, _Index> >::value,
  "tuple index out of bounds");
 };

template<class _This,
 class... _Rest>
 struct tuple_element<0, tuple<_This, _Rest...> >
 {
 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<size_t _Index,
 class _This,
 class... _Rest>
 struct tuple_element<_Index, tuple<_This, _Rest...> >
  : public tuple_element<_Index - 1, tuple<_Rest...> >
 {
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const volatile _Tuple>
  : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };



template<size_t _Index,
 class _Tuple>
 using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;




template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 0>) noexcept
 {
 return (_Pr.first);
 }

template<class _Ret,
 class _Pair> inline
 constexpr _Ret _Pair_get(_Pair& _Pr,
  integral_constant<size_t, 1>) noexcept
 {
 return (_Pr.second);
 }

template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
 return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }


template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
  _Ctype;
 return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<0>(_Pr));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
 {
 return (::std:: get<1>(_Pr));
 }


template<size_t _Idx,
 class _Ty1,
 class _Ty2> inline
 constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
  get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
 return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
 }


template<class _Ty1,
 class _Ty2> inline
 constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<0>(::std:: move(_Pr)));
 }

template<class _Ty2,
 class _Ty1> inline
 constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
 {
 return (::std:: get<1>(::std:: move(_Pr)));
 }
# 796 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
template<class _Ty,
 class _Other = _Ty> inline
 _Ty exchange(_Ty& _Val, _Other&& _New_val)
 {
 _Ty _Old_val = ::std:: move(_Val);
 _Val = ::std:: forward<_Other>(_New_val);
 return (_Old_val);
 }
# 845 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\utility" 3
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 1 3
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
 {
 _Container_base0()

  : _Myproxy(0)

  {
  }

 void _Orphan_all()
  {
  }

 void _Swap_all(_Container_base0&)
  {
  }


 _Container_proxy *_Myproxy;

 };

struct _Iterator_base0
 {
                _Iterator_base0()

  : _Myproxy(0), _Mynextiter(0)

  {
  }

 void _Adopt(const void *)
  {
  }

 const _Container_base0 *_Getcont() const
  {
  return (0);
  }


 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;

 };


struct _Container_proxy
 {
 _Container_proxy()
  : _Mycont(0), _Myfirstiter(0)
  {
  }

 const _Container_base12 *_Mycont;
 _Iterator_base12 *_Myfirstiter;
 };

struct _Container_base12
 {
public:
 _Container_base12()
  : _Myproxy(0)
  {
  }

 _Container_base12(const _Container_base12&)
  : _Myproxy(0)
  {
  }

 _Container_base12& operator=(const _Container_base12&)
  {
  return (*this);
  }

 ~_Container_base12() noexcept
  {
  _Orphan_all();
  }

 _Iterator_base12 **_Getpfirst() const
  {
  return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
  }

 void _Orphan_all();
 void _Swap_all(_Container_base12&);

 _Container_proxy *_Myproxy;
 };

struct _Iterator_base12
 {
public:
 _Iterator_base12()
  : _Myproxy(0), _Mynextiter(0)
  {
  }

 _Iterator_base12(const _Iterator_base12& _Right)
  : _Myproxy(0), _Mynextiter(0)
  {
  *this = _Right;
  }

 _Iterator_base12& operator=(const _Iterator_base12& _Right)
  {
  if (_Myproxy == _Right._Myproxy)
   ;
  else if (_Right._Myproxy != 0)
   _Adopt(_Right._Myproxy->_Mycont);
  else
   {




   }
  return (*this);
  }

 ~_Iterator_base12() noexcept
  {




  }

 void _Adopt(const _Container_base12 *_Parent)
  {
  if (_Parent == 0)
   {




   }
  else
   {
   _Container_proxy *_Parent_proxy = _Parent->_Myproxy;
# 258 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
   _Myproxy = _Parent_proxy;

   }
  }

 void _Clrcont()
  {
  _Myproxy = 0;
  }

 const _Container_base12 *_Getcont() const
  {
  return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
  }

 _Iterator_base12 **_Getpnext()
  {
  return (&_Mynextiter);
  }

 void _Orphan_me()
  {
# 293 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
  }

 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;
 };


inline void _Container_base12::_Orphan_all()
 {
# 313 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
 }

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
 {




 _Container_proxy *_Temp = _Myproxy;
 _Myproxy = _Right._Myproxy;
 _Right._Myproxy = _Temp;

 if (_Myproxy != 0)
  _Myproxy->_Mycont = (_Container_base12 *)this;
 if (_Right._Myproxy != 0)
  _Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
 }


typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;







struct _Zero_then_variadic_args_t
 {
 };

struct _One_then_variadic_args_t
 {
 };

template<class _Ty1,
 class _Ty2,
 bool = is_empty<_Ty1>::value>
 class _Compressed_pair
  : private _Ty1
 {
private:
 _Ty2 _Myval2;

public:
 _Compressed_pair()
  {
  }

 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Ty1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 _Compressed_pair(const _Compressed_pair& _Right)
  : _Ty1(_Right),
   _Myval2(_Right._Myval2)
  {
  }

 _Compressed_pair(_Compressed_pair&& _Right)
  : _Ty1(::std:: move(_Right)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Compressed_pair& operator=(_Compressed_pair&& _Right)
  {
  *this = ::std:: move(_Right);
  return (*this);
  }

 _Ty1& _Get_first() noexcept
  {
  return (*this);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (*this);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (*this);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (*this);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };

template<class _Ty1,
 class _Ty2>
 class _Compressed_pair<_Ty1, _Ty2, false>
 {
private:
 _Ty1 _Myval1;
 _Ty2 _Myval2;

public:
 _Compressed_pair()
  {
  }

 template<class... _Other2>
  constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
   _Other2&&... _Val2)
  : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 template<class _Other1,
  class... _Other2>
  _Compressed_pair(_One_then_variadic_args_t,
   _Other1&& _Val1, _Other2&&... _Val2)
  : _Myval1(::std:: forward<_Other1>(_Val1)),
   _Myval2(::std:: forward<_Other2>(_Val2)...)
  {
  }

 _Compressed_pair& operator=(_Compressed_pair&& _Right)
  {
  _Myval1 = ::std:: forward<_Ty1>(_Right._Myval1);
  _Myval2 = ::std:: forward<_Ty2>(_Right._Myval2);
  return (*this);
  }

 _Compressed_pair(const _Compressed_pair& _Right)
  : _Myval1(::std:: move(_Right._Myval1)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Compressed_pair(_Compressed_pair&& _Right)
  : _Myval1(::std:: move(_Right._Myval1)),
   _Myval2(::std:: move(_Right._Myval2))
  {
  }

 _Ty1& _Get_first() noexcept
  {
  return (_Myval1);
  }

 const _Ty1& _Get_first() const noexcept
  {
  return (_Myval1);
  }

 volatile _Ty1& _Get_first() volatile noexcept
  {
  return (_Myval1);
  }

 const volatile _Ty1& _Get_first() const volatile noexcept
  {
  return (_Myval1);
  }

 _Ty2& _Get_second() noexcept
  {
  return (_Myval2);
  }

 const _Ty2& _Get_second() const noexcept
  {
  return (_Myval2);
  }

 volatile _Ty2& _Get_second() volatile noexcept
  {
  return (_Myval2);
  }

 const volatile _Ty2& _Get_second() const volatile noexcept
  {
  return (_Myval2);
  }
 };






template<class _Ty>
 struct _Get_unchecked_type
  { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::_Unchecked_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Ty>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class = void>
 struct _Is_checked_helper
  : false_type
 {
 };

template<class _Ty>
 struct _Is_checked_helper<_Ty, typename _Param_tester<
  typename _Ty::_Unchecked_type>::type>
  : true_type
 {
 };


template<class _Iter> inline
 typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
 {
 return (typename _Is_checked_helper<_Iter>::type());
 }


template<class _Iter> inline
 _Iter _Unchecked(_Iter _Src)
 {
 return (_Src);
 }


template<class _Iter,
 class _UIter> inline
 _Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
 {
 _Dest = _Src;
 return (_Dest);
 }



struct input_iterator_tag
 {
 };

struct _Mutable_iterator_tag
 {
 };

struct output_iterator_tag
 : _Mutable_iterator_tag
 {
 };

struct forward_iterator_tag
 : input_iterator_tag, _Mutable_iterator_tag
 {
 };

struct bidirectional_iterator_tag
 : forward_iterator_tag
 {
 };

struct random_access_iterator_tag
 : bidirectional_iterator_tag
 {
 };

struct _Int_iterator_tag
 {
 };


struct _Nonscalar_ptr_iterator_tag
 {
 };
struct _Scalar_ptr_iterator_tag
 {
 };


template<class _Category,
 class _Ty,
 class _Diff = ptrdiff_t,
 class _Pointer = _Ty *,
 class _Reference = _Ty&>
 struct iterator
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;
 typedef _Diff distance_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
 };

template<class _Category,
 class _Ty,
 class _Diff,
 class _Pointer,
 class _Reference,
 class _Base>
 struct _Iterator012
  : public _Base
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;
 typedef _Diff distance_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
 };


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;


template<class,
 class = void>
 struct _Is_iterator
  : false_type
 {
 };

template<class _Ty>
 struct _Is_iterator<_Ty, typename _Param_tester<
  typename _Ty::iterator_category,
  typename _Ty::value_type,
  typename _Ty::difference_type,
  typename _Ty::pointer,
  typename _Ty::reference
  >::type>
  : true_type
 {
 };

template<class _Ty>
 struct _Is_iterator<_Ty *>
  : true_type
 {
 };


template<class _Iter,
 bool = _Is_iterator<_Iter>::value>
 struct _Iterator_traits_base
 {
 typedef typename _Iter::iterator_category iterator_category;
 typedef typename _Iter::value_type value_type;
 typedef typename _Iter::difference_type difference_type;
 typedef difference_type distance_type;
 typedef typename _Iter::pointer pointer;
 typedef typename _Iter::reference reference;
 };

template<class _Iter>
 struct _Iterator_traits_base<_Iter, false>
 {
 };

template<class _Iter>
 struct iterator_traits
  : _Iterator_traits_base<_Iter>
 {
 };

template<class _Ty>
 struct iterator_traits<_Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;
 typedef ptrdiff_t distance_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;
 };

template<class _Ty>
 struct iterator_traits<const _Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;
 typedef ptrdiff_t distance_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 };
# 795 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
template<class _Iter> inline
                typename iterator_traits<_Iter>::iterator_category
  _Iter_cat(const _Iter&)
 {
 typename iterator_traits<_Iter>::iterator_category _Cat;
 return (_Cat);
 }



template<class _Ty1, class _Ty2> inline
auto _Ptr_cat(_Ty1&, _Ty2&)
  -> typename std::conditional<(

      (!std::is_pointer<_Ty1>::value) ||

      (!std::is_pointer<_Ty2>::value) ||

      ((std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ) ||
      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
        std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value )) ||

      (std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
      !std::is_same<typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::type>::type,
                    typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::type>::type >::value ) ||

      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
       (!std::is_same<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type,
                     typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ))),
        _Nonscalar_ptr_iterator_tag,
        _Scalar_ptr_iterator_tag>::type {

  typename std::conditional<(

      (!std::is_pointer<_Ty1>::value) ||

      (!std::is_pointer<_Ty2>::value) ||

      ((std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ) ||
      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
        std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value )) ||

      (std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
      !std::is_same<typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::type>::type,
                    typename std::remove_const<typename std::remove_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::type>::type >::value ) ||

      (!std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value &&
       !std::is_pointer<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value &&
       (!std::is_same<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type,
                     typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty1>::type>::type>::value ||
       !std::is_scalar<typename std::remove_const<typename std::remove_pointer<_Ty2>::type>::type>::value ))),
        _Nonscalar_ptr_iterator_tag,
        _Scalar_ptr_iterator_tag>::type _Cat;


    return (_Cat);
}
# 901 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
inline _Scalar_ptr_iterator_tag _Ptr_cat(bool *, bool *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const bool *, bool *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(char *, char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const char *, char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(signed char *, signed char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const signed char *, signed char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned char *,
 unsigned char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned char *,
 unsigned char *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(short *, short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const short *, short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned short *,
 unsigned short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned short *,
 unsigned short *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(int *, int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const int *, int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned int *, unsigned int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned int *, unsigned int *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(long *, long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long *, long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned long *,
 unsigned long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long *,
 unsigned long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(float *, float *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const float *, float *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(double *, double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const double *, double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(long double *, long double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long double *, long double *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }


inline _Scalar_ptr_iterator_tag _Ptr_cat(long long *, long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long long *, long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned long long *, unsigned long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long long *, unsigned long long *)
 {
 _Scalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }
# 1332 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
template<class _Iter> inline
 typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
 {
 return (0);
 }


template<class _InIt,
 class _Diff> inline
                void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _FwdIt,
 class _Diff> inline
                void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _BidIt,
 class _Diff> inline
                void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
 {
 for (; 0 < _Off; --_Off)
  ++_Where;
 for (; _Off < 0; ++_Off)
  --_Where;
 }

template<class _RanIt,
 class _Diff> inline
                void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
 {
 _Where += _Off;
 }

template<class _InIt,
 class _Diff> inline
                void advance(_InIt& _Where, _Diff _Off)
 {
 _Advance(_Where, _Off, _Iter_cat(_Where));
 }


template<class _Iter> inline
 typename iterator_traits<_Iter>::difference_type
  *_Dist_type(_Iter)
 {
 return (0);
 }


template<class _InIt,
 class _Diff> inline
                 void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
   input_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _FwdIt,
 class _Diff> inline
                 void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
   forward_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _BidIt,
 class _Diff> inline
                 void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
   bidirectional_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _RanIt,
 class _Diff> inline
                 void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
   random_access_iterator_tag)
 {
# 1438 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
 _Off += _Last - _First;
 }

template<class _InIt> inline
                typename iterator_traits<_InIt>::difference_type
  distance(_InIt _First, _InIt _Last)
 {
 typename iterator_traits<_InIt>::difference_type _Off = 0;
 _Distance2(_First, _Last, _Off, _Iter_cat(_First));
 return (_Off);
 }

template<class _InIt,
 class _Diff> inline
  void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
 {
 _Distance2(_First, _Last, _Off, _Iter_cat(_First));
 }
# 1471 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
template<class _FwdIt> inline
 _FwdIt next(_FwdIt _First,
  typename iterator_traits<_FwdIt>::difference_type _Off = 1)
 {
 static_assert((is_base_of<forward_iterator_tag, typename iterator_traits<_FwdIt>::iterator_category>::value), "next requires forward iterator");



 ::std:: advance(_First, _Off);
 return (_First);
 }



template<class _BidIt> inline
                _BidIt prev(_BidIt _First,
  typename iterator_traits<_BidIt>::difference_type _Off = 1)
 {
 static_assert((is_base_of<bidirectional_iterator_tag, typename iterator_traits<_BidIt>::iterator_category>::value), "prev requires bidirectional iterator");



 ::std:: advance(_First, -_Off);
 return (_First);
 }


template<class _Ty>
 struct pointer_traits;

template<class _RanIt,
 class _Base>
 class _Revranit
  : public _Base
 {
public:
 typedef _Revranit<_RanIt, _Base> _Myt;
 typedef typename _Base::difference_type difference_type;
 typedef typename _Base::pointer pointer;
 typedef typename _Base::reference reference;
 typedef _RanIt iterator_type;

                _Revranit()
  : current()
  {
  }

                explicit _Revranit(_RanIt _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2,
  class _Base2>
  _Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
  : current(_Right.base())
  {
  }

                _RanIt base() const
  {
  return (current);
  }

                reference operator*() const
  {
  _RanIt _Tmp = current;
  return (*--_Tmp);
  }

                pointer operator->() const
  {
  return (::std:: addressof(operator*()));
  }

                _Myt& operator++()
  {
  --current;
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  ++current;
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

 template<class _RanIt2,
  class _Base2>
  bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
  {
  return (current == _Right.base());
  }



                _Myt& operator+=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

                _Myt& operator-=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 template<class _RanIt2,
  class _Base2>
  bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
  {
  return (_Right.base() < current);
  }

 difference_type operator-(const _Myt& _Right) const
  {
  return (_Right.base() - current);
  }

protected:
 _RanIt current;
 };


template<class _RanIt>
 class reverse_iterator
  : public _Revranit<_RanIt, iterator<
   typename iterator_traits<_RanIt>::iterator_category,
   typename iterator_traits<_RanIt>::value_type,
   typename iterator_traits<_RanIt>::difference_type,
   typename iterator_traits<_RanIt>::pointer,
   typename iterator_traits<_RanIt>::reference> >
 {
 typedef reverse_iterator<_RanIt> _Myt;
 typedef _Revranit<_RanIt, iterator<
  typename iterator_traits<_RanIt>::iterator_category,
  typename iterator_traits<_RanIt>::value_type,
  typename iterator_traits<_RanIt>::difference_type,
  typename iterator_traits<_RanIt>::pointer,
  typename iterator_traits<_RanIt>::reference> > _Mybase;

public:
 typedef typename iterator_traits<_RanIt>::difference_type difference_type;
 typedef typename iterator_traits<_RanIt>::pointer pointer;
 typedef typename iterator_traits<_RanIt>::reference reference;
 typedef _RanIt iterator_type;

                reverse_iterator()
  {
  }

                explicit reverse_iterator(_RanIt _Right)
  : _Mybase(_Right)
  {
  }

 template<class _Other>
                 reverse_iterator(const reverse_iterator<_Other>& _Right)
  : _Mybase(_Right.base())
  {
  }

 reverse_iterator(_Mybase _Right)
  : _Mybase(_Right)
  {
  }

 template<class _Other>
                 _Myt& operator=(const reverse_iterator<_Other>& _Right)
  {
  this->current = _Right.base();
  return (*this);
  }

                _Myt& operator++()
  {
  ++*((_Mybase *)this);
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  --*((_Mybase *)this);
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myt& operator+=(difference_type _Off)
  {
  *((_Mybase *)this) += _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myt& operator-=(difference_type _Off)
  {
  *((_Mybase *)this) -= _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }
 };

template<class _RanIt>
 struct _Is_checked_helper<reverse_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt> inline
                reverse_iterator<_RanIt> operator+(
  typename reverse_iterator<_RanIt>::difference_type _Off,
  const reverse_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
                auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
   -> decltype(_Right.base() - _Left.base())
 {
 return (_Right.base() - _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator==(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Left.base() == _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator!=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right.base() < _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }



template<class _RanIt> inline
                reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
 {
 return (reverse_iterator<_RanIt>(_Iter));
 }




template<class _Container>
                auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
                auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
                auto inline end(_Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Container>
                auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array);
 }

template<class _Ty,
 size_t _Size> inline
 constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
 {
 return (_Array + _Size);
 }



template<class _Ty>
 class valarray;
template<class _Ty>
 _Ty *begin(valarray<_Ty>&);
template<class _Ty>
 const _Ty *begin(const valarray<_Ty>&);
template<class _Ty>
 _Ty *end(valarray<_Ty>&);
template<class _Ty>
 const _Ty *end(const valarray<_Ty>&);

template<class _Container>
 constexpr auto inline cbegin(const _Container& _Cont)
  noexcept(noexcept(::std:: begin(_Cont)))
  -> decltype(::std:: begin(_Cont))
 {
 return (::std:: begin(_Cont));
 }

template<class _Container>
 constexpr auto inline cend(const _Container& _Cont)
  noexcept(noexcept(::std:: end(_Cont)))
  -> decltype(::std:: end(_Cont))
 {
 return (::std:: end(_Cont));
 }


template<class _Container>
                auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
                auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
                auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Container>
                auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Ty,
 size_t _Size> inline
                reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array + _Size));
 }

template<class _Ty,
 size_t _Size> inline
                reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array));
 }

template<class _Elem> inline
                reverse_iterator<const _Elem *>
  rbegin(::std:: initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.end()));
 }

template<class _Elem> inline
                reverse_iterator<const _Elem *>
  rend(::std:: initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.begin()));
 }


template<class _Container>
                auto inline crbegin(const _Container& _Cont)
  -> decltype(::std:: rbegin(_Cont))
 {
 return (::std:: rbegin(_Cont));
 }

template<class _Container>
                auto inline crend(const _Container& _Cont)
  -> decltype(::std:: rend(_Cont))
 {
 return (::std:: rend(_Cont));
 }
# 2015 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
template<class _Container,
 class _Pr> inline
 void _Erase_nodes_if(_Container& _Cont, _Pr _Pred)
 {
 auto _First = _Cont.begin();
 auto _Last = _Cont.end();
                                          ;
 while (_First != _Last)
  if (_Pred(*_First))
   _First = _Cont.erase(_First);
  else
   ++_First;
 }



template<class _Ty,
 size_t _Size>
 class _Array_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty&,
   _Iterator_base>
 {
public:
 typedef _Array_const_iterator<_Ty, _Size> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;


                _Array_const_iterator()
  {
  _Ptr = 0;
  }

                explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
  : _Ptr{_Parg + _Off}
  {

  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

                reference operator*() const
  {
  return (*_Ptr);
  }

                pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

                _Myiter& operator++()
  {
  ++_Ptr;
  return (*this);
  }

                _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myiter& operator--()
  {
  --_Ptr;
  return (*this);
  }

                _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myiter& operator+=(difference_type _Off)
  {
  _Ptr += _Off;
  return (*this);
  }

                _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

                _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

                difference_type operator-(const _Myiter& _Right) const
  {
  return (_Ptr - _Right._Ptr);
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

                bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

                bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

                bool operator<(const _Myiter& _Right) const
  {
  return (_Ptr < _Right._Ptr);
  }

                bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

                bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

                bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }

 pointer _Ptr;
# 2377 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiter" 3
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size>&
  _Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
   typename _Array_const_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
                _Array_const_iterator<_Ty, _Size> operator+(
  typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
  _Array_const_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _Ty,
 size_t _Size>
 class _Array_iterator
  : public _Array_const_iterator<_Ty, _Size>
 {
public:
 typedef _Array_iterator<_Ty, _Size> _Myiter;
 typedef _Array_const_iterator<_Ty, _Size> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;

                _Array_iterator()
  {
  }

                explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
  : _Mybase(_Parg, _Off)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  ((_Mybase *)this)->_Rechecked(_Right);
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return ((pointer)((_Mybase *)this)->_Unchecked());
  }

                reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

                pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

                _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

                _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

                _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

                _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

                _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

                _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

                _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

                _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

                difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

                reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size>&
  _Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
   typename _Array_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
                _Array_iterator<_Ty, _Size> operator+(
  typename _Array_iterator<_Ty, _Size>::difference_type _Off,
  _Array_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _RanIt>
 class move_iterator
 {
public:
 typedef move_iterator<_RanIt> _Myt;
 typedef typename iterator_traits<_RanIt>::iterator_category
  iterator_category;
 typedef typename iterator_traits<_RanIt>::value_type
  value_type;
 typedef typename iterator_traits<_RanIt>::difference_type
  difference_type;
 typedef _RanIt pointer;






 typedef value_type&& reference;

 typedef _RanIt iterator_type;

                move_iterator()
  : current()
  {
  }

                explicit move_iterator(iterator_type _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2>
                 move_iterator(const move_iterator<_RanIt2>& _Right)
  : current(_Right.base())
  {
  }

 template<class _RanIt2>
                 _Myt& operator=(const move_iterator<_RanIt2>& _Right)
  {
  current = _Right.base();
  return (*this);
  }

                _RanIt base() const
  {
  return (current);
  }

                reference operator*() const
  {
  return (::std:: move(*current));
  }

                pointer operator->() const
  {
  return (current);
  }

                _Myt& operator++()
  {
  ++current;
  return (*this);
  }

                _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

                _Myt& operator--()
  {
  --current;
  return (*this);
  }

                _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 template<class _RanIt2>
                 bool _Equal(const move_iterator<_RanIt2>& _Right) const
  {
  return (current == _Right.base());
  }



                _Myt& operator+=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

                _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

                _Myt& operator-=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

                _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

                reference operator[](difference_type _Off) const
  {
  return (::std:: move(current[_Off]));
  }

 template<class _RanIt2>
                 bool _Less(const move_iterator<_RanIt2>& _Right) const
  {
  return (current < _Right.base());
  }

                difference_type operator-(const _Myt& _Right) const
  {
  return (current - _Right.base());
  }

protected:
 iterator_type current;
 };

template<class _RanIt>
 struct _Is_checked_helper<move_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt,
 class _Diff> inline
                move_iterator<_RanIt>
  operator+(_Diff _Off,
  const move_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
                auto inline operator-(
  move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
   -> decltype(_Left.base() - _Right.base())
 {
 return (_Left.base() - _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator==(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator!=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator<=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
                bool operator>=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt> inline
                move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
 {
 return (move_iterator<_RanIt>(_Iter));
 }
}


#pragma clang diagnostic pop
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 2 3

namespace std {

template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_Dest)
  ::std:: iter_swap(_First1, _Dest);
 return (_Dest);
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 return (_Swap_ranges(_Unchecked(_First1), _Unchecked(_Last1),
  _Dest));
 }
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 3
template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
 return (_Rechecked(_First,
  _Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: lower_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (!_Pred(_Val, *_Mid))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
 return (_Rechecked(_First,
  _Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: upper_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  _Equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else if (_Pred(_Val, *_Mid))
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = ::std:: lower_bound(_First, _Mid, _Val, _Pred);
   ::std:: advance(_First, _Count);
   _FwdIt _Last2 = ::std:: upper_bound(++_Mid, _First, _Val, _Pred);
   return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
   }
  }

 return (pair<_FwdIt, _FwdIt>(_First, _First));
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred)
 {
 pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
  _Equal_range(_Unchecked(_First), _Unchecked(_Last),
   _Val, _Pred, _Dist_type(_First)));
 return (pair<_FwdIt, _FwdIt>(
  _Rechecked(_First, _Ans.first),
  _Rechecked(_Last, _Ans.second)));
 }


template<class _FwdIt,
 class _Ty> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val)
 {
 return (::std:: equal_range(_First, _Last, _Val, less<>()));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = ::std:: move(*_First);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Move(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Move(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 357 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xscan" 3
template<class _Ty>
 struct _Match_pred
 {
 _Match_pred(const _Ty& _Val_arg)
  : _Val(_Val_arg)
  {
  }
 bool operator()(const _Ty& _Val_arg) const
  {
  return (_Val_arg == _Val);
  }
private:
 const _Ty& _Val;
 };

template<class _Ty>
 _Match_pred<_Ty> _Make_match_pred(const _Ty& _Val)
 {
 return (_Match_pred<_Ty>(_Val));
 }


template<class _Fn1>
 struct _Negation_pred
 {
 _Negation_pred(const _Fn1& _F1)
  : _Func1(_F1)
  {
  }

 template<class _Ty>
  bool operator()(const _Ty& _Val) const
  {
  return (!_Func1(_Val));
  }
private:
 _Fn1 _Func1;
 };

template<class _Fn1>
 _Negation_pred<_Fn1> _Make_negation(const _Fn1& _F1)
 {
 return (_Negation_pred<_Fn1>(_F1));
 }
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 2 3

 namespace std {

template<class _FwdIt,
 class _Pr> inline
                pair<_FwdIt, _FwdIt>
  _Minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 pair<_FwdIt, _FwdIt> _Found(_First, _First);
 if (_First != _Last)
  for (; ++_First != _Last; )
   {
   _FwdIt _Next = _First;
   if (++_Next == _Last)
    {
    if (_Pred(*_First, *_Found.first))
     _Found.first = _First;
    else if (!_Pred(*_First, *_Found.second))
     _Found.second = _First;
    }
   else
    {
    if (_Pred(*_Next, *_First))
     {
     if (_Pred(*_Next, *_Found.first))
      _Found.first = _Next;
     if (!_Pred(*_First, *_Found.second))
      _Found.second = _First;
     }
    else
     {
     if (_Pred(*_First, *_Found.first))
      _Found.first = _First;
     if (!_Pred(*_Next, *_Found.second))
      _Found.second = _Next;
     }
    _First = _Next;
    }
   }
 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
                pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                                                                        ;
 pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
  _Minmax_element(_Unchecked(_First), _Unchecked(_Last), _Pred));
 return (pair<_FwdIt, _FwdIt>(
  _Rechecked(_First, _Ans.first),
  _Rechecked(_Last, _Ans.second)));
 }


template<class _FwdIt> inline
                pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: minmax_element(_First, _Last, less<>()));
 }


template<class _Ty> inline
 constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
 {
 return (((_Left) < (_Right)) ? _Right : _Left);
 }

template<class _Ty> inline
 constexpr _Ty (max)(::std:: initializer_list<_Ty> _Ilist)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (((*_Found) < (*_Next)))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty,
 class _Pr> inline
 constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right,
  _Pr _Pred)
 {
 return (_Pred(_Left, _Right) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline
 constexpr _Ty (max)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (_Pred(*_Found, *_Next))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty> inline
 constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
 {
 return (((_Right) < (_Left)) ? _Right : _Left);
 }

template<class _Ty> inline
 constexpr _Ty (min)(::std:: initializer_list<_Ty> _Ilist)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (((*_Next) < (*_Found)))
   _Found = _Next;
 return (*_Found);
 }


template<class _Ty,
 class _Pr> inline
 constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right,
  _Pr _Pred)
 {
 return (_Pred(_Right, _Left) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline
 constexpr _Ty (min)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Found = _Ilist.begin();
 for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
  if (_Pred(*_Next, *_Found))
   _Found = _Next;
 return (*_Found);
 }
# 163 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _Ty> inline
 constexpr pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty> inline
 constexpr pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist)
 {





 const _Ty *_First = _Ilist.begin();
 const _Ty *_Last = _Ilist.end();
 const _Ty *_Largest = _First;

 if (_First != _Last)
  {
  for (const _Ty *_Next = _First; ++_Next != _Last; )
   if (*_Next < *_First)
    _First = _Next;
   else if (!(*_Next < *_Largest))
    _Largest = _Next;
  }
 return (pair<_Ty, _Ty>(*_First, *_Largest));

 }


template<class _Ty,
 class _Pr> inline
 constexpr pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
 {
 return (_Pred(_Right, _Left)
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty,
 class _Pr> inline
 constexpr pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist,
  _Pr _Pred)
 {





 const _Ty *_First = _Ilist.begin();
 const _Ty *_Last = _Ilist.end();
 const _Ty *_Largest = _First;

 if (_First != _Last)
  {
  for (const _Ty *_Next = _First; ++_Next != _Last; )
   if (_Pred(*_Next, *_First))
    _First = _Next;
   else if (!_Pred(*_Next, *_Largest))
    _Largest = _Next;
  }
 return (pair<_Ty, _Ty>(*_First, *_Largest));

 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, (void)++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Copy_impl(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt copy(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Copy_impl(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 337 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag)
 {
 *_Dest = *_First;
 while (0 < --_Count)
  *++_Dest = *++_First;
 return (++_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 return (_Copy_n(_First, _Count,
  _Dest, _Iter_cat(_First)));
 }
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 return (_Copy_n(_First, _Count,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 if (_Count <= 0)
  return (_Dest);
 else
  return (_Rechecked(_Dest,
   _Copy_n(_Unchecked(_First), _Count,
    _Unchecked(_Dest))));
 }
# 525 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = *--_Last;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_backward(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest - _Count, &*_First,
  _Count * sizeof (*_First));
 return (_Dest - _Count);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Copy_backward(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Rechecked(_Dest,
  _Copy_backward(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 597 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = ::std:: move(*--_Last);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_backward(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest - _Count, &*_First,
  _Count * sizeof (*_First));
 return (_Dest - _Count);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Move_backward(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Rechecked(_Dest,
  _Move_backward(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 669 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _FwdIt,
 class _Ty> inline
 void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First)
  *_First = _Val;
 }

inline void _Fill(char *_First, char *_Last, char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

template<class _FwdIt,
 class _Ty> inline
 void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
                            ;
 _Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 for (; 0 < _Count; --_Count, (void)++_Dest)
  *_Dest = _Val;
 return (_Dest);
 }

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
 signed char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
 unsigned char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
 }
# 803 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (true);
 }

inline bool _Equal(const char *_First1, const char *_Last1,
 const char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
 const signed char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
 const unsigned char *_First2, equal_to<>)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Pred));
 }
# 893 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2)
 {
 return (::std:: equal(_First1, _Last1, _First2,
  equal_to<>()));
 }

template<class _InIt1,
 class _InTy,
 size_t _InSize> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InTy (&_First2)[_InSize])
 {
 return (::std:: equal(_First1, _Last1, _First2,
  equal_to<>()));
 }



template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
   input_iterator_tag, input_iterator_tag)
 {

                                                                 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
   random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
                                            ;
 return (_Equal(_First1, _Last1, _First2, _Pred));
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
 return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Iter_cat(_First1), _Iter_cat(_First2)));
 }


template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: equal(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }



template<class _InIt,
 class _Pr> inline
 _InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   break;
 return (_First);
 }

template<class _InIt,
 class _Pr> inline
 _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                                       ;
 return (_Rechecked(_First,
  _Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _InIt1,
 class _InIt2> inline
 bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (((*_First1) < (*_First2)))
   return (true);
  else if (*_First2 < *_First1)
   return (false);
 return (_First1 == _Last1 && _First2 != _Last2);
 }

inline bool _Lexicographical_compare(
 const unsigned char *_First1, const unsigned char *_Last1,
 const unsigned char *_First2, const unsigned char *_Last2)
 {
 ptrdiff_t _Num1 = _Last1 - _First1;
 ptrdiff_t _Num2 = _Last2 - _First2;
 int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
 return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
 }
# 1023 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _InIt1,
 class _InIt2> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
                              ;
                              ;
 return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2)));
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  {
  if (_Pred(*_First1, *_First2))
   return (true);
  else if (_Pred(*_First2, *_First1))
   return (false);
  }
 return (_First1 == _Last1 && _First2 != _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred));
 }


template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
 {
 return ((-0x7f - 1) <= _Val && _Val <= 0x7f);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
 {
 return (_Val <= 0x7f || static_cast<_Ty>((-0x7f - 1)) <= _Val);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
 {
 return (_Val <= 0x7f);
 }

template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
 {
 return (0 <= _Val && _Val <= 0xff);
 }

template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
 {
 return (_Val <= 0xff);
 }

template<class _InIt,
 class _Ty> inline
 bool _Within_limits(_InIt, const _Ty& _Val)
 {
 typedef typename remove_pointer<_InIt>::type _Elem;
 return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
  integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
 }

template<class _InIt> inline
 bool _Within_limits(_InIt, const bool&)
 {
 return (true);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
 {
 if (!_Within_limits(_First, _Val))
  return (_Last);
 _First = static_cast<_InIt>(:: memchr(
  _First, static_cast<unsigned char>(_Val), _Last - _First));
 return (_First ? _First : _Last);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
 {
 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   break;
 return (_First);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {

 typedef integral_constant<bool,
  (is_same<_InIt, char *>::value
  || is_same<_InIt, signed char *>::value
  || is_same<_InIt, unsigned char *>::value
  || is_same<_InIt, const char *>::value
  || is_same<_InIt, const signed char *>::value
  || is_same<_InIt, const unsigned char *>::value)
  && is_integral<_Ty>::value
 > _Memchr_opt;
 return (_Find(_First, _Last, _Val, _Memchr_opt()));
 }

template<class _InIt,
 class _Ty> inline
 _InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Rechecked(_First,
  _Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   break;
 return (_First);
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _FwdIt _Next = _First;
 for (++_First; _First != _Last; ++_First)
 if (!_Pred(*_First))
  *_Next++ = _Move(*_First);
 return (_Next);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _First = ::std:: find_if(_First, _Last, _Pred);
 if (_First == _Last)
  return (_First);
 else
  return (_Rechecked(_First,
   _Remove_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt _Remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _FwdIt _Next = _First;
 for (++_First; _First != _Last; ++_First)
  if (!(*_First == _Val))
   *_Next++ = _Move(*_First);
 return (_Next);
 }

template<class _FwdIt,
 class _Ty> inline
 _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _First = ::std:: find(_First, _Last, _Val);
 if (_First == _Last)
  return (_First);
 else
  return (_Rechecked(_First,
   _Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty> inline
 typename iterator_traits<_InIt>::difference_type
  _Count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   ++_Count;
 return (_Count);
 }

template<class _InIt,
 class _Ty> inline
 typename iterator_traits<_InIt>::difference_type
  count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Count(_Unchecked(_First), _Unchecked(_Last), _Val));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 typename iterator_traits<_InIt>::difference_type
  _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   ++_Count;
 return (_Count);
 }



template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr,
  forward_iterator_tag, forward_iterator_tag)
 {
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred,
  bidirectional_iterator_tag, bidirectional_iterator_tag)
 {

 while (_Pred(*--_Last1, *--_Last2))
  ;
 ++_Last1;
 ++_Last2;
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
 _Trim_matching_suffixes(_Last1, _Last2, _Pred,
  _Iter_cat(_Last1), _Iter_cat(_Last2));
 typedef typename iterator_traits<_FwdIt1>::difference_type _Diff1;
 typedef typename iterator_traits<_FwdIt2>::difference_type _Diff2;
 for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
  if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
   {
   _Diff2 _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
   if (_Count2 == 0)
    return (false);
   _FwdIt1 _Skip1 = ::std:: next(_Next1);
   _Diff1 _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
   if (_Count2 != _Count1)
    return (false);
   }
 return (true);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   _FwdIt2 _Last2 = ::std:: next(_First2,
    ::std:: distance(_First1, _Last1));
   return (_Check_match_counts(_First1, _Last1,
    _First2, _Last2, _Pred));
   }
 return (true);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Pred));
 }
# 1383 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, equal_to<>()));
 }

template<class _FwdIt1,
 class _InTy,
 size_t _InSize> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _InTy (&_First2)[_InSize])
 {
 return (::std:: is_permutation(_First1, _Last1, _First2, equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
  forward_iterator_tag, forward_iterator_tag)
 {

                                                                 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
  if (!_Pred(*_First1, *_First2))
   {
   if (::std:: distance(_First1, _Last1)
    != ::std:: distance(_First2, _Last2))
    return (false);
   else
    return (_Check_match_counts(_First1, _Last1,
     _First2, _Last2, _Pred));
   }
 return (_First1 == _Last1 && _First2 == _Last2);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
  random_access_iterator_tag, random_access_iterator_tag)
 {

 if (_Last1 - _First1 != _Last2 - _First2)
  return (false);
                                            ;
 return (_Is_permutation(_First1, _Last1, _First2, _Pred));
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {

                              ;
                              ;
 return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred,
  _Iter_cat(_First1), _Iter_cat(_First2)));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, _Last2, equal_to<>()));
 }



template<class _BidIt> inline
 void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
 {
 for (; _First != _Last && _First != --_Last; ++_First)
  ::std:: iter_swap(_First, _Last);
 }

template<class _BidIt> inline
 void reverse(_BidIt _First, _BidIt _Last)
 {
                            ;
 _Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
 }


template<class _FwdIt> inline
 _FwdIt _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag)
 {
 for (_FwdIt _Next = _Mid, _Res = _Last; ; )
  {
  ::std:: iter_swap(_First, _Next);
  if (++_First == _Mid)
   {
   if (++_Next == _Last)
    return (_Res == _Last ? _Mid : _Res);
   else
    _Mid = _Next;
   }
  else if (++_Next == _Last)
   {
   if (_Res == _Last)
    _Res = _First;
   _Next = _Mid;
   }
  }
 }

template<class _BidIt> inline
 pair<_BidIt, _BidIt> _Reverse_until_sentinel(
  _BidIt _First, _BidIt _Sentinel, _BidIt _Last)
 {
 while (_First != _Sentinel && _Last != _Sentinel)
  ::std:: iter_swap(_First++, --_Last);
 return (::std:: make_pair(_First, _Last));
 }

template<class _BidIt> inline
 _BidIt _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag)
 {
 ::std:: reverse(_First, _Mid);
 ::std:: reverse(_Mid, _Last);
 pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel(_First, _Mid, _Last);
 ::std:: reverse(_Tmp.first, _Tmp.second);
 return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
 }

template<class _RanIt> inline
 _RanIt _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag)
 {
 ::std:: reverse(_First, _Mid);
 ::std:: reverse(_Mid, _Last);
 ::std:: reverse(_First, _Last);
 return (_First + (_Last - _Mid));
 }

template<class _FwdIt> inline
 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
 {
                           ;
                          ;
 if (_First == _Mid)
  return (_Last);
 if (_Mid == _Last)
  return (_First);
 _Rechecked(_First, _Rotate(_Unchecked(_First), _Unchecked(_Mid),
  _Unchecked(_Last), _Iter_cat(_First)));
 return (_First);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr> inline
 _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *,
  forward_iterator_tag, forward_iterator_tag)
 {
 for (; ; ++_First1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (_Mid1 == _Last1)
    return (_Last1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr> inline
 _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *,
  random_access_iterator_tag, random_access_iterator_tag)
 {
 _Diff1 _Count1 = _Last1 - _First1;
 _Diff2 _Count2 = _Last2 - _First2;

 for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }
 return (_Last1);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                                                                 ;
 return (_Rechecked(_First1,
  _Search(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Dist_type(_First1), _Dist_type(_First2),
   _Iter_cat(_First1), _Iter_cat(_First2))));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: search(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _Diff,
 class _Urng>
 class _Rng_from_urng
 {
public:
 typedef make_unsigned_t<_Diff> _Ty0;
 typedef typename _Urng::result_type _Ty1;

 typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
  _Ty0, _Ty1>::type _Udiff;

 explicit _Rng_from_urng(_Urng& _Func)
  : _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
  {
  for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
   --_Bits;
  }

 _Diff operator()(_Diff _Index)
  {
  for (; ; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while (_Mask < _Udiff(_Index - 1))
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits();
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if (_Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff(_Index - 1))
    return (_Ret % _Index);
   }
  }

 _Udiff _Get_all_bits()
  {
  _Udiff _Ret = 0;

  for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
   _Num += _Bits)
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits();
   }

  return (_Ret);
  }

 _Rng_from_urng(const _Rng_from_urng&) = delete;
 _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
 _Udiff _Get_bits()
  {
  for (; ; )
   {
   _Udiff _Val = _Ref() - (_Urng::min)();

   if (_Val <= _Bmask)
    return (_Val);
   }
  }

 _Urng& _Ref;
 size_t _Bits;
 _Udiff _Bmask;
 };


template<class _Elem>
 class _Yarn
 {
public:
 typedef _Yarn<_Elem> _Myt;

 _Yarn()
  : _Myptr(0), _Nul(0)
  {
  }

 _Yarn(const _Myt& _Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Yarn(const _Elem *_Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Myt& operator=(const _Myt& _Right)
  {
  return (*this = _Right._Myptr);
  }

 _Myt& operator=(const _Elem *_Right)
  {
  if (_Myptr != _Right)
   {
   _Tidy();

   if (_Right != 0)
    {
    const _Elem *_Ptr = _Right;
    while (*_Ptr != (_Elem)0)
     ++_Ptr;
    size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

    _Myptr = (_Elem *):: malloc(_Count);
    if (_Myptr != 0)
     :: memcpy(_Myptr, _Right, _Count);
    }
   }
  return (*this);
  }

 ~_Yarn() noexcept
  {
  _Tidy();
  }

 bool empty() const
  {
  return (_Myptr == 0);
  }

 const _Elem *c_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

private:
 void _Tidy()
  {
  if (_Myptr != 0)
   :: free(_Myptr);

  _Myptr = 0;
  }

 _Elem *_Myptr;
 _Elem _Nul;
 };


template<class _Ty,
 class _Alloc>
 struct _Has_allocator_type
 {







 template<class _Uty>
  static auto _Fn(int)
   -> is_convertible<_Alloc,
    typename _Uty::allocator_type>;


 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_Ty>(0)) type;
 };


struct allocator_arg_t
 {



 };




constexpr allocator_arg_t allocator_arg = allocator_arg_t();


void _Xbad_alloc() __attribute__((__noreturn__));
void _Xinvalid_argument(const char *) __attribute__((__noreturn__));
void _Xlength_error(const char *) __attribute__((__noreturn__));
void _Xout_of_range(const char *) __attribute__((__noreturn__));
void _Xoverflow_error(const char *) __attribute__((__noreturn__));
void _Xrange_error(const char *) __attribute__((__noreturn__));
void _Xruntime_error(const char *) __attribute__((__noreturn__));
# 1837 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
}

namespace std {

template<class _Ty,
 class _Alloc>
 struct uses_allocator
  : _Has_allocator_type<_Ty, _Alloc>::type
 {
 };
# 1857 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xutility" 3
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"




namespace std {
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
template<class _Ty> inline
                     _Ty *_Allocate(size_t _Count, _Ty *,
  bool _Try_aligned_allocation = true)
 {
 void *_Ptr = 0;

 if (_Count == 0)
  return (static_cast<_Ty *>(_Ptr));


 if ((size_t)(-1) / sizeof (_Ty) < _Count)
  _Xbad_alloc();
 const size_t _User_size = _Count * sizeof (_Ty);


 if (_Try_aligned_allocation
  && 4096UL <= _User_size)
  {
  static_assert(sizeof (void *) < 32UL, "Big allocations should at least match vector register size");

  const size_t _Block_size = (sizeof(void *) + 32UL - 1) + _User_size;
  if (_Block_size <= _User_size)
   _Xbad_alloc();
  const uintptr_t _Ptr_container =
   reinterpret_cast<uintptr_t>(::operator new(_Block_size));
                                                  ;
  _Ptr = reinterpret_cast<void *>((_Ptr_container + (sizeof(void *) + 32UL - 1))
   & ~(32UL - 1));
  static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;




  }
 else


  {
  _Ptr = ::operator new(_User_size);
                                        ;
  }
 return (static_cast<_Ty *>(_Ptr));
 }


template<class _Ty> inline
 void _Deallocate(_Ty * _Ptr, size_t _Count)
 {

                                                                   ;
 const size_t _User_size = _Count * sizeof (_Ty);
 if (4096UL <= _User_size)
  {
  const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);

                                                      ;
  const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
  const uintptr_t _Ptr_container =
   *reinterpret_cast<uintptr_t *>(_Ptr_ptr);
# 115 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
                                                         ;







                                 ;



                     ;

  _Ptr = reinterpret_cast<_Ty *>(_Ptr_container);
  }


 ::operator delete(_Ptr);
 }


template<class _Ty1,
 class _Ty2> inline
 void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
 {
 void *_Vptr = _Ptr;
 ::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
 }

template<class _Ty1> inline
 void _Construct(_Ty1 *_Ptr)
 {
 void *_Vptr = _Ptr;

 ::new (_Vptr) _Ty1();
 }


template<class _Ty> inline
 void _Destroy(_Ty *_Ptr)
 {
 _Ptr->~_Ty();
 }


template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al,
  _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  _Al.destroy(::std:: addressof(*_First));
 }

template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al,
  _Scalar_ptr_iterator_tag)
 {
 }

template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al)
 {
 _Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
 }


template<class _Alty>
 struct _Is_simple_alloc
  : _Cat_base<is_same<typename _Alty::size_type, size_t>::value
  && is_same<typename _Alty::difference_type, ptrdiff_t>::value
  && is_same<typename _Alty::pointer,
   typename _Alty::value_type *>::value
  && is_same<typename _Alty::const_pointer,
   const typename _Alty::value_type *>::value
  && is_same<typename _Alty::reference,
   typename _Alty::value_type&>::value
  && is_same<typename _Alty::const_reference,
   const typename _Alty::value_type&>::value>
 {
 };


template<class _Value_type>
 struct _Simple_types
 {
 typedef _Value_type value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef value_type& reference;
 typedef const value_type& const_reference;
 };


template<class _Alty,
 class _Pointer>
 struct _Get_voidptr
 {
 typedef typename _Alty::template rebind<void>::other _Alvoid;
 typedef typename _Alvoid::pointer type;
 };

template<class _Alty,
 class _Ty>
 struct _Get_voidptr<_Alty, _Ty *>
 {
 typedef void *type;
 };



template<class _Ty>
 struct _Get_first_parameter;

template<template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Get_first_parameter<_Ty<_First, _Rest...> >
 {
 typedef _First type;
 };


template<class _Newfirst,
 class _Ty>
 struct _Replace_first_parameter;

template<class _Newfirst,
 template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
 {
 typedef _Ty<_Newfirst, _Rest...> type;
 };
# 273 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
template<class _Ty>
 struct _Get_element_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_ptr_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Other>
 struct _Get_rebind_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Other>
 struct _Get_pointer_traits_rebind_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other> >; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct pointer_traits
 {
 typedef typename _Get_element_type<_Ty>::type element_type;
 typedef _Ty pointer;
 typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;


 template<class _Other>
  using rebind =
   typename _Get_pointer_traits_rebind_type<_Ty, _Other>::type;
# 321 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
 typedef typename _If<is_void<element_type>::value,
  char&,
  add_lvalue_reference_t<element_type> >::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (_Ty::pointer_to(_Val));
  }
 };


template<class _Ty>
 struct pointer_traits<_Ty *>
 {
 typedef _Ty element_type;
 typedef _Ty *pointer;
 typedef ptrdiff_t difference_type;


 template<class _Other>
  using rebind = _Other *;
# 353 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
 typedef typename _If<is_void<_Ty>::value,
  char&,
  add_lvalue_reference_t<_Ty> >::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (::std:: addressof(_Val));
  }
 };


template<class _Ty>
 struct _Get_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_const_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_const_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_size_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<make_unsigned_t< typename _Get_difference_type<_Ty>::type> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_propagate_on_container_copy
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_move
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_swap
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_is_always_equal
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::is_always_equal>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename is_empty<_Ty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



struct _Alloc_allocate
 {

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer _Hint)
   -> decltype(_Al.allocate(_Count, _Hint))
  {
  return (_Al.allocate(_Count, _Hint));
  }

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(_Wrap_int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer)
   -> decltype(_Al.allocate(_Count))
  {
  return (_Al.allocate(_Count));
  }
 };


struct _Alloc_construct
 {


 template<class _Ty,
  class _Objty,
  class... _Types>
  static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
   _Types&&... _Args)
   -> __void_t<decltype(
    _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...))>
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty,
  class _Objty,
  class... _Types>
  static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
   _Types&&... _Args)
  {
  ::new (static_cast<void *>(_Ptr))
   _Objty(::std:: forward<_Types>(_Args)...);
  }
 };


struct _Alloc_destroy
 {
 template<class _Ty,
  class _Objty>
  static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
   -> __void_t<decltype(_Al.destroy(_Ptr))>
  {
  _Al.destroy(_Ptr);
  }

 template<class _Ty,
  class _Objty>
  static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
  {
  _Ptr->~_Objty();
  }
 };


struct _Alloc_max_size
 {
 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al) noexcept
   -> decltype(_Al.max_size())
  {
  return (_Al.max_size());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty&) noexcept
   -> typename _Get_size_type<_Ty>::type
  {
  return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
  }
 };


struct _Alloc_select
 {


 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al)
   -> decltype((_Ty)_Al.select_on_container_copy_construction())
  {
  return (_Al.select_on_container_copy_construction());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty& _Al)
   -> _Ty
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct allocator_traits
 {
 typedef _Alloc allocator_type;
 typedef typename _Alloc::value_type value_type;

 typedef typename _Get_pointer_type<_Alloc>::type
  pointer;
 typedef typename _Get_const_pointer_type<_Alloc>::type
  const_pointer;
 typedef typename _Get_void_pointer_type<_Alloc>::type
  void_pointer;
 typedef typename _Get_const_void_pointer_type<_Alloc>::type
  const_void_pointer;

 typedef typename _Get_size_type<_Alloc>::type size_type;
 typedef typename _Get_difference_type<_Alloc>::type difference_type;

 typedef typename _Get_propagate_on_container_copy<_Alloc>::type
  propagate_on_container_copy_assignment;
 typedef typename _Get_propagate_on_container_move<_Alloc>::type
  propagate_on_container_move_assignment;
 typedef typename _Get_propagate_on_container_swap<_Alloc>::type
  propagate_on_container_swap;






 template<class _Other>
  using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

 template<class _Other>
  using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
# 594 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
 static pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  static void construct(_Alloc& _Al, _Ty *_Ptr,
   _Types&&... _Args)
  {
  _Alloc_construct::_Fn(0, _Al, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  static void destroy(_Alloc& _Al, _Ty *_Ptr)
  {
  _Alloc_destroy::_Fn(0, _Al, _Ptr);
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Alloc_max_size::_Fn(0, _Al));
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Alloc_select::_Fn(0, _Al));
  }
 };


template<class _Ty>
 struct _Allocator_base
 {
 typedef _Ty value_type;
 };


template<class _Ty>
 struct _Allocator_base<const _Ty>
 {
 typedef _Ty value_type;
 };


template<class _Ty>
 class allocator
  : public _Allocator_base<_Ty>
 {
public:







 typedef _Allocator_base<_Ty> _Mybase;
 typedef typename _Mybase::value_type value_type;

 typedef value_type *pointer ;
 typedef const value_type *const_pointer ;

 typedef value_type& reference ;
 typedef const value_type& const_reference ;

 typedef size_t size_type ;
 typedef ptrdiff_t difference_type ;

 typedef false_type propagate_on_container_copy_assignment;

 typedef true_type propagate_on_container_move_assignment;



 typedef false_type propagate_on_container_swap;




 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

                pointer address(reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

                const_pointer address(const_reference _Val) const noexcept
  {
  return (::std:: addressof(_Val));
  }

 allocator() noexcept
  {
  }

 allocator(const allocator<_Ty>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<_Ty>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Deallocate(_Ptr, _Count);
  }

                     pointer allocate(size_type _Count)
  {
  return (_Allocate(_Count, (pointer)0));
  }

                                    pointer allocate(size_type _Count, const void *)
  {
  return (allocate(_Count));
  }

 template<class _Objty,
  class... _Types>
                 void construct(_Objty *_Ptr, _Types&&... _Args)
  {
  ::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
  }

 template<class _Uty>
                 void destroy(_Uty *_Ptr)
  {
  _Ptr->~_Uty();
  }

                size_t max_size() const noexcept
  {
  return ((size_t)(-1) / sizeof (_Ty));
  }
 };


template<>
 class allocator<void>
 {
public:






 typedef void value_type;

 typedef void *pointer;
 typedef const void *const_pointer;

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 allocator() noexcept
  {
  }

 allocator(const allocator<void>&) noexcept
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) noexcept
  {
  }

 template<class _Other>
  allocator<void>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const allocator<_Ty>&,
  const allocator<_Other>&) noexcept
 {
 return (true);
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const allocator<_Ty>& _Left,
  const allocator<_Other>& _Right) noexcept
 {
 return (false);
 }


template<class _Ty>
 struct allocator_traits<allocator<_Ty> >
 {
 typedef allocator<_Ty> _Alloc;

 typedef _Alloc allocator_type;

 typedef typename _Alloc::value_type value_type;




 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef void *void_pointer;
 typedef const void *const_void_pointer;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;

 typedef true_type propagate_on_container_move_assignment;



 typedef false_type propagate_on_container_swap;





 template<class _Other>
  using rebind_alloc = allocator<_Other>;

 template<class _Other>
  using rebind_traits = allocator_traits<allocator<_Other> >;
# 871 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
 static pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Al.allocate(_Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Objty,
  class... _Types>
  static void construct(_Alloc& _Al, _Objty *_Ptr,
   _Types&&... _Args)
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Uty>
  static void destroy(_Alloc& _Al, _Uty *_Ptr)
  {
  _Al.destroy(_Ptr);
  }

 static size_type max_size(const _Alloc& _Al) noexcept
  {
  return (_Al.max_size());
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct _Wrap_alloc
  : public _Alloc
 {






 typedef _Alloc _Mybase;
 typedef allocator_traits<_Alloc> _Mytraits;

 typedef typename _Mytraits::value_type value_type;

 typedef typename _Mytraits::pointer pointer;
 typedef typename _Mytraits::const_pointer const_pointer;
 typedef typename _Mytraits::void_pointer void_pointer;
 typedef typename _Mytraits::const_void_pointer const_void_pointer;

 typedef typename _If<is_void<value_type>::value,
  int, value_type>::type& reference;
 typedef typename _If<is_void<const value_type>::value,
  const int, const value_type>::type& const_reference;

 typedef typename _Mytraits::size_type size_type;
 typedef typename _Mytraits::difference_type difference_type;

 typedef typename _Mytraits::propagate_on_container_copy_assignment
  propagate_on_container_copy_assignment;
 typedef typename _Mytraits::propagate_on_container_move_assignment
  propagate_on_container_move_assignment;
 typedef typename _Mytraits::propagate_on_container_swap
  propagate_on_container_swap;





 _Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
  {
  return (_Mytraits::select_on_container_copy_construction(*this));
  }

 template<class _Other>
  struct rebind
  {
  typedef typename _Mytraits::template rebind_alloc<_Other>
   _Other_alloc;
  typedef _Wrap_alloc<_Other_alloc> other;
  };

 pointer address(reference _Val) const
  {
  return (::std:: addressof(_Val));
  }

 const_pointer address(const_reference _Val) const
  {
  return (::std:: addressof(_Val));
  }

 _Wrap_alloc() noexcept
  : _Mybase()
  {
  }

 _Wrap_alloc(const _Mybase& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc(const _Wrap_alloc& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Wrap_alloc(const _Other& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Wrap_alloc(_Other& _Right) noexcept
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc& operator=(const _Mybase& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 _Wrap_alloc& operator=(const _Wrap_alloc& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 template<class _Other>
  _Wrap_alloc& operator=(const _Other& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

                     pointer allocate(size_type _Count)
  {
  return (_Mybase::allocate(_Count));
  }

                     pointer allocate(size_type _Count,
  const_void_pointer _Hint, _Nil = _Nil())
  {
  return (_Mytraits::allocate(*this, _Count, _Hint));
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Mybase::deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  void construct(_Ty *_Ptr,
   _Types&&... _Args)
  {
  _Mytraits::construct(*this, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty>
  void destroy(_Ty *_Ptr)
  {
  _Mytraits::destroy(*this, _Ptr);
  }

 size_type max_size(_Nil = _Nil()) const noexcept
  {
  return (_Mytraits::max_size(*this));
  }
 };

template<class _Ty>
 struct _Wrap_alloc<_Ty *>
  : public _Wrap_alloc<allocator<_Ty *> >
 {
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
 {
 _Left = _Right;
 }

template<class _Alty> inline
 void _Pocca(_Alty&, const _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_copy_assignment _Tag;
 _Pocca(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Left = ::std:: move(_Right);
 }

template<class _Alty> inline
 void _Pocma(_Alty&, _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_move_assignment _Tag;
 _Pocma(_Left, _Right, _Tag);
 }


template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
 {
 _Swap_adl(_Left, _Right);
 }

template<class _Alty> inline
 void _Pocs(_Alty&, _Alty&, false_type) noexcept
 {
 }

template<class _Alty> inline
 void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
 {
 typename _Alty::propagate_on_container_swap _Tag;
 _Pocs(_Left, _Right, _Tag);
 }
}







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 2 3

namespace std {

typedef enum memory_order {
 memory_order_relaxed,
 memory_order_consume,
 memory_order_acquire,
 memory_order_release,
 memory_order_acq_rel,
 memory_order_seq_cst
 } memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;
# 97 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
typedef unsigned char _Atomic_flag_t;
# 119 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
extern "C" {
_Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order);
int _Atomic_compare_exchange_weak_4(
 volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order);
_Uint4_t _Atomic_fetch_add_4(
 volatile _Uint4_t *, _Uint4_t, memory_order);
_Uint4_t _Atomic_fetch_sub_4(
 volatile _Uint4_t *, _Uint4_t, memory_order);
}

_Uint4_t _Atomic_load_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, memory_order);
int _Atomic_compare_exchange_weak_4_locking(
 volatile _Atomic_flag_t *, _Uint4_t *, _Uint4_t *, _Uint4_t,
  memory_order, memory_order);
_Uint4_t _Atomic_fetch_add_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, _Uint4_t, memory_order);
_Uint4_t _Atomic_fetch_sub_4_locking(volatile _Atomic_flag_t *,
 _Uint4_t *, _Uint4_t, memory_order);
# 250 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
typedef _Atomic_integral_t _Atomic_counter_t;


inline _Atomic_integral_t
 _Get_atomic_count(const _Atomic_counter_t& _Counter)
 {
 return (_Counter);
 }

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
 _Atomic_integral_t _Value)
 {
 _Counter = _Value;
 }

inline _Atomic_integral_t _Inc_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_fetch_add_4(&_Counter, 1, _Order) + 1);
 }

inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Dec_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_fetch_sub_4(&_Counter, 1, _Order) - 1);
 }

inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Load_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_load_4(&_Counter, _Order));
 }

inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Load_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(
 _Atomic_counter_t& _Counter,
 _Atomic_integral_t _Expected,
 memory_order _Order)
 {
 return ((_Atomic_integral_t)_Atomic_compare_exchange_weak_4(
  &_Counter, &_Expected, _Expected + 1,
  _Order, _Order));
 }

inline _Atomic_integral_t _Compare_increment_atomic_counter(
 _Atomic_counter_t& _Counter, _Atomic_integral_t _Expected)
 {
 return (_Compare_increment_atomic_counter_explicit(
  _Counter, _Expected, memory_order_seq_cst));
 }
# 351 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic0.h" 3
extern "C" {
void _Lock_shared_ptr_spin_lock();
void _Unlock_shared_ptr_spin_lock();
}
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stddef.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 2 3
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 3
namespace std {

typedef unsigned char _Uint1_t;
typedef unsigned short _Uint2_t;

typedef unsigned long long _Uint8_t;
# 68 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 3
extern "C" {
void _Atomic_store_1(volatile _Uint1_t *_Tgt, _Uint1_t _Value,
 memory_order _Order);
_Uint1_t _Atomic_load_1(volatile _Uint1_t *_Tgt,
 memory_order _Order);
_Uint1_t _Atomic_exchange_1(volatile _Uint1_t *_Tgt,
 _Uint1_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_1(
 volatile _Uint1_t *_Tgt, _Uint1_t *_Exp, _Uint1_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_1(
 volatile _Uint1_t *_Tgt, _Uint1_t *_Exp, _Uint1_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint1_t _Atomic_fetch_add_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_sub_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_and_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_or_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
_Uint1_t _Atomic_fetch_xor_1(
 volatile _Uint1_t *_Tgt, _Uint1_t _Value, memory_order _Order);
void _Atomic_store_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_load_2(
 volatile _Uint2_t *_Tgt, memory_order _Order);
_Uint2_t _Atomic_exchange_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
int _Atomic_compare_exchange_weak_2(
 volatile _Uint2_t *_Tgt, _Uint2_t *_Exp, _Uint2_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_strong_2(
 volatile _Uint2_t *_Tgt, _Uint2_t *_Exp, _Uint2_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint2_t _Atomic_fetch_add_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_sub_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_and_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_or_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
_Uint2_t _Atomic_fetch_xor_2(
 volatile _Uint2_t *_Tgt, _Uint2_t _Value, memory_order _Order);
void _Atomic_store_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_load_4(
 volatile _Uint4_t *_Tgt, memory_order _Order);
_Uint4_t _Atomic_exchange_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_4(
 volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_4(
 volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint4_t _Atomic_fetch_add_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_sub_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_and_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_or_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
_Uint4_t _Atomic_fetch_xor_4(
 volatile _Uint4_t *_Tgt, _Uint4_t _Value, memory_order _Order);
void _Atomic_store_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_load_8(
 volatile _Uint8_t *_Tgt, memory_order _Order);
_Uint8_t _Atomic_exchange_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
int _Atomic_compare_exchange_strong_8(
 volatile _Uint8_t *_Tgt, _Uint8_t *_Exp, _Uint8_t _Value,
 memory_order _Order1, memory_order _Order2);
int _Atomic_compare_exchange_weak_8(
 volatile _Uint8_t *_Tgt, _Uint8_t *_Exp, _Uint8_t _Value,
 memory_order _Order1, memory_order _Order2);
_Uint8_t _Atomic_fetch_add_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_sub_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_and_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_or_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
_Uint8_t _Atomic_fetch_xor_8(
 volatile _Uint8_t *_Tgt, _Uint8_t _Value, memory_order _Order);
int _Atomic_flag_test_and_set(volatile _Atomic_flag_t *_Flag,
 memory_order _Order);
void _Atomic_flag_clear(volatile _Atomic_flag_t *_Flag,
 memory_order _Order);
void _Atomic_thread_fence(memory_order _Order);
void _Atomic_signal_fence(memory_order _Order);


int _Atomic_is_lock_free_1();
int _Atomic_is_lock_free_2();
int _Atomic_is_lock_free_4();
int _Atomic_is_lock_free_8();
}
# 190 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xatomic.h" 3
inline void _Lock_spin_lock_i(
 volatile _Atomic_flag_t *_Flag)
 {
 while (__c11_atomic_exchange ((_Atomic(_Atomic_flag_t)*)_Flag, (_Atomic_flag_t)1, memory_order_acquire))
                  ;
 }

inline void _Unlock_spin_lock_i(
 volatile _Atomic_flag_t *_Flag)
 {
 __c11_atomic_store ((_Atomic(_Atomic_flag_t)*)_Flag, (_Atomic_flag_t)0, memory_order_release);
 }



inline void _Atomic_copy_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile const void *_Src,
   memory_order _Order)
 {
 _Lock_spin_lock_i(_Flag);
 memcpy((void *)_Tgt, (void *)_Src, _Size);
 _Unlock_spin_lock_i(_Flag);
 }

inline void _Atomic_exchange_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile void *_Src,
   memory_order _Order)
 {
 unsigned char *_Left = (unsigned char *)_Tgt;
 unsigned char *_Right = (unsigned char *)_Src;

 _Lock_spin_lock_i(_Flag);
 for (; 0 < _Size; --_Size)
  {
  unsigned char _Tmp = *_Left;
  *_Left++ = *_Right;
  *_Right++ = _Tmp;
  }
 _Unlock_spin_lock_i(_Flag);
 }

inline int _Atomic_compare_exchange_weak_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
  volatile void *_Tgt, volatile void *_Exp, const volatile void *_Src,
   memory_order _Order1, memory_order _Order2)
 {
 int _Result;

 _Lock_spin_lock_i(_Flag);
 _Result = memcmp((const void *)_Tgt, (const void *)_Exp, _Size) == 0;
 if (_Result != 0)
  memcpy((void *)_Tgt, (void *)_Src, _Size);
 else
  memcpy((void *)_Exp, (void *)_Tgt, _Size);
 _Unlock_spin_lock_i(_Flag);
 return (_Result);
 }

inline int _Atomic_compare_exchange_strong_i(
 volatile _Atomic_flag_t *_Flag, size_t _Size,
 volatile void *_Tgt, volatile void *_Exp, const volatile void *_Src,
 memory_order _Order1, memory_order _Order2)
 {
 return (_Atomic_compare_exchange_weak_i(_Flag, _Size, _Tgt, _Exp, _Src,
  _Order1, _Order2));
 }
}
# 1147 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 2 3
# 1185 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory0" 3
#pragma clang diagnostic pop
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 2 3
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
namespace std {
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Ax = allocator<_Elem> >
 class basic_string;
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
template<class _Mystr>
 class _String_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Mystr::value_type,
   typename _Mystr::difference_type,
   typename _Mystr::const_pointer,
   typename _Mystr::const_reference,
   _Iterator_base>
 {
public:
 typedef _String_const_iterator<_Mystr> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::const_pointer pointer;
 typedef typename _Mystr::const_reference reference;

 _String_const_iterator()
  {
  this->_Ptr = 0;
  }

 _String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
  {
  this->_Adopt(_Pstring);
  this->_Ptr = _Parg;
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
# 106 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  return (*this->_Ptr);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  ++this->_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 161 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  --this->_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
# 193 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  if (this->_Getcont() != _Right._Getcont())
   _Compat(_Right);
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
# 277 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 void _Compat(const _Myiter&) const
  {
  }


 pointer _Ptr;
 };

template<class _Mystr> inline
 typename _String_const_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_const_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr>
  _Rechecked(_String_const_iterator<_Mystr>& _Iter,
   typename _String_const_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr> operator+(
  typename _String_const_iterator<_Mystr>
   ::difference_type _Off,
  _String_const_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Mystr>
 class _String_iterator
  : public _String_const_iterator<_Mystr>
 {
public:
 typedef _String_iterator<_Mystr> _Myiter;
 typedef _String_const_iterator<_Mystr> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::pointer pointer;
 typedef typename _Mystr::reference reference;

 _String_iterator()
  {
  }

 _String_iterator(pointer _Parg, const _Container_base *_Pstring)
  : _Mybase(_Parg, _Pstring)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Mystr> inline
 typename _String_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_iterator<_Mystr>
  _Rechecked(_String_iterator<_Mystr>& _Iter,
   typename _String_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_iterator<_Mystr> operator+(
  typename _String_iterator<_Mystr>
   ::difference_type _Off,
  _String_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }



template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _String_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _String_base_types
 {
# 474 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 typedef _Alloc0 _Alloc;


 typedef _String_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _String_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _String_val
  : public _Container_base
 {
public:
 typedef _String_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;






 typedef _String_iterator<_Myt> iterator;
 typedef _String_const_iterator<_Myt> const_iterator;


 _String_val()
  : _Bx{}
  {
  _Mysize = 0;
  _Myres = 0;
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
   : 16 / sizeof (value_type)};
 enum
  {
  _ALLOC_MASK = sizeof (value_type) <= 1 ? 15
   : sizeof (value_type) <= 2 ? 7
   : sizeof (value_type) <= 4 ? 3
   : sizeof (value_type) <= 8 ? 1 : 0};

 value_type *_Myptr()
  {
  return (this->_BUF_SIZE <= this->_Myres
   ? ::std:: addressof(*this->_Bx._Ptr)
   : this->_Bx._Buf);
  }

 const value_type *_Myptr() const
  {
  return (this->_BUF_SIZE <= this->_Myres
   ? ::std:: addressof(*this->_Bx._Ptr)
   : this->_Bx._Buf);
  }

 union _Bxty
  {
  value_type _Buf[_BUF_SIZE];
  pointer _Ptr;
  char _Alias[_BUF_SIZE];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _String_alloc
  : public _String_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alty _Alty;


 _String_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alval(_Al)
  {
  }

 _String_alloc(_Alloc0&& _Al)
  : _Alval(::std:: move(_Al))
  {
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Alval, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Alval, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(_Alval, _Right._Alval);
  }
# 657 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Alty& _Getal() noexcept
  {
  return (_Alval);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alval);
  }

 _Alty _Alval;
 };

template<class _Alloc_types>
 class _String_alloc<false, _Alloc_types>
  : public _String_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _String_alloc<false, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alty _Alty;


 _String_alloc(const _Alloc0& = _Alloc0())
  {
  }

 _String_alloc(_Alloc0&&)
  {
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 749 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Elem,
 class _Traits,
 class _Alloc>
 class basic_string
  : public _String_alloc<!is_empty<_Alloc>::value,
   _String_base_types<_Elem, _Alloc> >
 {
public:
 typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
 typedef _String_alloc<!is_empty<_Alloc>::value,
  _String_base_types<_Elem, _Alloc> > _Mybase;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
# 789 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;


 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 basic_string(const _Myt& _Right)
  : _Mybase(_Right._Getal().select_on_container_copy_construction())
  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
  : _Mybase(_Alloc())
  {
  _Tidy();
  }

 explicit basic_string(const _Alloc& _Al) noexcept
  : _Mybase(_Al)
  {
  _Tidy();
  }
# 830 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 basic_string(const _Myt& _Right, size_type _Roff,
  size_type _Count = npos)
  : _Mybase(_Right._Getal())
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }

 basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
  const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }
# 864 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 basic_string(const _Elem *_Ptr, size_type _Count)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(const _Elem *_Ptr, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(size_type _Count, _Elem _Ch)
  : _Mybase()
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
                             ;
  _Tidy();
  _Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, input_iterator_tag)
  {
  {{
  for (; _First != _Last; ++_First)
   append((size_type)1, (_Elem)*_First);
  } if (0) {
  _Tidy(true);
          ;
  }}
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, forward_iterator_tag)
  {
  size_type _Count = 0;
  _Distance(_First, _Last, _Count);
  reserve(_Count);
  _Construct(_First, _Last, input_iterator_tag());
  }

 void _Construct(_Elem *_First,
  _Elem *_Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   assign(_First, _Last - _First);
  }

 void _Construct(const _Elem *_First,
  const _Elem *_Last, random_access_iterator_tag)
  {
  if (_First != _Last)
   assign(_First, _Last - _First);
  }

 basic_string(_Myt&& _Right) noexcept
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Tidy();
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 basic_string(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  if (this->_Getal() != _Right._Getal())
   assign(_Right.begin(), _Right.end());
  else
   _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)




  noexcept

  {
  if (this != &_Right)
   {
   _Tidy(true);
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());
   if (this->_Getal() != _Right._Getal())
    assign(_Right.begin(), _Right.end());
   else
    _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 _Myt& assign(_Myt&& _Right) noexcept
  {
  if (this == &_Right)
   ;
  else if (get_allocator() != _Right.get_allocator()
   && this->_BUF_SIZE <= _Right._Myres)
   *this = _Right;
  else
   {
   _Tidy(true);
   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  if (_Right._Myres < this->_BUF_SIZE)
   _Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
    _Right._Mysize + 1);
  else
   {
   this->_Bx._Ptr = _Right._Bx._Ptr;
   _Right._Bx._Ptr = pointer();
   }
  this->_Mysize = _Right._Mysize;
  this->_Myres = _Right._Myres;
  _Right._Tidy();
  }

 basic_string(::std:: initializer_list<_Elem> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& assign(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& append(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
  }

 ~basic_string() noexcept
  {
  _Tidy(true);
  }

 static const size_type npos = (size_t)(-1);

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    _Tidy(true);
    this->_Copy_alloc(_Right._Getal());
    }
   assign(_Right);
   }
  return (*this);
  }
# 1091 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& operator=(const _Elem *_Ptr)
  {
  return (assign(_Ptr));
  }

 _Myt& operator=(_Elem _Ch)
  {
  return (assign(1, _Ch));
  }

 _Myt& operator+=(const _Myt& _Right)
  {
  return (append(_Right));
  }
# 1113 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& operator+=(const _Elem *_Ptr)
  {
  return (append(_Ptr));
  }

 _Myt& operator+=(_Elem _Ch)
  {
  return (append((size_type)1, _Ch));
  }

 _Myt& append(const _Myt& _Right)
  {
  return (append(_Right, 0, npos));
  }

 _Myt& append(const _Myt& _Right,
  size_type _Roff, size_type _Count = npos)
  {
  if (_Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;

  size_t _Oldsize = this->_Mysize;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::copy(this->_Myptr() + _Oldsize,
    _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& append(const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (append(*this,
    _Ptr - this->_Myptr(), _Count));
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  size_type _Num;
  size_type _Oldsize = this->_Mysize;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::copy(this->_Myptr() + _Oldsize, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& append(const _Elem *_Ptr)
  {
                      ;
  return (append(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& append(size_type _Count, _Elem _Ch)
  {
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Chassign(this->_Mysize, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& append(_Iter _First, _Iter _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }




 _Myt& append(const_pointer _First, const_pointer _Last)
  {
                                            ;
  if (_Last < _First)
   _Xran();
  return (append(_First, _Last - _First));
  }


 _Myt& append(const_iterator _First, const_iterator _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& assign(const _Myt& _Right)
  {
  return (assign(_Right, 0, npos));
  }

 _Myt& assign(const _Myt& _Right,
  size_type _Roff, size_type _Count = npos)
  {
  if (_Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Count < _Num)
   _Num = _Count;

  if (this == &_Right)
   erase((size_type)(_Roff + _Num)), erase(0, _Roff);
  else if (_Grow(_Num))
   {
   _Traits::copy(this->_Myptr(),
    _Right._Myptr() + _Roff, _Num);
   _Eos(_Num);
   }
  return (*this);
  }
# 1284 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& assign(const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (assign(*this,
    (size_type)(_Ptr - this->_Myptr()), _Count));

  if (_Grow(_Count))
   {
   _Traits::copy(this->_Myptr(), _Ptr, _Count);
   _Eos(_Count);
   }
  return (*this);
  }

 _Myt& assign(const _Elem *_Ptr)
  {
                      ;
  return (assign(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& assign(size_type _Count, _Elem _Ch)
  {
  if (_Count == npos)
   _Xlen();

  if (_Grow(_Count))
   {
   _Chassign(0, _Count, _Ch);
   _Eos(_Count);
   }
  return (*this);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& assign(_Iter _First, _Iter _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }




 _Myt& assign(const_pointer _First, const_pointer _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }


 _Myt& assign(const_iterator _First, const_iterator _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& insert(size_type _Off, const _Myt& _Right)
  {
  return (insert(_Off, _Right, 0, npos));
  }

 _Myt& insert(size_type _Off,
  const _Myt& _Right, size_type _Roff, size_type _Count = npos)
  {
  if (this->_Mysize < _Off || _Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   if (this == &_Right)
    _Traits::move(this->_Myptr() + _Off,
     this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
      _Count);
   else
    _Traits::copy(this->_Myptr() + _Off,
     _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1392 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& insert(size_type _Off,
  const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (insert(_Off, *this,
    _Ptr - this->_Myptr(), _Count));
  if (this->_Mysize < _Off)
   _Xran();
  if (npos - this->_Mysize <= _Count)
   _Xlen();
  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& insert(size_type _Off, const _Elem *_Ptr)
  {
                      ;
  return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& insert(size_type _Off,
  size_type _Count, _Elem _Ch)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (npos - this->_Mysize <= _Count)
   _Xlen();
  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 iterator insert(const_iterator _Where)
  {
  return (insert(_Where, _Elem()));
  }

 iterator insert(const_iterator _Where, _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, 1, _Ch);
  return (begin() + (difference_type)_Off);
  }

 iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
  {
  size_type _Off = _Where - begin();
  insert(_Off, _Count, _Ch);
  return (begin() + _Off);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }




 iterator insert(const_iterator _Where,
  const_pointer _First, const_pointer _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }


 iterator insert(const_iterator _Where,
  const_iterator _First, const_iterator _Last)
  {
  size_type _Off = _Where - begin();
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 _Myt& erase(size_type _Off = 0)
  {
  if (this->_Mysize < _Off)
   _Xran();
  _Eos(_Off);
  return (*this);
  }

 _Myt& erase(size_type _Off, size_type _Count)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off <= _Count)
   _Eos(_Off);
  else if (0 < _Count)
   {
   value_type *_Ptr = this->_Myptr() + _Off;
   size_type _Newsize = this->_Mysize - _Count;
   _Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
   _Eos(_Newsize);
   }
  return (*this);
  }

 iterator erase(const_iterator _Where)
  {
  size_type _Count = _Where - begin();
  erase(_Count, 1);
  return (begin() + _Count);
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
                             ;
  size_type _Count = _First - begin();
  erase(_Count, _Last - _First);
  return (begin() + _Count);
  }

 void clear() noexcept
  {
  _Eos(0);
  }

 _Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
  {
  return (replace(_Off, _N0, _Right, 0, npos));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Myt& _Right, size_type _Roff,
   size_type _Count = npos)
  {
  if (this->_Mysize < _Off || _Right.size() < _Roff)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();

  size_type _Nm = this->_Mysize - _N0 - _Off;
  size_type _Newsize = this->_Mysize + _Count - _N0;
  if (this->_Mysize < _Newsize)
   _Grow(_Newsize);

  if (this != &_Right)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off,
    _Right._Myptr() + _Roff, _Count);
   }
  else if (_Count <= _N0)
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   }
  else if (_Roff <= _Off)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   }
  else if (_Off + _N0 <= _Roff)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + (_Roff + _Count - _N0),
    _Count);
   }
  else
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _N0);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off + _N0,
    this->_Myptr() + _Roff + _Count,
    _Count - _N0);
   }

  _Eos(_Newsize);
  return (*this);
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count)
  {
                                      ;
  if (_Inside(_Ptr))
   return (replace(_Off, _N0, *this,
    (size_type)(_Ptr - this->_Myptr()),
    _Count));
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  size_type _Num;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num = this->_Mysize + _Count - _N0))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }
# 1660 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 _Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
  {
                      ;
  return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  size_type _Num;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num = this->_Mysize + _Count - _N0))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Myt& _Right)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Right));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr, size_type _Count)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Ptr));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch)
  {
  if (_First < begin() || _Last < _First)
   _Xran();
  return (replace(_First - begin(), _Last - _First, _Count, _Ch));
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  _Myt& replace(const_iterator _First, const_iterator _Last,
   _Iter _First2, _Iter _Last2)
  {
  _Myt _Right(_First2, _Last2);
  replace(_First, _Last, _Right);
  return (*this);
  }




 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  pointer _First2, pointer _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }


 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  iterator _First2, iterator _Last2)
  {
  if (_First < begin() || _Last < _First || _Last2 < _First2)
   _Xran();
  if (_First2 == _Last2)
   erase(_First - begin(), _Last - _First);
  else
   replace(_First - begin(), _Last - _First,
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 iterator begin() noexcept
  {
  return (iterator(this->_Myptr(), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Myptr(), this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Myptr() + this->_Mysize, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Myptr() + this->_Mysize, this));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 void shrink_to_fit()
  {
  if ((size() | this->_ALLOC_MASK) < capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 reference at(size_type _Off)
  {
  if (this->_Mysize <= _Off)
   _Xran();
  return (this->_Myptr()[_Off]);
  }

 const_reference at(size_type _Off) const
  {
  if (this->_Mysize <= _Off)
   _Xran();
  return (this->_Myptr()[_Off]);
  }
# 1883 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 reference operator[](size_type _Off)
  {
# 1893 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  return (this->_Myptr()[_Off]);
  }

 const_reference operator[](size_type _Off) const
  {
# 1906 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
  return (this->_Myptr()[_Off]);
  }

 void push_back(_Elem _Ch)
  {
  insert(end(), _Ch);
  }

 void pop_back()
  {
  erase(this->_Mysize - 1);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 const _Elem *c_str() const noexcept
  {
  return (this->_Myptr());
  }

 const _Elem *data() const noexcept
  {
  return (c_str());
  }

 _Elem *data() noexcept
  {
  return (this->_Myptr());
  }

 size_type length() const noexcept
  {
  return (this->_Mysize);
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  size_type _Num = this->_Getal().max_size();
  return (_Num <= 1 ? 1 : _Num - 1);
  }

 void resize(size_type _Newsize)
  {
  resize(_Newsize, _Elem());
  }

 void resize(size_type _Newsize, _Elem _Ch)
  {
  if (_Newsize <= this->_Mysize)
   _Eos(_Newsize);
  else
   append(_Newsize - this->_Mysize, _Ch);
  }

 size_type capacity() const noexcept
  {
  return (this->_Myres);
  }

 void reserve(size_type _Newcap = 0)
  {
  if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
   {
   size_type _Size = this->_Mysize;
   if (_Grow(_Newcap, true))
    _Eos(_Size);
   }
  }

 bool empty() const noexcept
  {
  return (this->_Mysize == 0);
  }

 size_type copy(_Elem *_Ptr,
  size_type _Count, size_type _Off = 0) const
  {
                                      ;
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _Count)
   _Count = this->_Mysize - _Off;
  _Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

 void _Swap_bx(_Myt& _Right)
  {
  if (this->_BUF_SIZE <= this->_Myres)
   if (this->_BUF_SIZE <= _Right._Myres)
    _Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
   else
    {
    pointer _Ptr = this->_Bx._Ptr;
    _Traits::copy(this->_Bx._Buf,
     _Right._Bx._Buf, _Right._Mysize + 1);
    _Right._Bx._Ptr = _Ptr;
    }
  else
   if (_Right._Myres < this->_BUF_SIZE)
    ::std:: swap(this->_Bx._Buf, _Right._Bx._Buf);
   else
    {
    pointer _Ptr = _Right._Bx._Ptr;
    _Traits::copy(_Right._Bx._Buf,
     this->_Bx._Buf, this->_Mysize + 1);
    this->_Bx._Ptr = _Ptr;
    }
  }

 void swap(_Myt& _Right)


  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   ::std:: swap(this->_Myres, _Right._Myres);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {

   this->_Swap_alloc(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Bx, _Right._Bx);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   ::std:: swap(this->_Myres, _Right._Myres);
   }
  else
   {
   _Myt _Tmp = *this;

   *this = _Right;
   _Right = _Tmp;
   }
  }

 size_type find(const _Myt& _Right, size_type _Off = 0) const noexcept
  {
  return (find(_Right._Myptr(), _Off, _Right.size()));
  }
# 2082 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Count == 0 && _Off <= this->_Mysize)
   return (_Off);

  size_type _Nm;
  if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
   {
   const _Elem *_Uptr, *_Vptr;
   for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
    (_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
    if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find(const _Elem *_Ptr, size_type _Off = 0) const
  {
                      ;
  return (find(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find(_Elem _Ch, size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type rfind(const _Myt& _Right, size_type _Off = npos) const noexcept
  {
  return (rfind(_Right._Myptr(), _Off, _Right.size()));
  }
# 2126 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type rfind(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Count == 0)
   return (_Off < this->_Mysize ? _Off
    : this->_Mysize);
  if (_Count <= this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr() +
    (_Off < this->_Mysize - _Count ? _Off
     : this->_Mysize - _Count);
   for (; ; --_Uptr)
    if (_Traits::eq(*_Uptr, *_Ptr)
     && _Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
  {
                      ;
  return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type rfind(_Elem _Ch, size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_of(const _Myt& _Right,
  size_type _Off = 0) const noexcept
  {
  return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2173 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < _Count && _Off < this->_Mysize)
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_of(const _Myt& _Right,
  size_type _Off = npos) const noexcept
  {
  return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2216 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < _Count && 0 < this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_not_of(const _Myt& _Right,
  size_type _Off = 0) const noexcept
  {
  return (find_first_not_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2261 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (_Off < this->_Mysize)
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
   }
  return (npos);
  }

 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_not_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_not_of(const _Myt& _Right,
  size_type _Off = npos) const noexcept
  {
  return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
  }
# 2303 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {
                                      ;
  if (0 < this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }
  return (npos);
  }

 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_not_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 _Myt substr(size_type _Off = 0, size_type _Count = npos) const
  {
  return (_Myt(*this, _Off, _Count, get_allocator()));
  }

 int compare(const _Myt& _Right) const noexcept
  {
  return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
  }
# 2350 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 int compare(size_type _Off, size_type _N0, const _Myt& _Right) const
  {
  return (compare(_Off, _N0, _Right, 0, npos));
  }
# 2362 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 int compare(size_type _Off, size_type _N0, const _Myt& _Right,
  size_type _Roff, size_type _Count = npos) const
  {
  if (_Right.size() < _Roff)
   _Xran();
  if (_Right._Mysize - _Roff < _Count)
   _Count = _Right._Mysize - _Roff;
  return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
  }
# 2380 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
 int compare(const _Elem *_Ptr) const
  {
                      ;
  return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
  {
                      ;
  return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count) const
  {
                                      ;
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;

  int _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
   _N0 < _Count ? _N0 : _Count);
  return (_Ans != 0 ? _Ans : _N0 < _Count ? -1
   : _N0 == _Count ? 0 : +1);
  }

 allocator_type get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
  {
  if (_Count == 1)
   _Traits::assign(*(this->_Myptr() + _Off), _Ch);
  else
   _Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
  }

 void _Copy(size_type _Newsize, size_type _Oldlen)
  {
  size_type _Newres = _Newsize | this->_ALLOC_MASK;
  if (max_size() < _Newres)
   _Newres = _Newsize;
  else if (this->_Myres / 2 <= _Newres / 3)
   ;
  else if (this->_Myres <= max_size() - this->_Myres / 2)
   _Newres = this->_Myres
    + this->_Myres / 2;
  else
   _Newres = max_size();

  _Elem *_Ptr;
  {{
   _Ptr = this->_Getal().allocate(_Newres + 1);
  } if (0) {
   _Newres = _Newsize;
   {{
    _Ptr = this->_Getal().allocate(_Newres + 1);
   } if (0) {
   _Tidy(true);
           ;
   }}
  }}

  if (0 < _Oldlen)
   _Traits::copy(_Ptr, this->_Myptr(),
    _Oldlen);
  _Tidy(true);
  this->_Bx._Ptr = _Ptr;
  this->_Myres = _Newres;
  _Eos(_Oldlen);
  }

 void _Eos(size_type _Newsize)
  {
  _Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
  }

 bool _Grow(size_type _Newsize,
  bool _Trim = false)
  {
  if (max_size() < _Newsize)
   _Xlen();
  if (this->_Myres < _Newsize)
   _Copy(_Newsize, this->_Mysize);
  else if (_Trim && _Newsize < this->_BUF_SIZE)
   _Tidy(true,
    _Newsize < this->_Mysize ? _Newsize : this->_Mysize);
  else if (_Newsize == 0)
   _Eos(0);
  return (0 < _Newsize);
  }

 bool _Inside(const _Elem *_Ptr)
  {
  if (_Ptr == 0 || _Ptr < this->_Myptr()
   || this->_Myptr() + this->_Mysize <= _Ptr)
   return (false);
  else
   return (true);
  }

 void _Tidy(bool _Built = false,
  size_type _Newsize = 0)
  {
  if (!_Built)
   ;
  else if (this->_BUF_SIZE <= this->_Myres)
   {
   pointer _Ptr = this->_Bx._Ptr;
   if (0 < _Newsize)
    _Traits::copy(this->_Bx._Buf,
     ::std:: addressof(*_Ptr), _Newsize);
   this->_Getal().deallocate(_Ptr, this->_Myres + 1);
   }
  this->_Myres = this->_BUF_SIZE - 1;
  _Eos(_Newsize);
  }

 void _Xlen() const
  {
  _Xlength_error("string too long");
  }

 void _Xran() const
  {
  _Xout_of_range("invalid string position");
  }
 };
# 2523 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
template<class _Elem, class _Tr, class _Alloc>
const typename basic_string<_Elem, _Tr, _Alloc>::size_type basic_string<_Elem, _Tr, _Alloc>::npos;
# 2541 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstring" 3
template<class _Elem,
 class _Traits,
 class _Alloc> inline
 void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Traits::length(_Left) + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(1 + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Traits::length(_Right));
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + 1);
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 if (_Right.size() <= _Left.capacity() - _Left.size()
  || _Right.capacity() - _Right.size() < _Left.size())
  return (::std:: move(_Left.append(_Right)));
 else
  return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
  size_type;
 return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem *_Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem _Right)
 {
 return (::std:: move(_Left.append(1, _Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) > 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left < _Right));
 }

typedef basic_string<char, char_traits<char>, allocator<char> >
 string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
 wstring;
}
namespace std {

template<class _Elem,
 class _Traits,
 class _Alloc>
 struct hash<basic_string<_Elem, _Traits, _Alloc> >
 {
 typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
   _Keyval.size() * sizeof (_Elem)));
  }
 };
}
namespace std {
typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
 u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
 u32string;
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 2 3
namespace std {
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdexcept" 3
class logic_error
 : public ::std:: exception
 {
public:
 explicit logic_error(const string& _Message)
  : _Str(_Message)
  {
  }

 explicit logic_error(const char *_Message)
  : _Str(_Message)
  {
  }


 virtual ~logic_error() noexcept;






 virtual const char *what() const noexcept
  {
  return (_Str.c_str());
  }

private:
 string _Str;




protected:
 virtual void _Doraise() const;

 };


class domain_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit domain_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit domain_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~domain_error() noexcept;

 };


class invalid_argument
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit invalid_argument(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit invalid_argument(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~invalid_argument() noexcept;

 };


class length_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit length_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit length_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~length_error() noexcept;

 };


class out_of_range
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit out_of_range(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit out_of_range(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~out_of_range() noexcept;

 };


class runtime_error
 : public ::std:: exception
 {
public:
 explicit runtime_error(const string& _Message)
  : _Str(_Message)
  {
  }

 explicit runtime_error(const char *_Message)
  : _Str(_Message)
  {
  }


 virtual ~runtime_error() noexcept;






 virtual const char *what() const noexcept
  {
  return (_Str.c_str());
  }

private:
 string _Str;
 };


class overflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit overflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit overflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~overflow_error() noexcept;

 };


class underflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit underflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit underflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~underflow_error() noexcept;

 };


class range_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit range_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit range_error(const char *_Message)
  : _Mybase(_Message)
  {
  }


 virtual ~range_error() noexcept;

 };
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {

template<class _Ty> inline
 pair<_Ty *, ptrdiff_t>
  get_temporary_buffer(ptrdiff_t _Count) noexcept
 {
 _Ty *_Pbuf;

 if (_Count < 0)
  _Count = 0;
 else if (((size_t)(-1) / sizeof (_Ty) < _Count))
  _Xbad_alloc();
 for (_Pbuf = 0; 0 < _Count; _Count /= 2)
  if ((_Pbuf = (_Ty *)::operator new(
   (size_t)_Count * sizeof (_Ty), nothrow)) != 0)
   break;

 return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
 }


template<class _Ty> inline
 void return_temporary_buffer(_Ty *_Pbuf)
 {
 ::operator delete(_Pbuf);
 }
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, input_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 _Construct(::std:: addressof(*_Dest),
  *_First);
 while (0 < --_Count)
  _Construct(::std:: addressof(*++_Dest), *++_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (++_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, forward_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
  _Construct(::std:: addressof(*_Dest), *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 return (_Uninitialized_copy_n(_First, _Count,
  _Dest, _Iter_cat(_First)));
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag)
 {
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy_n(_First, _Count,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 if (_Count <= 0)
  return (_Dest);
 else
  return (_Rechecked(_Dest,
   _Uninitialized_copy_n(_Unchecked(_First), _Count,
    _Unchecked(_Dest))));
 }
# 259 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Construct(::std:: addressof(*_Dest), *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy0(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
# 370 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Nonscalar_ptr_iterator_tag)
 {
                                       ;
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Al.construct(_Dest, *_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Scalar_ptr_iterator_tag)
 {
 return (_Uninit_copy(_First, _Last, _Dest,
  _Al, _Nonscalar_ptr_iterator_tag()));
 }

template<class _Ty1,
 class _Ty2> inline
 _Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<allocator<_Ty2> >&, _Scalar_ptr_iterator_tag)
 {
                                       ;
 size_t _Count = (size_t)(_Last - _First);
 return ((_Ty2 *):: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First)) + _Count);
 }
# 426 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Uninit_copy(_First, _Last, _Dest, _Al,
  _Ptr_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Rechecked(_Dest,
  _Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; (void)++_First, ++_Dest)
 ::new (static_cast<void *>(::std:: addressof(*_Dest)))
  typename iterator_traits<_FwdIt>::value_type(::std:: move(*_First));
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }


template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 pair<_InIt, _FwdIt> uninitialized_move_n(_InIt _First,
  _Diff _Count, _FwdIt _Dest)
 {
 _FwdIt _Next = _Dest;

 {{
 for (; 0 < _Count; ++_First, (void)++_Dest, --_Count)
  ::new (static_cast<void *>(::std:: addressof(*_Dest)))
   typename iterator_traits<_FwdIt>::value_type(::std:: move(*_First));
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 return (pair<_InIt, _FwdIt>(_First, _Dest));
 }
# 526 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
 {
                                       ;
 _FwdIt _Next = _Dest;

 {{
 for (; _First != _Last; ++_Dest, (void)++_First)
  _Al.construct(::std:: addressof(*_Dest), (_Valty&&)*_First);
 } if (0) {
 for (; _Next != _Dest; ++_Next)
  _Al.destroy(::std:: addressof(*_Next));
         ;
 }}
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
 {
 return (_Uninit_move(_First, _Last, _Dest,
  _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));
 }

template<class _Ty1,
 class _Ty2,
 class _Valty> inline
 _Ty2 *_Uninit_move(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<allocator<_Ty2> >&, _Valty *, _Scalar_ptr_iterator_tag)
 {
                                       ;
 size_t _Count = (size_t)(_Last - _First);
 return ((_Ty2 *):: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First)) + _Count);
 }
# 586 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Uninit_move(_First, _Last, _Dest, _Al,
  _Val_type(_First), _Ptr_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Rechecked(_Dest,
  _Uninit_move(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _FwdIt,
 class _Tval> inline
 void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
  _Nonscalar_ptr_iterator_tag)
 {
                            ;
 _FwdIt _Next = _First;

 {{
 for (; _First != _Last; ++_First)
  _Construct(::std:: addressof(*_First), _Val);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}
 }

template<class _Ty,
 class _Tval> inline
 void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
  _Scalar_ptr_iterator_tag)
 {
 ::std:: fill(_First, _Last, _Val);
 }

template<class _FwdIt,
 class _Tval> inline
 void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
 {
 _Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
 }


template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
  _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Construct(::std:: addressof(*_First), _Val);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Destroy(::std:: addressof(*_Next));
         ;
 }}

 return (_First);
 }

template<class _Ty,
 class _Diff,
 class _Tval> inline
 _Ty *_Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
  _Scalar_ptr_iterator_tag)
 {
 return (_Fill_n(_First, _Count, _Val));
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval& _Val)
 {
 return (_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First)));
 }


template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty> inline
 void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
   _Valty *, _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Al.construct(_First, *_Pval);
 } if (0) {
 for (; _Next != _First; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 }

template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty> inline
 void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
   _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Uninit_fill_n(_First, _Count,
  _Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
 }

template<class _Ty,
 class _Diff,
 class _Tval,
 class _Valty> inline
 void _Uninit_fill_n(_Ty *_First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<allocator<_Ty> >&,
   _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Fill_n(_First, _Count, *_Pval);
 }
# 751 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc> inline
 void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Alloc& _Al)
 {
 _Uninit_fill_n(_First, _Count, _Pval, _Al,
  _Val_type(_First), _Ptr_cat(_First, _First));
 }


template<class _FwdIt,
 class _Diff,
 class _Alloc,
 class _Valty> inline
 void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 {{
 for (; 0 < _Count; --_Count, (void)++_First)
  _Al.construct(_First);

 } if (0) {
 for (; _Next != _First; ++_Next)
  _Al.destroy(_Next);
         ;
 }}
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc,
 class _Valty> inline
 void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Uninit_def_fill_n(_First, _Count,
  _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
 }

template<class _Ty,
 class _Diff,
 class _Valty> inline
 void _Uninit_def_fill_n(_Ty *_First, _Diff _Count,
  _Wrap_alloc<allocator<_Ty> >&, _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Fill_n(_First, _Count, (_Valty)0);
 }
# 821 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
  _Alloc& _Al)
 {
 _Uninit_def_fill_n(_First, _Count, _Al,
  _Val_type(_First), _Ptr_cat(_First, _First));
 }
# 898 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xmemory" 3
template<class _OutIt,
 class _Ty>
 class raw_storage_iterator
  : public _Outit
 {
public:
 explicit raw_storage_iterator(_OutIt _First)
  : _Next(_First)
  {
  }

 raw_storage_iterator<_OutIt, _Ty>& operator*()
  {
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty>& operator=(const _Ty& _Val)
  {
  _Construct(::std:: addressof(*_Next), _Val);
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty>& operator++()
  {
  ++_Next;
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty> operator++(int)
  {
  raw_storage_iterator<_OutIt, _Ty> _Ans = *this;
  ++_Next;
  return (_Ans);
  }

 _OutIt base() const
  {
  return (_Next);
  }

private:
 _OutIt _Next;
 };


template<class _Ty>
 class _Temp_iterator
  : public _Outit
 {
public:
 typedef _Ty *_Pty;

 _Temp_iterator(ptrdiff_t _Count = 0)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = _Count;
  _Pbuf = &_Buf;
  }

 _Temp_iterator(const _Temp_iterator<_Ty>& _Right)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = 0;
  *this = _Right;
  }

 ~_Temp_iterator() noexcept
  {
  if (_Buf._Begin != 0)
   {
   for (_Pty _Next = _Buf._Begin;
    _Next != _Buf._Hiwater; ++_Next)
    _Destroy(_Next);
   ::std:: return_temporary_buffer(_Buf._Begin);
   }
  }

 _Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
  {
  _Pbuf = _Right._Pbuf;
  return (*this);
  }

 _Temp_iterator<_Ty>& operator=(const _Ty& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ = _Val;
  else
   {
   _Pty _Ptr = _Pbuf->_Current;
   _Construct(_Ptr, _Val);
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }
  return (*this);
  }

 _Temp_iterator<_Ty>& operator=(_Ty&& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ =
    ::std:: forward<_Ty>(_Val);
  else
   {
   _Pty _Ptr = _Pbuf->_Current;
   _Construct(_Ptr, ::std:: forward<_Ty>(_Val));
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }
  return (*this);
  }

 _Temp_iterator<_Ty>& operator*()
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& operator++()
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& operator++(int)
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& _Init()
  {
  _Pbuf->_Current = _Pbuf->_Begin;
  return (*this);
  }

 _Pty _First() const
  {
  return (_Pbuf->_Begin);
  }

 _Pty _Last() const
  {
  return (_Pbuf->_Current);
  }

 ptrdiff_t _Maxlen()
  {
  if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
   {
   pair<_Pty, ptrdiff_t> _Pair =
    ::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

   _Pbuf->_Begin = _Pair.first;
   _Pbuf->_Current = _Pair.first;
   _Pbuf->_Hiwater = _Pair.first;
   _Pbuf->_Size = _Pair.second;
   }
  return (_Pbuf->_Size);
  }

private:
 struct _Bufpar
  {
  _Pty _Begin;
  _Pty _Current;
  _Pty _Hiwater;
  ptrdiff_t _Size;
  };
 _Bufpar _Buf;
 _Bufpar *_Pbuf;
 };


template<class _Ty>
 class auto_ptr;

template<class _Ty>
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref(_Ty *_Right)
  : _Ref(_Right)
  {
  }

 _Ty *_Ref;
 };

template<class _Ty>
 class auto_ptr
  {
public:
 typedef auto_ptr<_Ty> _Myt;
 typedef _Ty element_type;

 explicit auto_ptr(_Ty *_Ptr = 0) noexcept
  : _Myptr(_Ptr)
  {
  }

 auto_ptr(_Myt& _Right) noexcept
  : _Myptr(_Right.release())
  {
  }

 auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  _Myptr = _Ptr;
  }

 template<class _Other>
  operator auto_ptr<_Other>() noexcept
  {
  return (auto_ptr<_Other>(*this));
  }

 template<class _Other>
  operator auto_ptr_ref<_Other>() noexcept
  {
  _Other *_Cvtptr = _Myptr;
  auto_ptr_ref<_Other> _Ans(_Cvtptr);
  _Myptr = 0;
  return (_Ans);
  }

 template<class _Other>
  _Myt& operator=(auto_ptr<_Other>& _Right) noexcept
  {
  reset(_Right.release());
  return (*this);
  }

 template<class _Other>
  auto_ptr(auto_ptr<_Other>& _Right) noexcept
  : _Myptr(_Right.release())
  {
  }

 _Myt& operator=(_Myt& _Right) noexcept
  {
  reset(_Right.release());
  return (*this);
  }

 _Myt& operator=(auto_ptr_ref<_Ty> _Right) noexcept
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  reset(_Ptr);
  return (*this);
  }

 ~auto_ptr() noexcept
  {
  delete _Myptr;
  }

 _Ty& operator*() const noexcept
  {





  return (*get());
  }

 _Ty *operator->() const noexcept
  {





  return (get());
  }

 _Ty *get() const noexcept
  {
  return (_Myptr);
  }

 _Ty *release() noexcept
  {
  _Ty *_Tmp = _Myptr;
  _Myptr = 0;
  return (_Tmp);
  }

 void reset(_Ty *_Ptr = 0)
  {
  if (_Ptr != _Myptr)
   delete _Myptr;
  _Myptr = _Ptr;
  }

private:
 _Ty *_Myptr;
 };
}


#pragma clang diagnostic pop
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 2 3




namespace std {

template<class _Mylist,
 class _Base = _Iterator_base0>
 class _List_unchecked_const_iterator
  : public _Iterator012<bidirectional_iterator_tag,
   typename _Mylist::value_type,
   typename _Mylist::difference_type,
   typename _Mylist::const_pointer,
   typename _Mylist::const_reference,
   _Base>
 {
public:
 typedef _List_unchecked_const_iterator<_Mylist, _Base> _Myiter;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::const_pointer pointer;
 typedef typename _Mylist::const_reference reference;

 _List_unchecked_const_iterator()
  : _Ptr(nullptr)
  {
  }

 _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Ptr(_Pnode)
  {
  this->_Adopt(_Plist);
  }

 reference operator*() const
  {
  return (_Mylist::_Myval(_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  _Ptr = _Mylist::_Nextnode(_Ptr);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  _Ptr = _Mylist::_Prevnode(_Ptr);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 _Nodeptr _Mynode() const
  {
  return (_Ptr);
  }

 _Nodeptr _Ptr;
 };


template<class _Mylist>
 class _List_unchecked_iterator
  : public _List_unchecked_const_iterator<_Mylist>
 {
public:
 typedef _List_unchecked_iterator<_Mylist> _Myiter;
 typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::pointer pointer;
 typedef typename _Mylist::reference reference;

 _List_unchecked_iterator()
  {
  }

 _List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };


template<class _Mylist>
 class _List_const_iterator
  : public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
 {
public:
 typedef _List_const_iterator<_Mylist> _Myiter;
 typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::const_pointer pointer;
 typedef typename _Mylist::const_reference reference;

 _List_const_iterator()
  : _Mybase()
  {
  }

 _List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
  }

 reference operator*() const
  {
# 221 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  return (_Mylist::_Myval(this->_Ptr));
  }

 _Myiter& operator++()
  {
# 241 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 271 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  this->_Ptr = _Mylist::_Prevnode(this->_Ptr);


  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
# 297 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }
 };

template<class _Mylist> inline
 typename _List_const_iterator<_Mylist>::_Unchecked_type
  _Unchecked(_List_const_iterator<_Mylist> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mylist> inline
 _List_const_iterator<_Mylist>&
  _Rechecked(_List_const_iterator<_Mylist>& _Iter,
   typename _List_const_iterator<_Mylist>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Mylist>
 class _List_iterator
  : public _List_const_iterator<_Mylist>
 {
public:
 typedef _List_iterator<_Mylist> _Myiter;
 typedef _List_const_iterator<_Mylist> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::pointer pointer;
 typedef typename _Mylist::reference reference;

 _List_iterator()
  {
  }

 _List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };

template<class _Mylist> inline
 typename _List_iterator<_Mylist>::_Unchecked_type
  _Unchecked(_List_iterator<_Mylist> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mylist> inline
 _List_iterator<_Mylist>&
  _Rechecked(_List_iterator<_Mylist>& _Iter,
   typename _List_iterator<_Mylist>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference,
 class _Nodeptr_type>
 struct _List_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 typedef _Nodeptr_type _Nodeptr;
 };

template<class _Value_type,
 class _Voidptr>
 struct _List_node
  {
  _Voidptr _Next;
  _Voidptr _Prev;
  _Value_type _Myval;

 private:
  _List_node& operator=(const _List_node&);
  };

template<class _Value_type>
 struct _List_node<_Value_type, void *>
  {
  typedef _List_node<_Value_type, void *> *_Nodeptr;
  _Nodeptr _Next;
  _Nodeptr _Prev;
  _Value_type _Myval;

 private:
  _List_node& operator=(const _List_node&);
  };

template<class _Ty>
 struct _List_simple_types
  : public _Simple_types<_Ty>
 {
 typedef _List_node<_Ty, void *> _Node;
 typedef _Node *_Nodeptr;
 };

template<class _Ty,
 class _Alloc0>
 struct _List_base_types
 {
# 478 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
 typedef _Alloc0 _Alloc;


 typedef _List_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
  _Voidptr;
 typedef _List_node<typename _Alty::value_type,
  _Voidptr> _Node;

 typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
 typedef typename _Alnod_type::pointer _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _List_simple_types<typename _Alty::value_type>,
  _List_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference,
   _Nodeptr> >::type
  _Val_types;
 };


template<class _Val_types>
 class _List_val
  : public _Container_base
 {
public:
 typedef _List_val<_Val_types> _Myt;

 typedef typename _Val_types::_Nodeptr _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _List_const_iterator<_Myt> const_iterator;
 typedef _List_iterator<_Myt> iterator;

 typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
 typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;

 _List_val()
  {
  this->_Myhead = 0;
  this->_Mysize = 0;
  }

 static _Nodepref _Nextnode(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Next);
  }

 static _Nodepref _Prevnode(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Prev);
  }

 static reference _Myval(_Nodeptr _Pnode)
  {
  return ((reference)_Pnode->_Myval);
  }

 _Nodeptr _Myhead;
 size_type _Mysize;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _List_alloc
  : public _List_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _List_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alnod(_Al)
  {
  this->_Myhead = _Buyheadnode();
  }

 _List_alloc(_Alloc0&& _Al)
  : _Alnod(::std:: move(_Al))
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_List_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Alnod, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Alnod, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(_Alnod, _Right._Alnod);
  }
# 676 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
 _Nodeptr _Buyheadnode()
  {
  return (_Buynode0(_Nodeptr(), _Nodeptr()));
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  _Alnod.destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  _Alnod.destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  _Alnod.deallocate(_Pnode, 1);
  }

 _Nodeptr _Buynode0(_Nodeptr _Next,
  _Nodeptr _Prev, _Nodeptr _Pnode = nullptr)
  {
  if (_Pnode == nullptr)
   _Pnode = _Alnod.allocate(1);

  if (_Next == _Nodeptr())
   {
   _Next = _Pnode;
   _Prev = _Pnode;
   }
  {{
  _Alnod.construct(
   ::std:: addressof(this->_Nextnode(_Pnode)), _Next);
  _Alnod.construct(
   ::std:: addressof(this->_Prevnode(_Pnode)), _Prev);
  } if (0) {
  _Alnod.deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 _Alty& _Getal() noexcept
  {
  return (_Alnod);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alnod);
  }

 _Alty _Alnod;
 };


template<class _Alloc_types>
 class _List_alloc<false, _Alloc_types>
  : public _List_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _List_alloc<false, _Alloc_types> _Myt;
 typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _List_alloc(const _Alloc0& = _Alloc0())
  {
  this->_Myhead = _Buyheadnode();
  }

 _List_alloc(_Alloc0&&)
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_List_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 830 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
 _Nodeptr _Buyheadnode()
  {
  return (_Buynode0(_Nodeptr(), _Nodeptr()));
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 _Nodeptr _Buynode0(_Nodeptr _Next,
  _Nodeptr _Prev, _Nodeptr _Pnode = nullptr)
  {
  if (_Pnode == nullptr)
   _Pnode = this->_Getal().allocate(1);

  if (_Next == _Nodeptr())
   {
   _Next = _Pnode;
   _Prev = _Pnode;
   }
  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Nextnode(_Pnode)), _Next);
  this->_Getal().construct(
   ::std:: addressof(this->_Prevnode(_Pnode)), _Prev);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc>
 class _List_buy
  : public _List_alloc<!is_empty<_Alloc>::value,
   _List_base_types<_Ty, _Alloc> >
 {
public:
 typedef _List_alloc<!is_empty<_Alloc>::value,
  _List_base_types<_Ty, _Alloc> > _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Nodeptr _Nodeptr;

 _List_buy(const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  }

 _List_buy(_Alloc&& _Al)
  : _Mybase(::std:: move(_Al))
  {
  }

 template<class... _Valty>
  _Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
   _Valty&&... _Val)
  {
  _Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Pnode)),
    ::std:: forward<_Valty>(_Val)...);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 void _Freenode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }
 };


template<class _Ty,
 class _Alloc = allocator<_Ty> >
 class list
  : public _List_buy<_Ty, _Alloc>
 {
public:
 typedef list<_Ty, _Alloc> _Myt;
 typedef _List_buy<_Ty, _Alloc> _Mybase;
 typedef typename _Mybase::_Node _Node;
 typedef typename _Mybase::_Nodeptr _Nodeptr;
 typedef typename _Mybase::_Alty _Alty;

 typedef _Alloc allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::value_type value_type;

 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::_Unchecked_const_iterator
  _Unchecked_const_iterator;
 typedef typename _Mybase::_Unchecked_iterator
  _Unchecked_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 list()
  : _Mybase()
  {
  }

 explicit list(const _Alloc& _Al)
  : _Mybase(_Al)
  {
  }

 explicit list(size_type _Count)
  : _Mybase()
  {
  resize(_Count);
  }


 list(size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  resize(_Count);
  }


 list(size_type _Count, const _Ty& _Val)
  : _Mybase()
  {
  _Construct_n(_Count, _Val);
  }

 list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct_n(_Count, _Val);
  }

 list(const _Myt& _Right)
  : _Mybase(_Right._Getal().select_on_container_copy_construction())
  {
  {{
  insert(begin(), _Right.begin(), _Right.end());
  } if (0) {
  _Tidy();
          ;
  }}
  }

 list(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  {{
  insert(begin(), _Right.begin(), _Right.end());
  } if (0) {
  _Tidy();
          ;
  }}
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  list(_Iter _First, _Iter _Last)
  : _Mybase()
  {
  _Construct(_First, _Last);
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
  list(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct(_First, _Last);
  }

 template<class _Iter>
            void _Construct(_Iter _First, _Iter _Last)
  {
  {{
  insert(begin(), _First, _Last);
  } if (0) {
  _Tidy();
          ;
  }}
  }

           void _Construct_n(size_type _Count,
  const _Ty& _Val)
  {
  {{
  _Insert_n(_Unchecked_begin(), _Count, _Val);
  } if (0) {
  _Tidy();
          ;
  }}
  }

 list(_Myt&& _Right)
  : _Mybase(::std:: move(_Right._Getal()))
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 list(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

           _Myt& operator=(_Myt&& _Right)

  {
  if (this != &_Right)
   {
   clear();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());
   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

           void _Assign_rv(_Myt&& _Right)
  {
  this->_Swap_all(_Right);
  _Swap_adl(this->_Myhead, _Right._Myhead);
  ::std:: swap(this->_Mysize, _Right._Mysize);
  }

 void push_front(_Ty&& _Val)
  {
  _Insert(_Unchecked_begin(), ::std:: forward<_Ty>(_Val));
  }

 void push_back(_Ty&& _Val)
  {
  _Insert(_Unchecked_end(), ::std:: forward<_Ty>(_Val));
  }

 iterator insert(const_iterator _Where, _Ty&& _Val)
  {
  return (emplace(_Where, ::std:: forward<_Ty>(_Val)));
  }

 template<class... _Valty>
  reference
  emplace_front(_Valty&&... _Val)
  {
  _Insert(_Unchecked_begin(), ::std:: forward<_Valty>(_Val)...);
  return (front());
  }

 template<class... _Valty>
  reference
  emplace_back(_Valty&&... _Val)
  {
  _Insert(_Unchecked_end(), ::std:: forward<_Valty>(_Val)...);
  return (back());
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {





  _Insert(_Where._Unchecked(), ::std:: forward<_Valty>(_Val)...);
  return (_Make_iter(--_Where));
  }

 template<class... _Valty>
            void _Insert(_Unchecked_const_iterator _Where,
  _Valty&&... _Val)
  {
  _Nodeptr _Pnode = _Where._Mynode();
  _Nodeptr _Newnode =
   this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
    ::std:: forward<_Valty>(_Val)...);
  _Incsize(1);
  this->_Prevnode(_Pnode) = _Newnode;
  this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
  }

 void _Insert(_Nodeptr _Ptr)
  {
  _Nodeptr _Pnode = _Unchecked_begin()._Mynode();
  _Nodeptr _Newnode = this->_Buynode0(_Pnode, this->_Prevnode(_Pnode),
     _Ptr);
  _Incsize(1);
  this->_Prevnode(_Pnode) = _Newnode;
  this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
  }

 list(::std:: initializer_list<_Ty> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  insert(begin(), _Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Ty> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<_Ty> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Ty> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~list() noexcept
  {
  _Tidy();
  }

           _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    clear();
    this->_Copy_alloc(_Right._Getal());
    }
   assign(_Right.begin(), _Right.end());
   }
  return (*this);
  }

 iterator begin() noexcept
  {
  return (iterator(this->_Nextnode(this->_Myhead), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(this->_Nextnode(this->_Myhead), this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Myhead, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Myhead, this));
  }

 _Unchecked_iterator _Unchecked_begin()
  {
  return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
   this));
  }

 _Unchecked_const_iterator _Unchecked_begin() const
  {
  return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
   this));
  }

 _Unchecked_iterator _Unchecked_end()
  {
  return (_Unchecked_iterator(this->_Myhead, this));
  }

 _Unchecked_const_iterator _Unchecked_end() const
  {
  return (_Unchecked_const_iterator(this->_Myhead, this));
  }

 iterator _Make_iter(const_iterator _Where) const noexcept
  {
  return (iterator(_Where._Ptr, this));
  }

 iterator _Make_iter(_Unchecked_const_iterator _Where) const
  {
  return (iterator(_Where._Ptr, this));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

           void resize(size_type _Newsize)
  {
  if (this->_Mysize < _Newsize)
   {
   size_type _Count = 0;
   {{
   for (; this->_Mysize < _Newsize; ++_Count)
    _Insert(_Unchecked_end());
   } if (0) {
   for (; 0 < _Count; --_Count)
    pop_back();
           ;
   }}
   }
  else
   while (_Newsize < this->_Mysize)
    pop_back();
  }

           void resize(size_type _Newsize, const _Ty& _Val)
  {
  if (this->_Mysize < _Newsize)
   _Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
  else
   while (_Newsize < this->_Mysize)
    pop_back();
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  return (this->_Getal().max_size());
  }

 bool empty() const noexcept
  {
  return (this->_Mysize == 0);
  }

 allocator_type get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(--end()));
  }

 const_reference back() const
  {
  return (*(--end()));
  }

 void push_front(const _Ty& _Val)
  {
  _Insert(_Unchecked_begin(), _Val);
  }

 void pop_front()
  {
  erase(begin());
  }

 void push_back(const _Ty& _Val)
  {
  _Insert(_Unchecked_end(), _Val);
  }

 void pop_back()
  {
  erase(--end());
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
            void assign(_Iter _First, _Iter _Last)
  {
  iterator _Old = begin();
  {{
  for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
   _Reusenode(_Old, *_First);
  for (; _First != _Last; ++_First)
   _Insert(_Unchecked_end(), *_First);
  } if (0) {
  clear();
          ;
  }}
  erase(_Old, end());
  }

 template<class _TArg>
            void _Reusenode(iterator _Where, _TArg&& _Arg)
  {
  {{
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Where._Ptr)));
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Where._Ptr)),
   ::std:: forward<_TArg>(_Arg));
  } if (0) {
  _Unlinknode(_Where);
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Where._Ptr)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Where._Ptr)));
  this->_Getal().deallocate(_Where._Ptr, 1);
          ;
  }}
  }

 void assign(size_type _Count, const _Ty& _Val)
  {
  clear();
  _Insert_n(_Unchecked_begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const _Ty& _Val)
  {





  _Insert(_Where._Unchecked(), _Val);
  return (_Make_iter(--_Where));
  }

           iterator insert(const_iterator _Where,
  size_type _Count, const _Ty& _Val)
  {





  iterator _Prev = _Make_iter(_Where);
  if (_Prev == begin())
   {
   _Insert_n(_Where._Unchecked(), _Count, _Val);
   return (begin());
   }
  else
   {
   --_Prev;
   _Insert_n(_Where._Unchecked(), _Count, _Val);
   return (++_Prev);
   }
  }

 template<class _Iter,
  class = enable_if_t<_Is_iterator<_Iter>::value,
   void> >
            iterator insert(const_iterator _Where,
   _Iter _First, _Iter _Last)
  {





  iterator _Prev = _Make_iter(_Where);
  if (_Prev == begin())
   {
   _Insert_range(_Where._Unchecked(), _First, _Last,
    _Iter_cat(_First));
   return (begin());
   }
  else
   {
   --_Prev;
   _Insert_range(_Where._Unchecked(), _First, _Last,
    _Iter_cat(_First));
   return (++_Prev);
   }
  }

 template<class _Iter>
            void _Insert_range(_Unchecked_const_iterator _Where,
   _Iter _First, _Iter _Last, input_iterator_tag)
  {
  size_type _Num = 0;

  {{
  for (; _First != _Last; ++_First, (void)++_Num)
   _Insert(_Where, *_First);
  } if (0) {
  for (; 0 < _Num; --_Num)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

 template<class _Iter>
            void _Insert_range(_Unchecked_const_iterator _Where,
   _Iter _First, _Iter _Last, forward_iterator_tag)
  {
                             ;
  _Iter _Next = _First;

  {{
  for (; _First != _Last; ++_First)
   _Insert(_Where, *_First);
  } if (0) {
  for (; _Next != _First; ++_Next)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

           _Nodeptr _Unlinknode(const_iterator _Where)
  {
# 1533 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  _Nodeptr _Pnode = (_Where)._Mynode();


  if (_Pnode != this->_Myhead)
   {
   this->_Nextnode(this->_Prevnode(_Pnode)) =
    this->_Nextnode(_Pnode);
   this->_Prevnode(this->_Nextnode(_Pnode)) =
    this->_Prevnode(_Pnode);

   --this->_Mysize;
   }
  return (_Pnode);
  }

           iterator erase(const_iterator _Where,
  bool _Keep = false)
  {
  _Nodeptr _Pnode = _Unlinknode(_Where++);
  if (!_Keep)
   if (_Pnode != this->_Myhead)
    this->_Freenode(_Pnode);
  return (_Make_iter(_Where));
  }

           void _Unchecked_erase(_Unchecked_const_iterator _Where)
  {
  _Nodeptr _Pnode = _Where._Mynode();

  if (_Pnode != this->_Myhead)
   {
   this->_Nextnode(this->_Prevnode(_Pnode)) =
    this->_Nextnode(_Pnode);
   this->_Prevnode(this->_Nextnode(_Pnode)) =
    this->_Prevnode(_Pnode);
   this->_Freenode(_Pnode);
   --this->_Mysize;
   }
  }

           iterator erase(const_iterator _First, const_iterator _Last)
  {
  if (_First == begin() && _Last == end())
   {
   clear();
   return (end());
   }
  else
   {
   while (_First != _Last)
    _First = erase(_First);
   return (_Make_iter(_Last));
   }
  }

           void clear() noexcept
  {




  _Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
  this->_Nextnode(this->_Myhead) = this->_Myhead;
  this->_Prevnode(this->_Myhead) = this->_Myhead;
  this->_Mysize = 0;

  for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
   {
   _Pnext = this->_Nextnode(_Pnode);
   this->_Freenode(_Pnode);
   }
  }

           void swap(_Myt& _Right)

  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else





   ::std:: terminate();

  }

 void splice(const_iterator _Where, _Myt& _Right)
  {
  if (this != ::std:: addressof(_Right) && !_Right.empty())
   {
   _Splice(_Where, _Right, _Right.begin(), _Right.end(),
    _Right._Mysize);
   }
  }

 void splice(const_iterator _Where, _Myt&& _Right)
  {
  splice(_Where, (_Myt&)_Right);
  }

           void splice(const_iterator _Where, _Myt& _Right,
  const_iterator _First)
  {






  if (_First != _Right.end())


   {
   const_iterator _Last = _First;
   ++_Last;
   if (this != ::std:: addressof(_Right)
    || (_Where != _First && _Where != _Last))
    _Splice(_Where, _Right, _First, _Last, 1);
   }
  }

 void splice(const_iterator _Where, _Myt&& _Right,
  const_iterator _First)
  {
  splice(_Where, (_Myt&)_Right, _First);
  }

           void splice(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last)
  {
  if (_First != _Last && (this != ::std:: addressof(_Right) || _Where != _Last))
   {
   size_type _Count = 0;

   if (this == ::std:: addressof(_Right))
    ;
   else if (_First == _Right.begin() && _Last == _Right.end())
    _Count = _Right._Mysize;
   else
    {
    const_iterator _Next = _First;

    for (; _Next != _Last; ++_Next, (void)++_Count)
     if (_Next == _Right.end())
      _Xlength_error("list<T> bad splice");
    }
   _Splice(_Where, _Right, _First, _Last, _Count);
   }
  }

 void splice(const_iterator _Where,
  _Myt&& _Right, const_iterator _First, const_iterator _Last)
  {
  splice(_Where, (_Myt&)_Right, _First, _Last);
  }

           void remove(const _Ty& _Val)
  {
  iterator _Val_it = end();

  for (iterator _First = begin(); _First != end(); )
   if (*_First == _Val)
    if (::std:: addressof(*_First) == ::std:: addressof(_Val))
     _Val_it = _First++;
    else
     _First = erase(_First);
   else
    ++_First;

  if (_Val_it != end())
   erase(_Val_it);
  }

 template<class _Pr1>
            void remove_if(_Pr1 _Pred)
  {
  for (iterator _First = begin(); _First != end(); )
   if (_Pred(*_First))
    _First = erase(_First);
   else
    ++_First;
  }

 void unique()
  {
  unique(equal_to<>());
  }

 template<class _Pr2>
            void unique(_Pr2 _Pred)
  {
  const _Nodeptr _Phead = this->_Myhead;
  _Nodeptr _Pprev = this->_Nextnode(_Phead);
  _Nodeptr _Pnode = this->_Nextnode(_Pprev);

  while (_Pnode != _Phead)
   if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
    {
    const _Nodeptr _Perase = _Pnode;
    _Pnode = this->_Nextnode(_Pnode);

    this->_Nextnode(_Pprev) = _Pnode;
    this->_Prevnode(_Pnode) = _Pprev;
    this->_Freenode(_Perase);

    --this->_Mysize;
    }
   else
    {
    _Pprev = _Pnode;
    _Pnode = this->_Nextnode(_Pnode);
    }
  }

 void merge(_Myt& _Right)
  {
  merge(_Right, less<>());
  }

 void merge(_Myt&& _Right)
  {
  merge((_Myt&)_Right);
  }

 template<class _Pr2>
            void merge(_Myt& _Right, _Pr2 _Pred)
  {
  if (::std:: addressof(_Right) != this)
   {
   iterator _First1 = begin(), _Last1 = end();
   iterator _First2 = _Right.begin(), _Last2 = _Right.end();
                                            ;
                                            ;

   while (_First1 != _Last1 && _First2 != _Last2)
    if (_Pred(*_First2, *_First1))
     {
     iterator _Mid2 = _First2;
     _Splice(_First1, _Right, _First2, ++_Mid2, 1);
     _First2 = _Mid2;
     }
    else
     ++_First1;

   if (_First2 != _Last2)
    _Splice(_Last1, _Right, _First2, _Last2,
     _Right._Mysize);
   }
  }

 template<class _Pr2>
  void merge(_Myt&& _Right, _Pr2 _Pred)
  {
  merge((_Myt&)_Right, _Pred);
  }

 void sort()
  {
  sort(less<>());
  }

 template<class _Pr2>
            void sort(_Pr2 _Pred)
  {
  _Sort(begin(), end(), _Pred, this->_Mysize);
  }

 template<class _Pr2>
  iterator _Sort(iterator _First, iterator _Last, _Pr2 _Pred,
   size_type _Size)
  {

  if (_Size < 2)
   return (_First);

  iterator _Mid = ::std:: next(_First, _Size / 2);
  _First = _Sort(_First, _Mid, _Pred, _Size / 2);
  _Mid = _Sort(_Mid, _Last, _Pred, _Size - _Size / 2);
  iterator _Newfirst = _First;

  for (bool _Initial_loop = true; ; _Initial_loop = false)
   {
   if (_Pred(*_Mid, *_First))
    {
    if (_Initial_loop)
     _Newfirst = _Mid;
    splice(_First, *this, _Mid++);
    if (_Mid == _Last)
     return (_Newfirst);
    }
   else
    {
    ++_First;
    if (_First == _Mid)
     return (_Newfirst);
    }
   }
  }

           void reverse() noexcept
  {
  const _Nodeptr _Phead = this->_Myhead;
  _Nodeptr _Pnode = _Phead;

  for (; ; )
   {
   const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
   this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
   this->_Prevnode(_Pnode) = _Pnext;

   if (_Pnext == _Phead)
    break;
   _Pnode = _Pnext;
   }
  }

           void _Splice(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last,
  size_type _Count)
  {
# 1924 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
  if (this->_Getal() != _Right._Getal())
   ::std:: terminate();


  _Splice_same(_Where, _Right, _First, _Last, _Count);
  }

           void _Splice_same(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last,
  size_type _Count)
  {
  if (this != ::std:: addressof(_Right))
   {
   _Incsize(_Count);
   _Right._Mysize -= _Count;
   }
  this->_Nextnode(this->_Prevnode(_First._Mynode())) =
   _Last._Mynode();
  this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
   _Where._Mynode();
  this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
   _First._Mynode();

  _Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
  this->_Prevnode(_Where._Mynode()) =
   this->_Prevnode(_Last._Mynode());
  this->_Prevnode(_Last._Mynode()) =
   this->_Prevnode(_First._Mynode());
  this->_Prevnode(_First._Mynode()) = _Pnode;
  }

           void _Unchecked_splice(_Unchecked_const_iterator _Where,
  _Unchecked_const_iterator _First,
  _Unchecked_const_iterator _Last)
  {
  this->_Nextnode(this->_Prevnode(_First._Mynode())) =
   _Last._Mynode();
  this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
   _Where._Mynode();
  this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
   _First._Mynode();

  _Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
  this->_Prevnode(_Where._Mynode()) =
   this->_Prevnode(_Last._Mynode());
  this->_Prevnode(_Last._Mynode()) =
   this->_Prevnode(_First._Mynode());
  this->_Prevnode(_First._Mynode()) = _Pnode;
  }

 void _Tidy()
  {
  clear();
  }

           void _Insert_n(_Unchecked_const_iterator _Where,
  size_type _Count, const _Ty& _Val)
  {
  size_type _Countsave = _Count;

  {{
  for (; 0 < _Count; --_Count)
   _Insert(_Where, _Val);
  } if (0) {
  for (; _Count < _Countsave; ++_Count)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
          ;
  }}
  }

 void _Incsize(size_type _Count)
  {
  if (max_size() - this->_Mysize - 1 < _Count)
   _Xlength_error("list<T> too long");
  this->_Mysize += _Count;
  }
# 2023 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
 };
# 2038 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
template<class _Ty,
 class _Alloc> inline
 void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator==(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator!=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }
# 2122 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\list" 3
}
# 7 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/../Managed/MemoryBufferManaged.h" 2

namespace SaveData
{


 enum class BufferIntegrityChecks
 {
  BufferBegin = 0,
  BufferEnd,

  PNGBegin,
  PNGEnd,
 };

 struct MemoryBufferManaged
 {
  UInt32 length;
  void* data;
 };

 class MemoryBuffer
 {
  const static Int32 MAX_BUFFER_SIZE = 1024*1024;

  void* data;
  UInt32 defaultBufferSize;
  UInt32 maxBufferSize;
  char* pos;

  static MemoryBuffer* s_MemoryBuffer;
  static MemoryBuffer* s_NotificationBuffer;

 public:

  void CopyTo(MemoryBufferManaged* destination);

  MemoryBuffer(UInt32 defaultSize);

  static void Initialise();
  static void Shutdown();
  static MemoryBuffer& GetBuffer();
  static MemoryBuffer& GetNotificationBuffer();

  void StartResponseWrite();
  void FinishResponseWrite();

  void Reset();

  void WriteMarker(BufferIntegrityChecks value);

  void WriteBool(bool value);

  void WriteInt8(Int8 value);
  void WriteUInt8(UInt8 value);

  void WriteInt16(Int16 value);
  void WriteUInt16(UInt16 value);

  void WriteInt32(Int32 value);
  void WriteUInt32(UInt32 value);

  void WriteInt64(Int64 value);
  void WriteUInt64(UInt64 value);

  void WritePtr(void* ptr);

  void WriteDouble(double value);

  void WriteData(const char* data, UInt32 size);

  void WriteString(const char* str);
  void WriteString(const char* str, UInt32 size);

 private:
  void GrowBuffer(size_t requiredSize);
 };


}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/../Managed/ManagedResponse.h" 2

namespace SaveData
{
 class ResponseBase
 {
 public:
  static void MarshalResponseBase(int returnCode, MemoryBuffer& buffer);
 };






}
# 27 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling/../Includes/PluginCommonIncludes.h" 2
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling\\ErrorCodes.cpp" 2



namespace SaveData
{
 const char* LookupSceErrorCode(int errorCode)
 {
  const char* errorString = __null;

  switch(errorCode)
  {


  default:
   break;
  }

  return errorString;
 }

}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/ErrorHandling\\Errors.cpp" 1




namespace SaveData
{


 void APIResult::SetResult(APIResult* result, APIResultTypes type)
 {
  result->apiResult = type;
  result->message = "";
  result->filename = "";
  result->lineNumber = 0;
  result->sceErrorCode = 0;
 }

 void APIResult::SetResult(APIResult* result, APIResultTypes type, char const * message, char const * filename, int lineNumber)
 {
  result->apiResult = type;
  result->message = message;
  result->filename = filename;
  result->lineNumber = lineNumber;
  result->sceErrorCode = 0;
 }

 void APIResult::SetSceResult(APIResult* result, APIResultTypes type, int sceErrorCode, char const * filename, int lineNumber)
 {
  char const* message = LookupSceErrorCode(sceErrorCode);

  result->apiResult = type;

  if ( message == 0)
  {
   result->message = "";
  }
  else
  {
   result->message = message;
  }
  result->filename = filename;
  result->lineNumber = lineNumber;
  result->sceErrorCode = sceErrorCode;
 }
}
# 4 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Managed\\ManagedRequest.cpp" 1



namespace SaveData
{

}
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Managed\\ManagedResponse.cpp" 1


namespace SaveData
{
 void ResponseBase::MarshalResponseBase(int returnCode, MemoryBuffer& buffer)
 {
  buffer.WriteInt32(returnCode);
 }
}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Managed\\MemoryBufferManaged.cpp" 1


namespace SaveData
{
 MemoryBuffer* MemoryBuffer::s_MemoryBuffer;
 MemoryBuffer* MemoryBuffer::s_NotificationBuffer;


 void MemoryBuffer::Initialise()
 {
  s_MemoryBuffer = new MemoryBuffer(MAX_BUFFER_SIZE);
  s_NotificationBuffer = new MemoryBuffer(MAX_BUFFER_SIZE);
 }

 void MemoryBuffer::Shutdown()
 {
  delete s_MemoryBuffer;
 }


 MemoryBuffer& MemoryBuffer::GetBuffer()
 {
  return *s_MemoryBuffer;
 }

 MemoryBuffer& MemoryBuffer::GetNotificationBuffer()
 {
  return *s_NotificationBuffer;
 }


 void MemoryBuffer::StartResponseWrite()
 {
  Reset();
  WriteMarker(BufferIntegrityChecks::BufferBegin);
 }

 void MemoryBuffer::FinishResponseWrite()
 {
  WriteMarker(BufferIntegrityChecks::BufferEnd);
 }

 MemoryBuffer::MemoryBuffer(UInt32 defaultSize)
 {
  defaultBufferSize = defaultSize;
  maxBufferSize = defaultBufferSize;
  data = new char[maxBufferSize];
 }

 void MemoryBuffer::Reset()
 {
  if (maxBufferSize != defaultBufferSize)
  {

   delete (char*)data;
   maxBufferSize = defaultBufferSize;
   data = new char[maxBufferSize];
  }

  pos = (char*)data;
 }

 void MemoryBuffer::CopyTo(MemoryBufferManaged* destination)
 {
  destination->data = data;
  destination->length = pos - (char*)data;
 }



 void MemoryBuffer::WriteMarker(BufferIntegrityChecks value)
 {
  GrowBuffer(4);

  *((char*)pos) = (unsigned char)255; pos += 1;
  *((char*)pos) = (unsigned char)254; pos += 1;
  *((char*)pos) = (unsigned char)253; pos += 1;

  *((char*)pos) = (char)value;
  pos += 1;
 }


 void MemoryBuffer::WriteBool(bool value)
 {
  GrowBuffer(1);

  if ( value == false ) *((char*)pos) = 0;
  else *((char*)pos) = 1;

  pos += 1;
 }

 void MemoryBuffer::WriteInt8(Int8 value)
 {
  GrowBuffer(sizeof(Int8));
  *((Int8*)pos) = value;
  pos += sizeof(Int8);
 }

 void MemoryBuffer::WriteUInt8(UInt8 value)
 {
  GrowBuffer(sizeof(UInt8));
  *((UInt8*)pos) = value;
  pos += sizeof(UInt8);
 }

 void MemoryBuffer::WriteInt16(Int16 value)
 {
  GrowBuffer(sizeof(Int16));
  *((Int16*)pos) = value;
  pos += sizeof(Int16);
 }

 void MemoryBuffer::WriteUInt16(UInt16 value)
 {
  GrowBuffer(sizeof(UInt16));
  *((UInt16*)pos) = value;
  pos += sizeof(UInt16);
 }

 void MemoryBuffer::WriteInt32(Int32 value)
 {
  GrowBuffer(sizeof(Int32));
  *((Int32*)pos) = value;
  pos += sizeof(Int32);
 }

 void MemoryBuffer::WriteUInt32(UInt32 value)
 {
  GrowBuffer(sizeof(UInt32));
  *((UInt32*)pos) = value;
  pos += sizeof(UInt32);
 }

 void MemoryBuffer::WriteInt64(Int64 value)
 {
  GrowBuffer(sizeof(UInt64));
  *((Int64*)pos) = value;
  pos += sizeof(Int64);
 }

 void MemoryBuffer::WriteUInt64(UInt64 value)
 {
  GrowBuffer(sizeof(UInt64));
  *((UInt64*)pos) = value;
  pos += sizeof(UInt64);
 }

 void MemoryBuffer::WritePtr(void* ptr)
 {
  GrowBuffer(sizeof(void*));

  *((UInt64*)pos) = (UInt64)ptr;
  pos += sizeof(void*);
 }

 void MemoryBuffer::WriteDouble(double value)
 {
  GrowBuffer(sizeof(double));
  *((double*)pos) = value;
  pos += sizeof(double);
 }

 void MemoryBuffer::WriteString(const char* str)
 {
  UInt32 strLen = strlen(str);

  WriteData(str, strLen);
 }

 void MemoryBuffer::WriteString(const char* str, UInt32 size)
 {
  WriteData(str, size);
 }

 void MemoryBuffer::WriteData(const char* data, UInt32 size)
 {
  GrowBuffer(size + sizeof(UInt32));

  *((UInt32*)pos) = size;
  pos += sizeof(UInt32);
  memcpy(pos, data, size);
  pos += size;
 }

 void MemoryBuffer::GrowBuffer(size_t requiredSize)
 {
  int sizeUsed = pos - (char*)data;
  if ( sizeUsed + requiredSize > maxBufferSize )
  {

   while (maxBufferSize < sizeUsed + requiredSize)
   {
    maxBufferSize *= 2;
   }
   void* extendedData = new char[maxBufferSize];
   memcpy(extendedData, data, sizeUsed);

   delete (char*)data;
   data = extendedData;


   pos = ((char*)data) + sizeUsed;
  }
 }

}
# 7 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/PlayerInterface\\UnityPrxPlugin.cpp" 1

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/PlayerInterface\\UnityPrxPlugin.cpp" 2
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 1 3
# 4 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/PlayerInterface\\UnityPrxPlugin.cpp" 2
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\istream" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\istream" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ios" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ios" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocnum" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocnum" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\typeinfo" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\typeinfo" 3
namespace std {

class bad_cast
 : public ::std:: exception
 {
public:
 bad_cast() noexcept
  {}

 virtual ~bad_cast() noexcept;





 virtual const char *what() const noexcept
  {
  return ("std::bad_cast");
  }






protected:
 virtual void _Doraise() const;

 };


class bad_typeid
 : public ::std:: exception
 {
public:
 bad_typeid() noexcept
  {}

 virtual ~bad_typeid() noexcept;





 virtual const char *what() const noexcept
  {
  return ("std::bad_typeid");
  }






protected:
 virtual void _Doraise() const;

 };
}




namespace __cxxabiv1
 {
 class __class_type_info;
 }


namespace std {





class type_info
 {
public:
 size_t hash_code() const noexcept
  {
  return (::std:: _Hash_seq((const unsigned char *)name(),
   :: strlen(name())));
  }

 virtual ~type_info() noexcept;
# 143 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\typeinfo" 3
 bool before(const type_info& _Right) const noexcept
  {
  return (strcmp(_Myname, _Right._Myname) < 0);
  }

 bool operator==(const type_info& _Right) const noexcept
  {
  return (_Myname == _Right._Myname
   || strcmp(_Myname, _Right._Myname) == 0);
  }


 bool operator!=(const type_info& _Right) const noexcept
  {
  return (!(*this == _Right));
  }

 const char *name() const
  {
  return (_Myname);
  }
# 173 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\typeinfo" 3
protected:
 explicit type_info(const char *_Name)
  : _Myname(_Name)
  {}
 const char *_Myname;


public:
 type_info(const type_info&) = delete;
 type_info& operator=(const type_info&) = delete;
 };
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cctype" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cctype" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cctype" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 2 3
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 3
extern "C" {
typedef const short *_Ctype_t;

_Ctype_t _Getpctype(void);
_Ctype_t _Getptolower(void);
_Ctype_t _Getptoupper(void);
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctype.h" 3
}



extern "C" {
inline int isalnum(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x20|0x10|0x02|0x200));
 }

inline int isalpha(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x10|0x02|0x200));
 }

inline int iscntrl(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x80);
 }

inline int isdigit(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x20);
 }

inline int isgraph(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x20|0x10|0x08|0x02|0x200));
 }

inline int islower(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x10);
 }

inline int isprint(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x20|0x10|0x08|0x04|0x02|0x200));
 }

inline int ispunct(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x08);
 }

inline int _Isspace(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x40|0x04|0x100));
 }

inline int isspace(int _Ch)
 {
 return (_Isspace(_Ch));
 }

inline int isupper(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x02);
 }

inline int isxdigit(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & 0x01);
 }


inline int isblank(int _Ch)
 {
 return (__extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getpctype()[_Tmp] : 0; }) & (0x04|0x400));
 }


inline int tolower(int _Ch)
 {
 return __extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getptolower()[_Tmp] : _Tmp; });
 }

inline int toupper(int _Ch)
 {
 return __extension__ ({ int _Tmp = (int)(_Ch); ((0x00 <= _Tmp) && (_Tmp <= 0x7f)) ? _Getptoupper()[_Tmp] : _Tmp; });
 }
}
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cctype" 2 3



namespace std {
using :: isalnum; using :: isalpha; using :: iscntrl;
using :: isdigit; using :: isgraph; using :: islower;
using :: isprint; using :: ispunct; using :: isspace;
using :: isupper; using :: isxdigit; using :: tolower;
using :: toupper; using :: _Isspace;

using :: isblank;







}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\clocale" 1 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 5 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\clocale" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\locale.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\locale.h" 2 3
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\locale.h" 3
struct lconv
 {

 char *currency_symbol;
 char *int_curr_symbol;
 char *mon_decimal_point;
 char *mon_grouping;
 char *mon_thousands_sep;
 char *negative_sign;
 char *positive_sign;

 char frac_digits;
 char n_cs_precedes;
 char n_sep_by_space;
 char n_sign_posn;
 char p_cs_precedes;
 char p_sep_by_space;
 char p_sign_posn;

 char int_frac_digits;

 char int_n_cs_precedes;
 char int_n_sep_by_space;
 char int_n_sign_posn;
 char int_p_cs_precedes;
 char int_p_sep_by_space;
 char int_p_sign_posn;
 short :16;



 char *decimal_point;
 char *grouping;
 char *thousands_sep;
 char *_Frac_grouping;
 char *_Frac_sep;
 char *_False;
 char *_True;


 char *_No;
 char *_Yes;
 };

struct _Linfo;


extern "C" {
struct lconv *localeconv(void);
char *setlocale(int, const char *);
extern struct lconv __thread _Locale;
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\clocale" 2 3



namespace std {
using :: lconv; using :: localeconv; using :: setlocale;
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3


# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 2 3
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 32 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 2 3
# 108 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 3
namespace std {
using :: clock_t; using :: size_t;
using :: time_t; using :: tm;
using :: asctime; using :: clock; using :: ctime;
using :: timespec;
# 123 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ctime" 3
using :: difftime; using :: gmtime; using :: localtime;


using :: mktime; using :: strftime; using :: time;
using :: timespec_get;
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstrxfrm.h" 1 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstate.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstate.h" 2 3
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstate.h" 3
typedef struct
 {
 const unsigned short *_Tab[16];
 } _Statab;
# 6 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xstrxfrm.h" 2 3


typedef struct Xfrm {
 const unsigned char *sbegin;
 const unsigned char *sin;
 const unsigned char *send;
 long weight;
 unsigned short phase, state, wc;
 } Xfrm;


extern "C" {
int _Strcollx(const char *, const char *, _Statab *);
size_t _Strxfrmx(char *, const char *, size_t, _Statab *);

size_t _CStrxfrm(char *, size_t, Xfrm *, _Statab *);
}
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtinfo.h" 1 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\time.h" 1 3
# 9 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtinfo.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtinfo.h" 2 3



typedef struct
 {
 const char *_Am_pm;
 const char *_Days;
  const char *_Abday;
  const char *_Day;
 const char *_Months;
  const char *_Abmon;
  const char *_Mon;
 const char *_Formats;
  const char *_D_t_fmt;
  const char *_D_fmt;
  const char *_T_fmt;
  const char *_T_fmt_ampm;
 const char *_Era_Formats;
  const char *_Era_D_t_fmt;
  const char *_Era_D_fmt;
  const char *_Era_T_fmt;
  const char *_Era_T_fmt_ampm;
 const char *_Era;
 const char *_Alt_digits;
 const char *_Isdst;
 const char *_Tzone;
 } _Tinfo;


extern "C" {
size_t _CStrftime(char *, size_t, const char *,
 const struct tm *, const _Tinfo *);
_Tinfo *_Getptimes(void);
}
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcsxfrm.h" 1 3




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwchar.h" 1 3



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wchar.h" 1 3
# 5 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwchar.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 2 3
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 3
typedef _Sizet wctrans_t;




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcc.h" 1 3




extern "C" {
int _Iswctype(wint_t, wctype_t);
wint_t _Towctrans(wint_t, wctrans_t);

}



extern "C" {
inline int iswalnum(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 1));
 }

inline int iswalpha(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 2));
 }

inline int iswcntrl(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 3));
 }

inline int iswctype(wint_t _Wc, wctype_t _Off)
 {
 return (_Iswctype(_Wc, _Off));
 }

inline int iswdigit(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 4));
 }

inline int iswgraph(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 5));
 }

inline int iswlower(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 6));
 }

inline int iswprint(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 7));
 }

inline int iswpunct(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 8));
 }

inline int iswspace(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 9));
 }

inline int iswupper(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 10));
 }

inline int iswxdigit(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 11));
 }

inline wint_t towlower(wint_t _Wc)
 {
 return (_Towctrans(_Wc, 1));
 }

inline wint_t towupper(wint_t _Wc)
 {
 return (_Towctrans(_Wc, 2));
 }


inline int iswblank(wint_t _Wc)
 {
 return (_Iswctype(_Wc, 12));
 }


}
# 33 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\wctype.h" 2 3

extern "C" {
wctrans_t wctrans(const char *);
wctype_t wctype(const char *);
}



extern "C" {
inline wint_t (towctrans)(wint_t _Wc, wctrans_t _Off)
 {
 return (_Towctrans(_Wc, _Off));
 }
}
# 6 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwchar.h" 2 3



extern "C" {

int _Mbtowc(wchar_t *, const char *, size_t, mbstate_t *);
size_t _Wcsftime(wchar_t *, size_t, const char *, size_t,
 const struct tm *);
int _Wctomb(char *, wchar_t, mbstate_t *);
long double _WStold(const wchar_t *, wchar_t **, long);
_Longlong _WStoll(const wchar_t *, wchar_t **, int);
unsigned long _WStoul(const wchar_t *, wchar_t **, int);
_ULonglong _WStoull(const wchar_t *, wchar_t **, int);

int _Mbtowcx(wchar_t *, const char *, size_t, mbstate_t *,
 _Statab *);
int _Wctombx(char *, wchar_t, mbstate_t *,
 _Statab *, _Statab *);

_Statab *_Getpmbstate(void);
_Statab *_Getpwcstate(void);
_Statab *_Getpcostate(void);
_Statab *_Getpwcostate(void);
}
# 6 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xwcsxfrm.h" 2 3


extern "C" {
int _Wcscollx(const wchar_t *,
 const wchar_t *, _Statab *);
size_t _Wcsxfrmx(wchar_t *,
 const wchar_t *, size_t, _Statab *);

size_t _CWcsxfrm(wchar_t *, const wchar_t **, size_t,
 mbstate_t *, _Statab *);
}
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 2 3
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 3
namespace std {
# 44 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocinfo" 3
struct _Collvec
 {
 :: _Statab *_Costate;
 :: _Statab *_WCostate;
 };


struct _Ctypevec
 {
 const short *_Table;
 const short *_Tolotab;
 const short *_Touptab;
 int _Delfl;
 int :32;
 };


struct _Cvtvec
 {
 :: _Statab *_Mbstate;
 :: _Statab *_Wcstate;
 };


class _Timevec
 {
public:
 _Timevec()
  : _Timestuff(*:: _Getptimes())
  {
  }

 const void *_Getptr() const
  {
  return ((const void *)&_Timestuff);
  }

private:
 :: _Tinfo _Timestuff;
 };


class _Locinfo
 {
public:
 typedef ::std:: _Collvec _Collvec;
 typedef ::std:: _Ctypevec _Ctypevec;
 typedef ::std:: _Cvtvec _Cvtvec;
 typedef ::std:: _Timevec _Timevec;

 _Locinfo(const char * = "C");
 _Locinfo(const string&);
 _Locinfo(int, const char *);

 ~_Locinfo() noexcept;

 _Locinfo& _Addcats(int, const char *);

 const char *_Getname() const
  {

  return (_Newlocname);



  }

 _Collvec _Getcoll() const
  {
  _Collvec _X;
  _X._Costate = :: _Getpcostate();
  _X._WCostate = :: _Getpwcostate();
  return (_X);
  }

 _Ctypevec _Getctype() const
  {
  _Ctypevec _X;
  _X._Table = :: _Getpctype();
  _X._Tolotab = :: _Getptolower();
  _X._Touptab = :: _Getptoupper();
  _X._Delfl = 0;
  return (_X);
  }

 _Cvtvec _Getcvt() const
  {
  _Cvtvec _X;
  _X._Mbstate = :: _Getpmbstate();
  _X._Wcstate = :: _Getpwcstate();
  return (_X);
  }

 const lconv *_Getlconv() const
  {
  return (localeconv());
  }

 _Timevec _Gettnames() const
  {
  return (_Timeinfo);
  }

 const char *_Getdays() const
  {
  return (:: _Getptimes()->_Days);
  }

 const char *_Getmonths() const
  {
  return (:: _Getptimes()->_Months);
  }

 const char *_Getfalse() const
  {
  return (localeconv()->_False);
  }

 const char *_Gettrue() const
  {
  return (localeconv()->_True);
  }

private:

 _Timevec _Timeinfo;

 const char *_Oldlocname;
 const char *_Newlocname;




 };


template<class _Elem> inline
 int _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
  const _Elem *_First2, const _Elem *_Last2, const _Collvec *)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
  if (*_First1 < *_First2)
   return (-1);
  else if (*_First2 < *_First1)
   return (+1);

 return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
 }

template<> inline
 int _LStrcoll(const char *_First1, const char *_Last1,
  const char *_First2, const char *_Last2, const _Collvec *_Pcoll)
 {
 string _Str1, _Str2;
 size_t _Len1 = (size_t)(_Last1 - _First1);
 size_t _Len2 = (size_t)(_Last2 - _First2);

 if (0 < _Len1 && _Last1[-1] != '\0')
  {
  _Str1.assign(_First1, _Last1);
  _First1 = _Str1.c_str();
  }
 if (0 < _Len2 && _Last2[-1] != '\0')
  {
  _Str2.assign(_First2, _Last2);
  _First2 = _Str2.c_str();
  }

 int _Ans = 0;
 while (0 < _Len1 && 0 < _Len2
  && (_Ans = _Strcollx(_First1, _First2, _Pcoll->_Costate)) == 0)
  {
  size_t _Prefix = :: strlen(_First1) + 1;
  if (_Len1 <= _Prefix || _Len2 <= _Prefix)
   return (_Len1 < _Len2 ? -1 : _Len1 == _Len2 ? 0 : +1);

  _Len1 -= _Prefix, _Len2 -= _Prefix;
  _First1 += _Prefix, _First2 += _Prefix;
  }
 return (_Ans != 0 || _Len1 == _Len2 ? _Ans
  : _Len1 < _Len2 ? -1 : +1);
  }

template<> inline
 int _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
  const wchar_t *_First2, const wchar_t *_Last2, const _Collvec *_Pcoll)
 {
 wstring _Str1, _Str2;
 size_t _Len1 = (size_t)(_Last1 - _First1);
 size_t _Len2 = (size_t)(_Last2 - _First2);

 if (0 < _Len1 && _Last1[-1] != L'\0')
  {
  _Str1.assign(_First1, _Last1);
  _First1 = _Str1.c_str();
  }
 if (0 < _Len2 && _Last2[-1] != L'\0')
  {
  _Str2.assign(_First2, _Last2);
  _First2 = _Str2.c_str();
  }

 int _Ans = 0;
 while (0 < _Len1 && 0 < _Len2
  && (_Ans = _Wcscollx(_First1, _First2, _Pcoll->_WCostate)) == 0)
  {
  size_t _Prefix = :: wcslen(_First1) + 1;
  if (_Len1 <= _Prefix || _Len2 <= _Prefix)
   return (_Len1 < _Len2 ? -1 : _Len1 == _Len2 ? 0 : +1);

  _Len1 -= _Prefix, _Len2 -= _Prefix;
  _First1 += _Prefix, _First2 += _Prefix;
  }
 return (_Ans != 0 || _Len1 == _Len2 ? _Ans
  : _Len1 < _Len2 ? -1 : +1);
  }


template<class _Elem> inline
 size_t _LStrxfrm(_Elem *_First1, _Elem *_Last1,
  const _Elem *_First2, const _Elem *_Last2,
   const _Locinfo::_Collvec *)
 {
 size_t _Count = _Last2 - _First2;

 if (_Count <= (size_t)(_Last1 - _First1))
  :: memcpy(_First1, _First2, _Count * sizeof (_Elem));
 return (_Count);
 }

template<> inline
 size_t _LStrxfrm(char *_First1, char *_Last1,
  const char *_First2, const char *_Last2,
   const _Locinfo::_Collvec *_Pcoll)
 {
 string _Str2;
 size_t _Len1 = (size_t)(_Last1 - _First1);
 size_t _Len2 = (size_t)(_Last2 - _First2);

 if (0 < _Len2 && _Last2[-1] != '\0')
  {
  _Str2.assign(_First2, _Last2);
  _First2 = _Str2.c_str();
  }

 size_t _Count = 0;
 while (0 < _Len2)
  {
  size_t _Num = _Strxfrmx(_First1, _First2, _Len1,
   _Pcoll->_Costate);
  _Count += _Num;
  if (_Len1 < _Num)
   break;

  size_t _Prefix = :: strlen(_First2) + 1;
  if (_Len1 <= _Prefix)
   break;
  _Len1 -= _Num;
  _First1 += _Num;
  _First2 += _Prefix;
  }
 return (_Count);
 }

template<> inline
 size_t _LStrxfrm(wchar_t *_First1, wchar_t *_Last1,
  const wchar_t *_First2, const wchar_t *_Last2,
   const _Locinfo::_Collvec *_Pcoll)
 {
 wstring _Str2;
 size_t _Len1 = (size_t)(_Last1 - _First1);
 size_t _Len2 = (size_t)(_Last2 - _First2);

 if (0 < _Len2 && _Last2[-1] != L'\0')
  {
  _Str2.assign(_First2, _Last2);
  _First2 = _Str2.c_str();
  }

 size_t _Count = 0;
 while (0 < _Len2)
  {
  size_t _Num = _Wcsxfrmx(_First1, _First2, _Len1,
   _Pcoll->_WCostate);
  _Count += _Num;
  if (_Len1 < _Num)
   break;

  size_t _Prefix = :: wcslen(_First2) + 1;
  if (_Len1 <= _Prefix)
   break;
  _Len1 -= _Num;
  _First1 += _Num;
  _First2 += _Prefix;
  }
 return (_Count);
 }


inline int _Mbrtowc(wchar_t *_Wptr, const char *_Ptr, size_t _Count,
 mbstate_t *_Pstate, const _Cvtvec *_Pcvt)
 {
 return (:: _Mbtowcx(_Wptr, _Ptr, _Count, _Pstate,
  _Pcvt->_Mbstate));
 }


inline size_t _Strftime(char *_Ptr, size_t _Count, const char *_Format,
 const struct tm *_Ptime, const void *_Timeptr)
 {
 return (:: _CStrftime(_Ptr, _Count, _Format, _Ptime,
  (const :: _Tinfo *)_Timeptr));
 }


inline int _Tolower(int _Byte, const _Ctypevec *_Pctype)
 {
 return (_Pctype->_Tolotab[_Byte & 0xff]);
 }


inline int _Toupper(int _Byte, const _Ctypevec *_Pctype)
 {
 return (_Pctype->_Touptab[_Byte & 0xff]);
 }


inline int _Wcrtomb(char *_Ptr, wchar_t _Char,
 mbstate_t *_Pstate, const _Cvtvec *_Pcvt)
 {
 return (:: _Wctombx(_Ptr, _Char, _Pstate,
  _Pcvt->_Mbstate, _Pcvt->_Wcstate));
 }
}
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 2 3





extern "C" {
void *_Getgloballocale();
void _Setgloballocale(void *);
}


namespace std {

class _Facet_base
 {
public:
 virtual ~_Facet_base() noexcept
  {
  }

 virtual void _Incref() = 0;
 virtual _Facet_base *_Decref() = 0;
 };


template<class _Dummy>
 class _Locbase
 {
public:
 static const int collate = ((1 << (1)) >> 1);
 static const int ctype = ((1 << (2)) >> 1);
 static const int monetary = ((1 << (3)) >> 1);
 static const int numeric = ((1 << (4)) >> 1);
 static const int time = ((1 << (5)) >> 1);
 static const int messages = ((1 << (6)) >> 1);
 static const int all = (((1 << (7)) >> 1) - 1);
 static const int none = 0;
 };

template<class _Dummy>
 const int _Locbase<_Dummy>::collate;
template<class _Dummy>
 const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
 const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
 const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
 const int _Locbase<_Dummy>::time;
template<class _Dummy>
 const int _Locbase<_Dummy>::messages;
template<class _Dummy>
 const int _Locbase<_Dummy>::all;
template<class _Dummy>
 const int _Locbase<_Dummy>::none;


class locale;
template<class _Facet>
 const _Facet& use_facet(const locale&);
template<class _Elem>
 class collate;

class locale
 : public _Locbase<int>
 {
public:
 typedef int category;


 class id
  {
 public:
  id(size_t _Val = 0)
   : _Id(_Val)
   {
   }

  operator size_t()
   {
   if (_Id == 0)
    {
    {::std:: _Lockit _Lock(0);
     if (_Id == 0)
      _Id = (size_t)++_Id_cnt;
    }
    }
   return (_Id);
   }

 private:
  size_t _Id;

  static int _Id_cnt;

 public:
  id(const id&) = delete;
  id& operator=(const id&) = delete;
  };

 class _Locimp;


 class facet
  : public _Facet_base
  {
 public:
  static size_t _Getcat(const facet ** = 0,
   const locale * = 0)
   {
   return ((size_t)(-1));
   }

  void _Register();

  virtual void _Incref()
   {
   _Inc_atomic_counter_explicit(_Refs, memory_order_relaxed);
   }

  virtual _Facet_base *_Decref()
   {
   if (_Dec_atomic_counter_explicit(_Refs, memory_order_acq_rel) == 0)
    return (this);
   else
    return (0);
   }


 private:
  _Atomic_counter_t _Refs;
  int :32;

 protected:
  explicit facet(size_t _Initrefs = 0)
   {
   _Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
   }

 public:
  virtual ~facet() noexcept
   {
   }

  bool _Shared() const
   {
   return (1 < _Get_atomic_count(_Refs));
   }
# 203 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 3
 public:
  facet(const facet&) = delete;
  facet& operator=(const facet&) = delete;
  };



 class _Locimp
  : public facet
  {
 protected:
  ~_Locimp() noexcept;

 private:
  friend class locale;

  static _Locimp *_New_Locimp(bool _Transparent = false)
   {
   return (new _Locimp(_Transparent));
   }

  static _Locimp *_New_Locimp(const _Locimp& _Right)
   {
   return (new _Locimp(_Right));
   }

  _Locimp(bool _Transparent = false);

  _Locimp(const _Locimp&);

  void _Addfac(facet *, size_t);

  static _Locimp *_Makeloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  static void _Makewloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  static void _Makexloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  facet **_Facetvec;
  size_t _Facetcount;
  category _Catmask;
  bool _Xparent;


  char :8;
  short :16;
  const char *_Name;




  static _Locimp *_Clocptr;
  };

 template<class _Elem,
  class _Traits,
  class _Alloc>
  bool operator()(const basic_string<_Elem, _Traits, _Alloc>&,
   const basic_string<_Elem, _Traits, _Alloc>&)
    const;

 template<class _Facet>
  locale combine(const locale& _Loc) const
  {
  _Facet *_Facptr;

  {{
   _Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
  } if (0) {
   _Xruntime_error("locale::combine facet missing");
  }}

  _Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
  _Newimp->_Addfac(_Facptr, _Facet::id);
  _Newimp->_Catmask = none;
  _Newimp->_Name = "*";
  return (locale(_Newimp));
  }


 template<class _Facet>
  locale(const locale& _Loc, const _Facet *_Facptr)
   : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {
  if (_Facptr != 0)
   _Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
  _Ptr->_Catmask = 0;
  _Ptr->_Name = "*";
  }
# 309 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 3
 locale(_Uninitialized)
  {
  }

 locale(const locale& _Right) noexcept
  : _Ptr(_Right._Ptr)
  {
  _Ptr->_Incref();
  }

 locale() noexcept
  : _Ptr(_Init())
  {
  _Getgloballocale()->_Incref();
  }


 locale(const locale& _Loc, const locale& _Other,
  category _Cat)
  {
  if (_Loc._Ptr == _Other._Ptr)
   {
   _Ptr = _Loc._Ptr;
   _Ptr->_Incref();
   }
  else
   {
   _Ptr = _Locimp::_New_Locimp(*_Loc._Ptr);
   {{
   {::std:: _Lockit _Lock(0); _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name);
    _Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
     _Other._Ptr->_Name), _Cat, _Ptr, &_Other);
   }
   } if (0) {
   delete _Ptr->_Decref();
           ;
   }}
   }
  }

 explicit locale(const char *_Locname,
  category _Cat = all)
  {
  if (_Locname == __null
   || (:: strcmp(_Locname, "C") != 0
    && :: strcmp(_Locname, "") != 0))
   _Xruntime_error("bad locale name");

  _Ptr = classic()._Ptr;
  _Ptr->_Incref();
  }

 locale(const locale& _Loc, const char *_Locname,
  category _Cat)
  {
  if (_Locname == __null
   || (:: strcmp(_Locname, "C") != 0
    && :: strcmp(_Locname, "") != 0))
   _Xruntime_error("bad locale name");

  if (_Loc._Ptr == classic()._Ptr)
   {
   _Ptr = classic()._Ptr;
   _Ptr->_Incref();
   }
  else
   {
   _Ptr = _Locimp::_New_Locimp(*_Loc._Ptr);
   {{
   {::std:: _Lockit _Lock(0); _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name);
    bool _Hadname = !_Badname(_Lobj);
    _Lobj._Addcats(_Cat, _Locname);

    if (_Hadname && _Badname(_Lobj))
     _Xruntime_error("bad locale name");

    _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
   }
   } if (0) {
   delete _Ptr->_Decref();
           ;
   }}
   }
  }

 explicit locale(const string& _Str,
  category _Cat = all)
  {
  if (!_Str.compare("C") && !_Str.compare(""))
   _Xruntime_error("bad locale name");

  _Ptr = classic()._Ptr;
  _Ptr->_Incref();
  }

 locale(const locale& _Loc, const string& _Str,
  category _Cat)
  {
  if (!_Str.compare("C") && !_Str.compare(""))
   _Xruntime_error("bad locale name");

  _Ptr = _Locimp::_New_Locimp(*_Loc._Ptr);
  {{
  _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name);
  bool _Hadname = !_Badname(_Lobj);
  _Lobj._Addcats(_Cat, _Str.c_str());

  if (_Hadname && _Badname(_Lobj))
   _Xruntime_error("bad locale name");
  _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
  } if (0) {
  delete _Ptr->_Decref();
          ;
  }}
  }
# 524 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocale" 3
 ~locale() noexcept
  {
  if (_Ptr != 0)
   delete _Ptr->_Decref();
  }

 locale& operator=(const locale& _Right) noexcept
  {
  if (_Ptr != _Right._Ptr)
   {
   delete _Ptr->_Decref();
   _Ptr = _Right._Ptr;
   _Ptr->_Incref();
   }
  return (*this);
  }

 string name() const
  {

  return (_Ptr == 0 ? string() : _Ptr->_Name);



  }

 const char *c_str() const
  {

  return (_Ptr == 0 ? "" : _Ptr->_Name);



  }

 const facet *_Getfacet(size_t _Id) const
  {
  const facet *_Facptr = _Id < _Ptr->_Facetcount
   ? _Ptr->_Facetvec[_Id] : 0;
  if (_Facptr != 0 || !_Ptr->_Xparent)
   return (_Facptr);
  else
   {
   locale::_Locimp *_Ptr0 = _Getgloballocale();
   return (_Id < _Ptr0->_Facetcount
    ? _Ptr0->_Facetvec[_Id]
    : 0);
   }
  }

 bool operator==(const locale& _Loc) const
  {
  return (_Ptr == _Loc._Ptr
   || (name().compare("*") != 0
    && name().compare(_Loc.name()) == 0));
  }

 bool operator!=(const locale& _Right) const
  {
  return (!(*this == _Right));
  }

 static const locale& classic();

 static locale global(const locale&);

 static locale empty();

private:
 locale(_Locimp *_Ptrimp)
  : _Ptr(_Ptrimp)
  {
  }

 static _Locimp *_Init();
 static _Locimp *_Init(
  bool _Do_incref);
 static _Locimp *_Getgloballocale();
 static void _Setgloballocale(void *);

 bool _Badname(const _Locinfo& _Lobj)
  {
  return (:: strcmp(_Lobj._Getname(), "*") == 0);
  }

 _Locimp *_Ptr;
 };




inline _Locinfo& _Get_locinfo()
 {
 static _Locinfo _Lobj;
 return (_Lobj);
 }

template<class _Facet>
 class _Wrap_facet
  : public _Facet
 {
public:
 _Wrap_facet()
  : _Facet(_Get_locinfo())
  {
  }
 };


template<class _Facet>
 struct _Facetptr
 {
 static const locale::facet *_Psave;
 };

template<class _Facet>
 const locale::facet *_Facetptr<_Facet>::
  _Psave = 0;






template<class _Facet> inline
 const _Facet& use_facet(const locale& _Loc)

 {
 {::std:: _Lockit _Lock(0);
  const locale::facet *_Psave =
   _Facetptr<_Facet>::_Psave;

  size_t _Id = _Facet::id;
  const locale::facet *_Pf = _Loc._Getfacet(_Id);

  if (_Pf != 0)
   ;
  else if (_Psave != 0)
   _Pf = _Psave;
  else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))
                            ;

  else
   {
   _Pf = _Psave;
   _Facetptr<_Facet>::_Psave = _Psave;

   locale::facet *_Pfmod = (_Facet *)_Psave;
   _Pfmod->_Incref();
   _Pfmod->_Register();
   }

  return ((const _Facet&)(*_Pf));
 }
 }


template<class _Elem,
 class _InIt> inline
 int _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
  const _Elem *_Ptr)
 {
 for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
  if (_Ptr[_Off] == _Ptr[0])
   ++_Numfields;
 string _Str(_Numfields, '\0');

 int _Ans = -2;
 for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++_Field)
   {
   for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
    ;

   if (_Str[_Field] != '\0')
    _Off += (size_t)_Str[_Field];
   else if (_Ptr[_Off += _Column] == _Ptr[0]
    || _Ptr[_Off] == (_Elem)0)
    {
    _Str[_Field] = (char)(_Column < 127
     ? _Column : 127);
    _Ans = (int)_Field;
    }
   else if (_First == _Last
    || tolower(_Ptr[_Off]) != tolower(*_First))
    _Str[_Field] = (char)(_Column < 127
     ? _Column : 127);
   else
    _Prefix = true;
   }

  if (!_Prefix || _First == _Last)
   break;
  }
 return (_Ans);
 }





template<class _Elem> inline
 char _Maklocbyte(_Elem _Char,
  const _Locinfo::_Cvtvec&)
 {
 return ((char)(unsigned char)_Char);
 }

template<> inline
 char _Maklocbyte(wchar_t _Char,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 char _Byte = '\0';
 _Mbstatet _Mbst1;
 _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
 return (_Byte);
 }





template<class _Elem> inline
 _Elem _Maklocchr(char _Byte, _Elem *,
  const _Locinfo::_Cvtvec&)
 {
 return ((_Elem)(unsigned char)_Byte);
 }

template<> inline
 wchar_t _Maklocchr(char _Byte, wchar_t *,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 wchar_t _Wc = L'\0';
 _Mbstatet _Mbst1;
 _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
 return (_Wc);
 }





template<class _Elem> inline
 _Elem *_Maklocstr(const char *_Ptr, _Elem *,
  const _Locinfo::_Cvtvec&)
 {
 size_t _Count = :: strlen(_Ptr) + 1;
 _Elem *_Ptrdest = (_Elem *):: malloc(_Count * sizeof (_Elem));
 if (!_Ptrdest)
  _Xbad_alloc();

 for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
  *_Ptrnext = (_Elem)(unsigned char)*_Ptr;
 return (_Ptrdest);
 }

template<> inline
 wchar_t *_Maklocstr(const char *_Ptr, wchar_t *,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 size_t _Count, _Count1;
 size_t _Wchars;
 const char *_Ptr1;
 int _Bytes;
 wchar_t _Wc;
 _Mbstatet _Mbst1;

 _Count1 = :: strlen(_Ptr) + 1;
 for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
  _Count -= (size_t)_Bytes, _Ptr1 += _Bytes, ++_Wchars)
  if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
   break;
 ++_Wchars;

 wchar_t *_Ptrdest = (wchar_t *):: malloc(_Wchars * sizeof (wchar_t));
 if (!_Ptrdest)
  _Xbad_alloc();
 wchar_t *_Ptrnext = _Ptrdest;
 _Mbstatet _Mbst2;

 for (; 0 < _Wchars;
  _Count -= (size_t)_Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
  if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
   break;
 *_Ptrnext = L'\0';
 return (_Ptrdest);
 }

template<class _Ty>
class _Makloc
        {
public:
        static _Ty *Currencysign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("", (_Ty *)0, _Cvt);
                }

        static _Ty *Plussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("", (_Ty *)0, _Cvt);
                }

        static _Ty *Minussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("-", (_Ty *)0, _Cvt);
                }

        static char *MonGrouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("", (char *)0, _Cvt);
                }

        static char *Grouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("", (char *)0, _Cvt);
                }

        static _Ty *Falsename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("false", (_Ty *)0, _Cvt);
                }

        static _Ty *Truename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr("true", (_Ty *)0, _Cvt);
                }

        static _Ty *Days(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr(":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday", (_Ty *)0, _Cvt);
                }

        static _Ty *Months(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr(":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December", (_Ty *)0, _Cvt);
                }

        static _Ty *Ampm(const _Locinfo::_Cvtvec& _Cvt)
                {
                return _Maklocstr(":AM:am:PM:pm", (_Ty *)0, _Cvt);
                }

        template<class _Ty2>
        static void destroy(_Ty2 *ptr)
                {
                delete ptr;
                }
 };

template<>
class _Makloc<char>
        {
public:
        static const char *Currencysign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Plussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Minussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "-";
                }

        static const char *MonGrouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Grouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Falsename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "false";
                }

        static const char *Truename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "true";
                }

        static const char *Days(const _Locinfo::_Cvtvec& _Cvt)
                {
                return ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
                }

        static const char *Months(const _Locinfo::_Cvtvec& _Cvt)
                {
                return ":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
                }

        static const char *Ampm(const _Locinfo::_Cvtvec& _Cvt)
                {
                return ":AM:am:PM:pm";
                }

        static void destroy(void *ptr)
                {
                }
        };

template<>
class _Makloc<wchar_t>
        {
public:
        static const wchar_t *Currencysign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"";
                }

        static const wchar_t *Plussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"";
                }

        static const wchar_t *Minussign(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"-";
                }

        static const char *MonGrouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const char *Grouping(const _Locinfo::_Cvtvec& _Cvt)
                {
                return "";
                }

        static const wchar_t *Falsename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"false";
                }

        static const wchar_t *Truename(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L"true";
                }

        static const wchar_t *Days(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
                }

        static const wchar_t *Months(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
                }

        static const wchar_t *Ampm(const _Locinfo::_Cvtvec& _Cvt)
                {
                return L":AM:am:PM:pm";
                }

        static void destroy(void *ptr)
                {
                }
        };



class codecvt_base
 : public locale::facet
 {
public:
 enum
  {
  ok, partial, error, noconv};
 typedef int result;

 codecvt_base(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  }

 bool always_noconv() const noexcept
  {
  return (do_always_noconv());
  }

 int max_length() const noexcept
  {
  return (do_max_length());
  }

 int encoding() const noexcept
  {
  return (do_encoding());
  }

 ~codecvt_base() noexcept
  {
  }

protected:
 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return (1);
  }

 virtual int do_encoding() const noexcept
  {
  return (1);
  }
 };


template<class _Elem,
 class _Byte,
 class _Statype>
 class codecvt
  : public codecvt_base
 {
public:
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (always_noconv() ? noconv
   : do_unshift(_State, _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

 static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Locinfo());
  }

 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (is_same<_Byte, _Elem>::value);
  }

 virtual result do_in(_Statype&,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if (is_same<_Byte, _Elem>::value)
   return (noconv);
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
    *_Mid2 = (_Elem)*_Mid1;
   return (ok);
   }
  }

 virtual result do_out(_Statype&,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if (is_same<_Byte, _Elem>::value)
   return (noconv);
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
    *_Mid2 = (_Byte)*_Mid1;
   return (ok);
   }
  }

 virtual result do_unshift(_Statype&,
  _Byte *_First2, _Byte *, _Byte *&_Mid2) const
  {
  _Mid2 = _First2;
  return (ok);
  }

 virtual int do_length(_Statype&, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return ((int)(_Count < (size_t)(_Last1 - _First1)
   ? _Count : _Last1 - _First1));
  }
 };


template<class _Elem,
 class _Byte,
 class _Statype>
 locale::id codecvt<_Elem, _Byte, _Statype>::id;

extern template class codecvt<char, char, _Mbstatet>;


enum _Codecvt_mode {
 _Consume_header = 4,
 _Generate_header = 2
 };


template<>
 class codecvt<char16_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
 typedef char16_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

 static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
  {
  _Init(_Lobj);
  }

 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
  _Codecvt_mode _Mode_arg, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned char _By = (unsigned char)*_Mid1;
   unsigned long _Ch;
   int _Nextra, _Nskip;

   if (*_Pstate <= 1)
    ;
   else if (_By < 0x80 || 0xc0 <= _By)
    return (_Mybase::error);
   else
    {
    ++_Mid1;
    *_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
    *_Pstate = 1;
    continue;
    }

   if (_By < 0x80)
    _Ch = _By, _Nextra = 0;
   else if (_By < 0xc0)
    {
    ++_Mid1;
    return (_Mybase::error);
    }
   else if (_By < 0xe0)
    _Ch = _By & 0x1f, _Nextra = 1;
   else if (_By < 0xf0)
    _Ch = _By & 0x0f, _Nextra = 2;
   else if (_By < 0xf8)
    _Ch = _By & 0x07, _Nextra = 3;
   else
    _Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

   _Nskip = _Nextra < 3 ? 0 : 1;
   _First1 = _Mid1;

   if (_Nextra == 0)
    ++_Mid1;
   else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
    break;
   else
    for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
     if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
      return (_Mybase::error);
     else
      _Ch = _Ch << 6 | (_By & 0x3f);
   if (0 < _Nskip)
    _Ch <<= 6;

   if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
    return (_Mybase::error);
   else if (0xffff < _Ch)
    {
    unsigned short _Ch0 =
     (unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

    *_Mid2++ = (_Elem)_Ch0;
    *_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
    continue;
    }

   if (_Nskip == 0)
    ;
   else if (_Mid1 == _Last1)
    {
    _Mid1 = _First1;
    break;
    }
   else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
    return (_Mybase::error);
   else
    _Ch |= _By & 0x3f;

   if (*_Pstate == 0)
    {
    *_Pstate = 1;

    if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
     {
     result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
      _First2, _Last2, _Mid2);

     if (_Ans == _Mybase::partial)
      {
      *_Pstate = 0;
      _Mid1 = _First1;
      }
     return (_Ans);
     }
    }

   *_Mid2++ = (_Elem)_Ch;
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned long _Ch;
   unsigned short _Ch1 = (unsigned short)*_Mid1;
   bool _Save = false;

   if (1 < *_Pstate)
    {
    if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
     return (_Mybase::error);
    _Ch = (unsigned long)((*_Pstate << 10) | (_Ch1 - 0xdc00));
    }
   else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
    {
    _Ch = (unsigned long)((_Ch1 - 0xd800 + 0x0040) << 10);
    _Save = true;
    }
   else
    _Ch = _Ch1;

   _Byte _By;
   int _Nextra;

   if (_Ch < 0x0080)
    _By = (_Byte)_Ch, _Nextra = 0;
   else if (_Ch < 0x0800)
    _By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
   else if (_Ch < 0x10000)
    _By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
   else
    _By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;

   int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

   if (_Last2 - _Mid2 < _Nput)
    break;
   else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
    ;
   else if (_Last2 - _Mid2 < 3 + _Nput)
    break;
   else
    {
    *_Mid2++ = (_Byte)(unsigned char)0xef;
    *_Mid2++ = (_Byte)(unsigned char)0xbb;
    *_Mid2++ = (_Byte)(unsigned char)0xbf;
    }

   ++_Mid1;
   if (_Save || _Nextra < 3)
    {
    *_Mid2++ = _By;
    --_Nput;
    }
   for (; 0 < _Nput; --_Nput)
    *_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);

   *_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *, _Byte *& _Mid2) const
  {
  unsigned short *_Pstate = (unsigned short *)&_State;
  _Mid2 = _First2;

  return (1 < *_Pstate
   ? _Mybase::error : _Mybase::ok);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  size_t _Wchars = 0;
  _Statype _Mystate = _State;

  for (; _Wchars < _Count && _First1 != _Last1; )
   {
   const _Byte *_Mid1;
   _Elem *_Mid2;
   _Elem _Ch;

   switch (do_in(_Mystate, _First1, _Last1, _Mid1,
    &_Ch, &_Ch + 1, _Mid2))
    {
   case _Mybase::noconv:
    return ((int)(_Wchars + (size_t)(_Last1 - _First1)));

   case _Mybase::ok:
    if (_Mid2 == &_Ch + 1)
     ++_Wchars;
    _First1 = _Mid1;
    break;

   default:
    return ((int)_Wchars);
    }
   }

  return ((int)_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return ((_Mode & _Consume_header) != 0 ? 9
   : (_Mode & _Generate_header) != 0 ? 7
   : 6);
  }

 virtual int do_encoding() const noexcept
  {
  return (0);
  }

private:
 unsigned long _Maxcode;
 _Codecvt_mode _Mode;
 int :32;
 };


template<>
 class codecvt<char32_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
 typedef char32_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

 static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
  {
  _Init(_Lobj);
  }

 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
  _Codecvt_mode _Mode_arg, size_t _Refs = 0)
  : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  char *_Pstate = (char *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   unsigned char _By = (unsigned char)*_Mid1;
   unsigned long _Ch;
   int _Nextra;

   if (_By < 0x80)
    _Ch = _By, _Nextra = 0;
   else if (_By < 0xc0)
    {
    ++_Mid1;
    return (_Mybase::error);
    }
   else if (_By < 0xe0)
    _Ch = _By & 0x1f, _Nextra = 1;
   else if (_By < 0xf0)
    _Ch = _By & 0x0f, _Nextra = 2;
   else if (_By < 0xf8)
    _Ch = _By & 0x07, _Nextra = 3;
   else
    _Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

   if (_Nextra == 0)
    ++_Mid1;
   else if (_Last1 - _Mid1 < _Nextra + 1)
    break;
   else
    for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
     if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
      return (_Mybase::error);
     else
      _Ch = _Ch << 6 | (_By & 0x3f);

   if (*_Pstate == 0)
    {
    *_Pstate = 1;

    if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
     {
     result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
      _First2, _Last2, _Mid2);

     if (_Ans == _Mybase::partial)
      {
      *_Pstate = 0;
      _Mid1 = _First1;
      }
     return (_Ans);
     }
    }

   if (_Maxcode < _Ch)
    return (_Mybase::error);
   *_Mid2++ = (_Elem)_Ch;
   }

  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  char *_Pstate = (char *)&_State;
  _Mid1 = _First1;
  _Mid2 = _First2;

  for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
   {
   _Byte _By;
   int _Nextra;
   unsigned long _Ch = (unsigned long)*_Mid1;

   if (_Maxcode < _Ch)
    return (_Mybase::error);

   if (_Ch < 0x0080)
    _By = (_Byte)_Ch, _Nextra = 0;
   else if (_Ch < 0x0800)
    _By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
   else if (_Ch < 0x00010000)
    _By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
   else if (_Ch < 0x00200000)
    _By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
   else if (_Ch < 0x04000000)
    _By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
   else
    _By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;

   if (*_Pstate == 0)
    {
    *_Pstate = 1;
    if ((_Mode & _Generate_header) == 0)
     ;
    else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
     return (_Mybase::partial);
    else
     {
     *_Mid2++ = (_Byte)(unsigned char)0xef;
     *_Mid2++ = (_Byte)(unsigned char)0xbb;
     *_Mid2++ = (_Byte)(unsigned char)0xbf;
     }
    }

   if (_Last2 - _Mid2 < 1 + _Nextra)
    break;

   ++_Mid1;
   for (*_Mid2++ = _By; 0 < _Nextra; )
    *_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
   }
  return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
  }

 virtual result do_unshift(_Statype&,
  _Byte *_First2, _Byte *, _Byte *& _Mid2) const
  {
  _Mid2 = _First2;
  return (_Mybase::ok);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  int _Wchars = 0;
  _Statype _Mystate = _State;

  for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
   {
   const _Byte *_Mid1;
   _Elem *_Mid2;
   _Elem _Ch;

   switch (do_in(_Mystate, _First1, _Last1, _Mid1,
    &_Ch, &_Ch + 1, _Mid2))
    {
   case _Mybase::noconv:
    return ((int)(_Wchars + (int)(_Last1 - _First1)));

   case _Mybase::ok:
    if (_Mid2 == &_Ch + 1)
     ++_Wchars;
    _First1 = _Mid1;
    break;

   default:
    return ((int)_Wchars);
    }
   }

  return ((int)_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return ((_Mode & (_Consume_header | _Generate_header)) != 0
   ? 9 : 6);
  }

 virtual int do_encoding() const noexcept
  {
  return ((_Mode & (_Consume_header | _Generate_header)) != 0
   ? -1 : 0);
  }

private:
 unsigned long _Maxcode;
 _Codecvt_mode _Mode;
 int :32;
 };


template<>
 class codecvt<wchar_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef wchar_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

 static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() noexcept
  {
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Cvt = _Lobj._Getcvt();
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
   _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  result _Ans = _Mid1 == _Last1 ? ok : partial;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, (size_t)(_Last1 - _Mid1),
    &_State, &_Cvt))
   {
   case -2:
    _Mid1 = _Last1;
    return (_Ans);

   case -1:
    return (error);

   case 0:
    if (*_Mid2 == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Mid2;
    _Ans = ok;
   }
  return (_Ans);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
   _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   if ((int)6 <= _Last2 - _Mid2)
    if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else
     ++_Mid1, _Mid2 += _Bytes;
   else
    {
    _Byte _Buf[6];
    _Statype _Stsave = _State;

    if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else if (_Last2 - _Mid2 < _Bytes)
     {
     _State = _Stsave;
     break;
     }
    else
     {
     :: memcpy(_Mid2, _Buf, _Bytes);
     ++_Mid1, _Mid2 += _Bytes;
     }
    }
  return (_Mid1 == _Last1 ? ok : partial);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
  _Mid2 = _First2;
  result _Ans = ok;
  int _Bytes;
  _Byte _Buf[6];
  _Statype _Stsave = _State;

  if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
   _Ans = error;
  else if (_Last2 - _Mid2 < --_Bytes)
   {
   _State = _Stsave;
   _Ans = partial;
   }
  else if (0 < _Bytes)
   {
   :: memcpy(_Mid2, _Buf, _Bytes);
   _Mid2 += _Bytes;
   }
  return (_Ans);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
                               ;
  int _Wchars;
  const _Byte *_Mid1;
  _Statype _Mystate = _State;

  for (_Wchars = 0, _Mid1 = _First1;
   (size_t)_Wchars < _Count && _Mid1 != _Last1; )
   {
   int _Bytes;
   _Elem _Ch;

   switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, (size_t)(_Last1 - _Mid1),
    &_Mystate, &_Cvt))
    {
   case -2:
    return (_Wchars);

   case -1:
    return (_Wchars);

   case 0:
    if (_Ch == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Wchars;
    }
   }
  return (_Wchars);
  }

 virtual bool do_always_noconv() const noexcept
  {
  return (false);
  }

 virtual int do_max_length() const noexcept
  {
  return (6);
  }

 virtual int do_encoding() const noexcept
  {
  return (0);
  }

private:
 _Locinfo::_Cvtvec _Cvt;
 };


template<class _Elem,
 class _Byte,
 class _Statype>
 class codecvt_byname
  : public codecvt<_Elem, _Byte, _Statype>
 {
public:
 explicit codecvt_byname(const char *_Locname, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit codecvt_byname(const string& _Str, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

 explicit codecvt_byname(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Lobj, _Refs)
  {
  }

protected:
 virtual ~codecvt_byname() noexcept
  {
  }
 };



struct ctype_base
 : public locale::facet
 {
 enum
  {
  alnum = 0x20 | 0x10 | 0x02 | 0x200, alpha = 0x10 | 0x02 | 0x200,
  cntrl = 0x80, digit = 0x20, graph = 0x20 | 0x10 | 0x08 | 0x02 | 0x200,
  lower = 0x10, print = 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x200 | 0x01,
  punct = 0x08, space = 0x40 | 0x04 | 0x100, upper = 0x02,
  xdigit = 0x01, blank = 0x40 | 0x04 | 0x100 | 0x400};
 typedef short mask;

 ctype_base(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  }

 ~ctype_base() noexcept
  {
  }
 };


template<class _Elem>
 class ctype
  : public ctype_base
 {
public:
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem *is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem *scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem *scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char *widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

 static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() noexcept
  {
  if (_Ctype._Delfl)
   :: free((void *)_Ctype._Table);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
   & _Maskval) != 0);
  }

 virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
  return (_First);
  }

 virtual const _Elem *do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem *do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Tolower(_Byte, &_Ctype)));
  }

 virtual const _Elem *do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Tolower(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Toupper(_Byte, &_Ctype)));
  }

 virtual const _Elem *do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Toupper(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
  }

 virtual const char *do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Byte;
  if (_Ch == (_Elem)0)
   return ('\0');
  else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
   return (_Dflt);
  else
   return (_Byte);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem *do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };


template<class _Elem>
 locale::id ctype<_Elem>::id;


template<>
 class ctype<char>
 : public ctype_base
 {
 typedef ctype<char> _Myt;

public:
 typedef char _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
  }

 const _Elem *is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)*_First];
  return (_First);
  }

 const _Elem *scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 const _Elem *scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const _Elem *widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 _Elem narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

 static locale::id id;

 explicit ctype(const mask *_Table = 0,
  bool _Deletetable = false,
  size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }

  _Tidy();
  if (_Table != 0)
   {
   _Ctype._Table = _Table;
   _Ctype._Delfl = _Deletetable ? -1 : 0;
   }
  else
   {
   _Ctype._Table = classic_table();
   _Ctype._Delfl = 0;
   }
  }

 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

 const mask *table() const noexcept
  {
  return (_Ctype._Table);
  }

 static const mask *classic_table() noexcept
  {
  const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
  return (_Ctype_fac.table());
  }

 static const size_t table_size;

protected:
 virtual ~ctype() noexcept
  {
  _Tidy();
  }

 void _Init(const _Locinfo& _Lobj)
  {




  _Ctype = _Lobj._Getctype();
  }

 void _Tidy()
  {
  if (0 < _Ctype._Delfl)
   :: free((void *)_Ctype._Table);
  else if (_Ctype._Delfl < 0)
   delete[] _Ctype._Table;
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
  }

 virtual const _Elem *do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
  }

 virtual const _Elem *do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Byte);
  }

 virtual const _Elem *do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  :: memcpy(_Dest, _First, _Last - _First);
  return (_Last);
  }

 virtual _Elem do_narrow(_Elem _Ch, char) const
  {
  return (_Ch);
  }

 virtual const _Elem *do_narrow(const _Elem *_First,
  const _Elem *_Last, char, char *_Dest) const
  {
                                        ;
  :: memcpy(_Dest, _First, _Last - _First);
  return (_Last);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 };


template<>
 class ctype<wchar_t>
 : public ctype_base
 {
 typedef ctype<wchar_t> _Myt;

public:
 typedef wchar_t _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem *is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem *scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem *scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char *widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

 static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() noexcept
  {
  if (_Ctype._Delfl)
   :: free((void *)_Ctype._Table);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
   & _Maskval) != 0);
  }

 virtual const _Elem *do_is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
  return (_First);
  }

 virtual const _Elem *do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem *do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Tolower(_Byte, &_Ctype)));
  }

 virtual const _Elem *do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Tolower(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Toupper(_Byte, &_Ctype)));
  }

 virtual const _Elem *do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Toupper(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 _Elem _Dowiden(char _Byte) const
  {
  _Mbstatet _Mbst;
  wchar_t _Wc;
  return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
   ? (wchar_t)((:: wint_t)(-1)) : _Wc);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Dowiden(_Byte));
  }

 virtual const char *do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Dowiden(*_First);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Buf[6];
  _Mbstatet _Mbst;
  return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
   ? _Dflt : _Buf[0]);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem *do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                                        ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };


template<class _Elem>
 class ctype_byname
 : public ctype<_Elem>
 {
public:
 explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
  : ctype<_Elem>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit ctype_byname(const string& _Str, size_t _Refs = 0)
  : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

 explicit ctype_byname(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype<_Elem>(_Lobj, _Refs)
  {
  }

protected:
 virtual ~ctype_byname() noexcept
  {
  }
 };


template<>
 class ctype_byname<char>
 : public ctype<char>
 {
public:
 explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
  : ctype<char>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit ctype_byname(const string& _Str, size_t _Refs = 0)
  : ctype<char>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

 explicit ctype_byname(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype<char>(_Lobj, _Refs)
  {
  }

protected:
 virtual ~ctype_byname() noexcept
  {
  }
 };


extern std::locale _sceLibcClassicLocale;


}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cerrno" 1 3
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cerrno" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cerrno" 2 3







# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\errno.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\errno.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/errno.h" 1 3
# 51 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/errno.h" 3
extern "C" {
int * __error(void);
}
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\errno.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\errno.h" 2 3
# 33 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\cerrno" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 2 3



namespace std {

enum class errc {
 address_family_not_supported = 47,
 address_in_use = 48,
 address_not_available = 49,
 already_connected = 56,
 argument_list_too_long = 7,
 argument_out_of_domain = 33,
 bad_address = 14,
 bad_file_descriptor = 9,
 bad_message = 89,
 broken_pipe = 32,
 connection_aborted = 53,
 connection_already_in_progress = 37,
 connection_refused = 61,
 connection_reset = 54,
 cross_device_link = 18,
 destination_address_required = 39,
 device_or_resource_busy = 16,
 directory_not_empty = 66,
 executable_format_error = 8,
 file_exists = 17,
 file_too_large = 27,
 filename_too_long = 63,
 function_not_supported = 78,
 host_unreachable = 65,
 identifier_removed = 82,
 illegal_byte_sequence = 86,
 inappropriate_io_control_operation = 25,
 interrupted = 4,
 invalid_argument = 22,
 invalid_seek = 29,
 io_error = 5,
 is_a_directory = 21,
 message_size = 40,
 network_down = 50,
 network_reset = 52,
 network_unreachable = 51,
 no_buffer_space = 55,
 no_child_process = 10,
 no_link = 91,
 no_lock_available = 77,
 no_message_available = 1040,
 no_message = 83,
 no_protocol_option = 42,
 no_space_on_device = 28,
 no_stream_resources = 1050,
 no_such_device_or_address = 6,
 no_such_device = 19,
 no_such_file_or_directory = 2,
 no_such_process = 3,
 not_a_directory = 20,
 not_a_socket = 38,
 not_a_stream = 1051,
 not_connected = 57,
 not_enough_memory = 12,
 not_supported = 45,
 operation_canceled = 85,
 operation_in_progress = 36,
 operation_not_permitted = 1,
 operation_not_supported = 45,
 operation_would_block = 35,
 owner_dead = 108,
 permission_denied = 13,
 protocol_error = 92,
 protocol_not_supported = 43,
 read_only_file_system = 30,
 resource_deadlock_would_occur = 11,
 resource_unavailable_try_again = 35,
 result_out_of_range = 34,
 state_not_recoverable = 107,
 stream_timeout = 1074,
 text_file_busy = 26,
 timed_out = 60,
 too_many_files_open_in_system = 23,
 too_many_files_open = 24,
 too_many_links = 31,
 too_many_symbolic_link_levels = 62,
 value_too_large = 84,
 wrong_protocol_type = 41
 };

typedef errc _Errc;


typedef errc generic_errno;



enum class io_errc {
 stream = 1
 };

typedef io_errc _Io_errc;
}
namespace std {

template<class _Enum>
 struct is_error_code_enum
  : public false_type
 {
 };

template<>
 struct is_error_code_enum<_Io_errc>
  : public true_type
 {
 };


template<class _Enum>
 struct is_error_condition_enum
  : public false_type
 {
 };

template<>
 struct is_error_condition_enum<generic_errno>
  : public true_type
 {
 };
}
namespace std {





class error_code;
class error_condition;
error_code make_error_code(_Errc) noexcept;
error_code make_error_code(_Io_errc) noexcept;
error_condition make_error_condition(_Errc) noexcept;
error_condition make_error_condition(_Io_errc) noexcept;


class error_category;

const error_category& generic_category() noexcept;
const error_category& iostream_category() noexcept;
const error_category& system_category() noexcept;

class error_category
 {
public:
 constexpr error_category() noexcept
  {
  }

 virtual ~error_category() noexcept;

 virtual const char *name() const noexcept = 0;

 virtual string message(int _Errval) const = 0;

 virtual error_condition
  default_error_condition(int _Errval) const noexcept;

 virtual bool equivalent(int _Errval,
  const error_condition& _Cond) const noexcept;

 virtual bool equivalent(const error_code& _Code,
  int _Errval) const noexcept;

 bool operator==(const error_category& _Right) const noexcept
  {
  return (this == &_Right);
  }

 bool operator!=(const error_category& _Right) const noexcept
  {
  return (!(*this == _Right));
  }

 bool operator<(const error_category& _Right) const noexcept
  {
  return (this < &_Right);
  }

 error_category(const error_category&) = delete;
 error_category& operator=(const error_category&) = delete;
 };


class error_code
 {
public:
 typedef error_code _Myt;

 error_code() noexcept
  : _Myval(0),
   _Mycat(&system_category())
  {
  }

 error_code(int _Val, const error_category& _Cat) noexcept
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = enable_if_t<is_error_code_enum<_Enum>::value,
   void> >
  error_code(_Enum _Errcode) noexcept
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_code(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) noexcept
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum>
  enable_if_t<is_error_code_enum<_Enum>::value,
   error_code>&
  operator=(_Enum _Errcode) noexcept
  {
  *this = make_error_code(_Errcode);
  return (*this);
  }

 void clear() noexcept
  {
  _Myval = 0;
  _Mycat = &system_category();
  }

 int value() const noexcept
  {
  return (_Myval);
  }

 const error_category& category() const noexcept
  {
  return (*_Mycat);
  }

 error_condition default_error_condition() const noexcept;

 string message() const
  {
  return (category().message(value()));
  }


 int _No_bool_decl = 0;


 explicit operator bool() const noexcept
  {
  return (value() != 0);
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


class error_condition
 {
public:
 typedef error_condition _Myt;

 error_condition() noexcept
  : _Myval(0),
   _Mycat(&generic_category())
  {
  }

 error_condition(int _Val, const error_category& _Cat) noexcept
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = enable_if_t<is_error_condition_enum<_Enum>::value,
   void> >
  error_condition(_Enum _Errcode) noexcept
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_condition(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) noexcept
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum,
  class = enable_if_t<is_error_condition_enum<_Enum>::value,
   void> >
  error_condition& operator=(_Enum _Errcode) noexcept
  {
  *this = make_error_condition(_Errcode);
  return (*this);
  }

 void clear() noexcept
  {
  _Myval = 0;
  _Mycat = &generic_category();
  }

 int value() const noexcept
  {
  return (_Myval);
  }

 const error_category& category() const noexcept
  {
  return (*_Mycat);
  }

 string message() const
  {
  return (category().message(value()));
  }


        int _No_bool_decl;


 explicit operator bool() const noexcept
  {
  return (value() != 0);
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


inline bool operator==(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (_Left.category() == _Right.category()
  && _Left.value() == _Right.value());
 }

inline bool operator==(
 const error_code& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category().equivalent(_Left.value(), _Right)
  || _Right.category().equivalent(_Left, _Right.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_code& _Right) noexcept
 {
 return (_Right.category().equivalent(_Right.value(), _Left)
  || _Left.category().equivalent(_Right, _Left.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category() == _Right.category()
  && _Left.value() == _Right.value());
 }


inline bool operator!=(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_code& _Left,
 const error_condition& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_code& _Right) noexcept
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (!(_Left == _Right));
 }


inline bool operator<(
 const error_code& _Left,
 const error_code& _Right) noexcept
 {
 return (_Left.category() < _Right.category()
  || (_Left.category() == _Right.category()
   && _Left.value() < _Right.value()));
 }

inline bool operator<(
 const error_condition& _Left,
 const error_condition& _Right) noexcept
 {
 return (_Left.category() < _Right.category()
  || (_Left.category() == _Right.category()
   && _Left.value() < _Right.value()));
 }


inline error_condition error_code::default_error_condition() const noexcept
 {
 return (category().default_error_condition(value()));
 }


inline error_code make_error_code(_Errc _Errno) noexcept
 {
 return (error_code((int)_Errno, generic_category()));
 }

inline error_code make_error_code(_Io_errc _Errno) noexcept
 {
 return (error_code((int)_Errno, iostream_category()));
 }


inline error_condition make_error_condition(_Errc _Errno) noexcept
 {
 return (error_condition((int)_Errno, generic_category()));
 }

inline error_condition make_error_condition(_Io_errc _Errno) noexcept
 {
 return (error_condition((int)_Errno, iostream_category()));
 }
}
namespace std {

template<>
 struct hash<error_code>
 {
 typedef error_code argument_type;
 typedef size_t result_type;

 size_t operator()(const argument_type& _Keyval) const
  {
  return (hash<int>()(_Keyval.value()));
  }
 };
# 490 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 3
}
namespace std {

class _System_error
 : public runtime_error
 {
private:
 static string _Makestr(error_code _Errcode, string _Message)
  {
  if (!_Message.empty())
   _Message.append(": ");
  _Message.append(_Errcode.message());
  return (_Message);
  }

protected:
 _System_error(error_code _Errcode, const string& _Message)
  : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
  {
  }

 error_code _Mycode;
 };

class system_error
 : public _System_error
 {
private:
 typedef _System_error _Mybase;

public:
 system_error(error_code _Errcode)
  : _Mybase(_Errcode, "")
  {
  }

 system_error(error_code _Errcode, const string& _Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(error_code _Errcode, const char *_Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat)
  : _Mybase(error_code(_Errval, _Errcat), "")
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const string& _Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const char *_Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }


 virtual ~system_error() noexcept;


 const error_code& code() const noexcept
  {
  return (_Mycode);
  }




protected:
 virtual void _Doraise() const;

 };

const char *_Syserror_map(int);


class _Generic_error_category
 : public error_category
 {
public:
 _Generic_error_category() noexcept
  {
  }

 virtual const char *name() const noexcept
  {
  return ("generic");
  }

 virtual string message(int _Errcode) const
  {
  const char *_Name = _Syserror_map(_Errcode);
  return (string(_Name != 0 ? _Name : "unknown error"));
  }
 };

template<class _Ty>
 struct _Immortalizer
 {
 _Immortalizer()
  {
  ::new (static_cast<void *>(&_Storage)) _Ty();
  }

 ~_Immortalizer() noexcept
  {
  }

 _Immortalizer(const _Immortalizer&) = delete;
 _Immortalizer& operator=(const _Immortalizer&) = delete;

 typename aligned_union<1, _Ty>::type _Storage;
 };

template<class _Ty> inline
 _Ty& _Immortalize()
 {
 static _Immortalizer<_Ty> _Static;
 return (*reinterpret_cast<_Ty *>(&_Static._Storage));
 }
# 629 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\system_error" 3
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 2 3

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\yvals.h" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 2 3



namespace std {
# 75 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xiosbase" 3
template<class _Dummy>
 class _Iosb
 {
public:
 enum _Dummy_enum {_Dummy_enum_val = 1};
 enum _Fmtflags
  {
  _Fmtmask = 0xffff, _Fmtzero = 0};

 static constexpr _Fmtflags skipws = (_Fmtflags)0x0001;
 static constexpr _Fmtflags unitbuf = (_Fmtflags)0x2000;
 static constexpr _Fmtflags uppercase = (_Fmtflags)0x0200;
 static constexpr _Fmtflags showbase = (_Fmtflags)0x0080;
 static constexpr _Fmtflags showpoint = (_Fmtflags)0x0100;
 static constexpr _Fmtflags showpos = (_Fmtflags)0x0400;
 static constexpr _Fmtflags left = (_Fmtflags)0x0002;
 static constexpr _Fmtflags right = (_Fmtflags)0x0004;
 static constexpr _Fmtflags internal = (_Fmtflags)0x0008;
 static constexpr _Fmtflags dec = (_Fmtflags)0x0010;
 static constexpr _Fmtflags oct = (_Fmtflags)0x0020;
 static constexpr _Fmtflags hex = (_Fmtflags)0x0040;
 static constexpr _Fmtflags scientific = (_Fmtflags)0x0800;
 static constexpr _Fmtflags fixed = (_Fmtflags)0x1000;

 static constexpr _Fmtflags hexfloat =
  (_Fmtflags)0x1800;

 static constexpr _Fmtflags boolalpha = (_Fmtflags)0x8000;
 static constexpr _Fmtflags _Stdio = (_Fmtflags)0x4000;
 static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0002
  | 0x0004 | 0x0008);
 static constexpr _Fmtflags basefield = (_Fmtflags)(0x0010
  | 0x0020 | 0x0040);
 static constexpr _Fmtflags floatfield = (_Fmtflags)(0x0800
  | 0x1000);

 enum _Iostate
  {
  _Statmask = 0x17};

 static constexpr _Iostate goodbit = (_Iostate)0x0;
 static constexpr _Iostate eofbit = (_Iostate)0x1;
 static constexpr _Iostate failbit = (_Iostate)0x2;
 static constexpr _Iostate badbit = (_Iostate)0x4;

 enum _Openmode
  {
  _Openmask = 0xff};

 static constexpr _Openmode in = (_Openmode)0x01;
 static constexpr _Openmode out = (_Openmode)0x02;
 static constexpr _Openmode ate = (_Openmode)0x04;
 static constexpr _Openmode app = (_Openmode)0x08;
 static constexpr _Openmode trunc = (_Openmode)0x10;
 static constexpr _Openmode _Nocreate = (_Openmode)0x20;
 static constexpr _Openmode _Noreplace = (_Openmode)0x40;
 static constexpr _Openmode binary = (_Openmode)0x80;

 enum _Seekdir
  {
  _Seekbeg,
  _Seekcur,
  _Seekend
  };

 static constexpr _Seekdir beg = _Seekbeg;
 static constexpr _Seekdir cur = _Seekcur;
 static constexpr _Seekdir end = _Seekend;

 enum
  {
  _Openprot = 0666};
 };

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags
  _Iosb<_Dummy>::hexfloat;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;


class ios_base
 : public _Iosb<int>
 {
public:
 typedef _Fmtflags fmtflags;
 typedef _Iostate iostate;
 typedef _Openmode openmode;
 typedef _Seekdir seekdir;

 typedef ::std:: streamoff streamoff;
 typedef ::std:: streampos streampos;

 enum event
  {
  erase_event, imbue_event, copyfmt_event};

 typedef void (*event_callback)(event, ios_base&, int);
 typedef unsigned int io_state, open_mode, seek_dir;


 class failure
  : public system_error
  {
 public:
  explicit failure(const string &_Message,
   const error_code& _Errcode = make_error_code(io_errc::stream))
   : system_error(_Errcode, _Message)
   {
   }

  explicit failure(const char *_Message,
   const error_code& _Errcode = make_error_code(io_errc::stream))
   : system_error(_Errcode, _Message)
   {
   }


  virtual ~failure() noexcept;





 protected:
  virtual void _Doraise() const;

  };


 class Init
  {
 public:
  Init();

  ~Init() noexcept;

 private:
  static int _Init_cnt;
  };

 operator void *() const
  {
  return (fail() ? 0 : (void *)this);
  }

 explicit operator bool() const
  {
  return (!fail());
  }

 bool operator!() const
  {
  return (fail());
  }

 void clear(iostate _State, bool _Reraise)
  {
  _Mystate = (iostate)(_State & _Statmask);
  if ((_Mystate & _Except) == 0)
   ;
  else if (_Reraise)
           ;
  else if (_Mystate & _Except & badbit)
   failure("ios_base::badbit set")._Raise();
  else if (_Mystate & _Except & failbit)
   failure("ios_base::failbit set")._Raise();
  else
   failure("ios_base::eofbit set")._Raise();
  }

 void clear(iostate _State = goodbit)
  {
  clear(_State, false);
  }

 void clear(io_state _State)
  {
  clear((iostate)_State);
  }

 iostate rdstate() const
  {
  return (_Mystate);
  }

 void setstate(iostate _State, bool _Exreraise)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
  }

 void setstate(iostate _State)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), false);
  }

 void setstate(io_state _State)
  {
  setstate((iostate)_State);
  }

 bool good() const
  {
  return (rdstate() == goodbit);
  }

 bool eof() const
  {
  return ((int)rdstate() & (int)eofbit);
  }

 bool fail() const
  {
  return (((int)rdstate()
   & ((int)badbit | (int)failbit)) != 0);
  }

 bool bad() const
  {
  return (((int)rdstate() & (int)badbit) != 0);
  }

 iostate exceptions() const
  {
  return (_Except);
  }

 void exceptions(iostate _Newexcept)
  {
  _Except = (iostate)((int)_Newexcept & (int)_Statmask);
  clear(_Mystate);
  }

 void exceptions(io_state _State)
  {
  exceptions((iostate)_State);
  }

 fmtflags flags() const
  {
  return (_Fmtfl);
  }

 fmtflags flags(fmtflags _Newfmtflags)
  {
  fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
  return (_Oldfmtflags);
  }

 fmtflags setf(fmtflags _Newfmtflags)
  {
  ios_base::fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)((int)_Fmtfl
   | ((int)_Newfmtflags & (int)_Fmtmask));
  return (_Oldfmtflags);
  }

 fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask)
  {
  ios_base::fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
   | ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
  return (_Oldfmtflags);
  }

 void unsetf(fmtflags _Mask)
  {
  _Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
  }

 streamsize precision() const
  {
  return (_Prec);
  }

 streamsize precision(streamsize _Newprecision)
  {
  streamsize _Oldprecision = _Prec;
  _Prec = _Newprecision;
  return (_Oldprecision);
  }

 streamsize width() const
  {
  return (_Wide);
  }

 streamsize width(streamsize _Newwidth)
  {
  streamsize _Oldwidth = _Wide;
  _Wide = _Newwidth;
  return (_Oldwidth);
  }

 locale getloc() const
  {
  return (*_Ploc);
  }

 locale imbue(const locale& _Loc)
  {
  locale _Oldlocale = *_Ploc;

  if (_Ploc == &_sceLibcClassicLocale)
   _Ploc = new locale(_Loc);
  else
   *_Ploc = _Loc;



  _Callfns(imbue_event);
  return (_Oldlocale);
  }

 static int xalloc()
  {
  {::std:: _Lockit _Lock(2);
   return (_Index++);
  }
  }

 long& iword(int _Idx)
  {
  return (_Findarr(_Idx)._Lo);
  }

 void *& pword(int _Idx)
  {
  return (_Findarr(_Idx)._Vp);
  }

 void register_callback(event_callback _Pfn,
  int _Idx)
  {
  _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
  }

 ios_base& copyfmt(const ios_base& _Other)
  {
  if (this != &_Other)
   {
   _Tidy();

   if (_Ploc == &_sceLibcClassicLocale)
    _Ploc = new locale(*_Other._Ploc);
   else
    *_Ploc = *_Other._Ploc;



   _Fmtfl = _Other._Fmtfl;
   _Prec = _Other._Prec;
   _Wide = _Other._Wide;
   _Iosarray *_Ptr = _Other._Arr;

   for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
    if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
     {
     iword(_Ptr->_Index) = _Ptr->_Lo;
     pword(_Ptr->_Index) = _Ptr->_Vp;
     }

   for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
    _Pfa = _Pfa->_Next)
    register_callback(_Pfa->_Pfn, _Pfa->_Index);

   _Callfns(copyfmt_event);
   exceptions(_Other._Except);
   }
  return (*this);
  }

 static bool sync_with_stdio(bool _Newsync = true)
  {
  {::std:: _Lockit _Lock(2);
   const bool _Oldsync = _Sync;
   _Sync = _Newsync;
   return (_Oldsync);
  }
  }

 void swap(ios_base& _Right)
  {
  if (this != &_Right)
   {
   ::std:: swap(_Mystate, _Right._Mystate);
   ::std:: swap(_Except, _Right._Except);
   ::std:: swap(_Fmtfl, _Right._Fmtfl);
   ::std:: swap(_Prec, _Right._Prec);
   ::std:: swap(_Wide, _Right._Wide);

   ::std:: swap(_Arr, _Right._Arr);
   ::std:: swap(_Calls, _Right._Calls);
   ::std:: swap(_Ploc, _Right._Ploc);
   }
  }

 virtual ~ios_base() noexcept;

 static void _Addstd(ios_base *);

 size_t _Stdstr;

protected:
 ios_base()
  {
  }

 void _Init()
  {
  _Ploc = 0;
  _Stdstr = 0;
  _Except = goodbit;
  _Fmtfl = (fmtflags)(skipws | dec);
  _Prec = 6;
  _Wide = 0;
  _Arr = 0;
  _Calls = 0;
  clear(goodbit);

  _Ploc = &_sceLibcClassicLocale;



  }

private:

 struct _Iosarray
  {
 public:
  _Iosarray(int _Idx, _Iosarray *_Link)
   : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
   {
   }

  _Iosarray *_Next;
  int _Index;
  int :32;
  long _Lo;
  void *_Vp;
  };


 struct _Fnarray
  {
  _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
   : _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
   {
   }

  _Fnarray *_Next;
  int _Index;
  int :32;
  event_callback _Pfn;
  };

 void _Callfns(event _Ev)
  {
  for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
   (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
  }

 _Iosarray& _Findarr(int _Idx)
  {
  _Iosarray *_Ptr1, *_Ptr2;

  for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
   if (_Ptr1->_Index == _Idx)
    return (*_Ptr1);
   else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
    _Ptr2 = _Ptr1;

  if (_Ptr2 != 0)
   {
   _Ptr2->_Index = _Idx;
   return (*_Ptr2);
   }

  _Arr = new _Iosarray(_Idx, _Arr);
  return (*_Arr);
  }

 void _Tidy()
  {
  _Callfns(erase_event);
  _Iosarray *_Ptr1, *_Ptr2;

  for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
   {
   _Ptr2 = _Ptr1->_Next;
   delete _Ptr1;
   }
  _Arr = 0;

  _Fnarray *_Pfa1, *_Pfa2;
  for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
   {
   _Pfa2 = _Pfa1->_Next;
   delete _Pfa1;
   }
  _Calls = 0;
  }

 iostate _Mystate;
 iostate _Except;
 fmtflags _Fmtfl;
 streamsize _Prec;
 streamsize _Wide;
 _Iosarray *_Arr;
 _Fnarray *_Calls;
 locale *_Ploc;

 static int _Index;
 static bool _Sync;

public:
 ios_base(const ios_base&) = delete;
 ios_base& operator=(const ios_base&) = delete;
 };

inline ios_base::_Fmtflags& operator&=(ios_base::_Fmtflags& _Left, ios_base::_Fmtflags _Right) { _Left = (ios_base::_Fmtflags)((int)_Left & (int)_Right); return (_Left); } inline ios_base::_Fmtflags& operator|=(ios_base::_Fmtflags& _Left, ios_base::_Fmtflags _Right) { _Left = (ios_base::_Fmtflags)((int)_Left | (int)_Right); return (_Left); } inline ios_base::_Fmtflags& operator^=(ios_base::_Fmtflags& _Left, ios_base::_Fmtflags _Right) { _Left = (ios_base::_Fmtflags)((int)_Left ^ (int)_Right); return (_Left); } inline constexpr ios_base::_Fmtflags operator&(ios_base::_Fmtflags _Left, ios_base::_Fmtflags _Right) { return ((ios_base::_Fmtflags)((int)_Left & (int)_Right)); } inline constexpr ios_base::_Fmtflags operator|(ios_base::_Fmtflags _Left, ios_base::_Fmtflags _Right) { return ((ios_base::_Fmtflags)((int)_Left | (int)_Right)); } inline constexpr ios_base::_Fmtflags operator^(ios_base::_Fmtflags _Left, ios_base::_Fmtflags _Right) { return ((ios_base::_Fmtflags)((int)_Left ^ (int)_Right)); } inline constexpr ios_base::_Fmtflags operator~(ios_base::_Fmtflags _Left) { return ((ios_base::_Fmtflags)(~(int)_Left & 0xffff)); }
inline ios_base::_Iostate& operator&=(ios_base::_Iostate& _Left, ios_base::_Iostate _Right) { _Left = (ios_base::_Iostate)((int)_Left & (int)_Right); return (_Left); } inline ios_base::_Iostate& operator|=(ios_base::_Iostate& _Left, ios_base::_Iostate _Right) { _Left = (ios_base::_Iostate)((int)_Left | (int)_Right); return (_Left); } inline ios_base::_Iostate& operator^=(ios_base::_Iostate& _Left, ios_base::_Iostate _Right) { _Left = (ios_base::_Iostate)((int)_Left ^ (int)_Right); return (_Left); } inline constexpr ios_base::_Iostate operator&(ios_base::_Iostate _Left, ios_base::_Iostate _Right) { return ((ios_base::_Iostate)((int)_Left & (int)_Right)); } inline constexpr ios_base::_Iostate operator|(ios_base::_Iostate _Left, ios_base::_Iostate _Right) { return ((ios_base::_Iostate)((int)_Left | (int)_Right)); } inline constexpr ios_base::_Iostate operator^(ios_base::_Iostate _Left, ios_base::_Iostate _Right) { return ((ios_base::_Iostate)((int)_Left ^ (int)_Right)); } inline constexpr ios_base::_Iostate operator~(ios_base::_Iostate _Left) { return ((ios_base::_Iostate)(~(int)_Left & 0x1f)); }
inline ios_base::_Openmode& operator&=(ios_base::_Openmode& _Left, ios_base::_Openmode _Right) { _Left = (ios_base::_Openmode)((int)_Left & (int)_Right); return (_Left); } inline ios_base::_Openmode& operator|=(ios_base::_Openmode& _Left, ios_base::_Openmode _Right) { _Left = (ios_base::_Openmode)((int)_Left | (int)_Right); return (_Left); } inline ios_base::_Openmode& operator^=(ios_base::_Openmode& _Left, ios_base::_Openmode _Right) { _Left = (ios_base::_Openmode)((int)_Left ^ (int)_Right); return (_Left); } inline constexpr ios_base::_Openmode operator&(ios_base::_Openmode _Left, ios_base::_Openmode _Right) { return ((ios_base::_Openmode)((int)_Left & (int)_Right)); } inline constexpr ios_base::_Openmode operator|(ios_base::_Openmode _Left, ios_base::_Openmode _Right) { return ((ios_base::_Openmode)((int)_Left | (int)_Right)); } inline constexpr ios_base::_Openmode operator^(ios_base::_Openmode _Left, ios_base::_Openmode _Right) { return ((ios_base::_Openmode)((int)_Left ^ (int)_Right)); } inline constexpr ios_base::_Openmode operator~(ios_base::_Openmode _Left) { return ((ios_base::_Openmode)(~(int)_Left & 0xff)); }
inline ios_base::_Seekdir& operator&=(ios_base::_Seekdir& _Left, ios_base::_Seekdir _Right) { _Left = (ios_base::_Seekdir)((int)_Left & (int)_Right); return (_Left); } inline ios_base::_Seekdir& operator|=(ios_base::_Seekdir& _Left, ios_base::_Seekdir _Right) { _Left = (ios_base::_Seekdir)((int)_Left | (int)_Right); return (_Left); } inline ios_base::_Seekdir& operator^=(ios_base::_Seekdir& _Left, ios_base::_Seekdir _Right) { _Left = (ios_base::_Seekdir)((int)_Left ^ (int)_Right); return (_Left); } inline constexpr ios_base::_Seekdir operator&(ios_base::_Seekdir _Left, ios_base::_Seekdir _Right) { return ((ios_base::_Seekdir)((int)_Left & (int)_Right)); } inline constexpr ios_base::_Seekdir operator|(ios_base::_Seekdir _Left, ios_base::_Seekdir _Right) { return ((ios_base::_Seekdir)((int)_Left | (int)_Right)); } inline constexpr ios_base::_Seekdir operator^(ios_base::_Seekdir _Left, ios_base::_Seekdir _Right) { return ((ios_base::_Seekdir)((int)_Left ^ (int)_Right)); } inline constexpr ios_base::_Seekdir operator~(ios_base::_Seekdir _Left) { return ((ios_base::_Seekdir)(~(int)_Left & 0x3)); }
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 2 3


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {

template<class _Elem,
 class _Traits>
 class basic_streambuf
 {
 typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
 basic_streambuf()

  : _Plocale(&_sceLibcClassicLocale)



  {
  _Init();
  }

 basic_streambuf(_Uninitialized)
  {
  }

 basic_streambuf(const _Myt& _Right)

  : _Plocale(_Right._Plocale == &_sceLibcClassicLocale ? &_sceLibcClassicLocale : new locale(_Right.getloc()))



  {
  _Init();
  setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
  setg(_Right.eback(), _Right.gptr(), _Right.egptr());
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
   setg(_Right.eback(), _Right.gptr(), _Right.egptr());
   pubimbue(_Right.getloc());
   }
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   {
   _Elem *_Pfirst0 = pbase();
   _Elem *_Pnext0 = pptr();
   _Elem *_Pend = epptr();
   _Elem *_Gfirst0 = eback();
   _Elem *_Gnext0 = gptr();
   _Elem *_Gend = egptr();

   setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
   _Right.setp(_Pfirst0, _Pnext0, _Pend);

   setg(_Right.eback(), _Right.gptr(), _Right.egptr());
   _Right.setg(_Gfirst0, _Gnext0, _Gend);

   ::std:: swap(_Plocale, _Right._Plocale);
   }
  }

public:
 typedef _Elem char_type;
 typedef _Traits traits_type;

 virtual ~basic_streambuf() noexcept
  {

  if (_Plocale != &_sceLibcClassicLocale)
   delete _Plocale;



  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 pos_type pubseekoff(off_type _Off,
  ios_base::seekdir _Way,
  ios_base::openmode _Mode = ios_base::in | ios_base::out)
  {
  return (seekoff(_Off, _Way, _Mode));
  }

 pos_type pubseekoff(off_type _Off,
  ios_base::seek_dir _Way,
  ios_base::open_mode _Mode)
  {
  return (pubseekoff(_Off, (ios_base::seekdir)_Way,
   (ios_base::openmode)_Mode));
  }

 pos_type pubseekpos(pos_type _Pos,
  ios_base::openmode _Mode = ios_base::in | ios_base::out)
  {
  return (seekpos(_Pos, _Mode));
  }

 pos_type pubseekpos(pos_type _Pos,
  ios_base::open_mode _Mode)
  {
  return (seekpos(_Pos, (ios_base::openmode)_Mode));
  }

 _Myt *pubsetbuf(_Elem *_Buffer,
  streamsize _Count)
  {
  return (setbuf(_Buffer, _Count));
  }

 locale pubimbue(const locale &_Newlocale)
  {
  locale _Oldlocale = *_Plocale;
  imbue(_Newlocale);

  if (_Plocale == &_sceLibcClassicLocale)
   _Plocale = new locale(_Newlocale);
  else
   *_Plocale = _Newlocale;



  return (_Oldlocale);
  }

 locale getloc() const
  {
  return (*_Plocale);
  }

 streamsize in_avail()
  {
  streamsize _Res = _Gnavail();
  return (0 < _Res ? _Res : showmanyc());
  }

 int pubsync()
  {
  return (sync());
  }

 int_type sbumpc()
  {
  return (0 < _Gnavail()
   ? _Traits::to_int_type(*_Gninc()) : uflow());
  }

 int_type sgetc()
  {
  return (0 < _Gnavail()
   ? _Traits::to_int_type(*gptr()) : underflow());
  }

 streamsize sgetn(_Elem *_Ptr,
  streamsize _Count)
  {
  return (xsgetn(_Ptr, _Count));
  }

 int_type snextc()
  {
  return (1 < _Gnavail()
   ? _Traits::to_int_type(*_Gnpreinc())
   : _Traits::eq_int_type(_Traits::eof(), sbumpc())
    ? _Traits::eof() : sgetc());
  }

 int_type sputbackc(_Elem _Ch)
  {
  return (gptr() != 0 && eback() < gptr()
   && _Traits::eq(_Ch, gptr()[-1])
   ? _Traits::to_int_type(*_Gndec())
   : pbackfail(_Traits::to_int_type(_Ch)));
  }

 void stossc()
  {
  if (0 < _Gnavail())
   _Gninc();
  else
   uflow();
  }

 int_type sungetc()
  {
  return (gptr() != 0 && eback() < gptr()
   ? _Traits::to_int_type(*_Gndec()) : pbackfail());
  }

 int_type sputc(_Elem _Ch)
  {
  return (0 < _Pnavail()
   ? _Traits::to_int_type(*_Pninc() = _Ch)
   : overflow(_Traits::to_int_type(_Ch)));
  }

 streamsize sputn(const _Elem *_Ptr,
  streamsize _Count)
  {
  return (xsputn(_Ptr, _Count));
  }

 virtual void _Lock()
  {
  }

 virtual void _Unlock()
  {
  }

protected:
 _Elem *eback() const
  {
  return (*_IGfirst);
  }

 _Elem *gptr() const
  {
  return (*_IGnext);
  }

 _Elem *pbase() const
  {
  return (*_IPfirst);
  }

 _Elem *pptr() const
  {
  return (*_IPnext);
  }
# 358 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 3
 _Elem *egptr() const
  {
  return (*_IGlast);
  }

 void gbump(int _Off)
  {
  *_IGnext += _Off;
  }

 void setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
  {
  *_IGfirst = _First, *_IGnext = _Next, *_IGlast = _Last;
  }

 _Elem *epptr() const
  {
  return (*_IPlast);
  }

 _Elem *_Gndec()
  {
  return (--*_IGnext);
  }

 _Elem *_Gninc()
  {
  return ((*_IGnext)++);
  }

 _Elem *_Gnpreinc()
  {
  return (++(*_IGnext));
  }

 streamsize _Gnavail() const
  {
  return ((streamsize)(*_IGnext != 0 ? *_IGlast - *_IGnext : 0));
  }

 void pbump(int _Off)
  {
  *_IPnext += _Off;
  }

 void setp(_Elem *_First, _Elem *_Last)
  {
  *_IPfirst = _First;
  *_IPnext = _First;
  *_IPlast = _Last;
  }

 void setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
  {
  *_IPfirst = _First;
  *_IPnext = _Next;
  *_IPlast = _Last;
  }

 _Elem *_Pninc()
  {
  return ((*_IPnext)++);
  }

 streamsize _Pnavail() const
  {
  return ((streamsize)(*_IPnext != 0 ? *_IPlast - *_IPnext : 0));
  }

 void _Init()
  {
  _IGfirst = &_Gfirst;
  _IPfirst = &_Pfirst;
  _IGnext = &_Gnext;
  _IPnext = &_Pnext;
  _IGlast = &_Glast;
  _IPlast = &_Plast;
  setp(0, 0);
  setg(0, 0, 0);
  }

 void _Init(_Elem **_Gf, _Elem **_Gn, _Elem **_Gl,
  _Elem **_Pf, _Elem **_Pn, _Elem **_Pl)
  {
  _IGfirst = _Gf;
  _IPfirst = _Pf;
  _IGnext = _Gn;
  _IPnext = _Pn;
  _IGlast = _Gl;
  _IPlast = _Pl;
  }



public:
 int allocate()
  {
  return (0);
  }

 _Elem *base() const
  {
  return (eback());
  }

 int blen() const
  {
  return (egptr() == 0 ? 0 : (int)(egptr() - eback()));
  }

 int in_avail() const
  {
  return (egptr() == 0 ? 0 : (int)(egptr() - gptr()));
  }

 int out_waiting() const
  {
  return (epptr() == 0 ? 0 : (int)(epptr() - pptr()));
  }

 void setb(char *, char *, int)
  {
  }


 virtual int_type overflow(int_type = _Traits::eof())
  {
  return (_Traits::eof());
  }

 virtual int_type pbackfail(int_type = _Traits::eof())
  {
  return (_Traits::eof());
  }

 virtual streamsize showmanyc()
  {
  return (0);
  }

 virtual int_type underflow()
  {
  return (_Traits::eof());
  }

 virtual int_type uflow()
  {
  return (_Traits::eq_int_type(_Traits::eof(), underflow())
   ? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
  }

 virtual streamsize xsgetn(_Elem * _Ptr,
  streamsize _Count)
  {
  int_type _Meta;
  streamsize _Size, _Copied;

  for (_Copied = 0; 0 < _Count; )
   if (0 < (_Size = _Gnavail()))
    {
    if (_Count < _Size)
     _Size = _Count;
    _Traits::copy(_Ptr, gptr(), (size_t)_Size);
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    gbump((int)_Size);
    }
   else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
    break;
   else
    {
    *_Ptr++ = _Traits::to_char_type(_Meta);
    ++_Copied;
    --_Count;
    }

  return (_Copied);
  }

 virtual streamsize xsputn(const _Elem *_Ptr,
  streamsize _Count)
  {
  streamsize _Size, _Copied;

  for (_Copied = 0; 0 < _Count; )
   if (0 < (_Size = _Pnavail()))
    {
    if (_Count < _Size)
     _Size = _Count;
    _Traits::copy(pptr(), _Ptr, (size_t)_Size);
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    pbump((int)_Size);
    }
   else if (_Traits::eq_int_type(_Traits::eof(),
    overflow(_Traits::to_int_type(*_Ptr))))
    break;
   else
    {
    ++_Ptr;
    ++_Copied;
    --_Count;
    }

  return (_Copied);
  }

 virtual pos_type seekoff(off_type,
  ios_base::seekdir,
  ios_base::openmode = ios_base::in | ios_base::out)
  {
  return (streampos(_BADOFF));
  }

 virtual pos_type seekpos(pos_type,
  ios_base::openmode = ios_base::in | ios_base::out)
  {
  return (streampos(_BADOFF));
  }

 virtual _Myt *setbuf(_Elem *, streamsize)
  {
  return (this);
  }

 virtual int sync()
  {
  return (0);
  }

 virtual void imbue(const locale&)
  {
  }

private:
 _Elem *_Gfirst;
 _Elem *_Pfirst;
 _Elem **_IGfirst;
 _Elem **_IPfirst;
 _Elem *_Gnext;
 _Elem *_Pnext;
 _Elem **_IGnext;
 _Elem **_IPnext;
# 611 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\streambuf" 3
 _Elem *_Glast;
 _Elem *_Plast;
 _Elem **_IGlast;
 _Elem **_IPlast;


protected:
 locale *_Plocale;
 };


template<class _Elem,
 class _Traits>
 class istreambuf_iterator
  : public iterator<input_iterator_tag,
   _Elem, typename _Traits::off_type, const _Elem *, _Elem>
 {
 typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf<_Elem, _Traits> streambuf_type;
 typedef basic_istream<_Elem, _Traits> istream_type;

 typedef typename traits_type::int_type int_type;
 typedef const _Elem *pointer;

 constexpr istreambuf_iterator(streambuf_type *_Sb = 0) noexcept
  : _Strbuf(_Sb),
   _Got(_Sb == 0),
   _Val(0)
  {
  }

 istreambuf_iterator(istream_type& _Istr) noexcept
  : _Strbuf(_Istr.rdbuf()),
   _Got(_Istr.rdbuf() == 0),
   _Val(0)
  {
  }

 _Elem operator*() const
  {
  if (!_Got)
   _Peek();






  return (_Val);
  }

 const _Elem *operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {





  _Inc();
  return (*this);
  }

 _Myt operator++(int)
  {
  if (!_Got)
   _Peek();
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 bool equal(const _Myt& _Right) const
  {
  bool _Lvalid = _Strbuf != 0
   && !traits_type::eq_int_type(traits_type::eof(),
    _Strbuf->sgetc());
  bool _Rvalid = _Right._Strbuf != 0
   && !traits_type::eq_int_type(traits_type::eof(),
    _Right._Strbuf->sgetc());
  return (_Lvalid == _Rvalid);
  }

private:
 void _Inc()
  {
  if (_Strbuf == 0
   || traits_type::eq_int_type(traits_type::eof(),
    _Strbuf->sbumpc()))
   _Strbuf = 0, _Got = true;
  else
   _Got = false;
  }

 _Elem _Peek() const
  {
  int_type _Meta;
  if (_Strbuf == 0
   || traits_type::eq_int_type(traits_type::eof(),
    _Meta = _Strbuf->sgetc()))
   _Strbuf = 0;
  else
   _Val = traits_type::to_char_type(_Meta);
  _Got = true;
  return (_Val);
  }

 mutable streambuf_type *_Strbuf;
 mutable bool _Got;
 mutable _Elem _Val;
 };

template<class _Elem,
 class _Traits>
 struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
  : public true_type
 {
 };


template<class _Elem,
 class _Traits> inline
 bool operator==(
  const istreambuf_iterator<_Elem, _Traits>& _Left,
  const istreambuf_iterator<_Elem, _Traits>& _Right)
 {
 return (_Left.equal(_Right));
 }

template<class _Elem,
 class _Traits> inline
 bool operator!=(
  const istreambuf_iterator<_Elem, _Traits>& _Left,
  const istreambuf_iterator<_Elem, _Traits>& _Right)
 {
 return (!(_Left == _Right));
 }


template<class _Elem,
 class _Traits>
 class ostreambuf_iterator
  : public _Outit
 {
 typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf<_Elem, _Traits> streambuf_type;
 typedef basic_ostream<_Elem, _Traits> ostream_type;

 ostreambuf_iterator(streambuf_type *_Sb) noexcept
  : _Failed(false), _Strbuf(_Sb)
  {
  }

 ostreambuf_iterator(ostream_type& _Ostr) noexcept
  : _Failed(false), _Strbuf(_Ostr.rdbuf())
  {
  }

 _Myt& operator=(_Elem _Right)
  {
  if (_Strbuf == 0
   || traits_type::eq_int_type(_Traits::eof(),
    _Strbuf->sputc(_Right)))
   _Failed = true;
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt& operator++(int)
  {
  return (*this);
  }

 bool failed() const noexcept
  {
  return (_Failed);
  }

private:
 bool _Failed;
 streambuf_type *_Strbuf;
 };

template<class _Elem,
 class _Traits>
 struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
  : public true_type
 {
 };
}


#pragma clang diagnostic pop
# 15 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocnum" 2 3



extern "C" {
extern float _Stofx(const char *, char **,
 long, int *);
extern double _Stodx(const char *, char **,
 long, int *);
extern long double _Stoldx(const char *, char **,
 long, int *);
extern long _Stolx(const char *, char **,
 int, int *);
extern unsigned long _Stoulx(const char *, char **,
 int, int *);
extern long long _Stollx(const char *, char **,
 int, int *);
extern unsigned long long _Stoullx(const char *, char **,
 int, int *);
}


namespace std {



template<class _Elem> inline
 size_t _Find_elem(_Elem *_Base, _Elem _Ch)
 {
 _Elem *_Ptr = _Base;
 for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
  ;
 return ((size_t)(_Ptr - _Base));
 }

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
 {
 size_t _Count = :: wcslen(_Ptr) + 1;
 wchar_t *_Ptrdest = (wchar_t *):: malloc(_Count * sizeof (wchar_t));
 if (!_Ptrdest)
  _Xbad_alloc();
 :: wmemcpy(_Ptrdest, _Ptr, _Count);
 return (_Ptrdest);
 }


template<class _Elem>
 class numpunct
  : public locale::facet
 {
public:
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  string_type;
 typedef _Elem char_type;

 static locale::id id;

 _Elem decimal_point() const
  {
  return (do_decimal_point());
  }

 _Elem thousands_sep() const
  {
  return (do_thousands_sep());
  }

 string grouping() const
  {
  return (do_grouping());
  }

 string_type falsename() const
  {
  return (do_falsename());
  }

 string_type truename() const
  {
  return (do_truename());
  }

 explicit numpunct(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
   if (_Kseparator == 0)
    _Kseparator =
     _Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
  }
  }

 numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
  : locale::facet(_Refs)
  {
  _Init(_Lobj, _Isdef);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new numpunct<_Elem>(
    _Locinfo(_Ploc->c_str()), 0, true);
  return (4);
  }

protected:
 virtual ~numpunct() noexcept
  {
  _Tidy();
  }

 numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
  : locale::facet(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj(_Locname);
   _Init(_Lobj, _Isdef);
  }
  }

 template<class _Elem2>
  void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
  {
  _Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
  _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
  }

 void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
  {
  const lconv *_Ptr = _Lobj._Getlconv();
  _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();

  _Grouping = 0;
  _Falsename = 0;
  _Truename = 0;

  {{
  _Grouping = _Makloc<_Elem>::Grouping(_Cvt);
  _Falsename = _Makloc<_Elem>::Falsename(_Cvt);
  _Truename = _Makloc<_Elem>::Truename(_Cvt);
  } if (0) {
  _Tidy();
          ;
  }}

  if (_Isdef)
   {

   _Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
   _Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
   }
  else
   _Getvals((_Elem)0, _Ptr, _Cvt);
  }

 virtual _Elem do_decimal_point() const
  {
  return (_Dp);
  }

 virtual _Elem do_thousands_sep() const
  {
  return (_Kseparator);
  }

 virtual string do_grouping() const
  {
  return (string(_Grouping));
  }

 virtual string_type do_falsename() const
  {
  return (string_type(_Falsename));
  }

 virtual string_type do_truename() const
  {
  return (string_type(_Truename));
  }

private:
 void _Tidy()
  {
  _Makloc<_Elem>::destroy(const_cast<char *>(_Grouping));
  _Makloc<_Elem>::destroy(const_cast<_Elem *>(_Falsename));
  _Makloc<_Elem>::destroy(const_cast<_Elem *>(_Truename));
 }

 const char *_Grouping;
 _Elem _Dp;
 _Elem _Kseparator;
 const _Elem *_Falsename;
 const _Elem *_Truename;
 };


template<class _Elem>
 class numpunct_byname
  : public numpunct<_Elem>
 {
public:
 explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
  : numpunct<_Elem>(_Locname, _Refs)
  {
  }

 explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
  : numpunct<_Elem>(_Str.c_str(), _Refs)
  {
  }

 explicit numpunct_byname(const _Locinfo& _Lobj, size_t _Refs = 0)
  : numpunct<_Elem>(_Lobj, _Refs)
  {
  }

protected:
 virtual ~numpunct_byname() noexcept
  {
  }
 };


template<class _Elem>
 locale::id numpunct<_Elem>::id;

extern template class numpunct<char>;
extern template class numpunct<wchar_t>;


template<class _Elem,
 class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
 class num_get
  : public locale::facet
 {
public:
 typedef numpunct<_Elem> _Mypunct;
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  _Mystr;

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new num_get<_Elem, _InIt>(
    _Locinfo(_Ploc->c_str()));
  return (4);
  }

 static locale::id id;

protected:
 virtual ~num_get() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

public:
 explicit num_get(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  _Init(_Lobj);
  }

 typedef _Elem char_type;
 typedef _InIt iter_type;

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   bool& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned short& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned int& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }


 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }


 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   float& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   double& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long double& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   void *& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

protected:
 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   bool& _Val) const
  {
                             ;
  int _Ans = -1;

  if (_Iosbase.flags() & ios_base::boolalpha)
   {
   typedef typename _Mystr::size_type _Mystrsize;
   const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
   _Mystr _Str((_Mystrsize)1, (char_type)0);
   _Str += _Punct_fac.falsename();
   _Str += (char_type)0;
   _Str += _Punct_fac.truename();
   _Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
   }
  else
   {
   char _Ac[32], *_Ep;
   int _Errno = 0;
   const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
    _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
     _Iosbase.getloc()), &_Errno);
   if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
    _Ans = _Ulo;
   }

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ans < 0)
   {
   _State |= ios_base::failbit;
   _Val = true;
   }
  else
   _Val = _Ans != 0;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned short& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
   _Iosbase.getloc());
  char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ptr || (_Ac[0] == '-' && _Ans != 0))
   {
   _State |= ios_base::failbit;
   _Val = 0;
   }
  else if (_Errno != 0 || 0xffff < _Ans)
   {
   _State |= ios_base::failbit;
   _Val = 0xffff;
   }
  else
   _Val = (unsigned short)(_Ans);
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned int& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
   _Iosbase.getloc());
  char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ptr || (_Ac[0] == '-' && _Ans != 0))
   {
   _State |= ios_base::failbit;
   _Val = 0;
   }
  else if (_Errno != 0 || 0xffffffff < _Ans)
   {
   _State |= ios_base::failbit;
   _Val = 0xffffffff;
   }
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const long _Ans = :: _Stolx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  _Val = _Ans;
  if (_Ep == _Ac || (_Ac[0] == '-' && _Ans != 0))
   {
   _State |= ios_base::failbit;
   _Val = 0;
   }
  else if (_Errno != 0)
   _State |= ios_base::failbit;
  return (_First);
  }


 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const long long _Ans = :: _Stollx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const unsigned long long _Ans = :: _Stoullx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  _Val = _Ans;
  if (_Ep == _Ac || (_Ac[0] == '-' && _Ans != 0))
   {
   _State |= ios_base::failbit;
   _Val = 0;
   }
  else if (_Errno != 0)
   _State |= ios_base::failbit;
  return (_First);
  }


 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   float& _Val) const
  {
                             ;
  char _Ac[8 + 48 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  float _Ans = :: _Stofx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexpf(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   double& _Val) const
  {
                             ;
  char _Ac[8 + 48 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  double _Ans = :: _Stodx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexp(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long double& _Val) const
  {
                             ;
  char _Ac[8 + 48 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  long double _Ans = :: _Stoldx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexpl(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   void *& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;


  int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
   _Iosbase.getloc());
  const unsigned long long _Ans =
   (sizeof (void *) == sizeof (unsigned long))
    ? (unsigned long long):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
    : :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);







  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  _Val = (void *)((char *)0 + _Ans);
  return (_First);
  }

private:
 int _Getifld(char *_Ac,
  _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
   const locale& _Loc) const
  {
  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
  const string _Grouping = _Punct_fac.grouping();
  const _Elem _Kseparator = _Grouping.size() == 0
   ? (_Elem)0 : _Punct_fac.thousands_sep();

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24};
  static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Loc);
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  char *_Ptr = _Ac;

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  _Basefield &= ios_base::basefield;
  int _Base = _Basefield == ios_base::oct ? 8
   : _Basefield == ios_base::hex ? 16
   : _Basefield == ios_base::_Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if (_First != _Last && *_First == _Atoms[0])
   {
   _Seendigit = true, ++_First;
   if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
     || *_First == _Atoms[_NUMGET_XOFF])
    && (_Base == 0 || _Base == 16))
    _Base = 16, _Seendigit = false, ++_First;
   else if (_Base == 0)
    _Base = 8;
   }

  size_t _Dlen = _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6;
  string _Groups((size_t)1, (char)_Seendigit);
  size_t _Group = 0;

  for (char *const _Pe = &_Ac[32 - 1];
   _First != _Last; ++_First)
   {
   size_t _Idx = _Find_elem(_Atoms, *_First);
   if (_Idx < _Dlen)
    {
    *_Ptr = _Src[_Idx];
    if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
     ++_Ptr, _Nonzero = true;
    _Seendigit = true;
    if (_Groups[_Group] != 0x7f)
     ++_Groups[_Group];
    }
   else if (_Groups[_Group] == '\0'
    || _Kseparator == (_Elem)0
    || *_First != _Kseparator)
    break;
   else
    {
    _Groups.append((string::size_type)1, '\0');
    ++_Group;
    }
   }

  if (_Group == 0)
   ;
  else if ('\0' < _Groups[_Group])
   ++_Group;
  else
   _Seendigit = false;

  for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
   if (*_Pg == 0x7f)
    break;
   else if ((0 < --_Group && *_Pg != _Groups[_Group])
    || (0 == _Group && *_Pg < _Groups[_Group]))
    _Seendigit = false;
   else if ('\0' < _Pg[1])
    ++_Pg;

  if (_Seendigit && !_Nonzero)
   *_Ptr++ = '0';
  else if (!_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  return (_Base);
  }

 int _Getffld(char *_Ac,
  _InIt& _First, _InIt &_Last,
  ios_base& _Iosbase, int *_Phexexp) const
  {
  if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
   return (_Getffldx(_Ac, _First, _Last,
    _Iosbase, _Phexexp));

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  char *_Ptr = _Ac;
  bool _Bad = false;
  bool _Sticky = false;

  enum {
   _NUMGET_SIGNOFF = 10,
   _NUMGET_EOFF = 12};
  static const char _Src[] = {"0123456789-+Ee"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  char *_Leading = _Ptr;
  *_Ptr++ = '0';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;
  size_t _Idx;

  const char *_Pg = &_Grouping[0];
  if (*_Pg == 0x7f || *_Pg <= '\0')
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
     _Seendigit = true, ++_First)
    if (48 <= _Significant)
     {
     ++_Pten;
     if (0 < _Idx)
      _Sticky = true;
     }
    else if (_Idx == 0 && _Significant == 0)
     ;
    else
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping.size() == 0
    ? (_Elem)0 : _Punct_fac.thousands_sep();
   string _Groups((size_t)1, '\0');
   size_t _Group = 0;

   for (; _First != _Last; ++_First)
    if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
     {
     _Seendigit = true;
     if (48 <= _Significant)
      {
      ++_Pten;
      if (0 < _Idx)
       _Sticky = true;
      }
     else if (_Idx == 0 && _Significant == 0)
      ;
     else
      {
      *_Ptr++ = _Src[_Idx];
      ++_Significant;
      }
     if (_Groups[_Group] != 0x7f)
      ++_Groups[_Group];
     }
    else if (_Groups[_Group] == '\0'
     || _Kseparator == (_Elem)0
     || *_First != _Kseparator)
     break;
    else
     {
     _Groups.append((size_t)1, '\0');
     ++_Group;
     }
   if (_Group == 0)
    ;
   else if ('\0' < _Groups[_Group])
    ++_Group;
   else
    _Bad = true;

   while (!_Bad && 0 < _Group)
    if (*_Pg == 0x7f)
     break;
    else if ((0 < --_Group && *_Pg != _Groups[_Group])
     || (0 == _Group && *_Pg < _Groups[_Group]))
     _Bad = true;
    else if ('\0' < _Pg[1])
     ++_Pg;
   }

  if (_First != _Last && *_First == _Punct_fac.decimal_point())
   *_Ptr++ = localeconv()->decimal_point[0], ++_First;

  if (_Significant == 0)
   {
   for (; _First != _Last && *_First == _Atoms[0];
    _Seendigit = true, ++_First)
    --_Pten;
   if (_Pten < 0)
    *_Ptr++ = '0', ++_Pten;
   }

  for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
    _Seendigit = true, ++_First)
   if (_Significant < 48)
    {
    *_Ptr++ = _Src[_Idx];
    ++_Significant;
    }
   else if (0 < _Idx)
    _Sticky = true;

  if (_Sticky)
   {
   char *_Px = _Ptr;
   for (; --_Px != _Leading; )
    {
    if (*_Px == localeconv()->decimal_point[0])
     ;
    else if (*_Px != '9')
     {
     ++*_Px;
     break;
     }
    else
     *_Px = '0';
    }

   if (_Px == _Leading)
    {
    *_Px = '1';
    ++_Pten;
    }
   }

  if (_Seendigit && _First != _Last
   && (*_First == _Atoms[_NUMGET_EOFF + 1]
    || *_First == _Atoms[_NUMGET_EOFF]))
   {
   *_Ptr++ = 'e', ++_First;
   _Seendigit = false, _Significant = 0;

   if (_First == _Last)
    ;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
    *_Ptr++ = '+', ++_First;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF])
    *_Ptr++ = '-', ++_First;
   for (; _First != _Last && *_First == _Atoms[0]; )
    _Seendigit = true, ++_First;
   if (_Seendigit)
    *_Ptr++ = '0';
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
    _Seendigit = true, ++_First)
    if (_Significant < 8)
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
   }

  if (_Bad || !_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  return (_Pten);
  }

 int _Getffldx(char *_Ac,
  _InIt& _First, _InIt &_Last,
  ios_base& _Iosbase, int *_Phexexp) const
  {
  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24,
   _NUMGET_POFF = 26};
  static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
  _Elem _Atoms[sizeof (_Src)];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

  char *_Ptr = _Ac;
  bool _Bad = false;
  size_t _Idx;

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  *_Ptr++ = '0';
  *_Ptr++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if (_First == _Last || *_First != _Atoms[0])
   ;
  else if (++_First != _Last
   && (*_First == _Atoms[_NUMGET_XOFF + 1]
    || *_First == _Atoms[_NUMGET_XOFF]))
   ++_First;
  else
   _Seendigit = true;

  const char *_Pg = &_Grouping[0];
  if (*_Pg == 0x7f || *_Pg <= '\0')
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
     _Seendigit = true, ++_First)
    if (48 <= _Significant)
     ++_Phex;
    else if (_Idx == 0 && _Significant == 0)
     ;
    else
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping.size() == 0
    ? (_Elem)0 : _Punct_fac.thousands_sep();
   string _Groups((size_t)1, '\0');
   size_t _Group = 0;

   for (; _First != _Last; ++_First)
    if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
     {
     _Seendigit = true;
     if (48 <= _Significant)
      ++_Phex;
     else if (_Idx == 0 && _Significant == 0)
      ;
     else
      {
      *_Ptr++ = _Src[_Idx];
      ++_Significant;
      }
     if (_Groups[_Group] != 0x7f)
      ++_Groups[_Group];
     }
    else if (_Groups[_Group] == '\0'
     || _Kseparator == (_Elem)0
     || *_First != _Kseparator)
     break;
    else
     {
     _Groups.append((size_t)1, '\0');
     ++_Group;
     }
   if (_Group == 0)
    ;
   else if ('\0' < _Groups[_Group])
    ++_Group;
   else
    _Bad = true;

   while (!_Bad && 0 < _Group)
    if (*_Pg == 0x7f)
     break;
    else if ((0 < --_Group && *_Pg != _Groups[_Group])
     || (0 == _Group && *_Pg < _Groups[_Group]))
     _Bad = true;
    else if ('\0' < _Pg[1])
     ++_Pg;
   }

  if (_Seendigit && _Significant == 0)
   *_Ptr++ = '0';

  if (_First != _Last && *_First == _Punct_fac.decimal_point())
   *_Ptr++ = localeconv()->decimal_point[0], ++_First;

  if (_Significant == 0)
   {
   for (; _First != _Last && *_First == _Atoms[0];
    _Seendigit = true, ++_First)
    --_Phex;
   if (_Phex < 0)
    *_Ptr++ = '0', ++_Phex;
   }

  for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++_First)
   if (_Significant < 48)
    {
    *_Ptr++ = _Src[_Idx];
    ++_Significant;
    }

  if (_Seendigit && _First != _Last
   && (*_First == _Atoms[_NUMGET_POFF + 1]
    || *_First == _Atoms[_NUMGET_POFF]))
   {
   *_Ptr++ = 'p', ++_First;
   _Seendigit = false, _Significant = 0;

   if (_First == _Last)
    ;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
    *_Ptr++ = '+', ++_First;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF])
    *_Ptr++ = '-', ++_First;
   for (; _First != _Last && *_First == _Atoms[0]; )
    _Seendigit = true, ++_First;
   if (_Seendigit)
    *_Ptr++ = '0';
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++_First)
    if (_Significant < 8)
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
   }

  if (_Bad || !_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  *_Phexexp = _Phex;
  return (0);
  }
 };


template<class _Elem,
 class _InIt>
 locale::id num_get<_Elem, _InIt>::id;

extern template class num_get<char>;
extern template class num_get<wchar_t>;


template<class _Elem,
 class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
 class num_put
  : public locale::facet
 {
public:
 typedef numpunct<_Elem> _Mypunct;
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  _Mystr;

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new num_put<_Elem, _OutIt>(
    _Locinfo(_Ploc->c_str()));
  return (4);
  }

 static locale::id id;

protected:
 virtual ~num_put() noexcept
  {
  }

 void _Init(const _Locinfo&)
  {
  }

public:
 explicit num_put(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  {::std:: _Lockit _Lock(0); _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  _Init(_Lobj);
  }

 typedef _Elem char_type;
 typedef _OutIt iter_type;

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, bool _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }


 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }


 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, double _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long double _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

protected:
 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, bool _Val) const
  {
                       ;
  if (!(_Iosbase.flags() & ios_base::boolalpha))
   return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
  else
   {
   const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
   _Mystr _Str;
   if (_Val)
    _Str.assign(_Punct_fac.truename());
   else
    _Str.assign(_Punct_fac.falsename());

   size_t _Fillcount = _Iosbase.width() <= 0
    || (size_t)_Iosbase.width() <= _Str.size()
     ? 0 : (size_t)_Iosbase.width() - _Str.size();

   if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
    {
    _Dest = _Rep(_Dest, _Fill, _Fillcount);
    _Fillcount = 0;
    }
   _Dest = _Put(_Dest, _Str.c_str(), _Str.size());
   _Iosbase.width(0);
   return (_Rep(_Dest, _Fill, _Fillcount));
   }
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long _Val) const
  {
  char _Buf[2 * 32], _Fmt[6];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf),_Ifmt(_Fmt, "ld",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
  {
  char _Buf[2 * 32], _Fmt[6];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf),_Ifmt(_Fmt, "lu",
    _Iosbase.flags()), _Val)));
  }


 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long long _Val) const
  {
  char _Buf[2 * 32], _Fmt[8];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
  {
  char _Buf[2 * 32], _Fmt[8];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu",
    _Iosbase.flags()), _Val)));
  }


 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, double _Val) const
  {
  string _Buf;
  char _Fmt[8];
  bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
   == ios_base::fixed;
  bool _Ishex = (_Iosbase.flags() & ios_base::floatfield)
   == (ios_base::fixed | ios_base::scientific);
  streamsize _Precision = _Ishex ? 6 : _Iosbase.precision();
  size_t _Bufsize = (size_t)_Precision;
  if (_Isfixed && 1e10 < :: fabs(_Val))
   {
   int _Ptwo;
   (void):: frexp(_Val, &_Ptwo);
   _Bufsize += (:: abs)(_Ptwo) * 30103L / 100000L;
   }
  _Buf.resize(_Bufsize + 50);

  int _Ngen = :: snprintf((char *)_Buf.c_str(), _Bufsize + 50,
   _Ffmt(_Fmt, 0, _Iosbase.flags()), _Precision, _Val);
  return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long double _Val) const
  {
  string _Buf;
  char _Fmt[8];
  bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
   == ios_base::fixed;
  bool _Ishex = (_Iosbase.flags() & ios_base::floatfield)
   == (ios_base::fixed | ios_base::scientific);
  streamsize _Precision = _Ishex
   ? 6 : _Iosbase.precision();
  size_t _Bufsize = (size_t)_Precision;
  if (_Isfixed && 1e10 < :: fabsl(_Val))
   {
   int _Ptwo;
   (void):: frexpl(_Val, &_Ptwo);
   _Bufsize += (:: abs)(_Ptwo) * 30103L / 100000L;
   }
  _Buf.resize(_Bufsize + 50);

  int _Ngen = :: snprintf((char *)_Buf.c_str(), _Bufsize + 50,
   _Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);
  return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
  {
  char _Buf[2 * 32];
  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   (size_t):: snprintf(_Buf, sizeof(_Buf), "%p", _Val)));
  }

private:
 char *_Ffmt(char *_Fmt,
  char _Spec, ios_base::fmtflags _Flags) const
  {
  char *_Ptr = _Fmt;
  *_Ptr++ = '%';

  if (_Flags & ios_base::showpos)
   *_Ptr++ = '+';
  if (_Flags & ios_base::showpoint)
   *_Ptr++ = '#';
  if ((_Flags & ios_base::floatfield) != (ios_base::fixed | ios_base::scientific))
   {
   *_Ptr++ = '.';
   *_Ptr++ = '*';
   }
  if (_Spec != '\0')
   *_Ptr++ = _Spec;

  ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
  if (_Flags & ios_base::uppercase)
   *_Ptr++ = _Ffl == ios_base::fixed ? 'f'
    : _Ffl == ios_base::hexfloat ? 'A'
    : _Ffl == ios_base::scientific ? 'E' : 'G';
  else
   *_Ptr++ = _Ffl == ios_base::fixed ? 'f'
    : _Ffl == ios_base::hexfloat ? 'a'
    : _Ffl == ios_base::scientific ? 'e' : 'g';

  *_Ptr = '\0';
  return (_Fmt);
  }

 _OutIt _Fput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
   size_t _Beforepoint, size_t _Afterpoint,
    size_t _Trailing, size_t _Count) const
  {
                       ;
  size_t _Prefix = 0;
  if (0 < _Count && (*_Buf == '+' || *_Buf == '-'))
   _Prefix = 1;
  else if (2 <= _Count && _Buf[0] == '0'
   && (_Buf[1] == 'x' || _Buf[1] == 'X'))
   _Prefix = 2;
  bool _Isnan_inf = _Buf[_Prefix] == 'i' || _Buf[_Prefix] == 'I'
   || _Buf[_Prefix] == 'n' || _Buf[_Prefix] == 'N';
  const char *_Exps;
  if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
   _Exps = "eE";
  else
   {
   _Exps = "pP";
   }
  const size_t _Eoff =
   :: strcspn(&_Buf[0], _Exps);
  char _Dp[2] = {"."};
  _Dp[0] = :: localeconv()->decimal_point[0];
  const size_t _Poff =
   :: strcspn(&_Buf[0], &_Dp[0]);

  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  const _Elem _E0 = _Ctype_fac.widen('0');
  _Mystr _Groupstring(_Count, _Elem(0));
  _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  const _Elem _Kseparator = _Punct_fac.thousands_sep();

  size_t _Off = _Beforepoint;
  if (_Poff == _Count)
   {
   _Off += _Eoff;
   _Groupstring.insert(_Eoff, _Beforepoint, _E0);
   }
  else
   {
   _Off += _Poff;
   _Groupstring.insert(_Eoff, _Trailing, _E0);
   _Groupstring.insert(_Poff + 1, _Afterpoint, _E0);
   _Groupstring[_Poff] = _Punct_fac.decimal_point();
   _Groupstring.insert(_Poff, _Beforepoint, _E0);
   }

  const char *_Pg = &_Grouping[0];
  while (*_Pg != 0x7f && '\0' < *_Pg
   && (size_t)*_Pg < _Off - _Prefix
   && !_Isnan_inf)
   {
   _Groupstring.insert(_Off -= (size_t)*_Pg, (size_t)1, _Kseparator);
   if ('\0' < _Pg[1])
    ++_Pg;
   }

  _Count = _Groupstring.size();
  size_t _Fillcount = _Iosbase.width() <= 0
   || (size_t)_Iosbase.width() <= _Count
    ? 0 : (size_t)_Iosbase.width() - _Count;

  ios_base::fmtflags _Adjustfield =
   _Iosbase.flags() & ios_base::adjustfield;
  if (_Adjustfield != ios_base::left
   && _Adjustfield != ios_base::internal)
   {
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   }
  else if (_Adjustfield == ios_base::internal)
   {
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   }
  else
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
  _Iosbase.width(0);
  return (_Rep(_Dest, _Fill, _Fillcount));
  }

 _OutIt _Fput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
   size_t _Count) const
  {
  return _Fput(_Dest, _Iosbase, _Fill, _Buf, 0, 0, 0, _Count);
  }

 char *_Ifmt(char *_Fmt,
  const char *_Spec, ios_base::fmtflags _Flags) const
  {
  char *_Ptr = _Fmt;
  *_Ptr++ = '%';

  if (_Flags & ios_base::showpos)
   *_Ptr++ = '+';
  if (_Flags & ios_base::showbase)
   *_Ptr++ = '#';
  if (_Spec[0] != 'L')
   *_Ptr++ = _Spec[0];
  else


   {
   *_Ptr++ = 'l';
   *_Ptr++ = 'l';
   }
# 1506 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xlocnum" 3
  ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
  *_Ptr++ = _Basefield == ios_base::oct ? 'o'
   : _Basefield != ios_base::hex ? _Spec[1]
   : _Flags & ios_base::uppercase ? 'X' : 'x';
  *_Ptr = '\0';
  return (_Fmt);
  }

 _OutIt _Iput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
  {
                       ;
  size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
   ? 1 : 0;
  if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
   && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
   && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
   _Prefix += 2;

  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Mystr _Groupstring(_Count, _Elem(0));
  _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  const char *_Pg = &_Grouping[0];
  if (*_Pg != 0x7f && '\0' < *_Pg)
   {
   const _Elem _Kseparator = _Punct_fac.thousands_sep();
   while (*_Pg != 0x7f && '\0' < *_Pg
    && (size_t)*_Pg < _Count - _Prefix)
    {
    _Count -= (size_t)*_Pg;
    _Groupstring.insert(_Count, 1, _Kseparator);
    if ('\0' < _Pg[1])
     ++_Pg;
    }
   }

  _Count = _Groupstring.size();
  size_t _Fillcount = _Iosbase.width() <= 0
   || (size_t)_Iosbase.width() <= _Count
    ? 0 : (size_t)_Iosbase.width() - _Count;

  ios_base::fmtflags _Adjustfield =
   _Iosbase.flags() & ios_base::adjustfield;
  if (_Adjustfield != ios_base::left
   && _Adjustfield != ios_base::internal)
   {
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   }
  else if (_Adjustfield == ios_base::internal)
   {
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   }
  else
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
  _Iosbase.width(0);
  return (_Rep(_Dest, _Fill, _Fillcount));
  }

 _OutIt _Put(_OutIt _Dest,
  const _Elem *_Ptr, size_t _Count) const
  {
  for (; 0 < _Count; --_Count, ++_Dest, (void)++_Ptr)
   *_Dest = *_Ptr;
  return (_Dest);
  }

 _OutIt _Rep(_OutIt _Dest,
  _Elem _Ch, size_t _Count) const
  {
  for (; 0 < _Count; --_Count, ++_Dest)
   *_Dest = _Ch;
  return (_Dest);
  }
 };


template<class _Elem,
 class _OutIt>
 locale::id num_put<_Elem, _OutIt>::id;

extern template class num_put<char>;
extern template class num_put<wchar_t>;

}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ios" 2 3

namespace std {

template<class _Elem,
 class _Traits>
 class basic_ios
  : public ios_base
 {
public:
 typedef basic_ios<_Elem, _Traits> _Myt;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef ctype<_Elem> _Ctype;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 explicit basic_ios(_Mysb *_Strbuf)
  {
  init(_Strbuf);
  }

 virtual ~basic_ios() noexcept
  {
  }

 void clear(iostate _State = goodbit,
  bool _Reraise = false)
  {
  ios_base::clear((iostate)(_Mystrbuf == 0
   ? (int)_State | (int)badbit : (int)_State), _Reraise);
  }

 void clear(io_state _State)
  {
  clear((iostate)_State);
  }

 void setstate(iostate _State,
  bool _Reraise = false)
  {
  clear((iostate)((int)rdstate() | (int)_State), _Reraise);
  }

 void setstate(io_state _State)
  {
  setstate((iostate)_State);
  }

 _Myt& copyfmt(const _Myt& _Right)
  {
  _Tiestr = _Right.tie();
  _Fillch = _Right.fill();
  ios_base::copyfmt(_Right);
  return (*this);
  }

 _Myos *tie() const
  {
  return (_Tiestr);
  }

 _Myos *tie(_Myos *_Newtie)
  {
  _Myos *_Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return (_Oldtie);
  }

 _Mysb *rdbuf() const
  {
  return (_Mystrbuf);
  }

 _Mysb *rdbuf(_Mysb *_Strbuf)
  {
  _Mysb *_Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear();
  return (_Oldstrbuf);
  }

 locale imbue(const locale& _Loc)
  {
  locale _Oldlocale = ios_base::imbue(_Loc);
  if (rdbuf() != 0)
   rdbuf()->pubimbue(_Loc);
  return (_Oldlocale);
  }

 _Elem fill() const
  {
  return (_Fillch);
  }

 _Elem fill(_Elem _Newfill)
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return (_Oldfill);
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
  return (_Ctype_fac.narrow(_Ch, _Dflt));
  }

 _Elem widen(char _Byte) const
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
  return (_Ctype_fac.widen(_Byte));
  }

protected:
 void move(_Myt& _Right)
  {
  if (this != &_Right)
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this->swap(_Right);
   }
  }

 void move(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this->swap(_Right);
   }
  }

 void swap(_Myt& _Right) noexcept
  {
  ios_base::swap(_Right);
  ::std:: swap(_Fillch, _Right._Fillch);
  ::std:: swap(_Tiestr, _Right._Tiestr);
  }

 void set_rdbuf(_Mysb *_Strbuf)
  {
  _Mystrbuf = _Strbuf;
  }

 void init(_Mysb *_Strbuf = 0,
  bool _Isstd = false)
  {
  _Init();
  _Mystrbuf = _Strbuf;
  _Tiestr = 0;
  _Fillch = widen(' ');

  if (_Mystrbuf == 0)
   setstate(badbit);

  if (_Isstd)
   _Addstd(this);
  }

 basic_ios()
  {
  }

private:
 _Mysb *_Mystrbuf;
 _Myos *_Tiestr;
 _Elem _Fillch;

public:
 basic_ios(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;
 };


inline ios_base& boolalpha(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::boolalpha);
 return (_Iosbase);
 }

inline ios_base& dec(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::dec, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& defaultfloat(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& fixed(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& hex(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::hex, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& hexfloat(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
 return (_Iosbase);
 }







inline ios_base& internal(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& left(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::left, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& noboolalpha(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::boolalpha);
 return (_Iosbase);
 }

inline ios_base& noshowbase(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showbase);
 return (_Iosbase);
 }

inline ios_base& noshowpoint(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showpoint);
 return (_Iosbase);
 }

inline ios_base& noshowpos(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showpos);
 return (_Iosbase);
 }

inline ios_base& noskipws(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::skipws);
 return (_Iosbase);
 }

inline ios_base& nounitbuf(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::unitbuf);
 return (_Iosbase);
 }

inline ios_base& nouppercase(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::uppercase);
 return (_Iosbase);
 }

inline ios_base& oct(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::oct, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& right(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::right, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& scientific(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& showbase(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showbase);
 return (_Iosbase);
 }

inline ios_base& showpoint(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showpoint);
 return (_Iosbase);
 }

inline ios_base& showpos(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showpos);
 return (_Iosbase);
 }

inline ios_base& skipws(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::skipws);
 return (_Iosbase);
 }

inline ios_base& unitbuf(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::unitbuf);
 return (_Iosbase);
 }

inline ios_base& uppercase(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::uppercase);
 return (_Iosbase);
 }
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 2 3


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 3
template<class _Elem,
 class _Traits>
 class basic_ostream
  : virtual public basic_ios<_Elem, _Traits>
 {
public:
 typedef basic_ostream<_Elem, _Traits> _Myt;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
 typedef num_put<_Elem, _Iter> _Nput;


 explicit basic_ostream(
  basic_streambuf<_Elem, _Traits> *_Strbuf = 0,






  bool _Isstd = false)
  {
  _Myios::init(_Strbuf, _Isstd);
  }

 basic_ostream(_Uninitialized, bool _Addit = true)
  {
  if (_Addit)
   this->_Addstd(this);
  }

protected:
 basic_ostream(_Myt&& _Right)
  {
  _Myios::init();
  _Myios::move(::std:: move(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   _Myios::swap(_Right);
  }

public:
 basic_ostream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_ostream() noexcept
  {
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 class _Sentry_base
  {
 public:
  _Sentry_base(_Myt& _Ostr)
   : _Myostr(_Ostr)
   {
   if (_Myostr.rdbuf() != 0)
    _Myostr.rdbuf()->_Lock();
   }

  ~_Sentry_base() noexcept
   {
   if (_Myostr.rdbuf() != 0)
    _Myostr.rdbuf()->_Unlock();
   }

  _Myt& _Myostr;

 private:
  _Sentry_base& operator=(const _Sentry_base&);
  };

 class sentry
  : public _Sentry_base
  {
 public:
  explicit sentry(_Myt& _Ostr)
   : _Sentry_base(_Ostr)
   {
   if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
    _Ostr.tie()->flush();
   _Ok = _Ostr.good();
   }

  ~sentry() noexcept
   {
   if (!::std:: uncaught_exception())
    this->_Myostr._Osfx();
   }


        int _No_bool_decl;


  explicit operator bool() const
   {
   return (_Ok);
   }

  sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;

 private:
  bool _Ok;
  };

 bool opfx()
  {
  if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
   _Myios::tie()->flush();
  return (this->good());
  }

 void osfx()
  {
  _Osfx();
  }

 void _Osfx()
  {
  {{
  if (this->good() && this->flags() & ios_base::unitbuf)
   if (_Myios::rdbuf()->pubsync() == -1)
    _Myios::setstate(ios_base::badbit);
  } if (0) {
  }}
  }

 _Myt& operator<<(_Myt& (*_Pfn)(_Myt&))
  {
                      ;
  return ((*_Pfn)(*this));
  }

 _Myt& operator<<(_Myios& (*_Pfn)(_Myios&))
  {
                      ;
  (*_Pfn)(*(_Myios *)this);
  return (*this);
  }

 _Myt& operator<<(ios_base& (*_Pfn)(ios_base&))
  {
                      ;
  (*_Pfn)(*(ios_base *)this);
  return (*this);
  }

           _Myt& operator<<(bool _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(short _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
   ios_base::fmtflags _Bfl =
    this->flags() & ios_base::basefield;
   long _Tmp = (_Bfl == ios_base::oct
    || _Bfl == ios_base::hex)
    ? (long)(unsigned short)_Val : (long)_Val;

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Tmp).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(unsigned short _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (unsigned long)_Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(int _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
   ios_base::fmtflags _Bfl =
    this->flags() & ios_base::basefield;
   long _Tmp = (_Bfl == ios_base::oct
    || _Bfl == ios_base::hex)
    ? (long)(unsigned int)_Val : (long)_Val;

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Tmp).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(unsigned int _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (unsigned long)_Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(unsigned long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }


           _Myt& operator<<(long long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(unsigned long long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }


           _Myt& operator<<(float _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (double)_Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(double _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(long double _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(const void *_Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   {{
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator<<(_Mysb *_Strbuf)
  {
  ios_base::iostate _State = ios_base::goodbit;
  bool _Copied = false;
  const sentry _Ok(*this);

  if (_Ok && _Strbuf != 0)
   for (int_type _Meta = _Traits::eof(); ; _Copied = true)
    {
    {{
    _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
     ? _Strbuf->sgetc() : _Strbuf->snextc();
    } if (0) {
     _Myios::setstate(ios_base::failbit);
             ;
    }}

    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     break;

    {{
     if (_Traits::eq_int_type(_Traits::eof(),
      _Myios::rdbuf()->sputc(
       _Traits::to_char_type(_Meta))))
      {
      _State |= ios_base::badbit;
      break;
      }
    } if (0) { _Myios::setstate(ios_base::badbit, true); }}
    }

  this->width(0);
  _Myios::setstate(_Strbuf == 0 ? ios_base::badbit
   : !_Copied ? _State | ios_base::failbit : _State);
  return (*this);
  }

           _Myt& put(_Elem _Ch)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (!_Ok)
   _State |= ios_base::badbit;
  else
   {
   {{
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sputc(_Ch)))
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& write(const _Elem *_Str,
  streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (!_Ok)
   _State |= ios_base::badbit;
  else if (0 < _Count)
   {
                       ;
   {{
   if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
    _State |= ios_base::badbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& flush()
  {
  if (_Myios::rdbuf() != 0)
   {
   const sentry _Ok(*this);

   if (_Ok && _Myios::rdbuf()->pubsync() == -1)
    _Myios::setstate(ios_base::badbit);
   }
  return (*this);
  }

           _Myt& seekp(pos_type _Pos)
  {
  const sentry _Ok(*this);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
    ios_base::out) == _BADOFF)
   _Myios::setstate(ios_base::failbit);
  return (*this);
  }

           _Myt& seekp(off_type _Off, ios_base::seekdir _Way)
  {
  const sentry _Ok(*this);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
    ios_base::out) == _BADOFF)
   _Myios::setstate(ios_base::failbit);
  return (*this);
  }

           pos_type tellp()
  {
  const sentry _Ok(*this);

  if (!this->fail())
   return (_Myios::rdbuf()->pubseekoff(0,
    ios_base::cur, ios_base::out));
  else
   return (pos_type(_BADOFF));
  }
 };




template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
 {
 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize):: strlen(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  {{
  const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
 {
 ios_base::iostate _State = ios_base::goodbit;
 const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

 if (_Ok)
  {
  const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr,
  const char *_Val)
 {
 typedef char _Elem;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize)_Traits::length(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
   _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, char _Ch)
 {
 typedef char _Elem;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myos::sentry _Ok(_Ostr);

 if (_Ok)
  {
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ch)))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize)_Traits::length(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
   _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits,
 class _Mysizt> inline
 basic_ostream<_Elem, _Traits>& _Put_basic_string(
  basic_ostream<_Elem, _Traits>& _Ostr,
  _Mysizt _Size, const _Elem *_Val)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 _Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
  ? 0 : (_Mysizt)_Ostr.width() - _Size;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
 {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, (streamsize)_Size)
    != (streamsize)_Size)
    _State |= ios_base::badbit;
  else
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr,
  const basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return _Put_basic_string(_Ostr, _Str.size(), _Str.c_str());
 }
# 878 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\ostream" 3
template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myos::sentry _Ok(_Ostr);

 if (_Ok)
  {
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  {{
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ch)))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } if (0) { (_Ostr).setstate(ios_base::badbit, true); }}
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
 {
 return (_Ostr << (const char *)_Val);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
 {
 return (_Ostr << (char)_Ch);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
 {
 return (_Ostr << (const char *)_Val);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
 {
 return (_Ostr << (char)_Ch);
 }

template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_ostream<_Elem, _Traits>&
  operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
 {
 return (_Ostr << _Val);
 }


template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  endl(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.put(_Ostr.widen('\n'));
 _Ostr.flush();
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  ends(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.put(_Elem());
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  flush(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.flush();
 return (_Ostr);
 }


template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
   const error_code& _Errcode)
 {
 return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
 }
}


#pragma clang diagnostic pop
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\istream" 2 3

namespace std {

template<class _Elem,
 class _Traits>
 class basic_istream
  : virtual public basic_ios<_Elem, _Traits>
 {
public:
 typedef basic_istream<_Elem, _Traits> _Myt;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef istreambuf_iterator<_Elem, _Traits> _Iter;
 typedef ctype<_Elem> _Ctype;
 typedef num_get<_Elem, _Iter> _Nget;


 explicit basic_istream(_Mysb *_Strbuf = 0,
  bool _Isstd = false)






  : _Chcount(0)
  {
  _Myios::init(_Strbuf, _Isstd);
  }

 basic_istream(_Uninitialized)
  {
  this->_Addstd(this);
  }

protected:
 basic_istream(_Myt&& _Right)
  : _Chcount(_Right._Chcount)
  {
  _Myios::init();
  _Myios::move(::std:: move(_Right));
  _Right._Chcount = 0;
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  _Myios::swap(_Right);
  ::std:: swap(_Chcount, _Right._Chcount);
  }

public:
 basic_istream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_istream() noexcept
  {
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;


 class _Sentry_base
  {
 public:
  _Sentry_base(_Myt& _Istr)
   : _Myistr(_Istr)
   {
   if (_Myistr.rdbuf() != 0)
    _Myistr.rdbuf()->_Lock();
   }

  ~_Sentry_base() noexcept
   {
   if (_Myistr.rdbuf() != 0)
    _Myistr.rdbuf()->_Unlock();
   }

  _Myt& _Myistr;

 private:
  _Sentry_base& operator=(const _Sentry_base&);
  };

 class sentry
  : public _Sentry_base
  {
 public:
  explicit sentry(_Myt& _Istr, bool _Noskip = false)
   : _Sentry_base(_Istr)
   {
   _Ok = this->_Myistr._Ipfx(_Noskip);
   }


        int _No_bool_decl;


  explicit operator bool() const
   {
   return (_Ok);
   }

  sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;

 private:
  bool _Ok;
  };

           bool _Ipfx(bool _Noskip = false)
  {
  if (this->good())
   {
   if (_Myios::tie() != 0)
    _Myios::tie()->flush();

   if (!_Noskip && this->flags() & ios_base::skipws)
    {
    const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

    {{
    int_type _Meta = _Myios::rdbuf()->sgetc();

    for (; ; _Meta = _Myios::rdbuf()->snextc())
     if (_Traits::eq_int_type(_Traits::eof(), _Meta))
      {
      _Myios::setstate(ios_base::eofbit);
      break;
      }
     else if (!_Ctype_fac.is(_Ctype::space,
      _Traits::to_char_type(_Meta)))
      break;
    } if (0) { _Myios::setstate(ios_base::badbit, true); }}
    }

   if (this->good())
    return (true);
   }
  _Myios::setstate(ios_base::failbit);
  return (false);
  }

 bool ipfx(bool _Noskip = false)
  {
  return (_Ipfx(_Noskip));
  }

 void isfx()
  {
  }

 _Myt& operator>>(_Myt& (*_Pfn)(_Myt&))
  {
                      ;
  return ((*_Pfn)(*this));
  }

 _Myt& operator>>(_Myios& (*_Pfn)(_Myios&))
  {
                      ;
  (*_Pfn)(*(_Myios *)this);
  return (*this);
  }

 _Myt& operator>>(ios_base& (*_Pfn)(ios_base&))
  {
                      ;
  (*_Pfn)(*(ios_base *)this);
  return (*this);
  }

           _Myt& operator>>(bool& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(short& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   long _Tmp = 0;
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Tmp);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}

   if (_Tmp < (-0x7fff - 1) || 0x7fff < _Tmp)
    {
    _Val = _Tmp < (-0x7fff - 1) ? (-0x7fff - 1) : 0x7fff;
    _State |= ios_base::failbit;
    }
   else
    _Val = (short)_Tmp;
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(unsigned short& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(int& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   long _Tmp = 0;
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Tmp);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}

   if (_Tmp < (-0x7fffffff - 1) || 0x7fffffff < _Tmp)
    {
    _Val = _Tmp < (-0x7fffffff - 1) ? (-0x7fffffff - 1) : 0x7fffffff;
    _State |= ios_base::failbit;
    }
   else
    _Val = _Tmp;
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(unsigned int& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(unsigned long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }


           _Myt& operator>>(long long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(unsigned long long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }


           _Myt& operator>>(float& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(double& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(long double& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(void *& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   {{
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& operator>>(_Mysb *_Strbuf)
  {
  ios_base::iostate _State = ios_base::goodbit;
  bool _Copied = false;
  _Chcount = 0;
  const sentry _Ok(*this);

  if (_Ok && _Strbuf != 0)
   {
   {{
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     {{
      if (_Traits::eq_int_type(_Traits::eof(),
       _Strbuf->sputc(_Traits::to_char_type(_Meta))))
       break;
     ++_Chcount;
     } if (0) {
      break;
     }}
     _Copied = true;
     }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
  return (*this);
  }

           int_type get()
  {
  int_type _Meta = 0;
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (!_Ok)
   _Meta = _Traits::eof();
  else
   {
   {{
   _Meta = _Myios::rdbuf()->sgetc();

   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    _State |= ios_base::eofbit | ios_base::failbit;
   else
    {
    _Myios::rdbuf()->sbumpc();
    ++_Chcount;
    }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (_Meta);
  }

 _Myt& get(_Elem *_Str, streamsize _Count)
  {
  return (get(_Str, _Count, _Myios::widen('\n')));
  }

           _Myt& get(_Elem *_Str,
  streamsize _Count, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   {{
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (_Traits::to_char_type(_Meta) == _Delim)
     break;
    else
     {
                         ;
     *_Str++ = _Traits::to_char_type(_Meta);
     ++_Chcount;
     }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_Chcount == 0
   ? _State | ios_base::failbit : _State);
  *_Str = _Elem();
  return (*this);
  }

 _Myt& get(_Elem& _Ch)
  {
  int_type _Meta = get();
  if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
   _Ch = _Traits::to_char_type(_Meta);
  return (*this);
  }

 _Myt& get(_Mysb& _Strbuf)
  {
  return (get(_Strbuf, _Myios::widen('\n')));
  }

           _Myt& get(_Mysb& _Strbuf, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   {{
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     {{
      _Elem _Ch = _Traits::to_char_type(_Meta);
      if (_Ch == _Delim
       || _Traits::eq_int_type(_Traits::eof(),
        _Strbuf.sputc(_Ch)))
       break;
     } if (0) {
      break;
     }}
     ++_Chcount;
     }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  if (_Chcount == 0)
   _State |= ios_base::failbit;
  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& getline(_Elem *_Str, streamsize _Count)
  {
  return (getline(_Str, _Count, _Myios::widen('\n')));
  }

           _Myt& getline(_Elem *_Str,
  streamsize _Count, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);
  const bool _Null_terminate = 0 < _Count;

  if (_Ok && _Null_terminate)
   {
   int_type _Metadelim = _Traits::to_int_type(_Delim);

   {{
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (_Meta == _Metadelim)
     {
     ++_Chcount;
     _Myios::rdbuf()->sbumpc();
     break;
     }
    else if (--_Count <= 0)
     {
     _State |= ios_base::failbit;
     break;
     }
    else
     {
                         ;
     *_Str++ = _Traits::to_char_type(_Meta);
     ++_Chcount;
     }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  if (_Null_terminate)
   *_Str = _Elem();
  _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
  return (*this);
  }

           _Myt& ignore(streamsize _Count = 1,
  int_type _Metadelim = _Traits::eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   {{
   for (; ; )
    {
    int_type _Meta;
    if (_Count != (numeric_limits<streamsize>::max)()
     && --_Count < 0)
     break;
    else if (_Traits::eq_int_type(_Traits::eof(),
     _Meta = _Myios::rdbuf()->sbumpc()))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     ++_Chcount;
     if (_Meta == _Metadelim)
      break;
     }
    }
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& read(_Elem *_Str, streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   {{
                       ;
   const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
   _Chcount += _Num;
   if (_Num != _Count)
    _State |= ios_base::eofbit | ios_base::failbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           streamsize readsome(_Elem *_Str,
  streamsize _Count)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);
  streamsize _Num;

  if (!_Ok)
   _State |= ios_base::failbit;
  else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
   _State |= ios_base::eofbit;
  else if (0 < _Count && 0 < _Num)
   {
                       ;
   read(_Str, _Num < _Count ? _Num : _Count);
   }

  _Myios::setstate(_State);
  return (gcount());
  }

           int_type peek()
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok(*this, true);

  if (!_Ok)
   _Meta = _Traits::eof();
  else
   {
   {{
   if (_Traits::eq_int_type(_Traits::eof(),
    _Meta = _Myios::rdbuf()->sgetc()))
    _State |= ios_base::eofbit;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (_Meta);
  }

           _Myt& putback(_Elem _Ch)
  {
  _Chcount = 0;
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   {{
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sputbackc(_Ch)))
    _State |= ios_base::badbit | _Oldstate;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

           _Myt& unget()
  {
  _Chcount = 0;
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   {{
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sungetc()))
    _State |= ios_base::badbit | _Oldstate;
   } if (0) { _Myios::setstate(ios_base::badbit, true); }}
   }

  _Myios::setstate(_State);
  return (*this);
  }

 streamsize gcount() const
  {
  return (_Chcount);
  }

           int sync()
  {
  const sentry _Ok(*this, true);

  if (_Myios::rdbuf() == 0)
   return (-1);
  else if (_Myios::rdbuf()->pubsync() == -1)
   {
   _Myios::setstate(ios_base::badbit);
   return (-1);
   }
  else
   return (0);
  }

 _Myt& seekg(pos_type _Pos)
  {
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
    ios_base::in) == _BADOFF)
   _Myios::setstate(_State | ios_base::failbit);
  return (*this);
  }

 _Myt& seekg(off_type _Off, ios_base::seekdir _Way)
  {
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
    ios_base::in) == _BADOFF)
   _Myios::setstate(_State | ios_base::failbit);
  return (*this);
  }

 pos_type tellg()
  {
  const sentry _Ok(*this, true);

  if (!this->fail())
   return (_Myios::rdbuf()->pubseekoff(0,
    ios_base::cur, ios_base::in));
  else
   return (pos_type(_BADOFF));
  }

private:
 streamsize _Chcount;
 };




template<class _Elem,
 class _Traits>
 class basic_iostream
 : public basic_istream<_Elem, _Traits>,
  public basic_ostream<_Elem, _Traits>
 {
public:
 typedef basic_iostream<_Elem, _Traits> _Myt;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 explicit basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
  : _Myis(_Strbuf, false),
   _Myos(_Noinit, false)
  {
  }

protected:
 basic_iostream(_Myt&& _Right)
  : _Myis(_Right.rdbuf(), false),
   _Myos(_Noinit, false)
  {
  _Myios::init();
  _Myios::move(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   _Myios::swap(_Right);
  }

public:
 basic_iostream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_iostream() noexcept
  {
  }
 };
# 941 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\istream" 3
template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits> & _Istr, _Elem *_Str)
 {
                     ;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef ctype<_Elem> _Ctype;
 ios_base::iostate _State = ios_base::goodbit;
 _Elem *_Str0 = _Str;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

  {{
  streamsize _Count = 0 < _Istr.width() ? _Istr.width()
   : (numeric_limits<streamsize>::max)();
  typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
  _Elem _Ch;
  for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Ctype_fac.is(_Ctype::space,
    _Ch = _Traits::to_char_type(_Meta))
     || _Ch == _Elem())
    break;
   else
    *_Str++ = _Traits::to_char_type(_Meta);
  } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
  }

 *_Str = _Elem();
 _Istr.width(0);
 _Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits> & _Istr, _Elem& _Ch)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;

 typename _Myis::int_type _Meta;
 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  {{
  _Meta = _Istr.rdbuf()->sbumpc();
  if (_Traits::eq_int_type(_Traits::eof(), _Meta))
   _State |= ios_base::eofbit | ios_base::failbit;
  else
   _Ch = _Traits::to_char_type(_Meta);
  } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
  }

 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits> & _Istr, signed char *_Str)
 {
 return (_Istr >> (char *)_Str);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits> & _Istr, signed char& _Ch)
 {
 return (_Istr >> (char&)_Ch);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits> & _Istr, unsigned char *_Str)
 {
 return (_Istr >> (char *)_Str);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits> & _Istr, unsigned char& _Ch)
 {
 return (_Istr >> (char&)_Ch);
 }

template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_istream<_Elem, _Traits>&
  operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
 {
 return (_Istr >> _Val);
 }


template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_istream<_Elem, _Traits>&
  operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty *_Ptr)
 {
 return (_Istr >> _Ptr);
 }



template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>&
  ws(basic_istream<_Elem, _Traits>& _Istr)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef ctype<_Elem> _Ctype;

 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myis::sentry _Ok(_Istr, true);
 if (!_Istr.eof())
  {
  if (_Ok)
   {
   const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

   {{
   for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
    _Meta = _Istr.rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (!_Ctype_fac.is(_Ctype::space,
     _Traits::to_char_type(_Meta)))
     break;
   } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
   }

  _Istr.setstate(_State);
  }
 return (_Istr);
 }
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iterator" 1 3
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\iterator" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"


namespace std {

template<class _Container>
 class back_insert_iterator
  : public _Outit
 {
public:
 typedef back_insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 explicit back_insert_iterator(_Container& _Cont)

  : container(::std:: addressof(_Cont))



  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  container->push_back(_Val);
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  container->push_back(::std:: forward<_Valty>(_Val));
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 };

template<class _Container>
 struct _Is_checked_helper<back_insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 back_insert_iterator<_Container> back_inserter(_Container& _Cont)
 {
 return (back_insert_iterator<_Container>(_Cont));
 }


template<class _Container>
 class front_insert_iterator
  : public _Outit
 {
public:
 typedef front_insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 explicit front_insert_iterator(_Container& _Cont)

  : container(::std:: addressof(_Cont))



  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  container->push_front(_Val);
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  container->push_front(::std:: forward<_Valty>(_Val));
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 };

template<class _Container>
 struct _Is_checked_helper<front_insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 front_insert_iterator<_Container> front_inserter(_Container& _Cont)
 {
 return (front_insert_iterator<_Container>(_Cont));
 }


template<class _Container>
 class insert_iterator
  : public _Outit
 {
public:
 typedef insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 insert_iterator(_Container& _Cont, typename _Container::iterator _Where)

  : container(::std:: addressof(_Cont)), iter(_Where)



  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  iter = container->insert(iter, _Val);
  ++iter;
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  iter = container->insert(iter, ::std:: forward<_Valty>(_Val));
  ++iter;
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt& operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 typename _Container::iterator iter;
 };

template<class _Container>
 struct _Is_checked_helper<insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 insert_iterator<_Container> inserter(_Container& _Cont,
  typename _Container::iterator _Where)
 {
 return (insert_iterator<_Container>(_Cont, _Where));
 }


template<class _Ty,
 class _Elem = char,
 class _Traits = char_traits<_Elem>,
 class _Diff = ptrdiff_t>
 class istream_iterator
  : public iterator<input_iterator_tag, _Ty, _Diff,
   const _Ty *, const _Ty&>
 {
 typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_istream<_Elem, _Traits> istream_type;
 typedef const _Ty *pointer;

 constexpr istream_iterator()
  : _Myistr(0), _Myval()
  {
  }

 istream_iterator(istream_type& _Istr)
  : _Myistr(::std:: addressof(_Istr))
  {
  _Getval();
  }

 const _Ty& operator*() const
  {
  return (_Myval);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {
  _Getval();
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 bool _Equal(const _Myt& _Right) const
  {
  return (_Myistr == _Right._Myistr);
  }

protected:
 void _Getval()
  {
  if (_Myistr != 0 && !(*_Myistr >> _Myval))
   _Myistr = 0;
  }

 istream_type *_Myistr;
 _Ty _Myval;
 };

template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff>
 struct _Is_checked_helper<istream_iterator<_Ty, _Elem, _Traits, _Diff> >
  : public true_type
 {
 };


template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff> inline
 bool operator==(
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff> inline
 bool operator!=(
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
 {
 return (!(_Left == _Right));
 }


template<class _Ty,
 class _Elem = char,
 class _Traits = char_traits<_Elem> >
 class ostream_iterator
  : public _Outit
 {
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_ostream<_Elem, _Traits> ostream_type;

 ostream_iterator(ostream_type& _Ostr,
  const _Elem *_Delim = 0)
  : _Myostr(::std:: addressof(_Ostr)), _Mydelim(_Delim)
  {
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
  {
  *_Myostr << _Val;
  if (_Mydelim != 0)
   *_Myostr << _Mydelim;
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator*()
  {
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator++()
  {
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator++(int)
  {
  return (*this);
  }

protected:
 const _Elem *_Mydelim;
 ostream_type *_Myostr;
 };

template<class _Ty,
 class _Elem,
 class _Traits>
 struct _Is_checked_helper<ostream_iterator<_Ty, _Elem, _Traits> >
  : public true_type
 {
 };

}


#pragma clang diagnostic pop
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 2 3

namespace std {

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 typedef ctype<_Elem> _Ctype;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
 typedef typename _Mystr::size_type _Mysizt;

 ios_base::iostate _State = ios_base::goodbit;
 bool _Changed = false;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
  _Str.erase();

  {{
  _Mysizt _Size = 0 < _Istr.width()
   && (_Mysizt)_Istr.width() < _Str.max_size()
    ? (_Mysizt)_Istr.width() : _Str.max_size();
  typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Ctype_fac.is(_Ctype::space,
    _Traits::to_char_type(_Meta)))
    break;
   else
    {
    _Str.append(1, _Traits::to_char_type(_Meta));
    _Changed = true;
    }
  } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
  }

 _Istr.width(0);
 if (!_Changed)
  _State |= ios_base::failbit;
 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str,
  const _Elem _Delim)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;

 ios_base::iostate _State = ios_base::goodbit;
 bool _Changed = false;
 const typename _Myis::sentry _Ok(_Istr, true);

 if (_Ok)
  {
  {{
  _Str.erase();
  const typename _Traits::int_type _Metadelim =
   _Traits::to_int_type(_Delim);
  typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  for (; ; _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Traits::eq_int_type(_Meta, _Metadelim))
    {
    _Changed = true;
    _Istr.rdbuf()->sbumpc();
    break;
    }
   else if (_Str.max_size() <= _Str.size())
    {
    _State |= ios_base::failbit;
    break;
    }
   else
    {
    _Str += _Traits::to_char_type(_Meta);
    _Changed = true;
    }
  } if (0) { (_Istr).setstate(ios_base::badbit, true); }}
  }

 if (!_Changed)
  _State |= ios_base::failbit;
 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (getline(_Istr, _Str, _Istr.widen('\n')));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (::std:: move(_Istr) >> _Str);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str,
  const _Elem _Delim)
 {
 return (getline(::std:: move(_Istr), _Str, _Delim));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
 }
# 185 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 3
inline int stoi(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoi argument");
 if ((* __error()) == 34 || _Ans < (-0x7fffffff - 1) || 0x7fffffff < _Ans)
  _Xout_of_range("stoi argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return ((int)_Ans);
 }

inline long stol(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stol argument");
 if ((* __error()) == 34)
  _Xout_of_range("stol argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoul argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoul argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long long stoll(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoll argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoll argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long long stoull(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoull argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoull argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline float stof(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 float _Ans = :: strtof(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stof argument");
 if ((* __error()) == 34)
  _Xout_of_range("stof argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline double stod(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 double _Ans = :: strtod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stod argument");
 if ((* __error()) == 34)
  _Xout_of_range("stod argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long double stold(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (* __error()) = 0;
 long double _Ans = :: strtold(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stold argument");
 if ((* __error()) == 34)
  _Xout_of_range("stold argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }


inline int stoi(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoi argument");
 if ((* __error()) == 34 || _Ans < (-0x7fffffff - 1) || 0x7fffffff < _Ans)
  _Xout_of_range("stoi argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return ((int)_Ans);
 }

inline long stol(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stol argument");
 if ((* __error()) == 34)
  _Xout_of_range("stol argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoul argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoul argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long long stoll(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoll argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoll argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long long stoull(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoull argument");
 if ((* __error()) == 34)
  _Xout_of_range("stoull argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline float stof(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 float _Ans = :: wcstof(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stof argument");
 if ((* __error()) == 34)
  _Xout_of_range("stof argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline double stod(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 double _Ans = :: wcstod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stod argument");
 if ((* __error()) == 34)
  _Xout_of_range("stod argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (* __error()) = 0;
 long double _Ans = :: wcstold(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stold argument");
 if ((* __error()) == 34)
  _Xout_of_range("stold argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }




template<class _Ty> inline
 string _Integral_to_string(const char *_Fmt, _Ty _Val)
 {
 static_assert(is_integral<_Ty>::value, "_Ty must be integral");

 char _Buf[21];
 int _Len = :: sprintf_s(_Buf, 21, _Fmt, _Val);
 return (string(_Buf, _Len));
 }

template<class _Ty> inline
 string _Floating_to_string(const char *_Fmt, _Ty _Val)
 {
 static_assert(is_floating_point<_Ty>::value, "_Ty must be floating point");

 for (int _Len = 21; ; )
  {
  string _Str(_Len + 1, '\0');
  int _Len2 = :: snprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
  if (_Len2 <= _Len)
   {
   _Str.resize(_Len2);
   return (_Str);
   }
  _Len = _Len2;
  }
 }

template<class _Ty> inline
 wstring _Integral_to_wstring(const wchar_t *_Fmt, _Ty _Val)
 {
 static_assert(is_integral<_Ty>::value, "_Ty must be integral");

 wchar_t _Buf[21];
 int _Len = :: swprintf_s(_Buf, 21, _Fmt, _Val);
 return (wstring(_Buf, _Len));
 }

template<class _Ty> inline
 wstring _Floating_to_wstring(const wchar_t *_Fmt, _Ty _Val)
 {
 static_assert(is_floating_point<_Ty>::value, "_Ty must be floating point");

 for (int _Len = 21; ; )
  {
  wstring _Str(_Len + 1, '\0');
  int _Len2 = :: snwprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
  if (_Len2 <= _Len)
   {
   _Str.resize(_Len2);
   return (_Str);
   }
  _Len = _Len2;
  }
 }




inline string to_string(int _Val)
 {
 return (_Integral_to_string("%d", _Val));
 }

inline string to_string(unsigned int _Val)
 {
 return (_Integral_to_string("%u", _Val));
 }

inline string to_string(long _Val)
 {
 return (_Integral_to_string("%ld", _Val));
 }

inline string to_string(unsigned long _Val)
 {
 return (_Integral_to_string("%lu", _Val));
 }

inline string to_string(long long _Val)
 {
 return (_Integral_to_string("%lld", _Val));
 }

inline string to_string(unsigned long long _Val)
 {
 return (_Integral_to_string("%llu", _Val));
 }

inline string to_string(float _Val)
 {
 return (_Floating_to_string("%f", _Val));
 }

inline string to_string(double _Val)
 {
 return (_Floating_to_string("%f", _Val));
 }

inline string to_string(long double _Val)
 {
 return (_Floating_to_string("%Lf", _Val));
 }


inline wstring to_wstring(int _Val)
 {
 return (_Integral_to_wstring(L"%d", _Val));
 }

inline wstring to_wstring(unsigned int _Val)
 {
 return (_Integral_to_wstring(L"%u", _Val));
 }

inline wstring to_wstring(long _Val)
 {
 return (_Integral_to_wstring(L"%ld", _Val));
 }

inline wstring to_wstring(unsigned long _Val)
 {
 return (_Integral_to_wstring(L"%lu", _Val));
 }

inline wstring to_wstring(long long _Val)
 {
 return (_Integral_to_wstring(L"%lld", _Val));
 }

inline wstring to_wstring(unsigned long long _Val)
 {
 return (_Integral_to_wstring(L"%llu", _Val));
 }

inline wstring to_wstring(float _Val)
 {
 return (_Floating_to_wstring(L"%f", _Val));
 }

inline wstring to_wstring(double _Val)
 {
 return (_Floating_to_wstring(L"%f", _Val));
 }

inline wstring to_wstring(long double _Val)
 {
 return (_Floating_to_wstring(L"%Lf", _Val));
 }
# 630 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\string" 3
 inline namespace literals {
  inline namespace string_literals {
inline string operator ""s(const char *_Str, size_t _Len)
 noexcept
 {
 return (string(_Str, _Len));
 }

inline u16string operator""s(const char16_t *_Str, size_t _Len)
 noexcept
 {
 return (u16string(_Str, _Len));
 }

inline u32string operator""s(const char32_t *_Str, size_t _Len)
 noexcept
 {
 return (u32string(_Str, _Len));
 }

inline wstring operator""s(const wchar_t *_Str, size_t _Len)
 noexcept
 {
 return (wstring(_Str, _Len));
 }
  }
 }

}
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/PlayerInterface\\UnityPrxPlugin.cpp" 2
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\assert.h" 1 3
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/PlayerInterface\\UnityPrxPlugin.cpp" 2



fnPrxPluginQueryInterface g_QueryInterface = __null;
PrxPluginArgs g_AppInfo;

bool ProcessPrxPluginArgs(unsigned int sz, const void* arg, const char* pluginName)
{
 if (PrxPluginArgsV2::Validate((PrxPluginArgsV2*)arg, sz))
 {
  g_QueryInterface = ((PrxPluginArgsV2*)arg)->m_QueryInterface;
 }
 else if (PrxPluginArgs::Validate((PrxPluginArgs*)arg))
 {

  g_QueryInterface = ((PrxPluginArgs*)arg)->m_QueryInterface;
  g_AppInfo = *(PrxPluginArgs*)arg;
 }
 else
 {
  printf("\nERROR...\n");
  printf(" %s is an old version that cannot be used by the current player runtime.\n", pluginName);
  printf(" Please update the %s native module and any associated managed assemblies to the latest versions\n", pluginName);
  printf("  Plugin args version, found %04x, expected %04x\n", ((PrxPluginArgsV2*)arg)->m_Version, ((PrxPluginArgsV2*)arg)->s_Version);
  printf("  Plugin args struct size, expected %ld or %ld, found %d\n\n", sizeof(PrxPluginArgs), sizeof(PrxPluginArgsV2), ((PrxPluginArgsV2*)arg)->m_Size);

  return false;
 }

 return true;
}
# 8 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Backup.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Backup.h" 1




# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Core.h" 1






namespace SaveData
{
 struct DirNameManaged
 {
 public:
  char data[(32)];

  void CopyTo(SceSaveDataDirName &destination);
 };

 struct TitleIdManaged
 {
 public:
  char data[(10)];

  void CopyTo(SceSaveDataTitleId &destination);
 };


 struct FingerprintManaged
 {
 public:
  char data[(65)];

  void CopyTo(SceSaveDataFingerprint &destination);
 };


 class PNGWriter
 {
 public:
  struct PNG
  {
   char png[4];
   char crlfczlf[4];
  };

  struct IHDR
  {
   char ihdr[4];
   int ihdrlen;
   int width;
   int height;
   char bitDepth;
   char colorType;
   char compressionMethod;
   char filterMethod;
   char interlaceMethod;
  };

  static void WriteToBuffer(const void* iconData, Int32 size, MemoryBuffer& buffer);
  static void GetPNGSizes(const void* iconData, int& width, int& height);

 private:
  static void SwapBytes(short* val);
  static void SwapEndian(int* val);
 };

 class Core
 {
 public:

  static void WriteToBuffer(const SceSaveDataMountInfo& info, MemoryBuffer& buffer);
  static void WriteToBuffer(const SceSaveDataSearchInfo& info, MemoryBuffer& buffer);
  static void WriteToBuffer(const SceSaveDataParam& params, MemoryBuffer& buffer);
  static void WriteToBuffer(const SceSaveDataDirName& dirName, MemoryBuffer& buffer);

  static void InitIconForReading(SceSaveDataIcon& icon);

  static SceSaveDataDirName* GetTempDirNamesArray();
  static SceSaveDataDirName* GetTempDialogDirNamesArray();
  static SceSaveDataParam* GetTempParamsArray();
  static SceSaveDataSearchInfo* GetTempSearchInfosArray();

 private:
 };
}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Backup.h" 2

namespace SaveData
{
 class BackupRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;

  void CopyTo(SceSaveDataBackup &destination, SceSaveDataDirName& sceDirName);
 };

 class Backups
 {
 public:

  static void Backup(BackupRequest* managedRequest, APIResult* result);
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Backup.cpp" 2


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataBackup(BackupRequest* managedRequest, APIResult* result)
 {
  Backups::Backup(managedRequest, result);
 }

 void BackupRequest::CopyTo(SceSaveDataBackup &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
 }

 void Backups::Backup(BackupRequest* managedRequest, APIResult* result)
 {
  SceSaveDataBackup del;
  SceSaveDataDirName dirName;

  managedRequest->CopyTo(del, dirName);

  int ret = sceSaveDataBackup(&del);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Backup.cpp", 32));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 9 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Core.cpp" 1




namespace SaveData
{

 void DirNameManaged::CopyTo(SceSaveDataDirName &destination)
 {
  memcpy_s(destination.data, (32), data, (32));
 }

 void FingerprintManaged::CopyTo(SceSaveDataFingerprint& destination)
 {
  memcpy_s(destination.data, (65), data, (65));
 }

 void TitleIdManaged::CopyTo(SceSaveDataTitleId& destination)
 {
  memcpy_s(destination.data, (10), data, (10));
 }

 static char sIconBuffer[((776) * (436) * 4)];
 static SceSaveDataDirName sDirNames[(1024)];
 static SceSaveDataDirName sDialogDirNames[(1024)];
 static SceSaveDataParam sParams[(1024)];
 static SceSaveDataSearchInfo sInfos[(1024)];

 SceSaveDataDirName* Core::GetTempDirNamesArray()
 {
  return sDirNames;
 }

 SceSaveDataDirName* Core::GetTempDialogDirNamesArray()
 {
  return sDialogDirNames;
 }

 SceSaveDataParam* Core::GetTempParamsArray()
 {
  return sParams;
 }

 SceSaveDataSearchInfo* Core::GetTempSearchInfosArray()
 {
  return sInfos;
 }

 void Core::InitIconForReading(SceSaveDataIcon& icon)
 {
  memset(sIconBuffer, 0xAA, ((776) * (436) * 4));

  memset(&icon, 0x00, sizeof(icon));
  icon.buf = sIconBuffer;
  icon.bufSize = ((776) * (436) * 4);
 }

 void Core::WriteToBuffer(const SceSaveDataMountInfo& info, MemoryBuffer& buffer)
 {
  buffer.WriteUInt64(info.blocks);
  buffer.WriteUInt64(info.freeBlocks);
 }

 void Core::WriteToBuffer(const SceSaveDataSearchInfo& info, MemoryBuffer& buffer)
 {
  buffer.WriteUInt64(info.blocks);
  buffer.WriteUInt64(info.freeBlocks);
 }

 void Core::WriteToBuffer(const SceSaveDataParam& params, MemoryBuffer& buffer)
 {
  buffer.WriteString(params.title);
  buffer.WriteString(params.subTitle);
  buffer.WriteString(params.detail);
  buffer.WriteUInt32(params.userParam);
  buffer.WriteInt64(params.mtime);
 }

 void Core::WriteToBuffer(const SceSaveDataDirName& dirName, MemoryBuffer& buffer)
 {
  buffer.WriteString(dirName.data);
 }


 void PNGWriter::SwapBytes(short* val)
 {
  char* bytes = (char*)val;
  char tmp = bytes[0]; bytes[0] = bytes[1]; bytes[1] = tmp;
 }

 void PNGWriter::SwapEndian(int* val)
 {
  short* words = (short*)val;
  short tmp = words[0]; words[0] = words[1]; words[1] = tmp;
  SwapBytes(&words[0]);
  SwapBytes(&words[1]);
 }

 void PNGWriter::WriteToBuffer(const void* iconData, Int32 size, MemoryBuffer& buffer)
 {
  buffer.WriteMarker(BufferIntegrityChecks::PNGBegin);
  if (iconData == __null)
  {
   buffer.WriteBool(false);
  }
  else
  {
   buffer.WriteBool(true);
   buffer.WriteInt32(size);

   PNG* png = (PNG*)iconData;
   IHDR* header = (IHDR*)(png + 1);
   int width = header->width;
   int height = header->height;
   SwapEndian(&width);
   SwapEndian(&height);

   buffer.WriteInt32(width);
   buffer.WriteInt32(height);
   buffer.WriteData((char*)png, size);
  }

  buffer.WriteMarker(BufferIntegrityChecks::PNGEnd);
 }

 void PNGWriter::GetPNGSizes(const void* iconData, int& width, int& height)
 {
  if (iconData == __null)
  {
   return;
  }

  PNG* png = (PNG*)iconData;
  IHDR* header = (IHDR*)(png + 1);
  width = header->width;
  height = header->height;
  SwapEndian(&width);
  SwapEndian(&height);
 }
}
# 10 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Delete.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Delete.h" 1






namespace SaveData
{
 class DeleteRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;

  void CopyTo(SceSaveDataDelete &destination, SceSaveDataDirName& sceDirName);
 };

 class Deleting
 {
 public:

  static void Delete(DeleteRequest* managedRequest, APIResult* result);
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Delete.cpp" 2


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataDelete(DeleteRequest* managedRequest, APIResult* result)
 {
  Deleting::Delete(managedRequest, result);
 }

 void DeleteRequest::CopyTo(SceSaveDataDelete &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
 }

 void Deleting::Delete(DeleteRequest* managedRequest, APIResult* result)
 {
  SceSaveDataDelete del;
  SceSaveDataDirName dirName;

  managedRequest->CopyTo(del, dirName);

  int ret = sceSaveDataDelete(&del);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Delete.cpp", 32));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 11 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Dialogs.h" 1






namespace SaveData
{
# 18 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Dialogs.h"
 class OpenDialogSettings
 {
 public:
  SceSaveDataDialogMode mode;
  SceSaveDataDialogType dispType;

  void CopyTo(SceSaveDataDialogParam &destination);
 };

 class UserMessage
 {
 public:
  SceSaveDataDialogButtonType buttonType;
  SceSaveDataDialogUserMessageType msgType;

  char msg[(256)];

  void CopyTo(SceSaveDataDialogUserMessageParam &destination, SceSaveDataDialogParam &params);
 };

 class AnimationParam
 {
 public:
  SceSaveDataDialogAnimation userOK;
  SceSaveDataDialogAnimation userCancel;

  void CopyTo(SceSaveDataDialogAnimationParam &destination, SceSaveDataDialogParam &params);
 };

 class SystemMessage
 {
 public:
  SceSaveDataDialogSystemMessageType sysMsgType;
  UInt64 value;

  void CopyTo(SceSaveDataDialogSystemMessageParam &destination, SceSaveDataDialogParam &params);
 };

 class ErrorCode
 {
 public:
  Int32 errorCode;

  void CopyTo(SceSaveDataDialogErrorCodeParam &destination, SceSaveDataDialogParam &params);
 };

 class Items
 {
 public:

  DirNameManaged dirNames[(1024)];
  UInt32 dirNameNum;

  SceSaveDataDialogFocusPos focusPos;

  DirNameManaged focusPosDirName;

  SceSaveDataDialogItemStyle itemStyle;

  void CopyTo(SceSaveDataDialogItems &destination, SceSaveDataDialogParam &params, SceSaveDataDirName& focusDirName);
 };

 class NewItem
 {
 public:

  char iconPath[(128)];

  char title[(128)];

  void *iconBuf;
  UInt64 iconSize;

  void CopyTo(SceSaveDataDialogNewItem &newItem, SceSaveDataDialogItems &items);
 };

 class ProgressBar
 {
 public:

  SceSaveDataDialogProgressBarType barType;
  SceSaveDataDialogProgressSystemMessageType sysMsgType;

     char msg[(256)];

  void CopyTo(SceSaveDataDialogProgressBarParam &destination, SceSaveDataDialogParam &params);
 };

 class OptionParam
 {
 public:

  SceSaveDataDialogOptionBack back;

  void CopyTo(SceSaveDataDialogOptionParam &destination, SceSaveDataDialogParam &params);
 };

 class CloseParam
 {
 public:
  SceSaveDataDialogAnimation anim;

  void CopyTo(SceSaveDataDialogCloseParam &destination);
 };

 class Dialogs
 {
 public:

  static void OpenDialog(Int32 userId, OpenDialogSettings* basicSettings, Items* itemsSettings, UserMessage* userMsgSettings, SystemMessage* sysMsgSettings,
                      ErrorCode* errorCodeSettings, ProgressBar* progressBarSettings, NewItem* newItemSettings, OptionParam* optionSettings,
                      AnimationParam* animations, APIResult* result);

  static void Close(CloseParam* close, APIResult* result);

  static int DialogUpdateStatus();
  static int DialogGetStatus();
  static int DialogIsReadyToDisplay(APIResult* result);

  static void DialogGetResult(MemoryBufferManaged* outBuffer, APIResult* result);
  static void ProgressBarInc(UInt32 delta, APIResult* result);
  static void ProgressBarSetValue(UInt32 rate, APIResult* result);
  static void InitializeDialog(APIResult* result);
  static void TerminateDialog(APIResult* result);

 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp" 2


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataOpenDialog(Int32 userId, OpenDialogSettings* basicSettings, Items* itemsSettings, UserMessage* userMsgSettings, SystemMessage* sysMsgSettings,
  ErrorCode* errorCodeSettings, ProgressBar* progressBarSettings, NewItem* newItemSettings, OptionParam* optionSettings,
  AnimationParam* animations, APIResult* result)
 {
  Dialogs::OpenDialog(userId, basicSettings, itemsSettings, userMsgSettings, sysMsgSettings, errorCodeSettings, progressBarSettings, newItemSettings, optionSettings, animations, result);
 }

 extern "C" __declspec (dllexport) int PrxSaveDataDialogUpdateStatus()
 {
  return Dialogs::DialogUpdateStatus();
 }

 extern "C" __declspec (dllexport) int PrxSaveDataDialogGetStatus()
 {
  return Dialogs::DialogGetStatus();
 }

 extern "C" __declspec (dllexport) int PrxSaveDataDialogIsReadyToDisplay(APIResult* result)
 {
  return Dialogs::DialogIsReadyToDisplay(result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataDialogGetResult(MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Dialogs::DialogGetResult(outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataDialogProgressBarInc(UInt32 delta, APIResult* result)
 {
  Dialogs::ProgressBarInc(delta, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataDialogProgressBarSetValue(UInt32 rate, APIResult* result)
 {
  Dialogs::ProgressBarSetValue(rate, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataDialogClose(CloseParam* close, APIResult* result)
 {
  Dialogs::Close(close, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataInitializeDialog(APIResult* result)
 {
  Dialogs::InitializeDialog(result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataTerminateDialog(APIResult* result)
 {
  Dialogs::TerminateDialog(result);
 }

 void Dialogs::InitializeDialog(APIResult* result)
 {
  int32_t ret = sceSaveDataDialogInitialize();

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp", 65));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Dialogs::TerminateDialog(APIResult* result)
 {
  int32_t ret = sceSaveDataDialogTerminate();

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp", 78));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 int Dialogs::DialogUpdateStatus()
 {
  SceCommonDialogStatus stat = sceSaveDataDialogUpdateStatus();
  return stat;
 }

 int Dialogs::DialogGetStatus()
 {
  SceCommonDialogStatus stat = sceSaveDataDialogGetStatus();
  return stat;
 }

 int Dialogs::DialogIsReadyToDisplay(APIResult* result)
 {
  int ret = sceSaveDataDialogIsReadyToDisplay();

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp", 103));
   return ret;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));

  return ret;
 }

 void Dialogs::DialogGetResult(MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataDialogResult dialogResult;
  SceSaveDataDirName dirName;
  SceSaveDataParam param;

  memset(&dialogResult, 0, sizeof(dialogResult));
  memset(&dirName, 0, sizeof(dirName));
  memset(&param, 0, sizeof(param));

  dialogResult.dirName = &dirName;
  dialogResult.param = &param;

  int ret = sceSaveDataDialogGetResult(&dialogResult);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp", 129));
   return;
  }


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();


  buffer.WriteInt32(dialogResult.mode);
  buffer.WriteInt32(dialogResult.result);
  buffer.WriteInt32(dialogResult.buttonId);


  Core::WriteToBuffer(*dialogResult.dirName, buffer);
  Core::WriteToBuffer(*dialogResult.param, buffer);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void OpenDialogSettings::CopyTo(SceSaveDataDialogParam &destination)
 {
  sceSaveDataDialogParamInitialize(&destination);

  destination.mode = mode;
  destination.dispType = dispType;
 }

 void UserMessage::CopyTo(SceSaveDataDialogUserMessageParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.buttonType = buttonType;
  destination.msgType = msgType;
  destination.msg = msg;

  params.userMsgParam = &destination;
 }

 void AnimationParam::CopyTo(SceSaveDataDialogAnimationParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.userOK = userOK;
  destination.userCancel = userCancel;

  params.animParam = &destination;
 }

 void SystemMessage::CopyTo(SceSaveDataDialogSystemMessageParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.sysMsgType = sysMsgType;
  destination.value = value;

  params.sysMsgParam = &destination;
 }

 void ErrorCode::CopyTo(SceSaveDataDialogErrorCodeParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.errorCode = errorCode;

  params.errorCodeParam = &destination;
 }

 void ProgressBar::CopyTo(SceSaveDataDialogProgressBarParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.barType = barType;
  destination.sysMsgType = sysMsgType;
  destination.msg = msg;

  params.progBarParam = &destination;
 }

 void OptionParam::CopyTo(SceSaveDataDialogOptionParam& destination, SceSaveDataDialogParam &params)
 {
  memset(&destination, 0, sizeof(destination));

  destination.back = back;

  params.optionParam = &destination;
 }

 void Items::CopyTo(SceSaveDataDialogItems& destination, SceSaveDataDialogParam &params, SceSaveDataDirName& focusDirName)
 {
  memset(&destination, 0, sizeof(destination));

  if (dirNameNum > 0)
  {
   SceSaveDataDirName* nativeDirNames = Core::GetTempDialogDirNamesArray();

   destination.dirName = nativeDirNames;
   destination.dirNameNum = dirNameNum;

   for (int i = 0; i < dirNameNum; i++)
   {
    dirNames[i].CopyTo(nativeDirNames[i]);
   }
  }
  else
  {
   destination.dirName = __null;
   destination.dirNameNum = 0;
  }

  destination.focusPos = focusPos;
  destination.itemStyle = itemStyle;

  if (focusPos == (6))
  {
   focusPosDirName.CopyTo(focusDirName);
   destination.focusPosDirName = &focusDirName;
  }

  params.items = &destination;
 }

 void NewItem::CopyTo(SceSaveDataDialogNewItem& destination, SceSaveDataDialogItems &items)
 {
  memset(&destination, 0, sizeof(destination));

  destination.title = title;
  destination.iconBuf = iconBuf;
  destination.iconSize = iconSize;

  items.newItem = &destination;
 }

 void Dialogs::ProgressBarInc(UInt32 delta, APIResult* result)
 {
  int ret = sceSaveDataDialogProgressBarInc((0), delta);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp", 272));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Dialogs::ProgressBarSetValue(UInt32 rate, APIResult* result)
 {
  int ret = sceSaveDataDialogProgressBarSetValue((0), rate);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp", 285));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void CloseParam::CopyTo(SceSaveDataDialogCloseParam &destination)
 {
  memset(&destination, 0x00, sizeof(destination));
  destination.anim = anim;
 }

 void Dialogs::Close(CloseParam* close, APIResult* result)
 {
  SceSaveDataDialogCloseParam closeParam;

  close->CopyTo(closeParam);

  int ret = sceSaveDataDialogClose(&closeParam);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp", 308));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Dialogs::OpenDialog(Int32 userId, OpenDialogSettings* basicSettings, Items* itemsSettings, UserMessage* userMsgSettings, SystemMessage* sysMsgSettings,
                       ErrorCode* errorCodeSettings, ProgressBar* progressBarSettings, NewItem* newItemSettings, OptionParam* optionSettings,
                       AnimationParam* animations, APIResult* result)
 {
  SceSaveDataDialogParam param;
  SceSaveDataDialogUserMessageParam userMsgParam;
  SceSaveDataDialogAnimationParam animParam;
  SceSaveDataDialogSystemMessageParam sysMsgParam;
  SceSaveDataDialogErrorCodeParam errorParam;
  SceSaveDataDialogProgressBarParam barParam;
  SceSaveDataDialogNewItem newItem;
  SceSaveDataDialogItems items;
  SceSaveDataDialogOptionParam optionParam;
  SceSaveDataDirName focusDirName;


  basicSettings->CopyTo(param);

  if (itemsSettings != __null)
  {
   itemsSettings->CopyTo(items, param, focusDirName);
  }
  else
  {
   memset(&items, 0, sizeof(items));
   param.items = &items;
  }

  param.items->userId = userId;

  if (animations != __null)
  {
   animations->CopyTo(animParam, param);
  }

  if (newItemSettings != __null)
  {
   newItemSettings->CopyTo(newItem, items);
  }

  if (optionSettings != __null)
  {
   optionSettings->CopyTo(optionParam, param);
  }

  if (param.mode == (2) && userMsgSettings != __null)
  {
   userMsgSettings->CopyTo(userMsgParam, param);
  }
  else if (param.mode == (3) && sysMsgSettings != __null)
  {
   sysMsgSettings->CopyTo(sysMsgParam, param);
  }
  else if (param.mode == (4) && errorCodeSettings != __null)
  {
   errorCodeSettings->CopyTo(errorParam, param);
  }
  else if (param.mode == (5) && progressBarSettings != __null)
  {
   progressBarSettings->CopyTo(barParam, param);
  }

  int ret = sceSaveDataDialogOpen(&param);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Dialogs.cpp", 381));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 12 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Info.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Info.h" 1






namespace SaveData
{
# 23 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Info.h"
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Info.cpp" 2


namespace SaveData
{
# 39 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Info.cpp"
}
# 13 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Main.h" 1





namespace SaveData
{
 struct InitResult
 {
 public:
  bool initialized;
  UInt32 sceSDKVersion;

  InitResult()
  {
   initialized = false;
  }
 };

 struct ThreadSettings
 {
 public:
  char name[32];
  UInt64 affinityMask;
 };

 class Main
 {
 public:

 private:

  static bool s_Initialised;

  static IPluginUnity* s_IUnity;
  static IPluginSceAppParams* s_ISceAppParams;
  static IPluginSceNpParams* s_ISceNpParams;

 public:

  static void Initialize(InitResult& initResult, APIResult* result);
  static void Terminate(APIResult* result);
  static void SetThreadAffinity(ThreadSettings settings, APIResult* result);

  static void LoadModules();
  static void UnloadModules();

 private:

  static void SetupRuntimeInterfaces();

 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp" 2

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 1 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_rtc.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_rtc.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\_rtc.h" 2 3

typedef struct SceRtcTick {
 uint64_t tick;
} SceRtcTick;
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 2 3


extern "C" {
# 110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
typedef struct SceRtcDateTime {
 unsigned short year;
 unsigned short month;
 unsigned short day;
 unsigned short hour;
 unsigned short minute;
 unsigned short second;
 unsigned int microsecond;
} SceRtcDateTime;
# 127 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
int sceRtcGetCurrentTick(SceRtcTick *pTick);




int sceRtcGetCurrentClock(SceRtcDateTime *pTime, int iTimeZone);



int sceRtcGetCurrentClockLocalTime(SceRtcDateTime *pTime);




int sceRtcGetCurrentNetworkTick(SceRtcTick *pTick);



int sceRtcConvertUtcToLocalTime(const SceRtcTick *pUtc, SceRtcTick *pLocalTime);



int sceRtcConvertLocalTimeToUtc(const SceRtcTick *pLocalTime, SceRtcTick *pUtc);



int sceRtcIsLeapYear(int year);



int sceRtcGetDaysInMonth(int year, int month);
# 168 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
int sceRtcGetDayOfWeek(int year, int month, int day);



int sceRtcCheckValid(const SceRtcDateTime *pTime);
# 182 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
int sceRtcSetTime_t(SceRtcDateTime *pTime, time_t llTime);




int sceRtcGetTime_t(const SceRtcDateTime *pTime, time_t *pllTime);







int sceRtcSetDosTime(SceRtcDateTime *pTime, unsigned int uiDosTime);




int sceRtcGetDosTime(const SceRtcDateTime *pTime, unsigned int *puiDosTime);




int sceRtcSetWin32FileTime(SceRtcDateTime *pTime, uint64_t ulWin32Time);




int sceRtcGetWin32FileTime(const SceRtcDateTime *pTime, uint64_t *ulWin32Time);







int sceRtcSetTick(SceRtcDateTime *pTime, const SceRtcTick *pTick);




int sceRtcGetTick(const SceRtcDateTime *pTime, SceRtcTick *pTick);



unsigned int sceRtcGetTickResolution(void);







int sceRtcTickAddTicks(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddMicroseconds(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddSeconds(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddMinutes(SceRtcTick *pTick0, const SceRtcTick *pTick1, int64_t lAdd);


int sceRtcTickAddHours(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddDays(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddWeeks(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddMonths(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);


int sceRtcTickAddYears(SceRtcTick *pTick0, const SceRtcTick *pTick1, int iAdd);
# 268 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\rtc.h" 3
int sceRtcFormatRFC2822(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes);



int sceRtcFormatRFC2822LocalTime(char *pszDateTime, const SceRtcTick *pUtc);



int sceRtcFormatRFC3339(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes);



int sceRtcFormatRFC3339LocalTime(char *pszDateTime, const SceRtcTick *pUtc);



int sceRtcFormatRFC3339Precise(char *pszDateTime, const SceRtcTick *pUtc, int iTimeZoneMinutes, unsigned int secfrac);



int sceRtcFormatRFC3339PreciseLocalTime(char *pszDateTime, const SceRtcTick *pUtc, unsigned int secfrac);



int sceRtcParseDateTime(SceRtcTick *pUtc, const char *pszDateTime);



int sceRtcParseRFC3339(SceRtcTick *pUtc, const char *pszDateTime);





static __inline__ int sceRtcSetYear(SceRtcDateTime *pTime, int year);
static __inline__ int sceRtcSetMonth(SceRtcDateTime *pTime, int month);
static __inline__ int sceRtcSetDay(SceRtcDateTime *pTime, int day);
static __inline__ int sceRtcSetHour(SceRtcDateTime *pTime, int hour);
static __inline__ int sceRtcSetMinute(SceRtcDateTime *pTime, int minute);
static __inline__ int sceRtcSetSecond(SceRtcDateTime *pTime, int second);
static __inline__ int sceRtcSetMicrosecond(SceRtcDateTime *pTime, int microsecond);

static __inline__ int sceRtcGetYear(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMonth(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetDay(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetHour(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMinute(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetSecond(const SceRtcDateTime *pTime);
static __inline__ int sceRtcGetMicrosecond(const SceRtcDateTime *pTime);



static __inline__ int sceRtcSetYear(SceRtcDateTime *pTime, int year)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (year<1 || year>9999) {
  return (-2135621624);
 }

 pTime->year = static_cast<unsigned short>(year);



 return (0);
}



static __inline__ int sceRtcSetMonth(SceRtcDateTime *pTime, int month)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (month<1 || month>12) {
  return (-2135621623);
 }

 pTime->month = static_cast<unsigned short>(month);



 return (0);
}



static __inline__ int sceRtcSetDay(SceRtcDateTime *pTime, int day)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (day<1 || day>31) {
  return (-2135621622);
 }

 pTime->day = static_cast<unsigned short>(day);



 return (0);
}



static __inline__ int sceRtcSetHour(SceRtcDateTime *pTime, int hour)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (hour<0 || hour>23) {
  return (-2135621621);
 }

 pTime->hour = static_cast<unsigned short>(hour);



 return (0);
}



static __inline__ int sceRtcSetMinute(SceRtcDateTime *pTime, int minute)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (minute<0 || minute>59) {
  return (-2135621620);
 }

 pTime->minute = static_cast<unsigned short>(minute);



 return (0);
}



static __inline__ int sceRtcSetSecond(SceRtcDateTime *pTime, int second)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (second<0 || second>59) {
  return (-2135621619);
 }

 pTime->second = static_cast<unsigned short>(second);



 return (0);
}



static __inline__ int sceRtcSetMicrosecond(SceRtcDateTime *pTime, int microsecond)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 if (microsecond<0 || microsecond>999999) {
  return (-2135621618);
 }

 pTime->microsecond = static_cast<unsigned int>(microsecond);



 return (0);
}



static __inline__ int sceRtcGetYear(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->year);
}



static __inline__ int sceRtcGetMonth(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->month);
}



static __inline__ int sceRtcGetDay(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->day);
}



static __inline__ int sceRtcGetHour(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->hour);
}



static __inline__ int sceRtcGetMinute(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->minute);
}



static __inline__ int sceRtcGetSecond(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }
 return (pTime->second);
}



static __inline__ int sceRtcGetMicrosecond(const SceRtcDateTime *pTime)
{
 if (pTime == __null) {
  return (-2135621630);
 }

 return static_cast<int>(pTime->microsecond);



}



}
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp" 2
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sceerror.h" 1 3








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sys/_defines/_sce_ok.h" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\sceerror.h" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 2 3


extern "C" {
# 187 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\libsysmodule.h" 3
int sceSysmoduleLoadModule(uint16_t id);
int sceSysmoduleUnloadModule(uint16_t id);
int sceSysmoduleIsLoaded(uint16_t id);


}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp" 2



# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Mount.h" 1






namespace SaveData
{
 struct MountPointManaged
 {
 public:
  char data[(16)];

  void CopyTo(SceSaveDataMountPoint &destination);
 };

 class MountRequest : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;
  UInt64 blocks;
  UInt64 systemBlocks;
  SceSaveDataMountMode mountMode;

  void CopyTo(SceSaveDataMount3 &destination, SceSaveDataDirName& sceDirName);
 };

 class MountPS4Request : public RequestBaseManaged
 {
 public:
  DirNameManaged dirName;
  TitleIdManaged titleId;
  FingerprintManaged fingerprint;

  void CopyTo(SceSaveDataTransferringMount &destination, SceSaveDataDirName& sceDirName, SceSaveDataTitleId& sceTitleId, SceSaveDataFingerprint& sceFingerprint);
 };


 class UnmountRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
 };

 class GetMountInfoRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
 };

 class GetMountParamsRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
 };

 class SaveIconRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
  char iconPath[(128)];

  void *pngData;
  UInt64 pngDataSize;
 };

 class LoadIconRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;
 };
# 85 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Mount.h"
 class SetMountParamsRequest : public RequestBaseManaged
 {
 public:
  MountPointManaged mountPoint;

  char title[(128)];
  char subTitle[(128)];
  char detail[(1024)];
  UInt32 userParam;

  void CopyTo(SceSaveDataParam &destination);
 };

 class Mounting
 {
 public:

  static void Mount(MountRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);

  static void MountPS4(MountPS4Request* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);

  static void Unmount(UnmountRequest* managedRequest, APIResult* result);
  static void GetMountInfo(GetMountInfoRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
  static void GetMountParams(GetMountParamsRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
  static void SetMountParams(SetMountParamsRequest* managedRequest, APIResult* result);
  static void SaveIcon(SaveIconRequest* managedRequest, APIResult* result);
  static void LoadIcon(LoadIconRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
 };
}
# 10 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp" 2


#pragma comment(lib,"libSceSaveData_stub_weak.a")
#pragma comment(lib,"libSceSaveDataDialog_stub_weak.a")


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataInitialize(InitResult* initResult, APIResult* result)
 {
  Main::Initialize(*initResult, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataTerminate(APIResult* result)
 {
  Main::Terminate(result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataSetThreadAffinity(ThreadSettings settings, APIResult* result)
 {
  Main::SetThreadAffinity(settings, result);
 }

 bool Main::s_Initialised = false;

 IPluginUnity* Main::s_IUnity = __null;
 IPluginSceAppParams* Main::s_ISceAppParams = __null;
 IPluginSceNpParams* Main::s_ISceNpParams = __null;

 void Main::Initialize(InitResult& initResult, APIResult* result)
 {
  if (s_Initialised)
  {
   (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Error, "SaveData Plugin already initialised", "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp", 43));
   return;
  }

  MemoryBuffer::Initialise();

  int32_t ret = sceSaveDataInitialize3(__null);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp", 53));
   return;
  }

  ret = sceSysmoduleLoadModule(0x00a0);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp", 61));
   return;
  }



  s_Initialised = true;

  initResult.initialized = true;
  initResult.sceSDKVersion = (0x08000045u);

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Main::Terminate(APIResult* result)
 {
  int32_t ret = sceSaveDataTerminate();

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp", 81));
   return;
  }
# 93 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp"
  ret = sceSysmoduleUnloadModule(0x00a0);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp", 97));
   return;
  }

  MemoryBuffer::Shutdown();

  s_Initialised = false;

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }


 void Main::SetThreadAffinity(ThreadSettings settings, APIResult* result)
 {
  ScePthread thread = scePthreadSelf();

  int32_t ret = scePthreadRename(thread, settings.name);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp", 117));
   return;
  }

  ret = scePthreadSetaffinity(thread, settings.affinityMask);

  if (ret != 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp", 125));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Main::LoadModules()
 {





 }

 void Main::UnloadModules()
 {





 }

 void Main::SetupRuntimeInterfaces()
 {
  if (g_QueryInterface)
  {
   s_IUnity = GetRuntimeInterface<IPluginUnity>(0x00000001);
   s_ISceAppParams = GetRuntimeInterface<IPluginSceAppParams>(0x00000002);
   s_ISceNpParams = GetRuntimeInterface<IPluginSceNpParams>(0x00000003);
  }
 }
# 171 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Main.cpp"
}
# 14 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp" 1


# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Utils.h" 1






namespace SaveData
{
 class Utils
 {
 public:

  static int32_t LoadFile(const char *mountPoint, const char *fileName, uint8_t** loadeddata, __int64_t *datasize, bool dialogEnabled);
  static int32_t LoadFile(const char *path, uint8_t** data, size_t *datasize);
 };
}
# 4 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Transactions.h" 1




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 1 3
# 10 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 1 3
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
namespace std {

template<class _Mytree,
 class _Base = _Iterator_base0>
 class _Tree_unchecked_const_iterator
  : public _Iterator012<bidirectional_iterator_tag,
   typename _Mytree::value_type,
   typename _Mytree::difference_type,
   typename _Mytree::const_pointer,
   typename _Mytree::const_reference,
   _Base>
 {
public:
 typedef _Tree_unchecked_const_iterator<_Mytree, _Base> _Myiter;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::const_pointer pointer;
 typedef typename _Mytree::const_reference reference;

 _Tree_unchecked_const_iterator()
  : _Ptr(nullptr)
  {
  }

 _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Ptr(_Pnode)
  {
  this->_Adopt(_Plist);
  }

 reference operator*() const
  {
  return (_Mytree::_Myval(_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  if (_Mytree::_Isnil(_Ptr))
   ;
  else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
   _Ptr = _Mytree::_Min(
    _Mytree::_Right(_Ptr));
  else
   {
   _Nodeptr _Pnode;
   while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
    && _Ptr == _Mytree::_Right(_Pnode))
    _Ptr = _Pnode;
   _Ptr = _Pnode;
   }
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  if (_Mytree::_Isnil(_Ptr))
   _Ptr = _Mytree::_Right(_Ptr);
  else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
   _Ptr = _Mytree::_Max(
    _Mytree::_Left(_Ptr));
  else
   {
   _Nodeptr _Pnode;
   while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
    && _Ptr == _Mytree::_Left(_Pnode))
    _Ptr = _Pnode;
   if (_Mytree::_Isnil(_Ptr))
    ;
   else
    _Ptr = _Pnode;
   }
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 _Nodeptr _Mynode() const
  {
  return (_Ptr);
  }

 _Nodeptr _Ptr;
 };


template<class _Mytree>
 class _Tree_unchecked_iterator
  : public _Tree_unchecked_const_iterator<_Mytree>
 {
public:
 typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
 typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::pointer pointer;
 typedef typename _Mytree::reference reference;

 _Tree_unchecked_iterator()
  {
  }

 _Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };


template<class _Mytree>
 class _Tree_const_iterator
  : public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
 {
public:
 typedef _Tree_const_iterator<_Mytree> _Myiter;
 typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::const_pointer pointer;
 typedef typename _Mytree::const_reference reference;

 _Tree_const_iterator()
  : _Mybase()
  {
  }

 _Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
  }

 reference operator*() const
  {
# 250 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  return (_Mytree::_Myval(this->_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
# 274 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
# 311 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  --(*(_Mybase *)this);


  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
# 337 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }
 };

template<class _Mytree> inline
 typename _Tree_const_iterator<_Mytree>::_Unchecked_type
  _Unchecked(_Tree_const_iterator<_Mytree> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mytree> inline
 _Tree_const_iterator<_Mytree>&
  _Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
   typename _Tree_const_iterator<_Mytree>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Mytree>
 class _Tree_iterator
  : public _Tree_const_iterator<_Mytree>
 {
public:
 typedef _Tree_iterator<_Mytree> _Myiter;
 typedef _Tree_const_iterator<_Mytree> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;

 typedef typename _Mytree::pointer pointer;
 typedef typename _Mytree::reference reference;

 _Tree_iterator()
  {
  }

 _Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };

template<class _Mytree> inline
 typename _Tree_iterator<_Mytree>::_Unchecked_type
  _Unchecked(_Tree_iterator<_Mytree> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mytree> inline
 _Tree_iterator<_Mytree>&
  _Rechecked(_Tree_iterator<_Mytree>& _Iter,
   typename _Tree_iterator<_Mytree>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference,
 class _Nodeptr_type>
 struct _Tree_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 typedef _Nodeptr_type _Nodeptr;
 };

template<class _Value_type,
 class _Voidptr>
 struct _Tree_node
  {
  _Voidptr _Left;
  _Voidptr _Parent;
  _Voidptr _Right;
  char _Color;
  char _Isnil;
  _Value_type _Myval;

 private:
  _Tree_node& operator=(const _Tree_node&);
  };

template<class _Value_type>
 struct _Tree_node<_Value_type, void *>
  {
  typedef _Tree_node<_Value_type, void *> *_Nodeptr;
  _Nodeptr _Left;
  _Nodeptr _Parent;
  _Nodeptr _Right;
  char _Color;
  char _Isnil;
  _Value_type _Myval;

 private:
  _Tree_node& operator=(const _Tree_node&);
  };

template<class _Ty>
 struct _Tree_simple_types
  : public _Simple_types<_Ty>
 {
 typedef _Tree_node<_Ty, void *> _Node;
 typedef _Node *_Nodeptr;
 };

template<class _Ty,
 class _Alloc0>
 struct _Tree_base_types
 {
# 525 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 typedef _Alloc0 _Alloc;


 typedef _Tree_base_types<_Ty, _Alloc0> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;

 typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
  _Voidptr;
 typedef _Tree_node<typename _Alty::value_type,
  _Voidptr> _Node;

 typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
 typedef typename _Alnod_type::pointer _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Tree_simple_types<typename _Alty::value_type>,
  _Tree_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference,
   _Nodeptr> >::type
  _Val_types;
 };


template<class _Val_types>
 class _Tree_val
  : public _Container_base
 {
public:
 typedef _Tree_val<_Val_types> _Myt;

 typedef typename _Val_types::_Nodeptr _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _Tree_const_iterator<_Myt> const_iterator;
 typedef _Tree_iterator<_Myt> iterator;

 _Tree_val()
  {
  this->_Myhead = 0;
  this->_Mysize = 0;
  }

 enum _Redbl
  {
  _Red, _Black};

 static char& _Color(_Nodeptr _Pnode)
  {
  return ((char&)_Pnode->_Color);
  }

 static char& _Isnil(_Nodeptr _Pnode)
  {
  return ((char&)_Pnode->_Isnil);
  }

 static _Nodepref _Left(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Left);
  }

 static _Nodepref _Parent(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Parent);
  }

 static _Nodepref _Right(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Right);
  }

 static reference _Myval(_Nodeptr _Pnode)
  {
  return ((reference)_Pnode->_Myval);
  }

 static _Nodeptr _Max(_Nodeptr _Pnode)
  {
  while (!_Isnil(_Right(_Pnode)))
   _Pnode = _Right(_Pnode);
  return (_Pnode);
  }

 static _Nodeptr _Min(_Nodeptr _Pnode)
  {
  while (!_Isnil(_Left(_Pnode)))
   _Pnode = _Left(_Pnode);
  return (_Pnode);
  }

 _Nodeptr _Myhead;
 size_type _Mysize;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _Tree_alloc
  : public _Tree_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;

 _Tree_alloc(const _Alloc0& _Al = _Alloc0())
  : _Alnod(_Al)
  {
  _Construct();
  }

 _Tree_alloc(_Alloc0&& _Al)
  : _Alnod(::std:: move(_Al))
  {
  _Construct();
  }


 void _Construct()
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_Tree_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty& _Al)
  {
  _Pocca(_Alnod, _Al);
  }

 void _Move_alloc(_Alty& _Al)
  {
  _Pocma(_Alnod, _Al);
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Pocs(_Alnod, _Right._Alnod);
  }
# 745 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 _Nodeptr _Buyheadnode()
  {
  _Nodeptr _Pnode = _Alnod.allocate(1);

  {{
  _Alnod.construct(
   ::std:: addressof(this->_Left(_Pnode)), _Pnode);
  _Alnod.construct(
   ::std:: addressof(this->_Parent(_Pnode)), _Pnode);
  _Alnod.construct(
   ::std:: addressof(this->_Right(_Pnode)), _Pnode);
  } if (0) {
  _Alnod.deallocate(_Pnode, 1);
          ;
  }}

  this->_Color(_Pnode) = this->_Black;
  this->_Isnil(_Pnode) = true;
  return (_Pnode);
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  _Alnod.destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  _Alnod.destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  _Alnod.destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  _Alnod.deallocate(_Pnode, 1);
  }

 _Alty& _Getal() noexcept
  {
  return (_Alnod);
  }

 const _Alty& _Getal() const noexcept
  {
  return (_Alnod);
  }

 _Alty _Alnod;
 };


template<class _Alloc_types>
 class _Tree_alloc<false, _Alloc_types>
  : public _Tree_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _Tree_alloc<false, _Alloc_types> _Myt;
 typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc0;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;

 _Tree_alloc(const _Alloc0& = _Alloc0())
  {
  _Construct();
  }

 _Tree_alloc(_Alloc0&&)
  {
  _Construct();
  }


 void _Construct()
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_Tree_alloc() noexcept
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Copy_alloc(const _Alty&)
  {
  }

 void _Move_alloc(_Alty&&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
# 887 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 _Nodeptr _Buyheadnode()
  {
  _Nodeptr _Pnode = this->_Getal().allocate(1);

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Left(_Pnode)), _Pnode);
  this->_Getal().construct(
   ::std:: addressof(this->_Parent(_Pnode)), _Pnode);
  this->_Getal().construct(
   ::std:: addressof(this->_Right(_Pnode)), _Pnode);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  this->_Color(_Pnode) = this->_Black;
  this->_Isnil(_Pnode) = true;
  return (_Pnode);
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 _Alty _Getal() const noexcept
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc>
 class _Tree_buy
  : public _Tree_alloc<!is_empty<_Alloc>::value,
   _Tree_base_types<_Ty, _Alloc> >
 {
public:
 typedef _Tree_alloc<!is_empty<_Alloc>::value,
  _Tree_base_types<_Ty, _Alloc> > _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Nodeptr _Nodeptr;

 _Tree_buy(const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  }

 _Nodeptr _Buynode0(_Nodeptr _Pnode = nullptr)
  {
  if (_Pnode == nullptr)
   _Pnode = this->_Getal().allocate(1);

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Left(_Pnode)), this->_Myhead);
  this->_Getal().construct(
   ::std:: addressof(this->_Parent(_Pnode)), this->_Myhead);
  this->_Getal().construct(
   ::std:: addressof(this->_Right(_Pnode)), this->_Myhead);
  } if (0) {
  this->_Getal().deallocate(_Pnode, 1);
          ;
  }}

  return (_Pnode);
  }

 void _Freenode0(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 template<class... _Valty>
  _Nodeptr _Buynode(_Valty&&... _Val)
  {
  _Nodeptr _Pnode = _Buynode0();

  this->_Color(_Pnode) = this->_Red;
  this->_Isnil(_Pnode) = false;

  {{
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Pnode)),
    ::std:: forward<_Valty>(_Val)...);
  } if (0) {
  _Freenode0(_Pnode);
          ;
  }}

  return (_Pnode);
  }
 };


template<bool _Pr_has_storage,
 class _Traits>
 class _Tree_comp
  : public _Tree_buy<typename _Traits::value_type,
   typename _Traits::allocator_type>
 {
public:
 typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
 typedef _Tree_buy<typename _Traits::value_type,
  typename _Traits::allocator_type> _Mybase;

 typedef typename _Traits::allocator_type allocator_type;
 typedef typename _Traits::key_compare key_compare;

 _Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
  : _Mybase(_Al), comp(_Parg)
  {
  }

 key_compare& _Getcomp()
  {
  return (comp);
  }

 const key_compare& _Getcomp() const
  {
  return (comp);
  }

 void _Setcomp(const key_compare& _Right)
  {
  comp = _Right;
  }

 void _Swapcomp(key_compare& _Right)
  {
  _Swap_adl(comp, _Right);
  }

 key_compare comp;
 };

template<class _Traits>
 class _Tree_comp<false, _Traits>
  : public _Tree_buy<typename _Traits::value_type,
   typename _Traits::allocator_type>
 {
public:
 typedef _Tree_comp<false, _Traits> _Myt;
 typedef _Tree_buy<typename _Traits::value_type,
  typename _Traits::allocator_type> _Mybase;

 typedef typename _Traits::allocator_type allocator_type;
 typedef typename _Traits::key_compare key_compare;

 _Tree_comp(const key_compare&, const allocator_type& _Al)
  : _Mybase(_Al)
  {
  }

 key_compare _Getcomp() const
  {
  return (key_compare());
  }

 void _Setcomp(const key_compare&)
  {
  }

 void _Swapcomp(const key_compare&)
  {
  }
 };


template<class _Traits>
 class _Tree
  : public _Tree_comp<
   !is_empty<typename _Traits::key_compare>::value, _Traits>
 {
public:
 typedef _Tree<_Traits> _Myt;
 typedef _Tree_comp<
  !is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;

 typedef typename _Traits::key_type key_type;
 typedef typename _Traits::value_compare value_compare;
 enum
  {
  _Multi = _Traits::_Multi};

 typedef typename _Mybase::_Node _Node;
 typedef typename _Mybase::_Nodeptr _Nodeptr;
 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::key_compare key_compare;
 typedef typename _Mybase::allocator_type allocator_type;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;

 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _If<is_same<key_type, value_type>::value,
  typename _Mybase::const_iterator,
  typename _Mybase::iterator>::type iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 typedef pair<iterator, bool> _Pairib;
 typedef pair<iterator, iterator> _Pairii;
 typedef pair<const_iterator, const_iterator> _Paircc;

 struct _Copy_tag
  {
  };
 struct _Move_tag
  {
  };

 _Tree(const key_compare& _Parg,
  const allocator_type& _Al)
  : _Mybase(_Parg, _Al)
  {
  }

 _Tree(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right.key_comp(), _Al)
  {
  {{
  _Copy(_Right, _Copy_tag());
  } if (0) {
  _Tidy();
          ;
  }}
  }

 _Tree(_Myt&& _Right)
  : _Mybase(_Right.key_comp(), ::std:: move(_Right._Getal()))
  {
  _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  }

 _Tree(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(_Right.key_comp(), _Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   clear();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Move_alloc(_Right._Getal());

   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right, true_type)
  {
  this->_Swap_all(_Right);
  this->_Swapcomp(_Right._Getcomp());
  _Swap_adl(this->_Myhead, _Right._Myhead);
  ::std:: swap(this->_Mysize, _Right._Mysize);
  }

 void _Assign_rv(_Myt&& _Right, false_type)
  {
  if (get_allocator() == _Right.get_allocator())
   _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  else
   _Copy(_Right, _Move_tag());
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right),
   typename _Alty::propagate_on_container_move_assignment());
  }

 _Pairib insert(value_type&& _Val)
  {
  return (_Insert_nohint(false,
   ::std:: forward<value_type>(_Val), _Nil()));
  }

 iterator insert(const_iterator _Where, value_type&& _Val)
  {
  return (_Insert_hint(_Where,
   ::std:: forward<value_type>(_Val), _Nil()));
  }

 template<class _Valty,
  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,
   void> >
  _Pairib insert(_Valty&& _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
  return (_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class _Valty,
  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,
   void> >
  iterator insert(const_iterator _Where, _Valty&& _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
  return (_Insert_hint(_Where,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class _Valty>
  typename enable_if<is_convertible<_Valty, key_type>::value
   && !is_same<typename remove_cv<key_type>::type, value_type>::value,
   _Pairib>::type
  emplace(_Valty&& _Val)
  {
  typedef typename value_type::second_type mapped_type;
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val),
   mapped_type());
  return (_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class... _Valty>
  _Pairib emplace(_Valty&&... _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
  return (_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class... _Valty>
  iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
  return (_Insert_hint(_Where,
   this->_Myval(_Newnode), _Newnode));
  }

 ~_Tree() noexcept
  {
  _Tidy();
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   clear();
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    this->_Copy_alloc(_Right._Getal());
   this->_Getcomp() = _Right._Getcomp();
   _Copy(_Right, _Copy_tag());
   }
  return (*this);
  }

 iterator begin() noexcept
  {
  return (iterator(_Lmost(), this));
  }

 const_iterator begin() const noexcept
  {
  return (const_iterator(_Lmost(), this));
  }

 iterator end() noexcept
  {
  return (iterator(this->_Myhead, this));
  }

 const_iterator end() const noexcept
  {
  return (const_iterator(this->_Myhead, this));
  }

 reverse_iterator rbegin() noexcept
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const noexcept
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() noexcept
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const noexcept
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const noexcept
  {
  return (begin());
  }

 const_iterator cend() const noexcept
  {
  return (end());
  }

 const_reverse_iterator crbegin() const noexcept
  {
  return (rbegin());
  }

 const_reverse_iterator crend() const noexcept
  {
  return (rend());
  }

 size_type size() const noexcept
  {
  return (this->_Mysize);
  }

 size_type max_size() const noexcept
  {
  return (this->_Getal().max_size());
  }

 bool empty() const noexcept
  {
  return (size() == 0);
  }

 allocator_type get_allocator() const noexcept
  {
  return (this->_Getal());
  }

 key_compare key_comp() const
  {
  return (this->_Getcomp());
  }

 value_compare value_comp() const
  {
  return (value_compare(key_comp()));
  }
# 1401 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 _Pairib insert(const value_type& _Val)
  {
  return (_Insert_nohint(false,
   _Val, _Nil()));
  }

 iterator insert(const_iterator _Where,
  const value_type& _Val)
  {
  return (_Insert_hint(_Where,
   _Val, _Nil()));
  }

 template<class _Iter>
  void insert(_Iter _First, _Iter _Last)
  {
                             ;
  for (; _First != _Last; ++_First)
   emplace_hint(end(), *_First);
  }

 void insert(::std:: initializer_list<value_type> _Ilist)
  {
  insert(_Ilist.begin(), _Ilist.end());
  }

 iterator erase(const_iterator _Where,
  bool _Keep = false)
  {
# 1440 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
  if (this->_Isnil(_Where._Mynode()))
   _Xout_of_range("invalid map/set<T> iterator");
  _Nodeptr _Erasednode = _Where._Mynode();
  ++_Where;


  _Nodeptr _Fixnode;
  _Nodeptr _Fixnodeparent;
  _Nodeptr _Pnode = _Erasednode;

  if (this->_Isnil(this->_Left(_Pnode)))
   _Fixnode = this->_Right(_Pnode);
  else if (this->_Isnil(this->_Right(_Pnode)))
   _Fixnode = this->_Left(_Pnode);
  else
   {
   _Pnode = _Where._Mynode();
   _Fixnode = this->_Right(_Pnode);
   }

  if (_Pnode == _Erasednode)
   {
   _Fixnodeparent = this->_Parent(_Erasednode);
   if (!this->_Isnil(_Fixnode))
    this->_Parent(_Fixnode) = _Fixnodeparent;

   if (_Root() == _Erasednode)
    _Root() = _Fixnode;
   else if (this->_Left(_Fixnodeparent) == _Erasednode)
    this->_Left(_Fixnodeparent) = _Fixnode;
   else
    this->_Right(_Fixnodeparent) =
     _Fixnode;

   if (_Lmost() == _Erasednode)
    _Lmost() = this->_Isnil(_Fixnode)
     ? _Fixnodeparent
     : this->_Min(_Fixnode);

   if (_Rmost() == _Erasednode)
    _Rmost() = this->_Isnil(_Fixnode)
     ? _Fixnodeparent
     : this->_Max(_Fixnode);
   }
  else
   {
   this->_Parent(this->_Left(_Erasednode)) =
    _Pnode;
   this->_Left(_Pnode) =
    this->_Left(_Erasednode);

   if (_Pnode == this->_Right(_Erasednode))
    _Fixnodeparent = _Pnode;
   else
    {
    _Fixnodeparent =
     this->_Parent(_Pnode);
    if (!this->_Isnil(_Fixnode))
     this->_Parent(_Fixnode) = _Fixnodeparent;
    this->_Left(_Fixnodeparent) = _Fixnode;
    this->_Right(_Pnode) =
     this->_Right(_Erasednode);
    this->_Parent(this->_Right(_Erasednode)) =
     _Pnode;
    }

   if (_Root() == _Erasednode)
    _Root() = _Pnode;
   else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
    this->_Left(this->_Parent(_Erasednode)) =
     _Pnode;
   else
    this->_Right(this->_Parent(_Erasednode)) =
     _Pnode;

   this->_Parent(_Pnode) =
    this->_Parent(_Erasednode);
   ::std:: swap(this->_Color(_Pnode),
    this->_Color(_Erasednode));
   }

  if (this->_Color(_Erasednode) == this->_Black)
   {
   for (; _Fixnode != _Root()
    && this->_Color(_Fixnode) == this->_Black;
    _Fixnodeparent = this->_Parent(_Fixnode))
    if (_Fixnode == this->_Left(_Fixnodeparent))
     {
     _Pnode = this->_Right(_Fixnodeparent);
     if (this->_Color(_Pnode) == this->_Red)
      {
      this->_Color(_Pnode) = this->_Black;
      this->_Color(_Fixnodeparent) = this->_Red;
      _Lrotate(_Fixnodeparent);
      _Pnode = this->_Right(_Fixnodeparent);
      }

     if (this->_Isnil(_Pnode))
      _Fixnode = _Fixnodeparent;
     else if (this->_Color(this->_Left(_Pnode)) == this->_Black
      && this->_Color(this->_Right(_Pnode)) == this->_Black)
      {
      this->_Color(_Pnode) = this->_Red;
      _Fixnode = _Fixnodeparent;
      }
     else
      {
      if (this->_Color(this->_Right(_Pnode))
       == this->_Black)
       {
       this->_Color(this->_Left(_Pnode)) = this->_Black;
       this->_Color(_Pnode) = this->_Red;
       _Rrotate(_Pnode);
       _Pnode = this->_Right(_Fixnodeparent);
       }

      this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
      this->_Color(_Fixnodeparent) = this->_Black;
      this->_Color(this->_Right(_Pnode)) = this->_Black;
      _Lrotate(_Fixnodeparent);
      break;
      }
     }
    else
     {
     _Pnode = this->_Left(_Fixnodeparent);
     if (this->_Color(_Pnode) == this->_Red)
      {
      this->_Color(_Pnode) = this->_Black;
      this->_Color(_Fixnodeparent) = this->_Red;
      _Rrotate(_Fixnodeparent);
      _Pnode = this->_Left(_Fixnodeparent);
      }

     if (this->_Isnil(_Pnode))
      _Fixnode = _Fixnodeparent;
     else if (this->_Color(this->_Right(_Pnode)) ==
      this->_Black
      && this->_Color(this->_Left(_Pnode)) == this->_Black)
      {
      this->_Color(_Pnode) = this->_Red;
      _Fixnode = _Fixnodeparent;
      }
     else
      {
      if (this->_Color(this->_Left(_Pnode)) == this->_Black)
       {
       this->_Color(this->_Right(_Pnode)) = this->_Black;
       this->_Color(_Pnode) = this->_Red;
       _Lrotate(_Pnode);
       _Pnode = this->_Left(_Fixnodeparent);
       }

      this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
      this->_Color(_Fixnodeparent) = this->_Black;
      this->_Color(this->_Left(_Pnode)) = this->_Black;
      _Rrotate(_Fixnodeparent);
      break;
      }
     }

   this->_Color(_Fixnode) = this->_Black;
   }

  if (!_Keep)
   {
   this->_Getal().destroy(
    ::std:: addressof(this->_Myval(_Erasednode)));
   this->_Getal().deallocate(_Erasednode, 1);
   }
  if (0 < this->_Mysize)
   --this->_Mysize;

  return (iterator(_Where._Ptr,
   this));
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
  if (_First == begin() && _Last == end())
   {
   clear();
   return (begin());
   }
  else
   {
   while (_First != _Last)
    erase(_First++);
   return (iterator(_First._Ptr, this));
   }
  }

 size_type erase(const key_type& _Keyval)
  {
  _Pairii _Where = equal_range(_Keyval);
  size_type _Num = 0;
  _Distance(_Where.first, _Where.second, _Num);
  erase(_Where.first, _Where.second);
  return (_Num);
  }

 void clear() noexcept
  {




  _Erase(_Root());
  _Root() = this->_Myhead;
  _Lmost() = this->_Myhead;
  _Rmost() = this->_Myhead;
  this->_Mysize = 0;
  }

 iterator find(const key_type& _Keyval)
  {
  iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }

 const_iterator find(const key_type& _Keyval) const
  {
  const_iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  iterator find(const _Other& _Keyval)
  {
  iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }

 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  const_iterator find(const _Other& _Keyval) const
  {
  const_iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }


 size_type count(const key_type& _Keyval) const
  {
  _Paircc _Ans = equal_range(_Keyval);
  size_type _Num = 0;
  _Distance(_Ans.first, _Ans.second, _Num);
  return (_Num);
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  size_type count(const _Other& _Keyval) const
  {
  _Paircc _Ans = equal_range(_Keyval);
  size_type _Num = 0;
  _Distance(_Ans.first, _Ans.second, _Num);
  return (_Num);
  }


 iterator lower_bound(const key_type& _Keyval)
  {
  return (iterator(_Lbound(_Keyval), this));
  }

 const_iterator lower_bound(const key_type& _Keyval) const
  {
  return (const_iterator(_Lbound(_Keyval), this));
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  iterator lower_bound(const _Other& _Keyval)
  {
  return (iterator(_Lbound(_Keyval), this));
  }

 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  const_iterator lower_bound(const _Other& _Keyval) const
  {
  return (const_iterator(_Lbound(_Keyval), this));
  }


 iterator upper_bound(const key_type& _Keyval)
  {
  return (iterator(_Ubound(_Keyval), this));
  }

 const_iterator upper_bound(const key_type& _Keyval) const
  {
  return (const_iterator(_Ubound(_Keyval), this));
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  iterator upper_bound(const _Other& _Keyval)
  {
  return (iterator(_Ubound(_Keyval), this));
  }

 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  const_iterator upper_bound(const _Other& _Keyval) const
  {
  return (const_iterator(_Ubound(_Keyval), this));
  }


 _Pairii equal_range(const key_type& _Keyval)
  {
  return (_Eqrange(_Keyval));
  }

 _Paircc equal_range(const key_type& _Keyval) const
  {
  return (_Eqrange(_Keyval));
  }


 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  _Pairii equal_range(const _Other& _Keyval)
  {
  return (_Eqrange(_Keyval));
  }

 template<class _Other,
  class _Mycomp = key_compare,
  class = typename _Mycomp::is_transparent>
  _Paircc equal_range(const _Other& _Keyval) const
  {
  return (_Eqrange(_Keyval));
  }


 void swap(_Myt& _Right)
  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   this->_Swapcomp(_Right._Getcomp());
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   this->_Swapcomp(_Right._Getcomp());
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }
  else
   {




   ::std:: terminate();

   }
  }

protected:
 template<class _Valty>
  _Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
  {
  return (_Node);
  }

 template<class _Valty>
  _Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
  {
  return (this->_Buynode(::std:: forward<_Valty>(_Val)));
  }

 void _Destroy_if_not_nil(_Nodeptr _Newnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Newnode)));
  this->_Getal().deallocate(_Newnode, 1);
  }

 void _Destroy_if_not_nil(_Nil)
  {
  }

 template<class _Valty,
  class _Nodety>
  iterator _Insert_hint(const_iterator _Where,
   _Valty&& _Val, _Nodety _Newnode)
  {
  const_iterator _Next;
  bool _Leftish = false;

  {{






  if (size() == 0)
   return (_Insert_at(true, this->_Myhead,
    ::std:: forward<_Valty>(_Val), _Newnode));
  else if (this->_Multi)
   {
   if (_Where == begin())
    {
    if (!this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val)))

     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    _Leftish = true;
    }
   else if (_Where == end())
    {
    if (!this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Rmost())))

     return (_Insert_at(false, _Rmost(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (!this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val))

    && !this->_Getcomp()(this->_Kfn(_Val), this->_Key((--(_Next = _Where))._Mynode())))


    {
    if (this->_Isnil(this->_Right(_Next._Mynode())))
     return (_Insert_at(false, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (!this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode()))

    && (++(_Next = _Where) == end()
     || !this->_Getcomp()(this->_Key(_Next._Mynode()), this->_Kfn(_Val))))

    {
    if (this->_Isnil(this->_Right(_Where._Mynode())))
     return (_Insert_at(false, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else
    _Leftish = true;
   }
  else
   {
   if (_Where == begin())
    {
    if (this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode())))

     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (_Where == end())
    {
    if (this->_Getcomp()(this->_Key(_Rmost()), this->_Kfn(_Val)))

     return (_Insert_at(false, _Rmost(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode()))

    && this->_Getcomp()(this->_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))


    {
    if (this->_Isnil(this->_Right(_Next._Mynode())))
     return (_Insert_at(false, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val))

    && (++(_Next = _Where) == end()
     || this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Next._Mynode()))))

    {
    if (this->_Isnil(this->_Right(_Where._Mynode())))
     return (_Insert_at(false, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   }
  } if (0) {
  _Destroy_if_not_nil(_Newnode);
          ;
  }}

  return (_Insert_nohint(_Leftish,
   ::std:: forward<_Valty>(_Val), _Newnode).first);
  }

 template<class _Valty,
  class _Nodety>
  _Pairib _Insert_nohint(bool _Leftish,
   _Valty&& _Val, _Nodety _Newnode, bool _Keep = false)
  {
  {{
  _Nodeptr _Trynode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;
  bool _Addleft = true;

  while (!this->_Isnil(_Trynode))
   {
   _Wherenode = _Trynode;
   if (_Leftish)
    _Addleft = !this->_Getcomp()(this->_Key(_Trynode), this->_Kfn(_Val));


   else
    _Addleft = this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Trynode));


   _Trynode = _Addleft ? this->_Left(_Trynode)
    : this->_Right(_Trynode);
   }

  if (this->_Multi)
   return (_Pairib(_Insert_at(_Addleft, _Wherenode,
    ::std:: forward<_Valty>(_Val), _Newnode), true));
  else
   {
   iterator _Where = iterator(_Wherenode, this);
   if (!_Addleft)
    ;
   else if (_Where == begin())
    return (_Pairib(_Insert_at(true, _Wherenode,
     ::std:: forward<_Valty>(_Val), _Newnode), true));
   else
    --_Where;

   if (this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val)))


    return (_Pairib(_Insert_at(_Addleft, _Wherenode,
     ::std:: forward<_Valty>(_Val), _Newnode), true));
   else
    {
    if (!_Keep)
     _Destroy_if_not_nil(_Newnode);
    return (_Pairib(_Where, false));
    }
   }
  } if (0) {
  _Destroy_if_not_nil(_Newnode);
          ;
  }}
  }

 template<class _Valty,
  class _Nodety>
  iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
  _Valty&& _Val, _Nodety _Node)
  {
  if (max_size() - 1 <= this->_Mysize)
   {
   _Destroy_if_not_nil(_Node);
   _Xlength_error("map/set<T> too long");
   }
  _Nodeptr _Newnode = _Buynode_if_nil(_Node,
   ::std:: forward<_Valty>(_Val));

  ++this->_Mysize;
  _Newnode->_Parent = _Wherenode;

  if (_Wherenode == this->_Myhead)
   {
   _Root() = _Newnode;
   _Lmost() = _Newnode;
   _Rmost() = _Newnode;
   }
  else if (_Addleft)
   {
   this->_Left(_Wherenode) = _Newnode;
   if (_Wherenode == _Lmost())
    _Lmost() = _Newnode;
   }
  else
   {
   this->_Right(_Wherenode) = _Newnode;
   if (_Wherenode == _Rmost())
    _Rmost() = _Newnode;
   }

  for (_Nodeptr _Pnode = _Newnode;
   this->_Color(this->_Parent(_Pnode)) == this->_Red; )
   if (this->_Parent(_Pnode)
    == this->_Left(this->_Parent(this->_Parent(_Pnode))))
    {
    _Wherenode =
     this->_Right(this->_Parent(this->_Parent(_Pnode)));
    if (this->_Color(_Wherenode) == this->_Red)
     {
     this->_Color(this->_Parent(_Pnode)) = this->_Black;
     this->_Color(_Wherenode) = this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode)))
      = this->_Red;
     _Pnode = this->_Parent(this->_Parent(_Pnode));
     }
    else
     {
     if (_Pnode == this->_Right(this->_Parent(_Pnode)))
      {
      _Pnode = this->_Parent(_Pnode);
      _Lrotate(_Pnode);
      }
     this->_Color(this->_Parent(_Pnode)) =
      this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Rrotate(this->_Parent(this->_Parent(_Pnode)));
     }
    }
   else
    {
    _Wherenode =
     this->_Left(this->_Parent(this->_Parent(_Pnode)));
    if (this->_Color(_Wherenode) == this->_Red)
     {
     this->_Color(this->_Parent(_Pnode)) = this->_Black;
     this->_Color(_Wherenode) = this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Pnode = this->_Parent(this->_Parent(_Pnode));
     }
    else
     {
     if (_Pnode == this->_Left(this->_Parent(_Pnode)))
      {
      _Pnode = this->_Parent(_Pnode);
      _Rrotate(_Pnode);
      }
     this->_Color(this->_Parent(_Pnode)) =
      this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Lrotate(this->_Parent(this->_Parent(_Pnode)));
     }
    }

  this->_Color(_Root()) = this->_Black;
  return (iterator(_Newnode, this));
  }

 template<class _Moveit>
  void _Copy(const _Myt& _Right, _Moveit _Movefl)
  {
  _Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
  this->_Mysize = _Right.size();
  this->_Getcomp() = _Right._Getcomp();
  if (!this->_Isnil(_Root()))
   {
   _Lmost() = this->_Min(_Root());
   _Rmost() = this->_Max(_Root());
   }
  else
   {
   _Lmost() = this->_Myhead;
   _Rmost() = this->_Myhead;
   }
  }

 template<class _Ty,
  class _Is_set>
  _Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
  {
  return (this->_Buynode(_Val));
  }

 template<class _Ty>
  _Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
  {
  return (this->_Buynode(::std:: move(_Val)));
  }

 template<class _Ty>
  _Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
  {
  return (this->_Buynode(
   ::std:: move(const_cast<key_type&>(_Val.first)),
   ::std:: move(_Val.second)));
  }

 template<class _Moveit>
  _Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
   _Moveit _Movefl)
  {
  _Nodeptr _Newroot = this->_Myhead;

  if (!this->_Isnil(_Rootnode))
   {
   typename is_same<key_type, value_type>::type _Is_set;
   _Nodeptr _Pnode = _Copy_or_move(
    this->_Myval(_Rootnode), _Movefl, _Is_set);
   _Pnode->_Parent = _Wherenode;
   _Pnode->_Color = this->_Color(_Rootnode);
   if (this->_Isnil(_Newroot))
    _Newroot = _Pnode;

   {{
   this->_Left(_Pnode) =
    _Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
   this->_Right(_Pnode) =
    _Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
   } if (0) {
   _Erase(_Newroot);
           ;
   }}
   }

  return (_Newroot);
  }
# 2214 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 template<class _Other>
  _Paircc _Eqrange(const _Other& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Lonode = this->_Myhead;
  _Nodeptr _Hinode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    if (this->_Isnil(_Hinode)
      && this->_Getcomp()(_Keyval, this->_Key(_Pnode)))

     _Hinode = _Pnode;
    _Lonode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  _Pnode = this->_Isnil(_Hinode) ? _Root()
   : this->_Left(_Hinode);
  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(_Keyval, this->_Key(_Pnode)))
    {
    _Hinode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }
   else
    _Pnode = this->_Right(_Pnode);

  const_iterator _First = const_iterator(_Lonode, this);
  const_iterator _Last = const_iterator(_Hinode, this);
  return (_Paircc(_First, _Last));
  }

 template<class _Other>
  _Pairii _Eqrange(const _Other& _Keyval)
  {
  _Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));
  iterator _First = iterator(_Ans.first._Ptr, this);
  iterator _Last = iterator(_Ans.second._Ptr, this);
  return (_Pairii(_First, _Last));
  }

 void _Erase(_Nodeptr _Rootnode)
  {
  for (_Nodeptr _Pnode = _Rootnode;
   !this->_Isnil(_Pnode); _Rootnode = _Pnode)
   {
   _Erase(this->_Right(_Pnode));
   _Pnode = this->_Left(_Pnode);
   this->_Getal().destroy(
    ::std:: addressof(this->_Myval(_Rootnode)));

   this->_Getal().deallocate(_Rootnode, 1);
   }
  }

 bool _Compare(const key_type& _Left, const key_type& _Right) const
  {
  return (this->_Getcomp()(_Left, _Right));
  }

 template<class _Ty1,
  class _Ty2>
  bool _Compare(const _Ty1& _Left, const _Ty2& _Right) const
  {
  return (this->_Getcomp()(_Left, _Right));
  }

 template<class _Other>
  _Nodeptr _Lbound(const _Other& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (_Compare(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  return (_Wherenode);
  }

 template<class _Other>
  _Nodeptr _Lbound(const _Other& _Keyval)
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  return (_Wherenode);
  }

 _Nodeptr& _Lmost() const
  {
  return (this->_Left(this->_Myhead));
  }

 void _Lrotate(_Nodeptr _Wherenode)
  {
  _Nodeptr _Pnode = this->_Right(_Wherenode);
  this->_Right(_Wherenode) = this->_Left(_Pnode);

  if (!this->_Isnil(this->_Left(_Pnode)))
   this->_Parent(this->_Left(_Pnode)) = _Wherenode;
  this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  if (_Wherenode == _Root())
   _Root() = _Pnode;
  else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
   this->_Left(this->_Parent(_Wherenode)) = _Pnode;
  else
   this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  this->_Left(_Pnode) = _Wherenode;
  this->_Parent(_Wherenode) = _Pnode;
  }

 _Nodeptr& _Rmost() const
  {
  return (this->_Right(this->_Myhead));
  }

 _Nodeptr& _Root() const
  {
  return (this->_Parent(this->_Myhead));
  }

 void _Rrotate(_Nodeptr _Wherenode)
  {
  _Nodeptr _Pnode = this->_Left(_Wherenode);
  this->_Left(_Wherenode) = this->_Right(_Pnode);

  if (!this->_Isnil(this->_Right(_Pnode)))
   this->_Parent(this->_Right(_Pnode)) = _Wherenode;
  this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  if (_Wherenode == _Root())
   _Root() = _Pnode;
  else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
   this->_Right(this->_Parent(_Wherenode)) = _Pnode;
  else
   this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  this->_Right(_Pnode) = _Wherenode;
  this->_Parent(_Wherenode) = _Pnode;
  }

 template<class _Other>
  _Nodeptr _Ubound(const _Other& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (_Compare(_Keyval, this->_Key(_Pnode)))
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }
   else
    _Pnode = this->_Right(_Pnode);

  return (_Wherenode);
  }
# 2412 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\xtree" 3
 void _Tidy()
  {
  erase(begin(), end());
  }

 const key_type& _Kfn(const value_type& _Val) const
  {
  return (_Traits::_Kfn(_Val));
  }

 const key_type& _Key(_Nodeptr _Pnode) const
  {
  return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
  }
 };


template<class _Traits> inline
 bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (_Left.size() == _Right.size()
  && ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Traits> inline
 bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Traits> inline
 bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Traits> inline
 bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Traits> inline
 bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Traits> inline
 bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Left < _Right));
 }
}
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 1 3
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
namespace std {

template<class _Src,
 class _Dest>
 struct _Tuple_enable
 {
 };

template<>
 struct _Tuple_enable<tuple<>, tuple<> >
 {
 typedef void ** type;
 };

template<class _Src0,
 class... _Types1,
 class _Dest0,
 class... _Types2>
 struct _Tuple_enable<tuple<_Src0, _Types1...>,
  tuple<_Dest0, _Types2...> >





  : _If<is_convertible<_Src0, _Dest0>::value,


  _Tuple_enable<tuple<_Types1...>, tuple<_Types2...> >,
  _Tuple_enable<int, int>
 >::type
 {
 };


template<class _Src,
 class _Dest>
 struct _Is_tuple_constructible
 : public false_type
 {
 };

template<>
 struct _Is_tuple_constructible<tuple<>, tuple<>>
 : public true_type
 {
 };

template<class _Dest0,
 class... _Types1,
 class _Src0,
 class... _Types2>
 struct _Is_tuple_constructible<tuple<_Dest0, _Types1...>,
  tuple<_Src0, _Types2...> >
 : public integral_constant<bool,
  is_constructible<_Dest0, _Src0>::value
   && _Is_tuple_constructible<tuple<_Types1...>,
    tuple<_Types2...> >::value>
 {
 };


template<class _Src,
 class _Dest>
 struct _Is_tuple_convertible
 : public false_type
 {
 };

template<>
 struct _Is_tuple_convertible<tuple<>, tuple<>>
 : public true_type
 {
 };

template<class _Src0,
 class... _Types1,
 class _Dest0,
 class... _Types2>
 struct _Is_tuple_convertible<tuple<_Src0, _Types1...>,
  tuple<_Dest0, _Types2...> >
 : public integral_constant<bool,
  is_convertible<_Src0, _Dest0>::value
   && _Is_tuple_convertible<tuple<_Types1...>,
    tuple<_Types2...> >::value>
 {
 };


struct _Ignore
 {
 template<class _Ty>
  constexpr void operator=(const _Ty&) const
  {
  }
 };




const _Ignore ignore = _Ignore();



struct _Tuple_alloc_t
 {
 };


constexpr _Tuple_alloc_t _Tuple_alloc{};





template<class _Ty>
 struct _Tuple_val
 {
 constexpr _Tuple_val()
  : _Val()
  {
  }

 template<class _Other>
  constexpr _Tuple_val(_Other&& _Arg)
  : _Val(::std:: forward<_Other>(_Arg))
  {
  }

 template<class _Other>
  _Tuple_val& operator=(_Other&& _Right)
  {
  _Val = ::std:: forward<_Other>(_Right);
  return (*this);
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc&,
   enable_if_t<!uses_allocator<_Ty, _Alloc>::value,
    _Tuple_alloc_t>, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   enable_if_t<uses_allocator<_Ty, _Alloc>::value
    && is_constructible<_Ty,
     allocator_arg_t, _Alloc, _Other...>::value,
    _Tuple_alloc_t>, _Other&&... _Arg)
  : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   enable_if_t<uses_allocator<_Ty, _Alloc>::value
    && !is_constructible<_Ty,
     allocator_arg_t, _Alloc, _Other...>::value,
    _Tuple_alloc_t>, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)..., _Al)
  {
  }

 _Ty _Val;
 };


template<class... _Types>
 class tuple;

template<>
 class tuple<>
 {
public:
 typedef tuple<> _Myt;
 typedef _Myt _This_type;

 constexpr tuple() noexcept
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&) noexcept
  {
  }

 constexpr tuple(const tuple&) noexcept
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&, const _Myt&) noexcept
  {
  }

 void swap(_Myt&) noexcept
  {
  }

 constexpr bool _Equals(const _Myt&) const noexcept
  {
  return (true);
  }

 constexpr bool _Less(const _Myt&) const noexcept
  {
  return (false);
  }
 };

struct _One_arg_t
 {
 };

template<class _This,
 class... _Rest>
 class tuple<_This, _Rest...>
  : public tuple<_Rest...>
 {
public:
 typedef _This _This_type;
 typedef tuple<_This, _Rest...> _Myt;
 typedef tuple<_Rest...> _Mybase;
 static const size_t _Mysize = 1 + sizeof...(_Rest);

 template<class...>
  struct _Is_default_constructible
   : true_type
  {
  };

 template<class _Myty,
  class... _Myrest>
  struct _Is_default_constructible<_Myty, _Myrest...>
   : integral_constant<bool, is_default_constructible<_Myty>::value
    && _Is_default_constructible<_Myrest...>::value>
  {
  };







  constexpr tuple()
   : _Mybase(),
    _Myfirst()
  {
  }

 template<class... _Rest2>
  explicit constexpr tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
   : _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
    _Myfirst(allocator_arg)
  {
  }

 template<bool _SizeIs1, bool _SameAsThisTuple, class _Dummy = void>
  struct _CheckTupleLikeConstructor
  {
  template<class...>
   static constexpr bool _EnableCopyConstructor() { return true; }
  template<class...>
   static constexpr bool _EnableMoveConstructor() { return true; }
  };

 template<class _Dummy>
  struct _CheckTupleLikeConstructor<true, false, _Dummy>
  {
  template<class... _Other>
  static constexpr bool _EnableCopyConstructor()
   {
   return !is_convertible<const tuple<_Other...>&, _This>::value
    && !is_constructible<_This, const tuple<_Other...>&>::value;
   }

  template<class... _Other>
  static constexpr bool _EnableMoveConstructor()
   {
   return !is_convertible<tuple<_Other...>, _This>::value
    && !is_constructible<_This, tuple<_Other...>>::value;
   }
  };

 template<class _Dummy>
  struct _CheckTupleLikeConstructor<true, true, _Dummy>
  {
  template<class...>
   static constexpr bool _EnableCopyConstructor() { return false; }
  template<class...>
   static constexpr bool _EnableMoveConstructor() { return false; }
  };

 template<class... _Other,
# 333 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<const _Other&...>, _Myt>::type>

  constexpr tuple(const tuple<_Other...>& _Right)
  : _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
  {
  }
# 357 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Alloc,
  class... _Other,
# 369 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<const _Other&...>, _Myt>::type>

  tuple(allocator_arg_t, const _Alloc& _Al,
   const tuple<_Other...>& _Right)
  : _Mybase(allocator_arg, _Al, _Right._Get_rest()),
   _Myfirst(_Al, _Tuple_alloc,
    _Right._Myfirst._Val)
  {
  }
# 400 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class...>
  struct _Is_copy_constructible
   : true_type
  {
  };

 template<class _Myty,
  class... _Myrest>
  struct _Is_copy_constructible<_Myty, _Myrest...>
   : integral_constant<bool, is_copy_constructible<_Myty>::value
    && _Is_copy_constructible<_Myrest...>::value>
  {
  };







  constexpr explicit tuple(const _This& _This_arg,
   const _Rest&... _Rest_arg)
   : _Mybase(_Rest_arg...),
    _Myfirst(_This_arg)
  {
  }
# 448 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Alloc>

  tuple(allocator_arg_t, const _Alloc& _Al,
   const _This& _This_arg, const _Rest&... _Rest_arg)
  : _Mybase(allocator_arg, _Al, _Rest_arg...),
   _Myfirst(_Al, _Tuple_alloc, _This_arg)
  {
  }
# 472 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class...>
  struct _PackExpandsToThisTuple : false_type {};

 template<class _Ty>
  struct _PackExpandsToThisTuple<_Ty>
   : is_same<typename remove_cv<typename remove_reference<_Ty>::type>::type, _Myt>
  {
  };

 template<bool _MaybeEnable, class _Dummy = void>
  struct _CheckArgsConstructor
  {
  template<class...>
   static constexpr bool _EnableImplicit() { return false; }
  template<class...>
   static constexpr bool _EnableExplicit() { return false; }
  };

 template<class _Dummy>
 struct _CheckArgsConstructor<true, _Dummy>
  {
  template<class... _Types>
   static constexpr bool _EnableImplicit()
   {
   return _Is_tuple_constructible<_Myt, tuple<_Types&&...>>::value
     && _Is_tuple_convertible<tuple<_Types&&...>, _Myt>::value;
   };

  template<class... _Types>
   static constexpr bool _EnableExplicit()
   {
   return _Is_tuple_constructible<_Myt, tuple<_Types&&...>>::value
     && !_Is_tuple_convertible<tuple<_Types&&...>, _Myt>::value;
   };
  };

 template<class _This2,
  class... _Rest2,
# 520 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<_This2, _Rest2...>, _Myt>::type>

  constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }
# 543 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Alloc,
  class _This2,
  class... _Rest2,





  class = typename _Tuple_enable<
   tuple<_This2, _Rest2...>, _Myt>::type>

  tuple(allocator_arg_t, const _Alloc& _Al,
   _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_This2>(_This_arg))
  {
  }
# 580 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class... _Other,
# 591 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<_Other...>, _Myt>::type>

  constexpr tuple(tuple<_Other...>&& _Right)
  : _Mybase((typename tuple<_Other...>::_Mybase&&)_Right),
   _Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>
    (_Right._Myfirst._Val))
  {
  }
# 619 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Alloc,
  class... _Other,
# 631 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
  class = typename _Tuple_enable<
   tuple<_Other...>, _Myt>::type>

  tuple(allocator_arg_t, const _Alloc& _Al,
   tuple<_Other...>&& _Right)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<typename tuple<_Other...>::_Mybase>
     (_Right._Get_rest())),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<typename tuple<_Other...>::_This_type>
     (_Right._Myfirst._Val))
  {
  }
# 668 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<template<class, class> class _Is_fn,
  class _Tuple1,
  class _Tuple2>
  struct _Is_tuple_assignable;

 template<template<class, class> class _Is_fn,
  class _First0,
  class _First1>
  struct _Is_tuple_assignable<_Is_fn, tuple<_First0>, tuple<_First1> >
  {
  static const bool value = _Is_fn<_First0, _First1>::value;
  };

 template<template<class, class> class _Is_fn,
  class _First0,
  class... _Rest0,
  class _First1,
  class... _Rest1>
  struct _Is_tuple_assignable<_Is_fn, tuple<_First0, _Rest0...>,
   tuple<_First1, _Rest1...> >
  {
  static const bool value =
   _Is_fn<_First0, _First1>::value
    && _Is_tuple_assignable<_Is_fn,
     tuple<_Rest0...>,
     tuple<_Rest1...> >::value;
  };

 template<class _Ty1,
  class _Ty2>
  struct _Is_copy_assignable
   : public is_assignable<_Ty1&, const _Ty2&>
  {
  };
# 712 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Other0,
  class... _Other>
  _Myt& operator=(const tuple<_Other0, _Other...>& _Right)

  {
  _Myfirst._Val = _Right._Myfirst._Val;
  _Get_rest() = _Right._Get_rest();
  return (*this);
  }

 template<class _Ty1,
  class _Ty2>
  struct _Is_move_assignable
   : public is_assignable<_Ty1&, _Ty2&&>
  {
  };
# 738 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 template<class _Other0,
  class... _Other>
  _Myt& operator=(tuple<_Other0, _Other...>&& _Right)

  {
  _Myfirst._Val = ::std:: forward<typename tuple<_Other0, _Other...>
   ::_This_type>(_Right._Myfirst._Val);
  _Get_rest() = ::std:: forward<typename tuple<_Other0, _Other...>
   ::_Mybase>(_Right._Get_rest());
  return (*this);
  }

 template<class... _Other>
  constexpr bool _Equals(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other), "comparing tuple to object with different size");

  return (_Myfirst._Val == _Right._Myfirst._Val
   && _Mybase::_Equals(_Right._Get_rest()));
  }

 template<class... _Other>
  constexpr bool _Less(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other), "comparing tuple to object with different size");

  return (_Myfirst._Val < _Right._Myfirst._Val
   || (!(_Right._Myfirst._Val < _Myfirst._Val)
    && _Mybase::_Less(_Right._Get_rest())));
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al)
  : _Mybase(allocator_arg, _Al),
   _Myfirst(_Al, _Tuple_alloc)
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const _Myt& _Right)
  : _Mybase(allocator_arg, _Al, _Right._Get_rest()),
   _Myfirst(_Al, _Tuple_alloc,
    _Right._Myfirst._Val)
  {
  }
# 795 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
 tuple(const _Myt&) = default;
 tuple(_Myt&&) = default;


 template<class _Tag,
  class _This2,
  class = enable_if_t<is_same<_Tag, _One_arg_t>::value,
   void> >
  constexpr tuple(_Tag, _This2&& _This_arg)
  : _Mybase(),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }

 template<class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<const _First&, const _Second&>, _Myt>::type>
  constexpr tuple(const pair<_First, _Second>& _Right)

  : _Mybase(_One_arg_t(), _Right.second),
   _Myfirst(_Right.first)
  {

  }

 template<class _Alloc,
  class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<const _First&, const _Second&>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const pair<_First, _Second>& _Right)

  : _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
   _Myfirst(_Al, _Tuple_alloc,
    _Right.first)
  {

  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Myfirst._Val = _Right._Myfirst._Val;
  _Get_rest() = _Right._Get_rest();
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(const pair<_First, _Second>& _Right)
  {
  static_assert(_Mysize == 2, "assigning to tuple from object with different size");

  _Myfirst._Val = _Right.first;
  _Get_rest()._Myfirst._Val = _Right.second;
  return (*this);
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   _Myt&& _Right)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<_Mybase>(_Right._Get_rest())),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_This>(_Right._Myfirst._Val))
  {
  }

 template<class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<_First, _Second>, _Myt>::type>
  constexpr tuple(pair<_First, _Second>&& _Right)

  : _Mybase(_One_arg_t(), ::std:: forward<_Second>(_Right.second)),
   _Myfirst(::std:: forward<_First>(_Right.first))
  {

  }

 template<class _Alloc,
  class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<_First, _Second>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   pair<_First, _Second>&& _Right)

  : _Mybase(allocator_arg, _Al,
    tuple<_Second>(::std:: forward<_Second>(_Right.second))),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_First>(_Right.first))
  {

  }

 _Myt& operator=(_Myt&& _Right)
  noexcept(is_nothrow_move_assignable<_This>::value && is_nothrow_move_assignable<_Mybase>::value)

  {
  _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
  _Get_rest() = ::std:: forward<_Mybase>(_Right._Get_rest());
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(pair<_First, _Second>&& _Right)
  {
  static_assert(_Mysize == 2, "assigning to tuple from object with different size");

  _Myfirst._Val = ::std:: forward<_First>(_Right.first);
  _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
  return (*this);
  }

 constexpr _Mybase& _Get_rest() noexcept
  {
  return (*this);
  }

 constexpr const _Mybase& _Get_rest() const noexcept
  {
  return (*this);
  }

 void swap(tuple& _Right)
  noexcept(noexcept(_Swap_adl(this->_Myfirst._Val, _Right._Myfirst._Val)) && noexcept(_Swap_adl(_Right._Get_rest(), _Right._Get_rest())))


  {
  _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
  _Mybase::swap(_Right._Get_rest());
  }

 _Tuple_val<_This> _Myfirst;
 };
# 948 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator==(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Equals(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator!=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator<(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator>=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator>(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Right < _Left);
 }

template<class... _Types1,
 class... _Types2> inline
 constexpr bool operator<=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Right < _Left));
 }
# 1016 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class... _Types> inline


 void swap(tuple<_Types...>& _Left,
  tuple<_Types...>& _Right)
   noexcept(noexcept(_Left.swap(_Right)))
 {
 return (_Left.swap(_Right));
 }


template<class _Ty,
 class _Tuple>
 struct _Tuple_element;

template<class _This,
 class... _Rest>
 struct _Tuple_element<_This, tuple<_This, _Rest...> >
 {
 typedef int _Check_type;
 static_assert((is_void<typename _Tuple_element<_This, tuple<_Rest...> >::_Check_type>::value), "duplicate type T in get<T>(tuple)");



 typedef _This type;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<class _Ty,
 class _This,
 class... _Rest>
 struct _Tuple_element<_Ty, tuple<_This, _Rest...> >
  : public _Tuple_element<_Ty, tuple<_Rest...> >
 {
 };

template<class _Ty>
 struct _Tuple_element<_Ty, tuple<> >
 {
 typedef void _Check_type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, const _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, volatile _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<class _Ty,
 class _Tuple>
 struct _Tuple_element<_Ty, const volatile _Tuple>
  : public _Tuple_element<_Ty, _Tuple>
 {
 typedef _Tuple_element<_Ty, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };


template<size_t _Index,
 class... _Types> inline
 constexpr typename tuple_element<_Index, tuple<_Types...> >::type&
  get(tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 constexpr const typename tuple_element<_Index, tuple<_Types...> >::type&
  get(const tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 constexpr typename tuple_element<_Index, tuple<_Types...> >::type&&
  get(tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
  _RRtype;
 return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
 }
# 1133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class _Ty,
 class... _Types> inline
 constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<class _Ty,
 class... _Types> inline
 constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<class _Ty,
 class... _Types> inline
 constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept
 {
 typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
 return (::std:: forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
 }
# 1168 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class... _Types> inline
 constexpr tuple<typename _Unrefwrap<_Types>::type...>
  make_tuple(_Types&&... _Args)
 {
 typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
 return (_Ttype(::std:: forward<_Types>(_Args)...));
 }


template<class... _Types> inline
 constexpr tuple<_Types&...>
  tie(_Types&... _Args) noexcept
 {
 typedef tuple<_Types&...> _Ttype;
 return (_Ttype(_Args...));
 }


template<class _Ty,
 size_t _Size>
 class array;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
 class _Ty,
 size_t _Size>
 constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;
# 1252 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
template<class... _Types> inline
 constexpr tuple<_Types&&...>
  forward_as_tuple(_Types&&... _Args) noexcept
 {
 return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
 }


template<class _Seq_type1,
 class _Seq_type2>
 struct _Cat_sequences;

template<size_t... _Indexes1,
 size_t... _Indexes2>
 struct _Cat_sequences<integer_sequence<size_t, _Indexes1...>,
  integer_sequence<size_t, _Indexes2...> >
 {
 typedef integer_sequence<size_t, _Indexes1..., _Indexes2...> type;
 };


template<class _Ty,
 class... _For_array>
 struct _View_as_tuple
 {
 static_assert(_Always_false<_Ty>::value, "Unsupported tuple_cat arguments.");

 };

template<class... _Types>
 struct _View_as_tuple<tuple<_Types...> >
 {
 typedef tuple<_Types...> type;
 };

template<class _Ty1,
 class _Ty2>
 struct _View_as_tuple<pair<_Ty1, _Ty2> >
 {
 typedef tuple<_Ty1, _Ty2> type;
 };

template<class _Ty,
 class... _Types>
 struct _View_as_tuple<array<_Ty, 0>, _Types...>
 {
 typedef tuple<_Types...> type;
 };

template<class _Ty,
 size_t _Size,
 class... _Types>
 struct _View_as_tuple<array<_Ty, _Size>, _Types...>
  : _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
 {
 };


template<size_t _Nx,
 class _Ty>
 struct _Repeat_for
  : integral_constant<size_t, _Nx>
 {
 };


template<class _Ret,
 class _Kx_arg,
 class _Ix_arg,
 size_t _Ix_next,
 class... _Tuples>
 struct _Tuple_cat2
 {
 static_assert(sizeof...(_Tuples) == 0, "Unsupported tuple_cat arguments.");

 typedef _Ret type;
 typedef _Kx_arg _Kx_arg_seq;
 typedef _Ix_arg _Ix_arg_seq;
 };

template<class... _Types1,
 class _Kx_arg,
 size_t... _Ix,
 size_t _Ix_next,
 class... _Types2,
 class... _Rest>
 struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
  integer_sequence<size_t, _Ix...>, _Ix_next,
  tuple<_Types2...>, _Rest...>
  : _Tuple_cat2<
   tuple<_Types1..., _Types2...>,
   typename _Cat_sequences<_Kx_arg,
    typename make_integer_sequence<size_t, sizeof...(_Types2)>
     ::type>::type,
   integer_sequence<size_t, _Ix...,
    _Repeat_for<_Ix_next, _Types2>::value...>,
   _Ix_next + 1,
   _Rest...>
 {
 };

template<class... _Tuples>
 struct _Tuple_cat1
  : _Tuple_cat2<tuple<>, integer_sequence<size_t>,
    integer_sequence<size_t>, 0,
   typename _View_as_tuple<typename decay<_Tuples>::type>::type...>
 {
 };

template<class _Ret,
 size_t... _Kx,
 size_t... _Ix,
 class _Ty> inline
 constexpr _Ret _Tuple_cat(integer_sequence<size_t, _Kx...>,
  integer_sequence<size_t, _Ix...>, _Ty&& _Arg)
 {
 return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
 }

template<class... _Tuples> inline
 constexpr typename _Tuple_cat1<_Tuples...>::type
  tuple_cat(_Tuples&&... _Tpls)
 {
 typedef _Tuple_cat1<_Tuples...> _Cat1;
 return (_Tuple_cat<typename _Cat1::type>(
  typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
  ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
 }



template<class _Ty1,
 class _Ty2>
 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   integer_sequence<size_t, _Indexes1...>,
   integer_sequence<size_t, _Indexes2...>)
  : first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
   second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
  {
  }


template<class _Ty1,
 class _Ty2>
 template<class... _Types1,
  class... _Types2> inline
  pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2)
  : pair(_Val1, _Val2,
   make_integer_sequence<size_t, sizeof...(_Types1)>(),
   make_integer_sequence<size_t, sizeof...(_Types2)>())
  {
  }
# 1444 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\tuple" 3
struct _Uses_alloc_none {};
struct _Uses_alloc_arg {};
struct _Uses_alloc_last {};

template<class _Objty, class _Alty, class... _Types,
 class = typename enable_if<
  !uses_allocator<_Objty, _Alty>::value
  && is_constructible<_Objty, _Types...>::value
 >::type>
 _Uses_alloc_none _Uses_alloc_type(int, int);

template<class _Objty, class _Alty, class... _Types,
 class = typename enable_if<
  uses_allocator<_Objty, _Alty>::value
  && is_constructible<_Objty, allocator_arg_t, _Alty, _Types...>::value
 >::type>
 _Uses_alloc_arg _Uses_alloc_type(_Wrap_int, int);

template<class _Objty, class _Alty, class... _Types,
 class = typename enable_if<
  uses_allocator<_Objty, _Alty>::value
  && is_constructible<_Objty, _Types..., _Alty>::value
 >::type>
 _Uses_alloc_last _Uses_alloc_type(_Wrap_int, _Wrap_int);

template<class _Objty, class _Alty, class... _Types, size_t... _Indices> inline
 tuple<_Types&&...>
 _Make_uses_alloc_construct_args_impl(_Uses_alloc_none,
  _Alty& _Al, tuple<_Types...>&& _Tup, index_sequence<_Indices...>)
 {
 return ::std:: forward_as_tuple(::std:: get<_Indices>(::std:: move(_Tup))...);
 }

template<class _Objty, class _Alty, class... _Types, size_t... _Indices> inline
 tuple<const allocator_arg_t&, _Alty&, _Types&&...>
 _Make_uses_alloc_construct_args_impl(_Uses_alloc_arg,
  _Alty& _Al, tuple<_Types...>&& _Tup, index_sequence<_Indices...>)
 {
 return ::std:: forward_as_tuple(allocator_arg, _Al,
  ::std:: get<_Indices>(::std:: move(_Tup))...);
 }

template<class _Objty, class _Alty, class... _Types, size_t... _Indices> inline
 tuple<_Types&&..., _Alty&>
 _Make_uses_alloc_construct_args_impl(_Uses_alloc_last,
  _Alty& _Al, tuple<_Types...>&& _Tup, index_sequence<_Indices...>)
 {
 return ::std:: forward_as_tuple(::std:: get<_Indices>(::std:: move(_Tup))..., _Al);
 }

template<class _Objty, class _Alty, class... _Types> inline
 decltype(auto) _Make_uses_alloc_construct_args(_Alty& _Al, tuple<_Types...>&& _Tup)
 {
 using _UAType = decltype(_Uses_alloc_type<_Objty, _Alty, _Types...>(0, 0));
 return _Make_uses_alloc_construct_args_impl<_Objty>(_UAType(),
  _Al, ::std:: move(_Tup), make_index_sequence<sizeof...(_Types)>());
 }

}

namespace std {

template<class... _Types,
 class _Alloc>
 struct uses_allocator<tuple<_Types...>, _Alloc>
  : true_type
 {
 };
}
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 2 3

namespace std {

template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc>
 class multimap;


template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc,
 bool _Mfl>
 class _Tmap_traits
 {
public:
 typedef _Kty key_type;
 typedef pair<const _Kty, _Ty> value_type;
 typedef _Pr key_compare;
 typedef _Alloc allocator_type;

 enum
  {
  _Multi = _Mfl};

 class value_compare
  {
  friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

 public:
  typedef value_type first_argument_type ;
  typedef value_type second_argument_type ;
  typedef bool result_type ;

  bool operator()(const value_type& _Left,
   const value_type& _Right) const
   {
   return (comp(_Left.first, _Right.first));
   }

  value_compare(key_compare _Pred)
   : comp(_Pred)
   {
   }

 protected:
  key_compare comp;
  };

 template<class _Ty1,
  class _Ty2>
  static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)
  {
  return (_Val.first);
  }
 };


template<class _Kty,
 class _Ty,
 class _Pr = less<_Kty>,
 class _Alloc = allocator<pair<const _Kty, _Ty> > >
 class map
  : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
 {
public:
 typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
 typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
 typedef _Kty key_type;
 typedef _Ty mapped_type;
 typedef _Pr key_compare;
 typedef typename _Mybase::value_compare value_compare;
 typedef typename _Mybase::allocator_type allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::reverse_iterator reverse_iterator;
 typedef typename _Mybase::const_reverse_iterator
  const_reverse_iterator;
 typedef typename _Mybase::value_type value_type;

 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Pairib _Pairib;






 map()
  : _Mybase(key_compare(), allocator_type())
  {
  }

 explicit map(const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  }

 map(const _Myt& _Right)
  : _Mybase(_Right,
   _Right._Getal().select_on_container_copy_construction())
  {
  }

 map(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 explicit map(const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  }

 map(const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last,
   const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last,
   const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_First, _Last);
  }


 template<class _Iter>
  map(_Iter _First, _Iter _Last, const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  _Mybase::insert(_First, _Last);
  }


 _Myt& operator=(const _Myt& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 map(_Myt&& _Right)
  : _Mybase(::std:: move(_Right))
  {
  }

 map(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(::std:: move(_Right), _Al)
  {
  }

 _Myt& operator=(_Myt&& _Right)


  {
  _Mybase::operator=(::std:: move(_Right));
  return (*this);
  }

 mapped_type& operator[](key_type&& _Keyval)
  {
  iterator _Where = _Mybase::lower_bound(_Keyval);
  if (_Where == _Mybase::end()
   || _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
   _Where = _Mybase::emplace_hint(_Where,
    piecewise_construct,
    ::std:: forward_as_tuple(::std:: move(_Keyval)),
    tuple<>());

  return (_Where->second);
  }

 void swap(_Myt& _Right)



  {
  _Mybase::swap(_Right);
  }
# 228 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 _Pairib insert(const value_type& _Val)
  {
  return (_Mybase::_Insert_nohint(false, _Val, _Nil()));
  }

 iterator insert(const_iterator _Where, const value_type& _Val)
  {
  return (_Mybase::insert(_Where, _Val));
  }


 _Pairib insert(value_type&& _Val)
  {
  return (_Mybase::_Insert_nohint(false,
   ::std:: forward<value_type>(_Val), _Nil()));
  }

 iterator insert(const_iterator _Where, value_type&& _Val)
  {
  return (_Mybase::_Insert_hint(_Where,
   ::std:: forward<value_type>(_Val), _Nil()));
  }


 template<class _Iter>
  void insert(_Iter _First, _Iter _Last)
  {
  _Mybase::insert(_First, _Last);
  }

 void insert(::std:: initializer_list<value_type> _Ilist)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 template<class _Valty,
  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,
   void> >
  _Pairib insert(_Valty&& _Val)
  {
  typename _Mybase::_Nodeptr
   _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
  return (_Mybase::_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class _Valty,
  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,
   void> >
  iterator insert(const_iterator _Where, _Valty&& _Val)
  {
  return (_Mybase::insert(_Where, ::std:: forward<_Valty>(_Val)));
  }
# 389 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 map(::std:: initializer_list<value_type> _Ilist)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 map(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }


 map(::std:: initializer_list<value_type> _Ilist,
  const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }


 map(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  _Mybase::clear();
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 mapped_type& operator[](const key_type& _Keyval)
  {
  iterator _Where = _Mybase::lower_bound(_Keyval);
  if (_Where == _Mybase::end()
   || _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
   _Where = _Mybase::emplace_hint(_Where,
    piecewise_construct,
    ::std:: forward_as_tuple(_Keyval),
    tuple<>());
  return (_Where->second);
  }

 mapped_type& at(const key_type& _Keyval)
  {
  iterator _Where = _Mybase::lower_bound(_Keyval);
  if (_Where == _Mybase::end()
   || _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
   _Xout_of_range("invalid map<K, T> key");
  return (_Where->second);
  }

 const mapped_type& at(const key_type& _Keyval) const
  {
  const_iterator _Where = _Mybase::lower_bound(_Keyval);
  if (_Where == _Mybase::end()
   || _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
   _Xout_of_range("invalid map<K, T> key");
  return (_Where->second);
  }
# 480 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 };
# 503 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc> inline
 void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
  map<_Kty, _Ty, _Pr, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }
# 536 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
template<class _Kty,
 class _Ty,
 class _Pr = less<_Kty>,
 class _Alloc = allocator<pair<const _Kty, _Ty> > >
 class multimap
  : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
 {
public:
 typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
 typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
 typedef _Kty key_type;
 typedef _Ty mapped_type;
 typedef _Pr key_compare;
 typedef typename _Mybase::value_compare value_compare;
 typedef typename _Mybase::allocator_type allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::reverse_iterator reverse_iterator;
 typedef typename _Mybase::const_reverse_iterator
  const_reverse_iterator;
 typedef typename _Mybase::value_type value_type;

 typedef typename _Mybase::_Alty _Alty;





 multimap()
  : _Mybase(key_compare(), allocator_type())
  {
  }

 explicit multimap(const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  }

 multimap(const _Myt& _Right)
  : _Mybase(_Right,
   _Right._Getal().select_on_container_copy_construction())
  {
  }

 multimap(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 explicit multimap(const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  }

 multimap(const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last,
   const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last,
   const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_First, _Last);
  }


 template<class _Iter>
  multimap(_Iter _First, _Iter _Last, const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  _Mybase::insert(_First, _Last);
  }


 _Myt& operator=(const _Myt& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 multimap(_Myt&& _Right)
  : _Mybase(::std:: move(_Right))
  {
  }

 multimap(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(::std:: move(_Right), _Al)
  {
  }

 _Myt& operator=(_Myt&& _Right)


  {
  _Mybase::operator=(::std:: move(_Right));
  return (*this);
  }

 template<class _Valty,

  class = enable_if_t<is_constructible<value_type, _Valty&&>::value,



   void> >
  iterator insert(_Valty&& _Val)
  {
  return (_Mybase::insert(::std:: forward<_Valty>(_Val)).first);
  }

 template<class _Valty,

   class = enable_if_t<is_constructible<value_type, _Valty&&>::value,



   void> >
  iterator insert(const_iterator _Where, _Valty&& _Val)
  {
  return (_Mybase::insert(_Where, ::std:: forward<_Valty>(_Val)));
  }
# 693 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 template<class... _Valty>
  iterator emplace(_Valty&&... _Val)
  {
  return (_Mybase::emplace(::std:: forward<_Valty>(_Val)...).first);
  }

 void swap(_Myt& _Right)



  {
  _Mybase::swap(_Right);
  }

 multimap(::std:: initializer_list<value_type> _Ilist)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 multimap(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }


 multimap(::std:: initializer_list<value_type> _Ilist,
  const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }


 multimap(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  _Mybase::clear();
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void insert(::std:: initializer_list<value_type> _Ilist)
  {
  _Mybase::insert(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const value_type& _Val)
  {
  return (_Mybase::insert(_Val).first);
  }

 iterator insert(const_iterator _Where, const value_type& _Val)
  {
  return (_Mybase::insert(_Where, _Val));
  }


 iterator insert(value_type&& _Val)
  {
  return (_Mybase::insert(::std:: forward<value_type>(_Val)).first);
  }

 iterator insert(const_iterator _Where, value_type&& _Val)
  {
  return (_Mybase::insert(_Where, ::std:: forward<value_type>(_Val)));
  }


 template<class _Iter>
  void insert(_Iter _First, _Iter _Last)
  {
  _Mybase::insert(_First, _Last);
  }
# 801 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
 };
# 824 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc> inline
 void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
  multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)

 {
 _Left.swap(_Right);
 }
# 860 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\map" 3
}
# 6 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Transactions.h" 2

namespace SaveData
{
 class Transaction
 {
 public:

  Transaction() :
   m_TransactionId((-1))
  {

  }

  SceSaveDataTransactionResourceId m_TransactionId;
  SceSaveDataMountPoint m_MountPoint;
 };

 class Transactions
 {
 public:

  static Transaction* CreateTransactionId(uint32_t size = (786432));
  static int DeleteTransactionId(Transaction* id);

  static void RecordMountedTransaction(Transaction* id, SceSaveDataMountPoint& mp);
  static int RemoveTransaction(Transaction* id);

  static Transaction* FindTransaction(SceSaveDataMountPoint& mp);

  static std::list<Transaction*> s_TransactionList;
 };
}
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp" 2

namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataMount(MountRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Mounting::Mount(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataMountPS4(MountPS4Request* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {

  Mounting::MountPS4(managedRequest, outBuffer, result);




 }

 extern "C" __declspec (dllexport) void PrxSaveDataUnmount(UnmountRequest* managedRequest, APIResult* result)
 {
  Mounting::Unmount(managedRequest, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataGetMountInfo(GetMountInfoRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Mounting::GetMountInfo(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataGetMountParams(GetMountParamsRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Mounting::GetMountParams(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataSetMountParams(SetMountParamsRequest* managedRequest, APIResult* result)
 {
  Mounting::SetMountParams(managedRequest, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataSaveIcon(SaveIconRequest* managedRequest, APIResult* result)
 {
  Mounting::SaveIcon(managedRequest, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataLoadIcon(LoadIconRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Mounting::LoadIcon(managedRequest, outBuffer, result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataGetIconSize(void *pngData, Int32* width, Int32* height)
 {
  *width = 0;
  *height = 0;

  PNGWriter::GetPNGSizes(pngData, *width, *height);
 }

 void MountPointManaged::CopyTo(SceSaveDataMountPoint &destination)
 {
  memcpy_s(destination.data, (16), data, (16));
 }

 void MountRequest::CopyTo(SceSaveDataMount3 &destination, SceSaveDataDirName& sceDirName)
 {
  dirName.CopyTo(sceDirName);

  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
  destination.blocks = blocks;
  destination.systemBlocks = systemBlocks;
  destination.mountMode = mountMode;
  destination.resource = (-1);
 }

 void MountPS4Request::CopyTo(SceSaveDataTransferringMount& destination, SceSaveDataDirName& sceDirName, SceSaveDataTitleId& sceTitleId, SceSaveDataFingerprint& sceFingerprint)
 {
  dirName.CopyTo(sceDirName);
  fingerprint.CopyTo(sceFingerprint);
  titleId.CopyTo(sceTitleId);


  memset(&destination, 0x00, sizeof(destination));
  destination.userId = userId;
  destination.dirName = &sceDirName;
  destination.fingerprint = &sceFingerprint;
  destination.titleId = &sceTitleId;


 }


 void SetMountParamsRequest::CopyTo(SceSaveDataParam &destination)
 {
  memset(&destination, 0x00, sizeof(destination));

  memcpy_s(destination.title, (128), title, (128));
  memcpy_s(destination.subTitle, (128), subTitle, (128));
  memcpy_s(destination.detail, (1024), detail, (1024));

  destination.userParam = userParam;
 }

 void Mounting::Mount(MountRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataDirName dirName;

  SceSaveDataMount3 mount;

  managedRequest->CopyTo(mount, dirName);


  Transaction* transId = __null;

  if ((managedRequest->mountMode & (0x00000002)) != 0)
  {
   transId = Transactions::CreateTransactionId((786432));

   mount.resource = transId->m_TransactionId;
  }

  SceSaveDataMountResult mountResult;
  memset(&mountResult, 0x00, sizeof(mountResult));




  mount.mountMode &= ~(0x00000002);
  mount.mountMode |= (0x00000001);

  int ret = sceSaveDataMount3(&mount, &mountResult);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  buffer.WriteString(mountResult.mountPoint.data);

  buffer.WriteUInt64(mountResult.requiredBlocks);
  buffer.WriteUInt32(mountResult.mountStatus);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   Transactions::DeleteTransactionId(transId);
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 152));
   return;
  }

  if (transId != __null)
  {

   Transactions::RecordMountedTransaction(transId, mountResult.mountPoint);


   SceSaveDataPrepareParam prepareParam;
   memset(&prepareParam, 0x00, sizeof(prepareParam));
   prepareParam.resource = transId->m_TransactionId;
   prepareParam.prepareMode = 0;

   ret = sceSaveDataPrepare(&mountResult.mountPoint, &prepareParam);
   if (ret < 0)
   {
    (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 170));
    return;
   }
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }


 void Mounting::MountPS4(MountPS4Request* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataDirName dirName;
  SceSaveDataFingerprint fingerprint;
  SceSaveDataTitleId titleId;
  memset(&dirName, 0, sizeof(SceSaveDataDirName));
  memset(&fingerprint, 0, sizeof(SceSaveDataFingerprint));
  memset(&titleId, 0, sizeof(SceSaveDataTitleId));

  SceSaveDataTransferringMount mount;

  managedRequest->CopyTo(mount, dirName, titleId, fingerprint );


  Transaction* transId = __null;



  SceSaveDataMountResult mountResult;
  memset(&mountResult, 0x00, sizeof(mountResult));


  int ret = sceSaveDataTransferringMountPs4(&mount, &mountResult);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  buffer.WriteString(mountResult.mountPoint.data);

  buffer.WriteUInt64(mountResult.requiredBlocks);
  buffer.WriteUInt32(mountResult.mountStatus);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   Transactions::DeleteTransactionId(transId);
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 219));
   return;
  }

  if (transId != __null)
  {

   Transactions::RecordMountedTransaction(transId, mountResult.mountPoint);


   SceSaveDataPrepareParam prepareParam;
   memset(&prepareParam, 0x00, sizeof(prepareParam));
   prepareParam.resource = transId->m_TransactionId;
   prepareParam.prepareMode = 0;

   ret = sceSaveDataPrepare(&mountResult.mountPoint, &prepareParam);
   if (ret < 0)
   {
    (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 237));
    return;
   }
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::Unmount(UnmountRequest* managedRequest, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  managedRequest->mountPoint.CopyTo(mountPoint);

  Transaction* transId = Transactions::FindTransaction(mountPoint);

  int ret = 0;

  if (transId != __null)
  {

   SceSaveDataCommitParam param;
   memset(&param, 0x0, sizeof(param));
   param.resource = transId->m_TransactionId;

   ret = sceSaveDataCommit(&param);

   if (ret < 0)
   {
    (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 266));
    return;
   }
  }

  ret = sceSaveDataUmount2((0x00000000), &mountPoint);


  int ret2 = Transactions::RemoveTransaction(transId);
  if (ret2 < 0)
  {

   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret2, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 278));
   return;
  }

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 284));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::GetMountInfo(GetMountInfoRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  managedRequest->mountPoint.CopyTo(mountPoint);

  SceSaveDataMountInfo mountInfo;
  memset(&mountInfo, 0x00, sizeof(mountInfo));

  int ret = sceSaveDataGetMountInfo(&mountPoint, &mountInfo);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  Core::WriteToBuffer(mountInfo, buffer);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 314));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::GetMountParams(GetMountParamsRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  managedRequest->mountPoint.CopyTo(mountPoint);

  size_t gotSize = 0;
  SceSaveDataParam params;
  memset(&params, 0x00, sizeof(params));

  int ret = sceSaveDataGetParam(&mountPoint, (0), &params, sizeof(SceSaveDataParam), &gotSize);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  Core::WriteToBuffer(params, buffer);


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 345));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::SetMountParams(SetMountParamsRequest* managedRequest, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  SceSaveDataParam params;

  managedRequest->mountPoint.CopyTo(mountPoint);
  managedRequest->CopyTo(params);

  int ret = sceSaveDataSetParam(&mountPoint, (0), &params, sizeof(SceSaveDataParam));

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 365));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::SaveIcon(SaveIconRequest* managedRequest, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  managedRequest->mountPoint.CopyTo(mountPoint);

  uint8_t *data = __null;
  size_t data_size = 0;


  int ret = 0;

  if (managedRequest->pngDataSize == 0)
  {






   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, -2137063424, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 392));
   return;
  }
  else
  {
   data = (uint8_t*)managedRequest->pngData;
   data_size = managedRequest->pngDataSize;
  }

  SceSaveDataIcon icon;
  memset(&icon, 0x00, sizeof(icon));
  icon.buf = data;
  icon.bufSize = data_size;
  icon.dataSize = data_size;

  ret = sceSaveDataSaveIcon(&mountPoint, &icon);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 411));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 void Mounting::LoadIcon(LoadIconRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataMountPoint mountPoint;

  SceSaveDataIcon icon;
  Core::InitIconForReading(icon);

  managedRequest->mountPoint.CopyTo(mountPoint);

  int ret = sceSaveDataLoadIcon(&mountPoint, &icon);


  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();

  if (ret < 0)
  {
   buffer.WriteBool(false);
  }
  else
  {
   buffer.WriteBool(true);
   PNGWriter::WriteToBuffer(icon.buf, (Int32)icon.dataSize, buffer);
  }


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Mount.cpp", 449));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 15 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Notifications.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Notifications.h" 1






namespace SaveData
{
 class Notifications
 {
 public:

  static void NotificationPoll(MemoryBufferManaged* outBuffer, APIResult* result);
 };

}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Notifications.cpp" 2

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic.h" 1 3
# 11 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common.h" 1 3
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common/scebase_target.h" 1 3
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common/scebase_stdint.h" 1 3
# 54 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common/scebase_stdint.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdint.h" 1 3
# 55 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common/scebase_stdint.h" 2 3
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common/scebase_stdbool.h" 1 3
# 29 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\scebase_common.h" 2 3
# 12 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic/sce_atomic_common.h" 1 3
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic.h" 2 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic/sce_atomic_impl.h" 1 3
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic/sce_atomic_impl.h" 3
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 1 3 4
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 1 3 4
# 41 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bsfd(int __A) {
  return __builtin_ctz((unsigned int)__A);
}
# 58 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bsrd(int __A) {
  return 31 - __builtin_clz((unsigned int)__A);
}
# 74 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bswapd(int __A) {
  return (int)__builtin_bswap32((unsigned int)__A);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
_bswap(int __A) {
  return (int)__builtin_bswap32((unsigned int)__A);
}
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bsfq(long long __A) {
  return (long long)__builtin_ctzll((unsigned long long)__A);
}
# 117 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__bsrq(long long __A) {
  return 63 - __builtin_clzll((unsigned long long)__A);
}
# 133 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__)) constexpr
__bswapq(long long __A) {
  return (long long)__builtin_bswap64((unsigned long long)__A);
}
# 153 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__)) constexpr
__popcntd(unsigned int __A)
{
  return __builtin_popcount(__A);
}
# 174 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__)) constexpr
__popcntq(unsigned long long __A)
{
  return __builtin_popcountll(__A);
}





static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__readeflags(void)
{
  return __builtin_ia32_readeflags_u64();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
__writeeflags(unsigned long long __f)
{
  __builtin_ia32_writeeflags_u64(__f);
}
# 220 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__)) constexpr
_castf32_u32(float __A) {
  return __builtin_bit_cast(unsigned int, __A);
}
# 235 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__)) constexpr
_castf64_u64(double __A) {
  return __builtin_bit_cast(unsigned long long, __A);
}
# 250 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ float __attribute__((__always_inline__)) constexpr
_castu32_f32(unsigned int __A) {
  return __builtin_bit_cast(float, __A);
}
# 265 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ double __attribute__((__always_inline__)) constexpr
_castu64_f64(unsigned long long __A) {
  return __builtin_bit_cast(double, __A);
}
# 285 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
__crc32b(unsigned int __C, unsigned char __D)
{
  return __builtin_ia32_crc32qi(__C, __D);
}
# 306 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
__crc32w(unsigned int __C, unsigned short __D)
{
  return __builtin_ia32_crc32hi(__C, __D);
}
# 327 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
__crc32d(unsigned int __C, unsigned int __D)
{
  return __builtin_ia32_crc32si(__C, __D);
}
# 349 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ia32intrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
__crc32q(unsigned long long __C, unsigned long long __D)
{
  return __builtin_ia32_crc32di(__C, __D);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdpmc(int __A) {
  return __builtin_ia32_rdpmc(__A);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdtscp(unsigned int *__A) {
  return __builtin_ia32_rdtscp(__A);
}





static __inline__ void __attribute__((__always_inline__, __nodebug__))
_wbinvd(void) {
  __builtin_ia32_wbinvd();
}

static __inline__ unsigned char __attribute__((__always_inline__, __nodebug__)) constexpr
__rolb(unsigned char __X, int __C) {
  return __builtin_rotateleft8(__X, __C);
}

static __inline__ unsigned char __attribute__((__always_inline__, __nodebug__)) constexpr
__rorb(unsigned char __X, int __C) {
  return __builtin_rotateright8(__X, __C);
}

static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__)) constexpr
__rolw(unsigned short __X, int __C) {
  return __builtin_rotateleft16(__X, __C);
}

static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__)) constexpr
__rorw(unsigned short __X, int __C) {
  return __builtin_rotateright16(__X, __C);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__)) constexpr
__rold(unsigned int __X, int __C) {
  return __builtin_rotateleft32(__X, (unsigned int)__C);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__)) constexpr
__rord(unsigned int __X, int __C) {
  return __builtin_rotateright32(__X, (unsigned int)__C);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__)) constexpr
__rolq(unsigned long long __X, int __C) {
  return __builtin_rotateleft64(__X, (unsigned long long)__C);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__)) constexpr
__rorq(unsigned long long __X, int __C) {
  return __builtin_rotateright64(__X, (unsigned long long)__C);
}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86gprintrin.h" 1 3 4
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86gprintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\crc32intrin.h" 1 3 4
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\crc32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
_mm_crc32_u8(unsigned int __C, unsigned char __D)
{
  return __builtin_ia32_crc32qi(__C, __D);
}
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\crc32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
_mm_crc32_u16(unsigned int __C, unsigned short __D)
{
  return __builtin_ia32_crc32hi(__C, __D);
}
# 70 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\crc32intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
_mm_crc32_u32(unsigned int __C, unsigned int __D)
{
  return __builtin_ia32_crc32si(__C, __D);
}
# 91 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\crc32intrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("crc32")))
_mm_crc32_u64(unsigned long long __C, unsigned long long __D)
{
  return __builtin_ia32_crc32di(__C, __D);
}
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86gprintrin.h" 2 3 4
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
typedef long long __m64 __attribute__((__vector_size__(8), __aligned__(8)));

typedef long long __v1di __attribute__((__vector_size__(8)));
typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_empty(void)
{
    __builtin_ia32_emms();
}
# 58 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}
# 80 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}
# 101 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}
# 122 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}
# 158 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}
# 194 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}
# 230 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}
# 263 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}
# 292 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}
# 319 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}
# 352 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}
# 381 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}
# 408 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}
# 435 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}
# 462 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}
# 489 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}
# 517 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}
# 546 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}
# 574 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}
# 602 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}
# 629 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}
# 656 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}
# 683 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}
# 712 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}
# 741 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}
# 767 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}
# 793 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}
# 822 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}
# 849 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}
# 876 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}
# 905 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}
# 933 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}
# 962 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}
# 990 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}
# 1016 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq((__v1di)__m, __count);
}
# 1042 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi((__v1di)__m, __count);
}
# 1068 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}
# 1093 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}
# 1119 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}
# 1144 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}
# 1170 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}
# 1195 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}
# 1221 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}
# 1246 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}
# 1270 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq((__v1di)__m, __count);
}
# 1295 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi((__v1di)__m, __count);
}
# 1319 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand((__v1di)__m1, (__v1di)__m2);
}
# 1346 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn((__v1di)__m1, (__v1di)__m2);
}
# 1370 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por((__v1di)__m1, (__v1di)__m2);
}
# 1394 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor((__v1di)__m1, (__v1di)__m2);
}
# 1420 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}
# 1446 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}
# 1472 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}
# 1498 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}
# 1524 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}
# 1550 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}
# 1567 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setzero_si64(void)
{
    return __extension__ (__m64){ 0LL };
}
# 1594 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}
# 1625 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}
# 1668 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}
# 1694 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}
# 1718 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}
# 1741 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}
# 1768 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}
# 1799 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}
# 1842 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 1 3 4
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16), __aligned__(16)));

typedef float __m128_u __attribute__((__vector_size__(16), __aligned__(1)));


typedef unsigned int __v4su __attribute__((__vector_size__(16)));




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mm_malloc.h" 1 3 4
# 13 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mm_malloc.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include\\stdlib.h" 1 3 4
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mm_malloc.h" 2 3 4
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mm_malloc.h" 3 4
extern "C" int posix_memalign(void **__memptr, size_t __alignment, size_t __size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__, __alloc_size__(1),
                                       __alloc_align__(2)))
_mm_malloc(size_t __size, size_t __align) {
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{





  free(__p);

}
# 32 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 2 3 4
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}
# 85 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a + (__v4sf)__b);
}
# 113 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}
# 140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a - (__v4sf)__b);
}
# 168 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}
# 194 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a * (__v4sf)__b);
}
# 222 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}
# 247 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a / (__v4sf)__b);
}
# 270 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sqrt_ss(__m128 __a)
{
  return (__m128)__builtin_ia32_sqrtss((__v4sf)__a);
}
# 292 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps((__v4sf)__a);
}
# 315 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rcp_ss(__m128 __a)
{
  return (__m128)__builtin_ia32_rcpss((__v4sf)__a);
}
# 337 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rcp_ps(__m128 __a)
{
  return (__m128)__builtin_ia32_rcpps((__v4sf)__a);
}
# 361 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rsqrt_ss(__m128 __a)
{
  return __builtin_ia32_rsqrtss((__v4sf)__a);
}
# 383 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps((__v4sf)__a);
}
# 412 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss((__v4sf)__a, (__v4sf)__b);
}
# 437 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps((__v4sf)__a, (__v4sf)__b);
}
# 466 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss((__v4sf)__a, (__v4sf)__b);
}
# 491 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps((__v4sf)__a, (__v4sf)__b);
}
# 515 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a & (__v4su)__b);
}
# 543 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4su)__a & (__v4su)__b);
}
# 567 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a | (__v4su)__b);
}
# 592 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a ^ (__v4su)__b);
}
# 620 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqss((__v4sf)__a, (__v4sf)__b);
}
# 644 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqps((__v4sf)__a, (__v4sf)__b);
}
# 673 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltss((__v4sf)__a, (__v4sf)__b);
}
# 698 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__a, (__v4sf)__b);
}
# 728 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpless((__v4sf)__a, (__v4sf)__b);
}
# 753 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__a, (__v4sf)__b);
}
# 782 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 809 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__b, (__v4sf)__a);
}
# 839 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 866 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__b, (__v4sf)__a);
}
# 895 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqss((__v4sf)__a, (__v4sf)__b);
}
# 920 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqps((__v4sf)__a, (__v4sf)__b);
}
# 950 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltss((__v4sf)__a, (__v4sf)__b);
}
# 976 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__a, (__v4sf)__b);
}
# 1007 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnless((__v4sf)__a, (__v4sf)__b);
}
# 1033 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__a, (__v4sf)__b);
}
# 1064 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 1092 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__b, (__v4sf)__a);
}
# 1123 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 1151 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__b, (__v4sf)__a);
}
# 1182 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordss((__v4sf)__a, (__v4sf)__b);
}
# 1208 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordps((__v4sf)__a, (__v4sf)__b);
}
# 1239 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordss((__v4sf)__a, (__v4sf)__b);
}
# 1265 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordps((__v4sf)__a, (__v4sf)__b);
}
# 1293 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq((__v4sf)__a, (__v4sf)__b);
}
# 1322 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt((__v4sf)__a, (__v4sf)__b);
}
# 1350 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile((__v4sf)__a, (__v4sf)__b);
}
# 1378 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt((__v4sf)__a, (__v4sf)__b);
}
# 1406 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige((__v4sf)__a, (__v4sf)__b);
}
# 1434 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq((__v4sf)__a, (__v4sf)__b);
}
# 1462 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq((__v4sf)__a, (__v4sf)__b);
}
# 1490 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt((__v4sf)__a, (__v4sf)__b);
}
# 1519 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile((__v4sf)__a, (__v4sf)__b);
}
# 1548 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt((__v4sf)__a, (__v4sf)__b);
}
# 1577 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige((__v4sf)__a, (__v4sf)__b);
}
# 1605 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq((__v4sf)__a, (__v4sf)__b);
}
# 1628 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si((__v4sf)__a);
}
# 1651 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}
# 1676 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64((__v4sf)__a);
}
# 1699 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi((__v4sf)__a);
}
# 1720 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}
# 1744 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvttss_si32(__m128 __a)
{
  return __builtin_ia32_cvttss2si((__v4sf)__a);
}
# 1768 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}
# 1793 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvttss_si64(__m128 __a)
{
  return __builtin_ia32_cvttss2si64((__v4sf)__a);
}
# 1817 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi((__v4sf)__a);
}
# 1839 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}
# 1867 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}
# 1896 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}
# 1926 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}
# 1958 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps((__v4sf)__a, (__v2si)__b);
}
# 1987 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}
# 2009 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}
# 2036 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((const struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}
# 2069 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((const struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}
# 2101 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((const struct __mm_load_ss_struct*)__p)->__u;
  return __extension__ (__m128){ __u, 0, 0, 0 };
}
# 2128 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((const struct __mm_load1_ps_struct*)__p)->__u;
  return __extension__ (__m128){ __u, __u, __u, __u };
}
# 2159 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load_ps(const float *__p)
{
  return *(const __m128*)__p;
}
# 2181 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_ps*)__p)->__v;
}
# 2208 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
}
# 2226 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_undefined_ps(void)
{
  return (__m128)__builtin_ia32_undef128();
}
# 2251 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ss(float __w)
{
  return __extension__ (__m128){ __w, 0, 0, 0 };
}
# 2274 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set1_ps(float __w)
{
  return __extension__ (__m128){ __w, __w, __w, __w };
}
# 2298 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}
# 2333 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return __extension__ (__m128){ __w, __x, __y, __z };
}
# 2369 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return __extension__ (__m128){ __z, __y, __x, __w };
}
# 2388 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_setzero_ps(void)
{
  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };
}
# 2409 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  typedef float __mm_storeh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_storeh_pi_struct {
    __mm_storeh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pi_struct*)__p)->__u = __builtin_shufflevector(__a, __a, 2, 3);
}
# 2434 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  typedef float __mm_storeh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_storeh_pi_struct {
    __mm_storeh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pi_struct*)__p)->__u = __builtin_shufflevector(__a, __a, 0, 1);
}
# 2459 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}
# 2484 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storeu_ps(float *__p, __m128 __a)
{
  struct __storeu_ps {
    __m128_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
}
# 2509 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128*)__p = __a;
}
# 2532 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 0, 0);
  _mm_store_ps(__p, __a);
}
# 2556 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ps1(float *__p, __m128 __a)
{
  _mm_store1_ps(__p, __a);
}
# 2579 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
# 2645 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}
# 2668 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_nontemporal_store((__v4sf)__a, (__v4sf*)__p);
}


extern "C" {
# 2689 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
void _mm_sfence(void);


}
# 2781 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}
# 2806 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}
# 2831 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}
# 2856 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}
# 2879 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}
# 2904 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}
# 2978 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}
# 3003 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}
# 3028 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}
# 3056 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}


extern "C" {
# 3079 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
unsigned int _mm_getcsr(void);
# 3092 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
void _mm_setcsr(unsigned int __i);


}
# 3170 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 2, 6, 3, 7);
}
# 3198 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 4, 1, 5);
}
# 3226 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_move_ss(__m128 __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}
# 3254 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 6, 7, 2, 3);
}
# 3281 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 1, 4, 5);
}
# 3304 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 3339 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 3373 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 3403 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 3436 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}
# 3465 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}
# 3495 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}
# 3525 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps((__v4sf)__a);
}
# 3612 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 1 3 4
# 18 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 2 3 4

typedef double __m128d __attribute__((__vector_size__(16), __aligned__(16)));
typedef long long __m128i __attribute__((__vector_size__(16), __aligned__(16)));

typedef double __m128d_u __attribute__((__vector_size__(16), __aligned__(1)));
typedef long long __m128i_u
    __attribute__((__vector_size__(16), __aligned__(1)));


typedef double __v2df __attribute__((__vector_size__(16)));
typedef long long __v2di __attribute__((__vector_size__(16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));


typedef unsigned long long __v2du __attribute__((__vector_size__(16)));
typedef unsigned short __v8hu __attribute__((__vector_size__(16)));
typedef unsigned char __v16qu __attribute__((__vector_size__(16)));



typedef signed char __v16qs __attribute__((__vector_size__(16)));



typedef _Float16 __v8hf __attribute__((__vector_size__(16), __aligned__(16)));
typedef _Float16 __m128h __attribute__((__vector_size__(16), __aligned__(16)));
typedef _Float16 __m128h_u __attribute__((__vector_size__(16), __aligned__(1)));

typedef __bf16 __v8bf __attribute__((__vector_size__(16), __aligned__(16)));
typedef __bf16 __m128bh __attribute__((__vector_size__(16), __aligned__(16)));
# 80 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_sd(__m128d __a,
                                                        __m128d __b) {
  __a[0] += __b[0];
  return __a;
}
# 104 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2df)__a + (__v2df)__b);
}
# 132 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_sd(__m128d __a,
                                                        __m128d __b) {
  __a[0] -= __b[0];
  return __a;
}
# 156 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2df)__a - (__v2df)__b);
}
# 183 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mul_sd(__m128d __a,
                                                        __m128d __b) {
  __a[0] *= __b[0];
  return __a;
}
# 207 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mul_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2df)__a * (__v2df)__b);
}
# 235 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_div_sd(__m128d __a,
                                                        __m128d __b) {
  __a[0] /= __b[0];
  return __a;
}
# 260 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_div_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2df)__a / (__v2df)__b);
}
# 290 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sqrt_sd(__m128d __a,
                                                         __m128d __b) {
  __m128d __c = __builtin_ia32_sqrtsd((__v2df)__b);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 312 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sqrt_pd(__m128d __a) {
  return __builtin_ia32_sqrtpd((__v2df)__a);
}
# 340 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_min_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_minsd((__v2df)__a, (__v2df)__b);
}
# 365 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_min_pd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_minpd((__v2df)__a, (__v2df)__b);
}
# 394 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_max_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_maxsd((__v2df)__a, (__v2df)__b);
}
# 419 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_max_pd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_maxpd((__v2df)__a, (__v2df)__b);
}
# 442 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_and_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2du)__a & (__v2du)__b);
}
# 468 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_andnot_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)(~(__v2du)__a & (__v2du)__b);
}
# 491 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_or_pd(__m128d __a,
                                                       __m128d __b) {
  return (__m128d)((__v2du)__a | (__v2du)__b);
}
# 514 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_xor_pd(__m128d __a,
                                                        __m128d __b) {
  return (__m128d)((__v2du)__a ^ (__v2du)__b);
}
# 538 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpeqpd((__v2df)__a, (__v2df)__b);
}
# 563 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__a, (__v2df)__b);
}
# 587 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmple_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__a, (__v2df)__b);
}
# 611 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__b, (__v2df)__a);
}
# 635 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpge_pd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__b, (__v2df)__a);
}
# 659 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpord_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpordpd((__v2df)__a, (__v2df)__b);
}
# 684 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpunord_pd(__m128d __a,
                                                             __m128d __b) {
  return (__m128d)__builtin_ia32_cmpunordpd((__v2df)__a, (__v2df)__b);
}
# 708 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpneq_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpneqpd((__v2df)__a, (__v2df)__b);
}
# 732 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnlt_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__a, (__v2df)__b);
}
# 756 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnle_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__a, (__v2df)__b);
}
# 780 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpngt_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__b, (__v2df)__a);
}
# 804 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnge_pd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__b, (__v2df)__a);
}
# 830 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_sd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpeqsd((__v2df)__a, (__v2df)__b);
}
# 858 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_sd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmpltsd((__v2df)__a, (__v2df)__b);
}
# 886 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmple_sd(__m128d __a,
                                                          __m128d __b) {
  return (__m128d)__builtin_ia32_cmplesd((__v2df)__a, (__v2df)__b);
}
# 914 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_sd(__m128d __a,
                                                          __m128d __b) {
  __m128d __c = __builtin_ia32_cmpltsd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 943 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpge_sd(__m128d __a,
                                                          __m128d __b) {
  __m128d __c = __builtin_ia32_cmplesd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 972 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpord_sd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpordsd((__v2df)__a, (__v2df)__b);
}
# 1001 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpunord_sd(__m128d __a,
                                                             __m128d __b) {
  return (__m128d)__builtin_ia32_cmpunordsd((__v2df)__a, (__v2df)__b);
}
# 1029 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpneq_sd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpneqsd((__v2df)__a, (__v2df)__b);
}
# 1057 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnlt_sd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnltsd((__v2df)__a, (__v2df)__b);
}
# 1085 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnle_sd(__m128d __a,
                                                           __m128d __b) {
  return (__m128d)__builtin_ia32_cmpnlesd((__v2df)__a, (__v2df)__b);
}
# 1113 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpngt_sd(__m128d __a,
                                                           __m128d __b) {
  __m128d __c = __builtin_ia32_cmpnltsd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 1142 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpnge_sd(__m128d __a,
                                                           __m128d __b) {
  __m128d __c = __builtin_ia32_cmpnlesd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}
# 1169 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comieq_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdeq((__v2df)__a, (__v2df)__b);
}
# 1197 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comilt_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdlt((__v2df)__a, (__v2df)__b);
}
# 1225 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comile_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdle((__v2df)__a, (__v2df)__b);
}
# 1253 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comigt_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdgt((__v2df)__a, (__v2df)__b);
}
# 1281 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comige_sd(__m128d __a,
                                                       __m128d __b) {
  return __builtin_ia32_comisdge((__v2df)__a, (__v2df)__b);
}
# 1309 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_comineq_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_comisdneq((__v2df)__a, (__v2df)__b);
}
# 1336 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomieq_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdeq((__v2df)__a, (__v2df)__b);
}
# 1364 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomilt_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdlt((__v2df)__a, (__v2df)__b);
}
# 1392 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomile_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdle((__v2df)__a, (__v2df)__b);
}
# 1420 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomigt_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdgt((__v2df)__a, (__v2df)__b);
}
# 1448 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomige_sd(__m128d __a,
                                                        __m128d __b) {
  return __builtin_ia32_ucomisdge((__v2df)__a, (__v2df)__b);
}
# 1476 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_ucomineq_sd(__m128d __a,
                                                         __m128d __b) {
  return __builtin_ia32_ucomisdneq((__v2df)__a, (__v2df)__b);
}
# 1499 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtpd_ps(__m128d __a) {
  return __builtin_ia32_cvtpd2ps((__v2df)__a);
}
# 1522 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtps_pd(__m128 __a) {
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 1), __v2df);
}
# 1544 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtepi32_pd(__m128i __a) {
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4si)__a, (__v4si)__a, 0, 1), __v2df);
}
# 1567 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtpd_epi32(__m128d __a) {
  return __builtin_ia32_cvtpd2dq((__v2df)__a);
}
# 1587 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsd_si32(__m128d __a) {
  return __builtin_ia32_cvtsd2si((__v2df)__a);
}
# 1616 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsd_ss(__m128 __a,
                                                         __m128d __b) {
  return (__m128)__builtin_ia32_cvtsd2ss((__v4sf)__a, (__v2df)__b);
}
# 1644 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi32_sd(__m128d __a,
                                                            int __b) {
  __a[0] = __b;
  return __a;
}
# 1675 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtss_sd(__m128d __a,
                                                          __m128 __b) {
  __a[0] = __b[0];
  return __a;
}
# 1699 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvttpd_epi32(__m128d __a) {
  return (__m128i)__builtin_ia32_cvttpd2dq((__v2df)__a);
}
# 1720 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvttsd_si32(__m128d __a) {
  return __builtin_ia32_cvttsd2si((__v2df)__a);
}
# 1740 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_cvtpd_pi32(__m128d __a) {
  return (__m64)__builtin_ia32_cvtpd2pi((__v2df)__a);
}
# 1760 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_cvttpd_pi32(__m128d __a) {
  return (__m64)__builtin_ia32_cvttpd2pi((__v2df)__a);
}
# 1780 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_cvtpi32_pd(__m64 __a) {
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}
# 1800 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsd_f64(__m128d __a) {
  return __a[0];
}
# 1820 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_load_pd(double const *__dp) {
  return *(const __m128d *)__dp;
}
# 1841 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_load1_pd(double const *__dp) {
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_load1_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, __u};
}
# 1873 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadr_pd(double const *__dp) {
  __m128d __u = *(const __m128d *)__dp;
  return __builtin_shufflevector((__v2df)__u, (__v2df)__u, 1, 0);
}
# 1894 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadu_pd(double const *__dp) {
  struct __loadu_pd {
    __m128d_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_pd *)__dp)->__v;
}
# 1917 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadu_si64(void const *__a) {
  struct __loadu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  long long __u = ((const struct __loadu_si64 *)__a)->__v;
  return __extension__(__m128i)(__v2di){__u, 0LL};
}
# 1941 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadu_si32(void const *__a) {
  struct __loadu_si32 {
    int __v;
  } __attribute__((__packed__, __may_alias__));
  int __u = ((const struct __loadu_si32 *)__a)->__v;
  return __extension__(__m128i)(__v4si){__u, 0, 0, 0};
}
# 1965 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadu_si16(void const *__a) {
  struct __loadu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  short __u = ((const struct __loadu_si16 *)__a)->__v;
  return __extension__(__m128i)(__v8hi){__u, 0, 0, 0, 0, 0, 0, 0};
}
# 1989 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_load_sd(double const *__dp) {
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_load_sd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, 0};
}
# 2020 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadh_pd(__m128d __a,
                                                          double const *__dp) {
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_loadh_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__a[0], __u};
}
# 2052 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_loadl_pd(__m128d __a,
                                                          double const *__dp) {
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_loadl_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, __a[1]};
}
# 2076 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_undefined_pd(void) {
  return (__m128d)__builtin_ia32_undef128();
}
# 2099 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_sd(double __w) {
  return __extension__(__m128d){__w, 0};
}
# 2120 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_pd(double __w) {
  return __extension__(__m128d){__w, __w};
}
# 2141 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_pd1(double __w) {
  return _mm_set1_pd(__w);
}
# 2165 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_pd(double __w,
                                                        double __x) {
  return __extension__(__m128d){__x, __w};
}
# 2191 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setr_pd(double __w,
                                                         double __x) {
  return __extension__(__m128d){__w, __x};
}
# 2209 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setzero_pd(void) {
  return __extension__(__m128d){0.0, 0.0};
}
# 2234 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_move_sd(__m128d __a,
                                                         __m128d __b) {
  __a[0] = __b[0];
  return __a;
}
# 2255 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store_sd(double *__dp,
                                                       __m128d __a) {
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct *)__dp)->__u = __a[0];
}
# 2280 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store_pd(double *__dp,
                                                       __m128d __a) {
  *(__m128d *)__dp = __a;
}
# 2303 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store1_pd(double *__dp,
                                                        __m128d __a) {
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
  _mm_store_pd(__dp, __a);
}
# 2327 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store_pd1(double *__dp,
                                                        __m128d __a) {
  _mm_store1_pd(__dp, __a);
}
# 2348 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_pd(double *__dp,
                                                        __m128d __a) {
  struct __storeu_pd {
    __m128d_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_pd *)__dp)->__v = __a;
}
# 2374 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storer_pd(double *__dp,
                                                        __m128d __a) {
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 1, 0);
  *(__m128d *)__dp = __a;
}
# 2395 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeh_pd(double *__dp,
                                                        __m128d __a) {
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct *)__dp)->__u = __a[1];
}
# 2418 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storel_pd(double *__dp,
                                                        __m128d __a) {
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct *)__dp)->__u = __a[0];
}
# 2446 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_epi8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)((__v16qu)__a + (__v16qu)__b);
}
# 2471 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_epi16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v8hu)__a + (__v8hu)__b);
}
# 2496 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_epi32(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v4su)__a + (__v4su)__b);
}
# 2519 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_add_si64(__m64 __a,
                                                            __m64 __b) {
  return (__m64)__builtin_ia32_paddq((__v1di)__a, (__v1di)__b);
}
# 2544 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_add_epi64(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v2du)__a + (__v2du)__b);
}
# 2570 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_adds_epi8(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_add_sat((__v16qs)__a, (__v16qs)__b);
}
# 2597 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_adds_epi16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_elementwise_add_sat((__v8hi)__a, (__v8hi)__b);
}
# 2623 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_adds_epu8(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_add_sat((__v16qu)__a, (__v16qu)__b);
}
# 2649 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_adds_epu16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_elementwise_add_sat((__v8hu)__a, (__v8hu)__b);
}
# 2674 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_avg_epu8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}
# 2699 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_avg_epu16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}
# 2725 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_madd_epi16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}
# 2750 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_max_epi16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_max((__v8hi)__a, (__v8hi)__b);
}
# 2775 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_max_epu8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)__builtin_elementwise_max((__v16qu)__a, (__v16qu)__b);
}
# 2800 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_min_epi16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_min((__v8hi)__a, (__v8hi)__b);
}
# 2825 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_min_epu8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)__builtin_elementwise_min((__v16qu)__a, (__v16qu)__b);
}
# 2850 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mulhi_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}
# 2875 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mulhi_epu16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}
# 2900 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mullo_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v8hu)__a * (__v8hu)__b);
}
# 2924 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_mul_su32(__m64 __a,
                                                            __m64 __b) {
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}
# 2948 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_mul_epu32(__m128i __a,
                                                           __m128i __b) {
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}
# 2975 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sad_epu8(__m128i __a,
                                                          __m128i __b) {
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}
# 2998 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_epi8(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)((__v16qu)__a - (__v16qu)__b);
}
# 3021 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_epi16(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v8hu)__a - (__v8hu)__b);
}
# 3044 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_epi32(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v4su)__a - (__v4su)__b);
}
# 3068 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64))) _mm_sub_si64(__m64 __a,
                                                            __m64 __b) {
  return (__m64)__builtin_ia32_psubq((__v1di)__a, (__v1di)__b);
}
# 3091 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sub_epi64(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v2du)__a - (__v2du)__b);
}
# 3117 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_subs_epi8(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_sub_sat((__v16qs)__a, (__v16qs)__b);
}
# 3143 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_subs_epi16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_elementwise_sub_sat((__v8hi)__a, (__v8hi)__b);
}
# 3168 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_subs_epu8(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)__builtin_elementwise_sub_sat((__v16qu)__a, (__v16qu)__b);
}
# 3193 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_subs_epu16(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)__builtin_elementwise_sub_sat((__v8hu)__a, (__v8hu)__b);
}
# 3216 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_and_si128(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v2du)__a & (__v2du)__b);
}
# 3241 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_andnot_si128(__m128i __a,
                                                              __m128i __b) {
  return (__m128i)(~(__v2du)__a & (__v2du)__b);
}
# 3263 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_or_si128(__m128i __a,
                                                          __m128i __b) {
  return (__m128i)((__v2du)__a | (__v2du)__b);
}
# 3286 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_xor_si128(__m128i __a,
                                                           __m128i __b) {
  return (__m128i)((__v2du)__a ^ (__v2du)__b);
}
# 3344 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_slli_epi16(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}
# 3368 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sll_epi16(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}
# 3392 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_slli_epi32(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}
# 3416 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sll_epi32(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}
# 3440 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_slli_epi64(__m128i __a,
                                                            int __count) {
  return __builtin_ia32_psllqi128((__v2di)__a, __count);
}
# 3464 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sll_epi64(__m128i __a,
                                                           __m128i __count) {
  return __builtin_ia32_psllq128((__v2di)__a, (__v2di)__count);
}
# 3489 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srai_epi16(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}
# 3514 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sra_epi16(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}
# 3539 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srai_epi32(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}
# 3564 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_sra_epi32(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
# 3622 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srli_epi16(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}
# 3646 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srl_epi16(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}
# 3670 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srli_epi32(__m128i __a,
                                                            int __count) {
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}
# 3694 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srl_epi32(__m128i __a,
                                                           __m128i __count) {
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}
# 3718 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srli_epi64(__m128i __a,
                                                            int __count) {
  return __builtin_ia32_psrlqi128((__v2di)__a, __count);
}
# 3742 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_srl_epi64(__m128i __a,
                                                           __m128i __count) {
  return __builtin_ia32_psrlq128((__v2di)__a, (__v2di)__count);
}
# 3766 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_epi8(__m128i __a,
                                                            __m128i __b) {
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}
# 3790 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}
# 3814 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpeq_epi32(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v4si)__a == (__v4si)__b);
}
# 3839 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_epi8(__m128i __a,
                                                            __m128i __b) {


  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}
# 3865 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}
# 3889 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmpgt_epi32(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)((__v4si)__a > (__v4si)__b);
}
# 3913 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_epi8(__m128i __a,
                                                            __m128i __b) {
  return _mm_cmpgt_epi8(__b, __a);
}
# 3937 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_epi16(__m128i __a,
                                                             __m128i __b) {
  return _mm_cmpgt_epi16(__b, __a);
}
# 3961 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cmplt_epi32(__m128i __a,
                                                             __m128i __b) {
  return _mm_cmpgt_epi32(__b, __a);
}
# 3990 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi64_sd(__m128d __a,
                                                            long long __b) {
  __a[0] = __b;
  return __a;
}
# 4012 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsd_si64(__m128d __a) {
  return __builtin_ia32_cvtsd2si64((__v2df)__a);
}
# 4033 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvttsd_si64(__m128d __a) {
  return __builtin_ia32_cvttsd2si64((__v2df)__a);
}
# 4052 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtepi32_ps(__m128i __a) {
  return (__m128) __builtin_convertvector((__v4si)__a, __v4sf);
}
# 4071 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtps_epi32(__m128 __a) {
  return (__m128i)__builtin_ia32_cvtps2dq((__v4sf)__a);
}
# 4091 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvttps_epi32(__m128 __a) {
  return (__m128i)__builtin_ia32_cvttps2dq((__v4sf)__a);
}
# 4110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi32_si128(int __a) {
  return __extension__(__m128i)(__v4si){__a, 0, 0, 0};
}
# 4130 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi64_si128(long long __a) {
  return __extension__(__m128i)(__v2di){__a, 0};
}
# 4150 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi128_si32(__m128i __a) {
  __v4si __b = (__v4si)__a;
  return __b[0];
}
# 4171 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_cvtsi128_si64(__m128i __a) {
  return __a[0];
}
# 4190 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load_si128(__m128i const *__p) {
  return *__p;
}
# 4210 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si128(__m128i_u const *__p) {
  struct __loadu_si128 {
    __m128i_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_si128 *)__p)->__v;
}
# 4235 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadl_epi64(__m128i_u const *__p) {
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return __extension__(__m128i){
      ((const struct __mm_loadl_epi64_struct *)__p)->__u, 0};
}
# 4257 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_undefined_si128(void) {
  return (__m128i)__builtin_ia32_undef128();
}
# 4283 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_epi64x(long long __q1,
                                                            long long __q0) {
  return __extension__(__m128i)(__v2di){__q0, __q1};
}
# 4310 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_epi64(__m64 __q1,
                                                           __m64 __q0) {
  return _mm_set_epi64x((long long)__q1, (long long)__q0);
}
# 4345 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set_epi32(int __i3, int __i2,
                                                           int __i1, int __i0) {
  return __extension__(__m128i)(__v4si){__i0, __i1, __i2, __i3};
}
# 4396 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi16(short __w7, short __w6, short __w5, short __w4, short __w3,
              short __w2, short __w1, short __w0) {
  return __extension__(__m128i)(__v8hi){__w0, __w1, __w2, __w3,
                                        __w4, __w5, __w6, __w7};
}
# 4465 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi8(char __b15, char __b14, char __b13, char __b12, char __b11,
             char __b10, char __b9, char __b8, char __b7, char __b6, char __b5,
             char __b4, char __b3, char __b2, char __b1, char __b0) {
  return __extension__(__m128i)(__v16qi){
      __b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7,
      __b8, __b9, __b10, __b11, __b12, __b13, __b14, __b15};
}
# 4492 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi64x(long long __q) {
  return _mm_set_epi64x(__q, __q);
}
# 4514 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi64(__m64 __q) {
  return _mm_set_epi64(__q, __q);
}
# 4536 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi32(int __i) {
  return _mm_set_epi32(__i, __i, __i, __i);
}
# 4558 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi16(short __w) {
  return _mm_set_epi16(__w, __w, __w, __w, __w, __w, __w, __w);
}
# 4580 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_set1_epi8(char __b) {
  return _mm_set_epi8(__b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b,
                      __b, __b, __b, __b, __b);
}
# 4605 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setr_epi64(__m64 __q0,
                                                            __m64 __q1) {
  return _mm_set_epi64(__q1, __q0);
}
# 4635 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setr_epi32(int __i0, int __i1,
                                                            int __i2,
                                                            int __i3) {
  return _mm_set_epi32(__i3, __i2, __i1, __i0);
}
# 4678 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi16(short __w0, short __w1, short __w2, short __w3, short __w4,
               short __w5, short __w6, short __w7) {
  return _mm_set_epi16(__w7, __w6, __w5, __w4, __w3, __w2, __w1, __w0);
}
# 4745 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
              char __b6, char __b7, char __b8, char __b9, char __b10,
              char __b11, char __b12, char __b13, char __b14, char __b15) {
  return _mm_set_epi8(__b15, __b14, __b13, __b12, __b11, __b10, __b9, __b8,
                      __b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 4765 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_setzero_si128(void) {
  return __extension__(__m128i)(__v2di){0LL, 0LL};
}
# 4785 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_store_si128(__m128i *__p,
                                                          __m128i __b) {
  *__p = __b;
}
# 4804 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_si128(__m128i_u *__p,
                                                           __m128i __b) {
  struct __storeu_si128 {
    __m128i_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si128 *)__p)->__v = __b;
}
# 4828 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_si64(void *__p,
                                                          __m128i __b) {
  struct __storeu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si64 *)__p)->__v = ((__v2di)__b)[0];
}
# 4852 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_si32(void *__p,
                                                          __m128i __b) {
  struct __storeu_si32 {
    int __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si32 *)__p)->__v = ((__v4si)__b)[0];
}
# 4876 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storeu_si16(void *__p,
                                                          __m128i __b) {
  struct __storeu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si16 *)__p)->__v = ((__v8hi)__b)[0];
}
# 4906 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_maskmoveu_si128(__m128i __d,
                                                              __m128i __n,
                                                              char *__p) {
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}
# 4929 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_storel_epi64(__m128i_u *__p,
                                                           __m128i __a) {
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct *)__p)->__u = __a[0];
}
# 4952 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_stream_pd(double *__p,
                                                        __m128d __a) {
  __builtin_nontemporal_store((__v2df)__a, (__v2df *)__p);
}
# 4971 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_stream_si128(__m128i *__p,
                                                           __m128i __a) {
  __builtin_nontemporal_store((__v2di)__a, (__v2di *)__p);
}
# 4990 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void
    __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
    _mm_stream_si32(int *__p, int __a) {
  __builtin_ia32_movnti(__p, __a);
}
# 5011 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ void
    __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
    _mm_stream_si64(long long *__p, long long __a) {
  __builtin_ia32_movnti64(__p, __a);
}



extern "C" {
# 5035 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
void _mm_clflush(void const *__p);
# 5048 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
void _mm_lfence(void);
# 5061 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
void _mm_mfence(void);


}
# 5095 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_packs_epi16(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}
# 5128 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_packs_epi32(__m128i __a,
                                                             __m128i __b) {
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}
# 5161 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_packus_epi16(__m128i __a,
                                                              __m128i __b) {
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}
# 5254 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_movemask_epi8(__m128i __a) {
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
# 5411 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_epi8(__m128i __a,
                                                               __m128i __b) {
  return (__m128i)__builtin_shufflevector(
      (__v16qi)__a, (__v16qi)__b, 8, 16 + 8, 9, 16 + 9, 10, 16 + 10, 11,
      16 + 11, 12, 16 + 12, 13, 16 + 13, 14, 16 + 14, 15, 16 + 15);
}
# 5445 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_epi16(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8 + 4, 5,
                                          8 + 5, 6, 8 + 6, 7, 8 + 7);
}
# 5474 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_epi32(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4 + 2, 3,
                                          4 + 3);
}
# 5501 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_epi64(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 1, 2 + 1);
}
# 5541 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_epi8(__m128i __a,
                                                               __m128i __b) {
  return (__m128i)__builtin_shufflevector(
      (__v16qi)__a, (__v16qi)__b, 0, 16 + 0, 1, 16 + 1, 2, 16 + 2, 3, 16 + 3, 4,
      16 + 4, 5, 16 + 5, 6, 16 + 6, 7, 16 + 7);
}
# 5576 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_epi16(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8 + 0, 1,
                                          8 + 1, 2, 8 + 2, 3, 8 + 3);
}
# 5605 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_epi32(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4 + 0, 1,
                                          4 + 1);
}
# 5632 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_epi64(__m128i __a,
                                                                __m128i __b) {
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 0, 2 + 0);
}
# 5653 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_movepi64_pi64(__m128i __a) {
  return (__m64)__a[0];
}
# 5673 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_movpi64_epi64(__m64 __a) {
  return __extension__(__m128i)(__v2di){(long long)__a, 0};
}
# 5694 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_move_epi64(__m128i __a) {
  return __builtin_shufflevector((__v2di)__a, _mm_setzero_si128(), 0, 2);
}
# 5719 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpackhi_pd(__m128d __a,
                                                             __m128d __b) {
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 1, 2 + 1);
}
# 5745 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_unpacklo_pd(__m128d __a,
                                                             __m128d __b) {
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 0, 2 + 0);
}
# 5768 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_movemask_pd(__m128d __a) {
  return __builtin_ia32_movmskpd((__v2df)__a);
}
# 5826 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castpd_ps(__m128d __a) {
  return (__m128)__a;
}
# 5846 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castpd_si128(__m128d __a) {
  return (__m128i)__a;
}
# 5866 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castps_pd(__m128 __a) {
  return (__m128d)__a;
}
# 5886 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castps_si128(__m128 __a) {
  return (__m128i)__a;
}
# 5906 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castsi128_ps(__m128i __a) {
  return (__m128)__a;
}
# 5926 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128))) _mm_castsi128_pd(__m128i __a) {
  return (__m128d)__a;
}


extern "C" {
# 5943 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\emmintrin.h" 3 4
void _mm_pause(void);


}
# 3613 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xmmintrin.h" 2 3 4
# 27 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 36 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 1 3 4
# 38 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_lddqu_si128(__m128i_u const *__p)
{
  return (__m128i)__builtin_ia32_lddqu((char const *)__p);
}
# 63 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_addsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_addsubps((__v4sf)__a, (__v4sf)__b);
}
# 92 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_hadd_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_haddps((__v4sf)__a, (__v4sf)__b);
}
# 121 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_hsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_hsubps((__v4sf)__a, (__v4sf)__b);
}
# 148 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_movehdup_ps(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 1, 1, 3, 3);
}
# 174 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_moveldup_ps(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 2, 2);
}
# 199 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_addsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_addsubpd((__v2df)__a, (__v2df)__b);
}
# 228 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_hadd_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_haddpd((__v2df)__a, (__v2df)__b);
}
# 257 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_hsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_hsubpd((__v2df)__a, (__v2df)__b);
}
# 303 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_movedup_pd(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
}
# 331 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_monitor(void const *__p, unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_monitor(__p, __extensions, __hints);
}
# 359 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\pmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse3"), __min_vector_width__(128)))
_mm_mwait(unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_mwait(__extensions, __hints);
}
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 1 3 4
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_abs_pi8(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsb((__v8qi)__a);
}
# 63 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_abs_epi8(__m128i __a)
{
    return (__m128i)__builtin_elementwise_abs((__v16qs)__a);
}
# 86 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_abs_pi16(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsw((__v4hi)__a);
}
# 109 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_abs_epi16(__m128i __a)
{
    return (__m128i)__builtin_elementwise_abs((__v8hi)__a);
}
# 132 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_abs_pi32(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsd((__v2si)__a);
}
# 155 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_abs_epi32(__m128i __a)
{
    return (__m128i)__builtin_elementwise_abs((__v4si)__a);
}
# 244 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hadd_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddw128((__v8hi)__a, (__v8hi)__b);
}
# 273 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hadd_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddd128((__v4si)__a, (__v4si)__b);
}
# 302 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hadd_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddw((__v4hi)__a, (__v4hi)__b);
}
# 331 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hadd_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddd((__v2si)__a, (__v2si)__b);
}
# 362 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hadds_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddsw128((__v8hi)__a, (__v8hi)__b);
}
# 393 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hadds_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddsw((__v4hi)__a, (__v4hi)__b);
}
# 422 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hsub_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubw128((__v8hi)__a, (__v8hi)__b);
}
# 451 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hsub_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubd128((__v4si)__a, (__v4si)__b);
}
# 480 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hsub_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubw((__v4hi)__a, (__v4hi)__b);
}
# 509 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hsub_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubd((__v2si)__a, (__v2si)__b);
}
# 540 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_hsubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubsw128((__v8hi)__a, (__v8hi)__b);
}
# 571 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_hsubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubsw((__v4hi)__a, (__v4hi)__b);
}
# 607 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_maddubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmaddubsw128((__v16qi)__a, (__v16qi)__b);
}
# 639 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_maddubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmaddubsw((__v8qi)__a, (__v8qi)__b);
}
# 665 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_mulhrs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmulhrsw128((__v8hi)__a, (__v8hi)__b);
}
# 691 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_mulhrs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmulhrsw((__v4hi)__a, (__v4hi)__b);
}
# 723 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_shuffle_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pshufb128((__v16qi)__a, (__v16qi)__b);
}
# 754 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_shuffle_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pshufb((__v8qi)__a, (__v8qi)__b);
}
# 779 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_sign_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignb128((__v16qi)__a, (__v16qi)__b);
}
# 804 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_sign_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignw128((__v8hi)__a, (__v8hi)__b);
}
# 829 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3"), __min_vector_width__(64)))
_mm_sign_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignd128((__v4si)__a, (__v4si)__b);
}
# 854 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_sign_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignb((__v8qi)__a, (__v8qi)__b);
}
# 879 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_sign_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignw((__v4hi)__a, (__v4hi)__b);
}
# 904 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\tmmintrin.h" 3 4
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,ssse3"), __min_vector_width__(64)))
_mm_sign_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignd((__v2si)__a, (__v2si)__b);
}
# 42 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 1 3 4
# 527 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_blendv_pd(__m128d __V1,
                                                           __m128d __V2,
                                                           __m128d __M) {
  return (__m128d)__builtin_ia32_blendvpd((__v2df)__V1, (__v2df)__V2,
                                          (__v2df)__M);
}
# 561 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_blendv_ps(__m128 __V1,
                                                          __m128 __V2,
                                                          __m128 __M) {
  return (__m128)__builtin_ia32_blendvps((__v4sf)__V1, (__v4sf)__V2,
                                         (__v4sf)__M);
}
# 595 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_blendv_epi8(__m128i __V1,
                                                             __m128i __V2,
                                                             __m128i __M) {
  return (__m128i)__builtin_ia32_pblendvb128((__v16qi)__V1, (__v16qi)__V2,
                                             (__v16qi)__M);
}
# 657 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_mullo_epi32(__m128i __V1,
                                                             __m128i __V2) {
  return (__m128i)((__v4su)__V1 * (__v4su)__V2);
}
# 682 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_mul_epi32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_ia32_pmuldq128((__v4si)__V1, (__v4si)__V2);
}
# 780 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128)))
_mm_stream_load_si128(__m128i const *__V) {
  return (__m128i)__builtin_nontemporal_load((const __v2di *)__V);
}
# 805 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_min_epi8(__m128i __V1,
                                                          __m128i __V2) {
  return (__m128i)__builtin_elementwise_min((__v16qs)__V1, (__v16qs)__V2);
}
# 829 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_max_epi8(__m128i __V1,
                                                          __m128i __V2) {
  return (__m128i)__builtin_elementwise_max((__v16qs)__V1, (__v16qs)__V2);
}
# 853 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_min_epu16(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_min((__v8hu)__V1, (__v8hu)__V2);
}
# 877 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_max_epu16(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_max((__v8hu)__V1, (__v8hu)__V2);
}
# 901 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_min_epi32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_min((__v4si)__V1, (__v4si)__V2);
}
# 925 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_max_epi32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_max((__v4si)__V1, (__v4si)__V2);
}
# 949 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_min_epu32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_min((__v4su)__V1, (__v4su)__V2);
}
# 973 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_max_epu32(__m128i __V1,
                                                           __m128i __V2) {
  return (__m128i)__builtin_elementwise_max((__v4su)__V1, (__v4su)__V2);
}
# 1335 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_testz_si128(__m128i __M,
                                                         __m128i __V) {
  return __builtin_ia32_ptestz128((__v2di)__M, (__v2di)__V);
}
# 1358 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_testc_si128(__m128i __M,
                                                         __m128i __V) {
  return __builtin_ia32_ptestc128((__v2di)__M, (__v2di)__V);
}
# 1382 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_testnzc_si128(__m128i __M,
                                                           __m128i __V) {
  return __builtin_ia32_ptestnzc128((__v2di)__M, (__v2di)__V);
}
# 1477 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cmpeq_epi64(__m128i __V1,
                                                             __m128i __V2) {
  return (__m128i)((__v2di)__V1 == (__v2di)__V2);
}
# 1501 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi8_epi16(__m128i __V) {


  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3, 4, 5, 6,
                              7),
      __v8hi);
}
# 1528 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi8_epi32(__m128i __V) {


  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3), __v4si);
}
# 1553 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi8_epi64(__m128i __V) {


  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1), __v2di);
}
# 1578 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi16_epi32(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1, 2, 3), __v4si);
}
# 1601 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi16_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1), __v2di);
}
# 1624 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepi32_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v4si)__V, (__v4si)__V, 0, 1), __v2di);
}
# 1648 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu8_epi16(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3, 4, 5, 6,
                              7),
      __v8hi);
}
# 1673 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu8_epi32(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3), __v4si);
}
# 1696 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu8_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1), __v2di);
}
# 1719 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu16_epi32(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v8hu)__V, (__v8hu)__V, 0, 1, 2, 3), __v4si);
}
# 1742 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu16_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v8hu)__V, (__v8hu)__V, 0, 1), __v2di);
}
# 1765 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_cvtepu32_epi64(__m128i __V) {
  return (__m128i) __builtin_convertvector(
      __builtin_shufflevector((__v4su)__V, (__v4su)__V, 0, 1), __v2di);
}
# 1799 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_packus_epi32(__m128i __V1,
                                                              __m128i __V2) {
  return (__m128i)__builtin_ia32_packusdw128((__v4si)__V1, (__v4si)__V2);
}
# 1869 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1"), __min_vector_width__(128))) _mm_minpos_epu16(__m128i __V) {
  return (__m128i)__builtin_ia32_phminposuw128((__v8hi)__V);
}
# 2790 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.2"))) _mm_cmpgt_epi64(__m128i __V1,
                                                             __m128i __V2) {
  return (__m128i)((__v2di)__V1 > (__v2di)__V2);
}



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\popcntintrin.h" 1 3 4
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\popcntintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("popcnt"))) constexpr
_mm_popcnt_u32(unsigned int __A)
{
  return __builtin_popcount(__A);
}
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\popcntintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("popcnt"))) constexpr
_mm_popcnt_u64(unsigned long long __A)
{
  return __builtin_popcountll(__A);
}
# 2798 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\smmintrin.h" 2 3 4
# 47 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\wmmintrin.h" 1 3 4
# 19 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\wmmintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 1 3 4
# 40 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesenc_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenc128((__v2di)__V, (__v2di)__R);
}
# 66 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesenclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenclast128((__v2di)__V, (__v2di)__R);
}
# 92 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesdec_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdec128((__v2di)__V, (__v2di)__R);
}
# 118 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesdeclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdeclast128((__v2di)__V, (__v2di)__R);
}
# 140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\__wmmintrin_aes.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes"), __min_vector_width__(128)))
_mm_aesimc_si128(__m128i __V)
{
  return (__m128i)__builtin_ia32_aesimc128((__v2di)__V);
}
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\wmmintrin.h" 2 3 4

# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\__wmmintrin_pclmul.h" 1 3 4
# 22 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\wmmintrin.h" 2 3 4
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\clflushoptintrin.h" 1 3 4
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\clflushoptintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("clflushopt")))
_mm_clflushopt(void const * __m) {
  __builtin_ia32_clflushopt(__m);
}
# 57 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\clwbintrin.h" 1 3 4
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\clwbintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("clwb")))
_mm_clwb(void const *__p) {
  __builtin_ia32_clwb(__p);
}
# 62 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
typedef double __v4df __attribute__ ((__vector_size__ (32)));
typedef float __v8sf __attribute__ ((__vector_size__ (32)));
typedef long long __v4di __attribute__ ((__vector_size__ (32)));
typedef int __v8si __attribute__ ((__vector_size__ (32)));
typedef short __v16hi __attribute__ ((__vector_size__ (32)));
typedef char __v32qi __attribute__ ((__vector_size__ (32)));


typedef unsigned long long __v4du __attribute__ ((__vector_size__ (32)));
typedef unsigned int __v8su __attribute__ ((__vector_size__ (32)));
typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));
typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));



typedef signed char __v32qs __attribute__((__vector_size__(32)));

typedef float __m256 __attribute__ ((__vector_size__ (32), __aligned__(32)));
typedef double __m256d __attribute__((__vector_size__(32), __aligned__(32)));
typedef long long __m256i __attribute__((__vector_size__(32), __aligned__(32)));

typedef float __m256_u __attribute__ ((__vector_size__ (32), __aligned__(1)));
typedef double __m256d_u __attribute__((__vector_size__(32), __aligned__(1)));
typedef long long __m256i_u __attribute__((__vector_size__(32), __aligned__(1)));



typedef _Float16 __v16hf __attribute__((__vector_size__(32), __aligned__(32)));
typedef _Float16 __m256h __attribute__((__vector_size__(32), __aligned__(32)));
typedef _Float16 __m256h_u __attribute__((__vector_size__(32), __aligned__(1)));

typedef __bf16 __v16bf __attribute__((__vector_size__(32), __aligned__(32)));
typedef __bf16 __m256bh __attribute__((__vector_size__(32), __aligned__(32)));
# 75 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_add_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a+(__v4df)__b);
}
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_add_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a+(__v8sf)__b);
}
# 123 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_sub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a-(__v4df)__b);
}
# 147 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_sub_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a-(__v8sf)__b);
}
# 172 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_addsub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_addsubpd256((__v4df)__a, (__v4df)__b);
}
# 197 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_addsub_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_addsubps256((__v8sf)__a, (__v8sf)__b);
}
# 221 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_div_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a/(__v4df)__b);
}
# 245 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_div_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a/(__v8sf)__b);
}
# 270 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_max_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_maxpd256((__v4df)__a, (__v4df)__b);
}
# 295 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_max_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_maxps256((__v8sf)__a, (__v8sf)__b);
}
# 320 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_min_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_minpd256((__v4df)__a, (__v4df)__b);
}
# 345 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_min_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_minps256((__v8sf)__a, (__v8sf)__b);
}
# 369 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_mul_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4df)__a * (__v4df)__b);
}
# 393 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_mul_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8sf)__a * (__v8sf)__b);
}
# 415 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_sqrt_pd(__m256d __a)
{
  return (__m256d)__builtin_ia32_sqrtpd256((__v4df)__a);
}
# 437 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_sqrt_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_sqrtps256((__v8sf)__a);
}
# 459 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_rsqrt_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_rsqrtps256((__v8sf)__a);
}
# 481 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_rcp_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_rcpps256((__v8sf)__a);
}
# 671 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_and_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a & (__v4du)__b);
}
# 695 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_and_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a & (__v8su)__b);
}
# 722 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_andnot_pd(__m256d __a, __m256d __b)
{
  return (__m256d)(~(__v4du)__a & (__v4du)__b);
}
# 749 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_andnot_ps(__m256 __a, __m256 __b)
{
  return (__m256)(~(__v8su)__a & (__v8su)__b);
}
# 773 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_or_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a | (__v4du)__b);
}
# 797 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_or_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a | (__v8su)__b);
}
# 821 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_xor_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4du)__a ^ (__v4du)__b);
}
# 845 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_xor_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8su)__a ^ (__v8su)__b);
}
# 875 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_hadd_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_haddpd256((__v4df)__a, (__v4df)__b);
}
# 904 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_hadd_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_haddps256((__v8sf)__a, (__v8sf)__b);
}
# 933 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_hsub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_hsubpd256((__v4df)__a, (__v4df)__b);
}
# 962 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_hsub_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_hsubps256((__v8sf)__a, (__v8sf)__b);
}
# 998 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_permutevar_pd(__m128d __a, __m128i __c)
{
  return (__m128d)__builtin_ia32_vpermilvarpd((__v2df)__a, (__v2di)__c);
}
# 1043 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_permutevar_pd(__m256d __a, __m256i __c)
{
  return (__m256d)__builtin_ia32_vpermilvarpd256((__v4df)__a, (__v4di)__c);
}
# 1105 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_permutevar_ps(__m128 __a, __m128i __c)
{
  return (__m128)__builtin_ia32_vpermilvarps((__v4sf)__a, (__v4si)__c);
}
# 1202 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_permutevar_ps(__m256 __a, __m256i __c)
{
  return (__m256)__builtin_ia32_vpermilvarps256((__v8sf)__a, (__v8si)__c);
}
# 1692 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_blendv_pd(__m256d __a, __m256d __b, __m256d __c)
{
  return (__m256d)__builtin_ia32_blendvpd256(
    (__v4df)__a, (__v4df)__b, (__v4df)__c);
}
# 1727 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_blendv_ps(__m256 __a, __m256 __b, __m256 __c)
{
  return (__m256)__builtin_ia32_blendvps256(
    (__v8sf)__a, (__v8sf)__b, (__v8sf)__c);
}
# 2556 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtepi32_pd(__m128i __a)
{
  return (__m256d)__builtin_convertvector((__v4si)__a, __v4df);
}
# 2576 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtepi32_ps(__m256i __a)
{
  return (__m256)__builtin_convertvector((__v8si)__a, __v8sf);
}
# 2597 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtpd_ps(__m256d __a)
{
  return (__m128)__builtin_ia32_cvtpd2ps256((__v4df) __a);
}
# 2617 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtps_epi32(__m256 __a)
{
  return (__m256i)__builtin_ia32_cvtps2dq256((__v8sf) __a);
}
# 2638 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtps_pd(__m128 __a)
{
  return (__m256d)__builtin_convertvector((__v4sf)__a, __v4df);
}
# 2660 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvttpd_epi32(__m256d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq256((__v4df) __a);
}
# 2682 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtpd_epi32(__m256d __a)
{
  return (__m128i)__builtin_ia32_cvtpd2dq256((__v4df) __a);
}
# 2703 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvttps_epi32(__m256 __a)
{
  return (__m256i)__builtin_ia32_cvttps2dq256((__v8sf) __a);
}
# 2724 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline double __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtsd_f64(__m256d __a)
{
 return __a[0];
}
# 2745 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtsi256_si32(__m256i __a)
{
 __v8si __b = (__v8si)__a;
 return __b[0];
}
# 2767 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline float __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_cvtss_f32(__m256 __a)
{
 return __a[0];
}
# 2798 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_movehdup_ps(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 1, 1, 3, 3, 5, 5, 7, 7);
}
# 2828 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_moveldup_ps(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 0, 0, 2, 2, 4, 4, 6, 6);
}
# 2855 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_movedup_pd(__m256d __a)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__a, 0, 0, 2, 2);
}
# 2884 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_unpackhi_pd(__m256d __a, __m256d __b)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__b, 1, 5, 1+2, 5+2);
}
# 2912 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_unpacklo_pd(__m256d __a, __m256d __b)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__b, 0, 4, 0+2, 4+2);
}
# 2945 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_unpackhi_ps(__m256 __a, __m256 __b)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__b, 2, 10, 2+1, 10+1, 6, 14, 6+1, 14+1);
}
# 2978 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_unpacklo_ps(__m256 __a, __m256 __b)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__b, 0, 8, 0+1, 8+1, 4, 12, 4+1, 12+1);
}
# 3005 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testz_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestzpd((__v2df)__a, (__v2df)__b);
}
# 3031 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testc_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestcpd((__v2df)__a, (__v2df)__b);
}
# 3058 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testnzc_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestnzcpd((__v2df)__a, (__v2df)__b);
}
# 3084 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testz_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestzps((__v4sf)__a, (__v4sf)__b);
}
# 3110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testc_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestcps((__v4sf)__a, (__v4sf)__b);
}
# 3137 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_testnzc_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestnzcps((__v4sf)__a, (__v4sf)__b);
}
# 3163 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testz_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestzpd256((__v4df)__a, (__v4df)__b);
}
# 3189 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testc_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestcpd256((__v4df)__a, (__v4df)__b);
}
# 3216 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testnzc_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestnzcpd256((__v4df)__a, (__v4df)__b);
}
# 3242 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testz_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestzps256((__v8sf)__a, (__v8sf)__b);
}
# 3268 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testc_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestcps256((__v8sf)__a, (__v8sf)__b);
}
# 3295 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testnzc_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestnzcps256((__v8sf)__a, (__v8sf)__b);
}
# 3319 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testz_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestz256((__v4di)__a, (__v4di)__b);
}
# 3343 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testc_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestc256((__v4di)__a, (__v4di)__b);
}
# 3368 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_testnzc_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestnzc256((__v4di)__a, (__v4di)__b);
}
# 3392 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_movemask_pd(__m256d __a)
{
  return __builtin_ia32_movmskpd256((__v4df)__a);
}
# 3415 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline int __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_movemask_ps(__m256 __a)
{
  return __builtin_ia32_movmskps256((__v8sf)__a);
}
# 3430 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zeroall(void)
{
  __builtin_ia32_vzeroall();
}
# 3444 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zeroupper(void)
{
  __builtin_ia32_vzeroupper();
}
# 3468 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_broadcast_ss(float const *__a)
{
  float __f = *__a;
  return __extension__ (__m128)(__v4sf){ __f, __f, __f, __f };
}
# 3492 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_broadcast_sd(double const *__a)
{
  double __d = *__a;
  return __extension__ (__m256d)(__v4df){ __d, __d, __d, __d };
}
# 3516 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_broadcast_ss(float const *__a)
{
  float __f = *__a;
  return __extension__ (__m256)(__v8sf){ __f, __f, __f, __f, __f, __f, __f, __f };
}
# 3540 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_broadcast_pd(__m128d const *__a)
{
  __m128d __b = _mm_loadu_pd((const double *)__a);
  return (__m256d)__builtin_shufflevector((__v2df)__b, (__v2df)__b,
                                          0, 1, 0, 1);
}
# 3565 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_broadcast_ps(__m128 const *__a)
{
  __m128 __b = _mm_loadu_ps((const float *)__a);
  return (__m256)__builtin_shufflevector((__v4sf)__b, (__v4sf)__b,
                                         0, 1, 2, 3, 0, 1, 2, 3);
}
# 3590 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_load_pd(double const *__p)
{
  return *(const __m256d *)__p;
}
# 3611 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_load_ps(float const *__p)
{
  return *(const __m256 *)__p;
}
# 3633 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu_pd(double const *__p)
{
  struct __loadu_pd {
    __m256d_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_pd*)__p)->__v;
}
# 3658 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu_ps(float const *__p)
{
  struct __loadu_ps {
    __m256_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_ps*)__p)->__v;
}
# 3683 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_load_si256(__m256i const *__p)
{
  return *__p;
}
# 3704 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu_si256(__m256i_u const *__p)
{
  struct __loadu_si256 {
    __m256i_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_si256*)__p)->__v;
}
# 3730 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_lddqu_si256(__m256i_u const *__p)
{
  return (__m256i)__builtin_ia32_lddqu256((char const *)__p);
}
# 3754 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_store_pd(double *__p, __m256d __a)
{
  *(__m256d *)__p = __a;
}
# 3776 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_store_ps(float *__p, __m256 __a)
{
  *(__m256 *)__p = __a;
}
# 3798 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu_pd(double *__p, __m256d __a)
{
  struct __storeu_pd {
    __m256d_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_pd*)__p)->__v = __a;
}
# 3822 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu_ps(float *__p, __m256 __a)
{
  struct __storeu_ps {
    __m256_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
}
# 3847 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_store_si256(__m256i *__p, __m256i __a)
{
  *__p = __a;
}
# 3868 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu_si256(__m256i_u *__p, __m256i __a)
{
  struct __storeu_si256 {
    __m256i_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si256*)__p)->__v = __a;
}
# 3902 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_maskload_pd(double const *__p, __m128i __m)
{
  return (__m128d)__builtin_ia32_maskloadpd((const __v2df *)__p, (__v2di)__m);
}
# 3932 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_maskload_pd(double const *__p, __m256i __m)
{
  return (__m256d)__builtin_ia32_maskloadpd256((const __v4df *)__p,
                                               (__v4di)__m);
}
# 3963 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_maskload_ps(float const *__p, __m128i __m)
{
  return (__m128)__builtin_ia32_maskloadps((const __v4sf *)__p, (__v4si)__m);
}
# 3993 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_maskload_ps(float const *__p, __m256i __m)
{
  return (__m256)__builtin_ia32_maskloadps256((const __v8sf *)__p, (__v8si)__m);
}
# 4023 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_maskstore_ps(float *__p, __m256i __m, __m256 __a)
{
  __builtin_ia32_maskstoreps256((__v8sf *)__p, (__v8si)__m, (__v8sf)__a);
}
# 4052 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_maskstore_pd(double *__p, __m128i __m, __m128d __a)
{
  __builtin_ia32_maskstorepd((__v2df *)__p, (__v2di)__m, (__v2df)__a);
}
# 4081 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_maskstore_pd(double *__p, __m256i __m, __m256d __a)
{
  __builtin_ia32_maskstorepd256((__v4df *)__p, (__v4di)__m, (__v4df)__a);
}
# 4110 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(128)))
_mm_maskstore_ps(float *__p, __m128i __m, __m128 __a)
{
  __builtin_ia32_maskstoreps((__v4sf *)__p, (__v4si)__m, (__v4sf)__a);
}
# 4134 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_stream_si256(__m256i *__a, __m256i __b)
{
  typedef __v4di __v4di_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v4di_aligned)__b, (__v4di_aligned*)__a);
}
# 4158 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_stream_pd(double *__a, __m256d __b)
{
  typedef __v4df __v4df_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v4df_aligned)__b, (__v4df_aligned*)__a);
}
# 4183 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_stream_ps(float *__p, __m256 __a)
{
  typedef __v8sf __v8sf_aligned __attribute__((aligned(32)));
  __builtin_nontemporal_store((__v8sf_aligned)__a, (__v8sf_aligned*)__p);
}
# 4202 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_undefined_pd(void)
{
  return (__m256d)__builtin_ia32_undef256();
}
# 4219 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_undefined_ps(void)
{
  return (__m256)__builtin_ia32_undef256();
}
# 4236 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_undefined_si256(void)
{
  return (__m256i)__builtin_ia32_undef256();
}
# 4271 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_pd(double __a, double __b, double __c, double __d)
{
  return __extension__ (__m256d){ __d, __c, __b, __a };
}
# 4322 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_ps(float __a, float __b, float __c, float __d,
              float __e, float __f, float __g, float __h)
{
  return __extension__ (__m256){ __h, __g, __f, __e, __d, __c, __b, __a };
}
# 4366 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_epi32(int __i0, int __i1, int __i2, int __i3,
                 int __i4, int __i5, int __i6, int __i7)
{
  return __extension__ (__m256i)(__v8si){ __i7, __i6, __i5, __i4, __i3, __i2, __i1, __i0 };
}
# 4434 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_epi16(short __w15, short __w14, short __w13, short __w12,
                 short __w11, short __w10, short __w09, short __w08,
                 short __w07, short __w06, short __w05, short __w04,
                 short __w03, short __w02, short __w01, short __w00)
{
  return __extension__ (__m256i)(__v16hi){ __w00, __w01, __w02, __w03, __w04, __w05, __w06,
    __w07, __w08, __w09, __w10, __w11, __w12, __w13, __w14, __w15 };
}
# 4553 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_epi8(char __b31, char __b30, char __b29, char __b28,
                char __b27, char __b26, char __b25, char __b24,
                char __b23, char __b22, char __b21, char __b20,
                char __b19, char __b18, char __b17, char __b16,
                char __b15, char __b14, char __b13, char __b12,
                char __b11, char __b10, char __b09, char __b08,
                char __b07, char __b06, char __b05, char __b04,
                char __b03, char __b02, char __b01, char __b00)
{
  return __extension__ (__m256i)(__v32qi){
    __b00, __b01, __b02, __b03, __b04, __b05, __b06, __b07,
    __b08, __b09, __b10, __b11, __b12, __b13, __b14, __b15,
    __b16, __b17, __b18, __b19, __b20, __b21, __b22, __b23,
    __b24, __b25, __b26, __b27, __b28, __b29, __b30, __b31
  };
}
# 4596 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_epi64x(long long __a, long long __b, long long __c, long long __d)
{
  return __extension__ (__m256i)(__v4di){ __d, __c, __b, __a };
}
# 4633 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_pd(double __a, double __b, double __c, double __d)
{
  return _mm256_set_pd(__d, __c, __b, __a);
}
# 4685 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_ps(float __a, float __b, float __c, float __d,
               float __e, float __f, float __g, float __h)
{
  return _mm256_set_ps(__h, __g, __f, __e, __d, __c, __b, __a);
}
# 4729 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_epi32(int __i0, int __i1, int __i2, int __i3,
                  int __i4, int __i5, int __i6, int __i7)
{
  return _mm256_set_epi32(__i7, __i6, __i5, __i4, __i3, __i2, __i1, __i0);
}
# 4797 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_epi16(short __w15, short __w14, short __w13, short __w12,
       short __w11, short __w10, short __w09, short __w08,
       short __w07, short __w06, short __w05, short __w04,
       short __w03, short __w02, short __w01, short __w00)
{
  return _mm256_set_epi16(__w00, __w01, __w02, __w03,
                          __w04, __w05, __w06, __w07,
                          __w08, __w09, __w10, __w11,
                          __w12, __w13, __w14, __w15);
}
# 4918 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_epi8(char __b31, char __b30, char __b29, char __b28,
                 char __b27, char __b26, char __b25, char __b24,
                 char __b23, char __b22, char __b21, char __b20,
                 char __b19, char __b18, char __b17, char __b16,
                 char __b15, char __b14, char __b13, char __b12,
                 char __b11, char __b10, char __b09, char __b08,
                 char __b07, char __b06, char __b05, char __b04,
                 char __b03, char __b02, char __b01, char __b00)
{
  return _mm256_set_epi8(__b00, __b01, __b02, __b03, __b04, __b05, __b06, __b07,
                         __b08, __b09, __b10, __b11, __b12, __b13, __b14, __b15,
                         __b16, __b17, __b18, __b19, __b20, __b21, __b22, __b23,
                         __b24, __b25, __b26, __b27, __b28, __b29, __b30, __b31);
}
# 4959 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_epi64x(long long __a, long long __b, long long __c, long long __d)
{
  return _mm256_set_epi64x(__d, __c, __b, __a);
}
# 4983 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_pd(double __w)
{
  return _mm256_set_pd(__w, __w, __w, __w);
}
# 5007 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_ps(float __w)
{
  return _mm256_set_ps(__w, __w, __w, __w, __w, __w, __w, __w);
}
# 5031 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_epi32(int __i)
{
  return _mm256_set_epi32(__i, __i, __i, __i, __i, __i, __i, __i);
}
# 5054 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_epi16(short __w)
{
  return _mm256_set_epi16(__w, __w, __w, __w, __w, __w, __w, __w,
                          __w, __w, __w, __w, __w, __w, __w, __w);
}
# 5077 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_epi8(char __b)
{
  return _mm256_set_epi8(__b, __b, __b, __b, __b, __b, __b, __b,
                         __b, __b, __b, __b, __b, __b, __b, __b,
                         __b, __b, __b, __b, __b, __b, __b, __b,
                         __b, __b, __b, __b, __b, __b, __b, __b);
}
# 5103 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set1_epi64x(long long __q)
{
  return _mm256_set_epi64x(__q, __q, __q, __q);
}
# 5122 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setzero_pd(void)
{
  return __extension__ (__m256d){ 0.0, 0.0, 0.0, 0.0 };
}
# 5140 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setzero_ps(void)
{
  return __extension__ (__m256){ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };
}
# 5157 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setzero_si256(void)
{
  return __extension__ (__m256i)(__v4di){ 0, 0, 0, 0 };
}
# 5180 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castpd_ps(__m256d __a)
{
  return (__m256)__a;
}
# 5202 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castpd_si256(__m256d __a)
{
  return (__m256i)__a;
}
# 5224 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castps_pd(__m256 __a)
{
  return (__m256d)__a;
}
# 5246 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castps_si256(__m256 __a)
{
  return (__m256i)__a;
}
# 5268 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castsi256_ps(__m256i __a)
{
  return (__m256)__a;
}
# 5290 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castsi256_pd(__m256i __a)
{
  return (__m256d)__a;
}
# 5312 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castpd256_pd128(__m256d __a)
{
  return __builtin_shufflevector((__v4df)__a, (__v4df)__a, 0, 1);
}
# 5334 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castps256_ps128(__m256 __a)
{
  return __builtin_shufflevector((__v8sf)__a, (__v8sf)__a, 0, 1, 2, 3);
}
# 5355 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castsi256_si128(__m256i __a)
{
  return __builtin_shufflevector((__v4di)__a, (__v4di)__a, 0, 1);
}
# 5378 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castpd128_pd256(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 1, -1, -1);
}
# 5401 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castps128_ps256(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 1, 2, 3, -1, -1, -1, -1);
}
# 5422 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_castsi128_si256(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, (__v2di)__a, 0, 1, -1, -1);
}
# 5446 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_zextpd128_pd256(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)_mm_setzero_pd(), 0, 1, 2, 3);
}
# 5469 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_zextps128_ps256(__m128 __a)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)_mm_setzero_ps(), 0, 1, 2, 3, 4, 5, 6, 7);
}
# 5492 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_zextsi128_si256(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, (__v2di)_mm_setzero_si128(), 0, 1, 2, 3);
}
# 5745 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_m128 (__m128 __hi, __m128 __lo)
{
  return (__m256) __builtin_shufflevector((__v4sf)__lo, (__v4sf)__hi, 0, 1, 2, 3, 4, 5, 6, 7);
}
# 5772 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_m128d (__m128d __hi, __m128d __lo)
{
  return (__m256d) __builtin_shufflevector((__v2df)__lo, (__v2df)__hi, 0, 1, 2, 3);
}
# 5798 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_set_m128i (__m128i __hi, __m128i __lo)
{
  return (__m256i) __builtin_shufflevector((__v2di)__lo, (__v2di)__hi, 0, 1, 2, 3);
}
# 5827 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_m128 (__m128 __lo, __m128 __hi)
{
  return _mm256_set_m128(__hi, __lo);
}
# 5856 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_m128d (__m128d __lo, __m128d __hi)
{
  return (__m256d)_mm256_set_m128d(__hi, __lo);
}
# 5883 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_setr_m128i (__m128i __lo, __m128i __hi)
{
  return (__m256i)_mm256_set_m128i(__hi, __lo);
}
# 5917 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu2_m128(float const *__addr_hi, float const *__addr_lo)
{
  return _mm256_set_m128(_mm_loadu_ps(__addr_hi), _mm_loadu_ps(__addr_lo));
}
# 5950 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu2_m128d(double const *__addr_hi, double const *__addr_lo)
{
  return _mm256_set_m128d(_mm_loadu_pd(__addr_hi), _mm_loadu_pd(__addr_lo));
}
# 5980 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_loadu2_m128i(__m128i_u const *__addr_hi, __m128i_u const *__addr_lo)
{
   return _mm256_set_m128i(_mm_loadu_si128(__addr_hi), _mm_loadu_si128(__addr_lo));
}
# 6010 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu2_m128(float *__addr_hi, float *__addr_lo, __m256 __a)
{
  __m128 __v128;

  __v128 = _mm256_castps256_ps128(__a);
  _mm_storeu_ps(__addr_lo, __v128);
  __v128 = ((__m128)__builtin_ia32_vextractf128_ps256((__v8sf)(__m256)(__a), (int)(1)));
  _mm_storeu_ps(__addr_hi, __v128);
}
# 6044 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu2_m128d(double *__addr_hi, double *__addr_lo, __m256d __a)
{
  __m128d __v128;

  __v128 = _mm256_castpd256_pd128(__a);
  _mm_storeu_pd(__addr_lo, __v128);
  __v128 = ((__m128d)__builtin_ia32_vextractf128_pd256((__v4df)(__m256d)(__a), (int)(1)));
  _mm_storeu_pd(__addr_hi, __v128);
}
# 6078 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avxintrin.h" 3 4
static inline void __attribute__((__always_inline__, __nodebug__, __target__("avx"), __min_vector_width__(256)))
_mm256_storeu2_m128i(__m128i_u *__addr_hi, __m128i_u *__addr_lo, __m256i __a)
{
  __m128i __v128;

  __v128 = _mm256_castsi256_si128(__a);
  _mm_storeu_si128(__addr_lo, __v128);
  __v128 = ((__m128i)__builtin_ia32_vextractf128_si256((__v8si)(__m256i)(__a), (int)(1)));
  _mm_storeu_si128(__addr_hi, __v128);
}
# 67 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avx2intrin.h" 1 3 4
# 26 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_abs_epi8(__m256i __a)
{
    return (__m256i)__builtin_elementwise_abs((__v32qs)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_abs_epi16(__m256i __a)
{
    return (__m256i)__builtin_elementwise_abs((__v16hi)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_abs_epi32(__m256i __a)
{
    return (__m256i)__builtin_elementwise_abs((__v8si)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_packs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packsswb256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_packs_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packssdw256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_packus_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packuswb256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_packus_epi32(__m256i __V1, __m256i __V2)
{
  return (__m256i) __builtin_ia32_packusdw256((__v8si)__V1, (__v8si)__V2);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_add_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qu)__a + (__v32qu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_add_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hu)__a + (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_add_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8su)__a + (__v8su)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_add_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a + (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_adds_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_add_sat((__v32qs)__a, (__v32qs)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_adds_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_add_sat((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_adds_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_add_sat((__v32qu)__a, (__v32qu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_adds_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_add_sat((__v16hu)__a, (__v16hu)__b);
}





static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_and_si256(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a & (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_andnot_si256(__m256i __a, __m256i __b)
{
  return (__m256i)(~(__v4du)__a & (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_avg_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pavgb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_avg_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pavgw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_blendv_epi8(__m256i __V1, __m256i __V2, __m256i __M)
{
  return (__m256i)__builtin_ia32_pblendvb256((__v32qi)__V1, (__v32qi)__V2,
                                              (__v32qi)__M);
}





static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cmpeq_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qi)__a == (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cmpeq_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a == (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cmpeq_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a == (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cmpeq_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4di)__a == (__v4di)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cmpgt_epi8(__m256i __a, __m256i __b)
{


  return (__m256i)((__v32qs)__a > (__v32qs)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cmpgt_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a > (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cmpgt_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a > (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cmpgt_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4di)__a > (__v4di)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_hadd_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_hadd_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_hadds_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_hsub_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_hsub_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_hsubs_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_maddubs_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_pmaddubsw256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_madd_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaddwd256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_max_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_max((__v32qs)__a, (__v32qs)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_max_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_max((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_max_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_max((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_max_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_max((__v32qu)__a, (__v32qu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_max_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_max((__v16hu)__a, (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_max_epu32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_max((__v8su)__a, (__v8su)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_min_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_min((__v32qs)__a, (__v32qs)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_min_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_min((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_min_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_min((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_min_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_min((__v32qu)__a, (__v32qu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_min_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_min((__v16hu)__a, (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_min_epu32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_min((__v8su)__a, (__v8su)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_movemask_epi8(__m256i __a)
{
  return __builtin_ia32_pmovmskb256((__v32qi)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepi8_epi16(__m128i __V)
{


  return (__m256i)__builtin_convertvector((__v16qs)__V, __v16hi);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepi8_epi32(__m128i __V)
{


  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3, 4, 5, 6, 7), __v8si);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepi8_epi64(__m128i __V)
{


  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3), __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepi16_epi32(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v8hi)__V, __v8si);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepi16_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1, 2, 3), __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepi32_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v4si)__V, __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepu8_epi16(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v16qu)__V, __v16hi);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepu8_epi32(__m128i __V)
{
  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3, 4, 5, 6, 7), __v8si);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepu8_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v16qu)__V, (__v16qu)__V, 0, 1, 2, 3), __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepu16_epi32(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v8hu)__V, __v8si);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepu16_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector(__builtin_shufflevector((__v8hu)__V, (__v8hu)__V, 0, 1, 2, 3), __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_cvtepu32_epi64(__m128i __V)
{
  return (__m256i)__builtin_convertvector((__v4su)__V, __v4di);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_mul_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmuldq256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_mulhrs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhrsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_mulhi_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhuw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_mulhi_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_mullo_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hu)__a * (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_mullo_epi32 (__m256i __a, __m256i __b)
{
  return (__m256i)((__v8su)__a * (__v8su)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_mul_epu32(__m256i __a, __m256i __b)
{
  return __builtin_ia32_pmuludq256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_or_si256(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a | (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sad_epu8(__m256i __a, __m256i __b)
{
  return __builtin_ia32_psadbw256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_shuffle_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pshufb256((__v32qi)__a, (__v32qi)__b);
}
# 478 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sign_epi8(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sign_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sign_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignd256((__v8si)__a, (__v8si)__b);
}







static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_slli_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psllwi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sll_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psllw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_slli_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_pslldi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sll_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_pslld256((__v8si)__a, (__v4si)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_slli_epi64(__m256i __a, int __count)
{
  return __builtin_ia32_psllqi256((__v4di)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sll_epi64(__m256i __a, __m128i __count)
{
  return __builtin_ia32_psllq256((__v4di)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srai_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrawi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sra_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psraw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srai_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psradi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sra_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrad256((__v8si)__a, (__v4si)__count);
}







static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srli_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrlwi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srl_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrlw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srli_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrldi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srl_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrld256((__v8si)__a, (__v4si)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srli_epi64(__m256i __a, int __count)
{
  return __builtin_ia32_psrlqi256((__v4di)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srl_epi64(__m256i __a, __m128i __count)
{
  return __builtin_ia32_psrlq256((__v4di)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sub_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qu)__a - (__v32qu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sub_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hu)__a - (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sub_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8su)__a - (__v8su)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sub_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a - (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_subs_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_sub_sat((__v32qs)__a, (__v32qs)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_subs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_sub_sat((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_subs_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_sub_sat((__v32qu)__a, (__v32qu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_subs_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_elementwise_sub_sat((__v16hu)__a, (__v16hu)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_unpackhi_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v32qi)__a, (__v32qi)__b, 8, 32+8, 9, 32+9, 10, 32+10, 11, 32+11, 12, 32+12, 13, 32+13, 14, 32+14, 15, 32+15, 24, 32+24, 25, 32+25, 26, 32+26, 27, 32+27, 28, 32+28, 29, 32+29, 30, 32+30, 31, 32+31);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_unpackhi_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v16hi)__a, (__v16hi)__b, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_unpackhi_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v8si)__a, (__v8si)__b, 2, 8+2, 3, 8+3, 6, 8+6, 7, 8+7);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_unpackhi_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v4di)__a, (__v4di)__b, 1, 4+1, 3, 4+3);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_unpacklo_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v32qi)__a, (__v32qi)__b, 0, 32+0, 1, 32+1, 2, 32+2, 3, 32+3, 4, 32+4, 5, 32+5, 6, 32+6, 7, 32+7, 16, 32+16, 17, 32+17, 18, 32+18, 19, 32+19, 20, 32+20, 21, 32+21, 22, 32+22, 23, 32+23);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_unpacklo_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v16hi)__a, (__v16hi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_unpacklo_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v8si)__a, (__v8si)__b, 0, 8+0, 1, 8+1, 4, 8+4, 5, 8+5);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_unpacklo_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v4di)__a, (__v4di)__b, 0, 4+0, 2, 4+2);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_xor_si256(__m256i __a, __m256i __b)
{
  return (__m256i)((__v4du)__a ^ (__v4du)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_stream_load_si256(__m256i const *__V)
{
  typedef __v4di __v4di_aligned __attribute__((aligned(32)));
  return (__m256i)__builtin_nontemporal_load((const __v4di_aligned *)__V);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_broadcastss_ps(__m128 __X)
{
  return (__m128)__builtin_shufflevector((__v4sf)__X, (__v4sf)__X, 0, 0, 0, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_broadcastsd_pd(__m128d __a)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_broadcastss_ps(__m128 __X)
{
  return (__m256)__builtin_shufflevector((__v4sf)__X, (__v4sf)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_broadcastsd_pd(__m128d __X)
{
  return (__m256d)__builtin_shufflevector((__v2df)__X, (__v2df)__X, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_broadcastsi128_si256(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v2di)__X, (__v2di)__X, 0, 1, 0, 1);
}
# 753 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_broadcastb_epi8(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v16qi)__X, (__v16qi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_broadcastw_epi16(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v8hi)__X, (__v8hi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_broadcastd_epi32(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v4si)__X, (__v4si)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_broadcastq_epi64(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v2di)__X, (__v2di)__X, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_broadcastb_epi8(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__X, (__v16qi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_broadcastw_epi16(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__X, (__v8hi)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_broadcastd_epi32(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v4si)__X, (__v4si)__X, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_broadcastq_epi64(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v2di)__X, (__v2di)__X, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_permutevar8x32_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_permvarsi256((__v8si)__a, (__v8si)__b);
}




static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_permutevar8x32_ps(__m256 __a, __m256i __b)
{
  return (__m256)__builtin_ia32_permvarsf256((__v8sf)__a, (__v8si)__b);
}
# 830 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\avx2intrin.h" 3 4
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_maskload_epi32(int const *__X, __m256i __M)
{
  return (__m256i)__builtin_ia32_maskloadd256((const __v8si *)__X, (__v8si)__M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_maskload_epi64(long long const *__X, __m256i __M)
{
  return (__m256i)__builtin_ia32_maskloadq256((const __v4di *)__X, (__v4di)__M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_maskload_epi32(int const *__X, __m128i __M)
{
  return (__m128i)__builtin_ia32_maskloadd((const __v4si *)__X, (__v4si)__M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_maskload_epi64(long long const *__X, __m128i __M)
{
  return (__m128i)__builtin_ia32_maskloadq((const __v2di *)__X, (__v2di)__M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_maskstore_epi32(int *__X, __m256i __M, __m256i __Y)
{
  __builtin_ia32_maskstored256((__v8si *)__X, (__v8si)__M, (__v8si)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_maskstore_epi64(long long *__X, __m256i __M, __m256i __Y)
{
  __builtin_ia32_maskstoreq256((__v4di *)__X, (__v4di)__M, (__v4di)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_maskstore_epi32(int *__X, __m128i __M, __m128i __Y)
{
  __builtin_ia32_maskstored((__v4si *)__X, (__v4si)__M, (__v4si)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_maskstore_epi64(long long *__X, __m128i __M, __m128i __Y)
{
  __builtin_ia32_maskstoreq(( __v2di *)__X, (__v2di)__M, (__v2di)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sllv_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psllv8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_sllv_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psllv4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_sllv_epi64(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psllv4di((__v4di)__X, (__v4di)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_sllv_epi64(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psllv2di((__v2di)__X, (__v2di)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srav_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrav8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_srav_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrav4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srlv_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrlv8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_srlv_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrlv4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(256)))
_mm256_srlv_epi64(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrlv4di((__v4di)__X, (__v4di)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2"), __min_vector_width__(128)))
_mm_srlv_epi64(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrlv2di((__v2di)__X, (__v2di)__Y);
}
# 72 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\f16cintrin.h" 1 3 4
# 43 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\f16cintrin.h" 3 4
static inline float __attribute__((__always_inline__, __nodebug__, __target__("f16c"), __min_vector_width__(128)))
_cvtsh_ss(unsigned short __a)
{
  __v8hi __v = {(short)__a, 0, 0, 0, 0, 0, 0, 0};
  __v4sf __r = __builtin_ia32_vcvtph2ps(__v);
  return __r[0];
}
# 131 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\f16cintrin.h" 3 4
static inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("f16c"), __min_vector_width__(128)))
_mm_cvtph_ps(__m128i __a)
{
  return (__m128)__builtin_ia32_vcvtph2ps((__v8hi)__a);
}
# 186 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\f16cintrin.h" 3 4
static inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("f16c"), __min_vector_width__(256)))
_mm256_cvtph_ps(__m128i __a)
{
  return (__m256)__builtin_ia32_vcvtph2ps256((__v8hi)__a);
}
# 77 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 1 3 4
# 56 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__))
__tzcnt_u16(unsigned short __X)
{
  return __builtin_ia32_tzcnt_u16(__X);
}
# 78 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
__tzcnt_u32(unsigned int __X)
{
  return __builtin_ia32_tzcnt_u32(__X);
}
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_tzcnt_32(unsigned int __X)
{
  return (int)__builtin_ia32_tzcnt_u32(__X);
}
# 126 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__tzcnt_u64(unsigned long long __X)
{
  return __builtin_ia32_tzcnt_u64(__X);
}
# 148 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_tzcnt_64(unsigned long long __X)
{
  return (long long)__builtin_ia32_tzcnt_u64(__X);
}
# 194 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__andn_u32(unsigned int __X, unsigned int __Y)
{
  return ~__X & __Y;
}
# 223 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__bextr_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bextr_u32(__X, __Y);
}
# 255 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr_u32(unsigned int __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u32 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}
# 284 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr2_u32(unsigned int __X, unsigned int __Y) {
  return __builtin_ia32_bextr_u32(__X, __Y);
}
# 305 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsi_u32(unsigned int __X)
{
  return __X & -__X;
}
# 327 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsmsk_u32(unsigned int __X)
{
  return __X ^ (__X - 1);
}
# 349 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsr_u32(unsigned int __X)
{
  return __X & (__X - 1);
}
# 390 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__andn_u64 (unsigned long long __X, unsigned long long __Y)
{
  return ~__X & __Y;
}
# 419 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__bextr_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bextr_u64(__X, __Y);
}
# 451 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr_u64(unsigned long long __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u64 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}
# 480 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr2_u64(unsigned long long __X, unsigned long long __Y) {
  return __builtin_ia32_bextr_u64(__X, __Y);
}
# 501 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsi_u64(unsigned long long __X)
{
  return __X & -__X;
}
# 523 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsmsk_u64(unsigned long long __X)
{
  return __X ^ (__X - 1);
}
# 545 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmiintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsr_u64(unsigned long long __X)
{
  return __X & (__X - 1);
}
# 81 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmi2intrin.h" 1 3 4
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\bmi2intrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_bzhi_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bzhi_si(__X, __Y);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pdep_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_pdep_si(__X, __Y);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pext_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_pext_si(__X, __Y);
}



static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_bzhi_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bzhi_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pdep_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_pdep_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pext_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_pext_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_mulx_u64 (unsigned long long __X, unsigned long long __Y,
    unsigned long long *__P)
{
  unsigned __int128 __res = (unsigned __int128) __X * __Y;
  *__P = (unsigned long long) (__res >> 64);
  return (unsigned long long) __res;
}
# 85 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\lzcntintrin.h" 1 3 4
# 59 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\lzcntintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
__lzcnt32(unsigned int __X)
{
  return __builtin_ia32_lzcnt_u32(__X);
}
# 81 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\lzcntintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
_lzcnt_u32(unsigned int __X)
{
  return __builtin_ia32_lzcnt_u32(__X);
}
# 128 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\lzcntintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
_lzcnt_u64(unsigned long long __X)
{
  return __builtin_ia32_lzcnt_u64(__X);
}
# 90 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 99 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 1 3 4
# 35 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddps((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}
# 55 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddpd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}
# 83 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmadd_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddss3((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}
# 111 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmadd_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsd3((__v2df)__A, (__v2df)__B, (__v2df)__C);
}
# 131 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddps((__v4sf)__A, (__v4sf)__B, -(__v4sf)__C);
}
# 151 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddpd((__v2df)__A, (__v2df)__B, -(__v2df)__C);
}
# 179 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmsub_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddss3((__v4sf)__A, (__v4sf)__B, -(__v4sf)__C);
}
# 207 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmsub_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsd3((__v2df)__A, (__v2df)__B, -(__v2df)__C);
}
# 227 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fnmadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddps(-(__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}
# 247 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fnmadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddpd(-(__v2df)__A, (__v2df)__B, (__v2df)__C);
}
# 275 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fnmadd_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddss3((__v4sf)__A, -(__v4sf)__B, (__v4sf)__C);
}
# 303 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fnmadd_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsd3((__v2df)__A, -(__v2df)__B, (__v2df)__C);
}
# 323 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fnmsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddps(-(__v4sf)__A, (__v4sf)__B, -(__v4sf)__C);
}
# 343 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fnmsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddpd(-(__v2df)__A, (__v2df)__B, -(__v2df)__C);
}
# 371 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fnmsub_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddss3((__v4sf)__A, -(__v4sf)__B, -(__v4sf)__C);
}
# 399 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fnmsub_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsd3((__v2df)__A, -(__v2df)__B, -(__v2df)__C);
}
# 425 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmaddsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddsubps((__v4sf)__A, (__v4sf)__B, (__v4sf)__C);
}
# 449 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmaddsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsubpd((__v2df)__A, (__v2df)__B, (__v2df)__C);
}
# 475 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmsubadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddsubps((__v4sf)__A, (__v4sf)__B, -(__v4sf)__C);
}
# 499 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(128)))
_mm_fmsubadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsubpd((__v2df)__A, (__v2df)__B, -(__v2df)__C);
}
# 519 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fmadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddps256((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}
# 539 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fmadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddpd256((__v4df)__A, (__v4df)__B, (__v4df)__C);
}
# 559 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fmsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddps256((__v8sf)__A, (__v8sf)__B, -(__v8sf)__C);
}
# 579 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fmsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddpd256((__v4df)__A, (__v4df)__B, -(__v4df)__C);
}
# 599 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fnmadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddps256(-(__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}
# 619 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fnmadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddpd256(-(__v4df)__A, (__v4df)__B, (__v4df)__C);
}
# 639 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fnmsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddps256(-(__v8sf)__A, (__v8sf)__B, -(__v8sf)__C);
}
# 659 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fnmsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddpd256(-(__v4df)__A, (__v4df)__B, -(__v4df)__C);
}
# 689 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fmaddsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddsubps256((__v8sf)__A, (__v8sf)__B, (__v8sf)__C);
}
# 715 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fmaddsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddsubpd256((__v4df)__A, (__v4df)__B, (__v4df)__C);
}
# 745 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fmsubadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddsubps256((__v8sf)__A, (__v8sf)__B, -(__v8sf)__C);
}
# 771 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fmaintrin.h" 3 4
static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma"), __min_vector_width__(256)))
_mm256_fmsubadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddsubpd256((__v4df)__A, (__v4df)__B, -(__v4df)__C);
}
# 100 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 287 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("rdpid")))
_rdpid_u32(void) {
  return __builtin_ia32_rdpid();
}
# 309 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand16_step(unsigned short *__p)
{
  return (int)__builtin_ia32_rdrand16_step(__p);
}
# 329 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand32_step(unsigned int *__p)
{
  return (int)__builtin_ia32_rdrand32_step(__p);
}
# 349 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand64_step(unsigned long long *__p)
{

  return (int)__builtin_ia32_rdrand64_step(__p);
# 368 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
}
# 385 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readfsbase_u32(void)
{
  return __builtin_ia32_rdfsbase32();
}
# 402 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readfsbase_u64(void)
{
  return __builtin_ia32_rdfsbase64();
}
# 419 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readgsbase_u32(void)
{
  return __builtin_ia32_rdgsbase32();
}
# 436 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readgsbase_u64(void)
{
  return __builtin_ia32_rdgsbase64();
}
# 453 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writefsbase_u32(unsigned int __V)
{
  __builtin_ia32_wrfsbase32(__V);
}
# 470 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writefsbase_u64(unsigned long long __V)
{
  __builtin_ia32_wrfsbase64(__V);
}
# 487 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writegsbase_u32(unsigned int __V)
{
  __builtin_ia32_wrgsbase32(__V);
}
# 504 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writegsbase_u64(unsigned long long __V)
{
  __builtin_ia32_wrgsbase64(__V);
}
# 523 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
static __inline__ short __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_loadbe_i16(void const * __P) {
  struct __loadu_i16 {
    unsigned short __v;
  } __attribute__((__packed__, __may_alias__));
  return (short)__builtin_bswap16(((const struct __loadu_i16*)__P)->__v);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_storebe_i16(void * __P, short __D) {
  struct __storeu_i16 {
    unsigned short __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_i16*)__P)->__v = __builtin_bswap16((unsigned short)__D);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_loadbe_i32(void const * __P) {
  struct __loadu_i32 {
    unsigned int __v;
  } __attribute__((__packed__, __may_alias__));
  return (int)__builtin_bswap32(((const struct __loadu_i32*)__P)->__v);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_storebe_i32(void * __P, int __D) {
  struct __storeu_i32 {
    unsigned int __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_i32*)__P)->__v = __builtin_bswap32((unsigned int)__D);
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_loadbe_i64(void const * __P) {
  struct __loadu_i64 {
    unsigned long long __v;
  } __attribute__((__packed__, __may_alias__));
  return (long long)__builtin_bswap64(((const struct __loadu_i64*)__P)->__v);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("movbe")))
_storebe_i64(void * __P, long long __D) {
  struct __storeu_i64 {
    unsigned long long __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_i64*)__P)->__v = __builtin_bswap64((unsigned long long)__D);
}
# 582 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\shaintrin.h" 1 3 4
# 23 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\shaintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha"), __min_vector_width__(128)))
_mm_sha1nexte_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1nexte((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha"), __min_vector_width__(128)))
_mm_sha1msg1_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1msg1((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha"), __min_vector_width__(128)))
_mm_sha1msg2_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1msg2((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha"), __min_vector_width__(128)))
_mm_sha256rnds2_epu32(__m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i)__builtin_ia32_sha256rnds2((__v4si)__X, (__v4si)__Y, (__v4si)__Z);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha"), __min_vector_width__(128)))
_mm_sha256msg1_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha256msg1((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha"), __min_vector_width__(128)))
_mm_sha256msg2_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha256msg2((__v4si)__X, (__v4si)__Y);
}
# 583 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 1 3 4
# 32 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave(void *__p)
{
  __builtin_ia32_fxsave(__p);
}
# 53 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor(void *__p)
{
  __builtin_ia32_fxrstor(__p);
}
# 73 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave64(void *__p)
{
  __builtin_ia32_fxsave64(__p);
}
# 94 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\fxsrintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor64(void *__p)
{
  __builtin_ia32_fxrstor64(__p);
}
# 588 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsaveintrin.h" 1 3 4
# 24 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsaveintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave(void *__p, unsigned long long __m) {
  __builtin_ia32_xsave(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstor(__p, __m);
}
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsaveintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsave64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor64(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstor64(__p, __m);
}
# 592 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsaveoptintrin.h" 1 3 4
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsaveoptintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaveopt")))
_xsaveopt(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaveopt(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaveopt")))
_xsaveopt64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaveopt64(__p, __m);
}
# 596 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsavecintrin.h" 1 3 4
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsavecintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsavec")))
_xsavec(void *__p, unsigned long long __m) {
  __builtin_ia32_xsavec(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsavec")))
_xsavec64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsavec64(__p, __m);
}
# 601 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsavesintrin.h" 1 3 4
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\xsavesintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xsaves(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaves(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xrstors(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstors(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xrstors64(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstors64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xsaves64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaves64(__p, __m);
}
# 606 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 615 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\adxintrin.h" 1 3 4
# 21 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\adxintrin.h" 3 4
static inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
               unsigned int *__p)
{
  return __builtin_ia32_addcarryx_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarryx_u64(__cf, __x, __y, __p);
}



static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_addcarryx_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u64(unsigned char __cf, unsigned long long __x,
              unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarryx_u64(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_subborrow_u32(__cf, __x, __y, __p);
}


static inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_subborrow_u64(__cf, __x, __y, __p);
}
# 616 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4



# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\rdseedintrin.h" 1 3 4
# 20 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\rdseedintrin.h" 3 4
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdseed")))
_rdseed16_step(unsigned short *__p)
{
  return (int) __builtin_ia32_rdseed16_step(__p);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdseed")))
_rdseed32_step(unsigned int *__p)
{
  return (int) __builtin_ia32_rdseed32_step(__p);
}


static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdseed")))
_rdseed64_step(unsigned long long *__p)
{
  return (int) __builtin_ia32_rdseed64_step(__p);
}
# 620 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\wbnoinvdintrin.h" 1 3 4
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\wbnoinvdintrin.h" 3 4
static __inline__ void
  __attribute__((__always_inline__, __nodebug__, __target__("wbnoinvd")))
_wbnoinvd (void)
{
  __builtin_ia32_wbnoinvd ();
}
# 625 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\immintrin.h" 2 3 4
# 16 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4








# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\prfchwintrin.h" 1 3 4
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\prfchwintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_m_prefetch(void *__P)
{
  __builtin_prefetch (__P, 0, 3 );
}
# 52 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\prfchwintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_m_prefetchw(volatile const void *__P)
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wcast-qual"
  __builtin_prefetch ((const void*)__P, 1, 3 );
#pragma clang diagnostic pop
}
# 25 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ammintrin.h" 1 3 4
# 82 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ammintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4a"), __min_vector_width__(128)))
_mm_extract_si64(__m128i __x, __m128i __y)
{
  return (__m128i)__builtin_ia32_extrq((__v2di)__x, (__v16qi)__y);
}
# 166 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ammintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4a"), __min_vector_width__(128)))
_mm_insert_si64(__m128i __x, __m128i __y)
{
  return (__m128i)__builtin_ia32_insertq((__v2di)__x, (__v2di)__y);
}
# 188 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ammintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse4a"), __min_vector_width__(128)))
_mm_stream_sd(double *__p, __m128d __a)
{
  __builtin_ia32_movntsd(__p, (__v2df)__a);
}
# 210 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\ammintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse4a"), __min_vector_width__(128)))
_mm_stream_ss(float *__p, __m128 __a)
{
  __builtin_ia32_movntss(__p, (__v4sf)__a);
}
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4
# 49 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 3 4
# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\lwpintrin.h" 1 3 4
# 31 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\lwpintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("lwp")))
__llwpcb (void *__addr)
{
  __builtin_ia32_llwpcb(__addr);
}
# 46 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\lwpintrin.h" 3 4
static __inline__ void* __attribute__((__always_inline__, __nodebug__, __target__("lwp")))
__slwpcb (void)
{
  return __builtin_ia32_slwpcb();
}
# 50 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mwaitxintrin.h" 1 3 4
# 37 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mwaitxintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mwaitx")))
_mm_monitorx(void * __p, unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_monitorx(__p, __extensions, __hints);
}
# 67 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\mwaitxintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mwaitx")))
_mm_mwaitx(unsigned __extensions, unsigned __hints, unsigned __clock)
{
  __builtin_ia32_mwaitx(__extensions, __hints, __clock);
}
# 55 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\clzerointrin.h" 1 3 4
# 28 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\clzerointrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("clzero")))
_mm_clzero (void * __line)
{
  __builtin_ia32_clzero ((void *)__line);
}
# 60 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4




# 1 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\rdpruintrin.h" 1 3 4
# 30 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\rdpruintrin.h" 3 4
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("rdpru")))
__rdpru (int reg_id)
{
  return __builtin_ia32_rdpru(reg_id);
}
# 65 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000\\host_tools\\lib\\clang\\include\\x86intrin.h" 2 3 4
# 17 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic/sce_atomic_impl.h" 2 3


static inline
void sceAtomicMemoryBarrier(void)
{
 _mm_mfence();
}



static inline
int32_t sceAtomicAdd32Relaxed(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_add(ptr, value, 0);
}

static inline
int32_t sceAtomicIncrement32Relaxed(volatile int32_t* ptr)
{
 return sceAtomicAdd32Relaxed(ptr, 1);
}

static inline
int32_t sceAtomicDecrement32Relaxed(volatile int32_t* ptr)
{
 return sceAtomicAdd32Relaxed(ptr, -1);
}

static inline
int32_t sceAtomicCompareAndSwap32Relaxed(volatile int32_t* ptr, int32_t compare, int32_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
int32_t sceAtomicOr32Relaxed(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_or(ptr, value, 0);
}

static inline
int32_t sceAtomicAnd32Relaxed(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_and(ptr, value, 0);
}

static inline
int32_t sceAtomicExchange32Relaxed(volatile int32_t* ptr, int32_t swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
void sceAtomicStore32Relaxed(volatile int32_t* ptr, int32_t value)
{
 sceAtomicExchange32Relaxed(ptr, value);
}

static inline
int32_t sceAtomicLoad32Relaxed(const volatile int32_t* ptr)
{
 return __atomic_load_n(ptr, 0);
}



static inline
int64_t sceAtomicAdd64Relaxed(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_add(ptr, value, 0);
}

static inline
int64_t sceAtomicIncrement64Relaxed(volatile int64_t* ptr)
{
 return sceAtomicAdd64Relaxed(ptr, 1);
}

static inline
int64_t sceAtomicDecrement64Relaxed(volatile int64_t* ptr)
{
 return sceAtomicAdd64Relaxed(ptr, -1);
}

static inline
int64_t sceAtomicCompareAndSwap64Relaxed(volatile int64_t* ptr, int64_t compare, int64_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
int64_t sceAtomicOr64Relaxed(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_or(ptr, value, 0);
}
static inline
int64_t sceAtomicAnd64Relaxed(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_and(ptr, value, 0);
}
static inline
int64_t sceAtomicExchange64Relaxed(volatile int64_t* ptr, int64_t swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
void sceAtomicStore64Relaxed(volatile int64_t* ptr, int64_t value)
{
 sceAtomicExchange64Relaxed(ptr, value);
}

static inline
int64_t sceAtomicLoad64Relaxed(const volatile int64_t* ptr)
{
 return __atomic_load_n(ptr, 0);
}



static inline
int16_t sceAtomicAdd16Relaxed(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_add(ptr, value, 0);
}

static inline
int16_t sceAtomicIncrement16Relaxed(volatile int16_t* ptr)
{
 return sceAtomicAdd16Relaxed(ptr, 1);
}

static inline
int16_t sceAtomicDecrement16Relaxed(volatile int16_t* ptr)
{
 return sceAtomicAdd16Relaxed(ptr, -1);
}

static inline
int16_t sceAtomicCompareAndSwap16Relaxed(volatile int16_t* ptr, int16_t compare, int16_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
int16_t sceAtomicOr16Relaxed(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_or(ptr, value, 0);
}

static inline
int16_t sceAtomicAnd16Relaxed(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_and(ptr, value, 0);
}

static inline
int16_t sceAtomicExchange16Relaxed(volatile int16_t* ptr, int16_t swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
void sceAtomicStore16Relaxed(volatile int16_t* ptr, int16_t value)
{
 sceAtomicExchange16Relaxed(ptr, value);
}

static inline
int16_t sceAtomicLoad16Relaxed(const volatile int16_t* ptr)
{
 return __atomic_load_n(ptr, 0);
}



static inline
int8_t sceAtomicCompareAndSwap8Relaxed(volatile int8_t* ptr, int8_t compare, int8_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
int8_t sceAtomicAdd8Relaxed(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_add(ptr, value, 0);
}

static inline
int8_t sceAtomicIncrement8Relaxed(volatile int8_t* ptr)
{
 return sceAtomicAdd8Relaxed(ptr, 1);
}

static inline
int8_t sceAtomicDecrement8Relaxed(volatile int8_t* ptr)
{
 return sceAtomicAdd8Relaxed(ptr, -1);
}

static inline
int8_t sceAtomicOr8Relaxed(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_or(ptr, value, 0);
}
static inline
int8_t sceAtomicAnd8Relaxed(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_and(ptr, value, 0);
}
static inline
int8_t sceAtomicExchange8Relaxed(volatile int8_t* ptr, int8_t swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
void sceAtomicStore8Relaxed(volatile int8_t* ptr, int8_t value)
{
 sceAtomicExchange8Relaxed(ptr, value);
}

static inline
int8_t sceAtomicLoad8Relaxed(const volatile int8_t* ptr)
{
 return __atomic_load_n(ptr, 0);
}



static inline
__int128 sceAtomicCompareAndSwap128Relaxed(volatile __int128* ptr, __int128 compare, __int128 swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 0, 0);
 return compare;
}

static inline
__int128 sceAtomicAdd128Relaxed(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Relaxed(ptr, oldval, oldval + value));
 return oldval;
}

static inline
__int128 sceAtomicIncrement128Relaxed(volatile __int128* ptr)
{
 return sceAtomicAdd128Relaxed(ptr, 1);
}

static inline
__int128 sceAtomicDecrement128Relaxed(volatile __int128* ptr)
{
 return sceAtomicAdd128Relaxed(ptr, -1);
}

static inline
__int128 sceAtomicOr128Relaxed(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Relaxed(ptr, oldval, oldval | value));
 return oldval;
}

static inline
__int128 sceAtomicAnd128Relaxed(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Relaxed(ptr, oldval, oldval & value));
 return oldval;
}

static inline
__int128 sceAtomicExchange128Relaxed(volatile __int128* ptr, __int128 swap)
{
 return __atomic_exchange_n(ptr, swap, 0);
}

static inline
bool sceAtomicCompareAndSwap128ByPointerRelaxed(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{
 __int128 c = *(__int128_t*)compare;
 __int128 old = sceAtomicCompareAndSwap128Relaxed((volatile __int128_t*)ptr, c, *(__int128_t*)swap);
 __int128 *o =(__int128 *)oldvalue;
 *o = old;
 return old == c;
}

static inline
bool sceAtomicCompareAndSwap128_64Relaxed(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{
 __int128 c = (((__int128)compareHigh) << 64) | (((__int128)compareLow) & 0xffffffffffffffff);
 __int128 s = (((__int128)swapHigh) << 64) | (((__int128)swapLow) & 0xffffffffffffffff);
 __int128 old = sceAtomicCompareAndSwap128Relaxed((volatile __int128_t*)(intptr_t)ptr, c, s);
 oldvalue[0] = (int64_t)(0xffffffffffffffff & old);
 oldvalue[1] = (int64_t)(0xffffffffffffffff & (old >> 64));
 return old == c;
}

static inline
void sceAtomicStore128Relaxed(volatile __int128* ptr, __int128 value)
{
 __atomic_store_n(ptr, value, 0);
}

static inline
__int128 sceAtomicLoad128Relaxed(const volatile __int128* ptr)
{
 return __atomic_load_n(ptr, 0);
}

static inline
void sceAtomicStore128_64Relaxed(volatile int64_t* ptr, const int64_t *source)
{
 __int128 s = (((__int128)source[1]) << 64) | (((__int128)source[0]) & 0xffffffffffffffff);
 sceAtomicStore128Relaxed((volatile __int128* )(intptr_t)ptr, s);
}

static inline
void sceAtomicLoad128_64Relaxed(const volatile int64_t* ptr, int64_t *destination)
{
 __int128 val = sceAtomicLoad128Relaxed((const volatile __int128* )(intptr_t)ptr);
 destination[0] = (int64_t)(0xffffffffffffffff & val);
 destination[1] = (int64_t)(0xffffffffffffffff & (val >> 64));
}

static inline
void* sceAtomicExchangePointerRelaxed(volatile void** ptr, void* swap)
{
 return (void*)(intptr_t)sceAtomicExchange64Relaxed((volatile int64_t*)(intptr_t)ptr, (int64_t)swap);
}
# 371 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic/sce_atomic_impl.h" 3
static inline int8_t sceAtomicAdd8Acquire(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int8_t sceAtomicOr8Acquire(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int8_t sceAtomicAnd8Acquire(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int8_t sceAtomicIncrement8Acquire(volatile int8_t* ptr)
{
 return sceAtomicAdd8Acquire(ptr, 1);
}

static inline int8_t sceAtomicDecrement8Acquire(volatile int8_t* ptr)
{
 return sceAtomicAdd8Acquire(ptr, -1);
}

static inline int8_t sceAtomicCompareAndSwap8Acquire(volatile int8_t* ptr, int8_t compare, int8_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int8_t sceAtomicExchange8Acquire(volatile int8_t* ptr, int8_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore8Acquire(volatile int8_t* ptr, int8_t value)
{
 sceAtomicExchange8Acquire(ptr, value);
}

static inline
int8_t sceAtomicLoad8Acquire(const volatile int8_t* ptr)
{
 int8_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int16_t sceAtomicAdd16Acquire(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int16_t sceAtomicOr16Acquire(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int16_t sceAtomicAnd16Acquire(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int16_t sceAtomicIncrement16Acquire(volatile int16_t* ptr)
{
 return sceAtomicAdd16Acquire(ptr, 1);
}

static inline int16_t sceAtomicDecrement16Acquire(volatile int16_t* ptr)
{
 return sceAtomicAdd16Acquire(ptr, -1);
}

static inline int16_t sceAtomicCompareAndSwap16Acquire(volatile int16_t* ptr, int16_t compare, int16_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int16_t sceAtomicExchange16Acquire(volatile int16_t* ptr, int16_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore16Acquire(volatile int16_t* ptr, int16_t value)
{
 sceAtomicExchange16Acquire(ptr, value);
}

static inline
int16_t sceAtomicLoad16Acquire(const volatile int16_t* ptr)
{
 int16_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int32_t sceAtomicAdd32Acquire(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int32_t sceAtomicOr32Acquire(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int32_t sceAtomicAnd32Acquire(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int32_t sceAtomicIncrement32Acquire(volatile int32_t* ptr)
{
 return sceAtomicAdd32Acquire(ptr, 1);
}

static inline int32_t sceAtomicDecrement32Acquire(volatile int32_t* ptr)
{
 return sceAtomicAdd32Acquire(ptr, -1);
}

static inline int32_t sceAtomicCompareAndSwap32Acquire(volatile int32_t* ptr, int32_t compare, int32_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int32_t sceAtomicExchange32Acquire(volatile int32_t* ptr, int32_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore32Acquire(volatile int32_t* ptr, int32_t value)
{
 sceAtomicExchange32Acquire(ptr, value);
}

static inline
int32_t sceAtomicLoad32Acquire(const volatile int32_t* ptr)
{
 int32_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
int64_t sceAtomicAdd64Acquire(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int64_t sceAtomicOr64Acquire(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int64_t sceAtomicAnd64Acquire(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int64_t sceAtomicIncrement64Acquire(volatile int64_t* ptr)
{
 return sceAtomicAdd64Acquire(ptr, 1);
}

static inline int64_t sceAtomicDecrement64Acquire(volatile int64_t* ptr)
{
 return sceAtomicAdd64Acquire(ptr, -1);
}

static inline int64_t sceAtomicCompareAndSwap64Acquire(volatile int64_t* ptr, int64_t compare, int64_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int64_t sceAtomicExchange64Acquire(volatile int64_t* ptr, int64_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore64Acquire(volatile int64_t* ptr, int64_t value)
{
 sceAtomicExchange64Acquire(ptr, value);
}

static inline
int64_t sceAtomicLoad64Acquire(const volatile int64_t* ptr)
{
 int64_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
__int128 sceAtomicCompareAndSwap128Acquire(volatile __int128* ptr, __int128 compare, __int128 swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline
__int128 sceAtomicAdd128Acquire(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Acquire(ptr, oldval, oldval + value));
 return oldval;
}

static inline
__int128 sceAtomicIncrement128Acquire(volatile __int128* ptr)
{
 return sceAtomicAdd128Acquire(ptr, 1);
}

static inline
__int128 sceAtomicDecrement128Acquire(volatile __int128* ptr)
{
 return sceAtomicAdd128Acquire(ptr, -1);
}

static inline
__int128 sceAtomicOr128Acquire(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Acquire(ptr, oldval, oldval | value));
 return oldval;
}

static inline
__int128 sceAtomicAnd128Acquire(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Acquire(ptr, oldval, oldval & value));
 return oldval;
}

static inline
__int128 sceAtomicExchange128Acquire(volatile __int128* ptr, __int128 swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
bool sceAtomicCompareAndSwap128ByPointerAcquire(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{
 __int128 c = *(__int128_t*)compare;
 __int128 old = sceAtomicCompareAndSwap128Acquire((volatile __int128_t*)ptr, c, *(__int128_t*)swap);
 __int128 *o =(__int128 *)oldvalue;
 *o = old;
 return old == c;
}

static inline
bool sceAtomicCompareAndSwap128_64Acquire(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{
 __int128 c = (((__int128)compareHigh) << 64) | (((__int128)compareLow) & 0xffffffffffffffff);
 __int128 s = (((__int128)swapHigh) << 64) | (((__int128)swapLow) & 0xffffffffffffffff);
 __int128 old = sceAtomicCompareAndSwap128Acquire((volatile __int128_t*)(intptr_t)ptr, c, s);
 oldvalue[0] = (int64_t)(0xffffffffffffffff & old);
 oldvalue[1] = (int64_t)(0xffffffffffffffff & (old >> 64));
 return old == c;
}

static inline
void sceAtomicStore128Acquire(volatile __int128* ptr, __int128 value)
{
 __atomic_store_n(ptr, value, 5);
}

static inline
__int128 sceAtomicLoad128Acquire(const volatile __int128* ptr)
{
 __int128 ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
void sceAtomicStore128_64Acquire(volatile int64_t* ptr, const int64_t *source)
{
 __int128 s = (((__int128)source[1]) << 64) | (((__int128)source[0]) & 0xffffffffffffffff);
 sceAtomicStore128Acquire((volatile __int128* )(intptr_t)ptr, s);
}

static inline
void sceAtomicLoad128_64Acquire(const volatile int64_t* ptr, int64_t *destination)
{
 __int128 val = sceAtomicLoad128Acquire((const volatile __int128* )(intptr_t)ptr);
 destination[0] = (int64_t)(0xffffffffffffffff & val);
 destination[1] = (int64_t)(0xffffffffffffffff & (val >> 64));
 sceAtomicMemoryBarrier();
}

static inline
void* sceAtomicExchangePointerAcquire(volatile void** ptr, void* swap)
{
   return (void*)(intptr_t)sceAtomicExchange64Acquire((volatile int64_t*)(intptr_t)ptr, (int64_t)swap);
}
# 695 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic/sce_atomic_impl.h" 3
static inline
int8_t sceAtomicAdd8Release(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline
int8_t sceAtomicOr8Release(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline
int8_t sceAtomicAnd8Release(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline
int8_t sceAtomicIncrement8Release(volatile int8_t* ptr)
{
 return sceAtomicAdd8Release(ptr, 1);
}

static inline
int8_t sceAtomicDecrement8Release(volatile int8_t* ptr)
{
 return sceAtomicAdd8Release(ptr, -1);
}

static inline
int8_t sceAtomicCompareAndSwap8Release(volatile int8_t* ptr, int8_t compare, int8_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline
int8_t sceAtomicExchange8Release(volatile int8_t* ptr, int8_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore8Release(volatile int8_t* ptr, int8_t value)
{
 sceAtomicExchange8Release(ptr, value);
}

static inline
int8_t sceAtomicLoad8Release(const volatile int8_t* ptr)
{
 sceAtomicMemoryBarrier();
 return __atomic_load_n(ptr, 5);
}

static inline int16_t sceAtomicAdd16Release(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int16_t sceAtomicOr16Release(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int16_t sceAtomicAnd16Release(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int16_t sceAtomicIncrement16Release(volatile int16_t* ptr)
{
 return sceAtomicAdd16Release(ptr, 1);
}

static inline int16_t sceAtomicDecrement16Release(volatile int16_t* ptr)
{
 return sceAtomicAdd16Release(ptr, -1);
}

static inline int16_t sceAtomicCompareAndSwap16Release(volatile int16_t* ptr, int16_t compare, int16_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int16_t sceAtomicExchange16Release(volatile int16_t* ptr, int16_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore16Release(volatile int16_t* ptr, int16_t value)
{
 sceAtomicExchange16Release(ptr, value);
}

static inline
int16_t sceAtomicLoad16Release(const volatile int16_t* ptr)
{
 sceAtomicMemoryBarrier();
 return __atomic_load_n(ptr, 5);
}

static inline int32_t sceAtomicAdd32Release(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int32_t sceAtomicOr32Release(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int32_t sceAtomicAnd32Release(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int32_t sceAtomicIncrement32Release(volatile int32_t* ptr)
{
 return sceAtomicAdd32Release(ptr, 1);
}

static inline int32_t sceAtomicDecrement32Release(volatile int32_t* ptr)
{
 return sceAtomicAdd32Release(ptr, -1);
}

static inline int32_t sceAtomicCompareAndSwap32Release(volatile int32_t* ptr, int32_t compare, int32_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int32_t sceAtomicExchange32Release(volatile int32_t* ptr, int32_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore32Release(volatile int32_t* ptr, int32_t value)
{
 sceAtomicExchange32Release(ptr, value);
}

static inline
int32_t sceAtomicLoad32Release(const volatile int32_t* ptr)
{
 sceAtomicMemoryBarrier();
 return __atomic_load_n(ptr, 5);
}

static inline int64_t sceAtomicAdd64Release(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int64_t sceAtomicOr64Release(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int64_t sceAtomicAnd64Release(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int64_t sceAtomicIncrement64Release(volatile int64_t* ptr)
{
 return sceAtomicAdd64Release(ptr, 1);
}

static inline int64_t sceAtomicDecrement64Release(volatile int64_t* ptr)
{
 return sceAtomicAdd64Release(ptr, -1);
}

static inline int64_t sceAtomicCompareAndSwap64Release(volatile int64_t* ptr, int64_t compare, int64_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int64_t sceAtomicExchange64Release(volatile int64_t* ptr, int64_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore64Release(volatile int64_t* ptr, int64_t value)
{
 sceAtomicExchange64Release(ptr, value);
}

static inline
int64_t sceAtomicLoad64Release(const volatile int64_t* ptr)
{
 sceAtomicMemoryBarrier();
 return __atomic_load_n(ptr, 5);
}

static inline
__int128 sceAtomicCompareAndSwap128Release(volatile __int128* ptr, __int128 compare, __int128 swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline
__int128 sceAtomicAdd128Release(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Release(ptr, oldval, oldval + value));
 return oldval;
}

static inline
__int128 sceAtomicIncrement128Release(volatile __int128* ptr)
{
 return sceAtomicAdd128Release(ptr, 1);
}

static inline
__int128 sceAtomicDecrement128Release(volatile __int128* ptr)
{
 return sceAtomicAdd128Release(ptr, -1);
}

static inline
__int128 sceAtomicOr128Release(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Release(ptr, oldval, oldval | value));
 return oldval;
}

static inline
__int128 sceAtomicAnd128Release(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128Release(ptr, oldval, oldval & value));
 return oldval;
}

static inline
__int128 sceAtomicExchange128Release(volatile __int128* ptr, __int128 swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
bool sceAtomicCompareAndSwap128ByPointerRelease(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{
 __int128 c = *(__int128_t*)compare;
 __int128 old = sceAtomicCompareAndSwap128Release((volatile __int128_t*)ptr, c, *(__int128_t*)swap);
 __int128 *o =(__int128 *)oldvalue;
 *o = old;
 return old == c;
}

static inline
bool sceAtomicCompareAndSwap128_64Release(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{
 __int128 c = (((__int128)compareHigh) << 64) | (((__int128)compareLow) & 0xffffffffffffffff);
 __int128 s = (((__int128)swapHigh) << 64) | (((__int128)swapLow) & 0xffffffffffffffff);
 __int128 old = sceAtomicCompareAndSwap128Release((volatile __int128_t*)(intptr_t)ptr, c, s);
 oldvalue[0] = (int64_t)(0xffffffffffffffff & old);
 oldvalue[1] = (int64_t)(0xffffffffffffffff & (old >> 64));
 return old == c;
}

static inline
void sceAtomicStore128Release(volatile __int128* ptr, __int128 value)
{
 __atomic_store_n(ptr, value, 5);
}

static inline
__int128 sceAtomicLoad128Release(const volatile __int128* ptr)
{
 sceAtomicMemoryBarrier();
 __int128 ret = __atomic_load_n(ptr, 5);
 return ret;
}

static inline
void sceAtomicStore128_64Release(volatile int64_t* ptr, const int64_t *source)
{
 __int128 s = (((__int128)source[1]) << 64) | (((__int128)source[0]) & 0xffffffffffffffff);
 sceAtomicStore128Release((volatile __int128* )(intptr_t)ptr, s);
}

static inline
void sceAtomicLoad128_64Release(const volatile int64_t* ptr, int64_t *destination)
{
 sceAtomicMemoryBarrier();
 __int128 val = sceAtomicLoad128Release((const volatile __int128* )(intptr_t)ptr);
 destination[0] = (int64_t)(0xffffffffffffffff & val);
 destination[1] = (int64_t)(0xffffffffffffffff & (val >> 64));
}

static inline
void* sceAtomicExchangePointerRelease(volatile void** ptr, void* swap)
{
 return (void*)(intptr_t)sceAtomicExchange64Release((volatile int64_t*)(intptr_t)ptr, (int64_t)swap);
}
# 1020 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic/sce_atomic_impl.h" 3
static inline int8_t sceAtomicAdd8AcqRel(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int8_t sceAtomicOr8AcqRel(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int8_t sceAtomicAnd8AcqRel(volatile int8_t* ptr, int8_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int8_t sceAtomicIncrement8AcqRel(volatile int8_t* ptr)
{
 return sceAtomicAdd8AcqRel(ptr, 1);
}

static inline int8_t sceAtomicDecrement8AcqRel(volatile int8_t* ptr)
{
 return sceAtomicAdd8AcqRel(ptr, -1);
}

static inline int8_t sceAtomicCompareAndSwap8AcqRel(volatile int8_t* ptr, int8_t compare, int8_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int8_t sceAtomicExchange8AcqRel(volatile int8_t* ptr, int8_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore8AcqRel(volatile int8_t* ptr, int8_t value)
{
 sceAtomicExchange8AcqRel(ptr, value);
}

static inline
int8_t sceAtomicLoad8AcqRel(const volatile int8_t* ptr)
{
 sceAtomicMemoryBarrier();
 int8_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int16_t sceAtomicAdd16AcqRel(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int16_t sceAtomicOr16AcqRel(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int16_t sceAtomicAnd16AcqRel(volatile int16_t* ptr, int16_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int16_t sceAtomicIncrement16AcqRel(volatile int16_t* ptr)
{
 return sceAtomicAdd16AcqRel(ptr, 1);
}

static inline int16_t sceAtomicDecrement16AcqRel(volatile int16_t* ptr)
{
 return sceAtomicAdd16AcqRel(ptr, -1);
}

static inline int16_t sceAtomicCompareAndSwap16AcqRel(volatile int16_t* ptr, int16_t compare, int16_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int16_t sceAtomicExchange16AcqRel(volatile int16_t* ptr, int16_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore16AcqRel(volatile int16_t* ptr, int16_t value)
{
 sceAtomicExchange16AcqRel(ptr, value);
}

static inline
int16_t sceAtomicLoad16AcqRel(const volatile int16_t* ptr)
{
 sceAtomicMemoryBarrier();
 int16_t ret = sceAtomicLoad16Relaxed(ptr);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int32_t sceAtomicAdd32AcqRel(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int32_t sceAtomicOr32AcqRel(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int32_t sceAtomicAnd32AcqRel(volatile int32_t* ptr, int32_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int32_t sceAtomicIncrement32AcqRel(volatile int32_t* ptr)
{
 return sceAtomicAdd32AcqRel(ptr, 1);
}

static inline int32_t sceAtomicDecrement32AcqRel(volatile int32_t* ptr)
{
 return sceAtomicAdd32AcqRel(ptr, -1);
}

static inline int32_t sceAtomicCompareAndSwap32AcqRel(volatile int32_t* ptr, int32_t compare, int32_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int32_t sceAtomicExchange32AcqRel(volatile int32_t* ptr, int32_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore32AcqRel(volatile int32_t* ptr, int32_t value)
{
 sceAtomicExchange32AcqRel(ptr, value);
}

static inline
int32_t sceAtomicLoad32AcqRel(const volatile int32_t* ptr)
{
 sceAtomicMemoryBarrier();
 int32_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline int64_t sceAtomicAdd64AcqRel(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_add(ptr, value, 5);
}

static inline int64_t sceAtomicOr64AcqRel(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_or(ptr, value, 5);
}

static inline int64_t sceAtomicAnd64AcqRel(volatile int64_t* ptr, int64_t value)
{
 return __atomic_fetch_and(ptr, value, 5);
}

static inline int64_t sceAtomicIncrement64AcqRel(volatile int64_t* ptr)
{
 return sceAtomicAdd64AcqRel(ptr, 1);
}

static inline int64_t sceAtomicDecrement64AcqRel(volatile int64_t* ptr)
{
 return sceAtomicAdd64AcqRel(ptr, -1);
}

static inline int64_t sceAtomicCompareAndSwap64AcqRel(volatile int64_t* ptr, int64_t compare, int64_t swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline int64_t sceAtomicExchange64AcqRel(volatile int64_t* ptr, int64_t swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
void sceAtomicStore64AcqRel(volatile int64_t* ptr, int64_t value)
{
 sceAtomicExchange64AcqRel(ptr, value);
}

static inline
int64_t sceAtomicLoad64AcqRel(const volatile int64_t* ptr)
{
 sceAtomicMemoryBarrier();
 int64_t ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
__int128 sceAtomicCompareAndSwap128AcqRel(volatile __int128* ptr, __int128 compare, __int128 swap)
{
 __atomic_compare_exchange_n(ptr, &compare, swap, false, 5, 5);
 return compare;
}

static inline
__int128 sceAtomicAdd128AcqRel(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128AcqRel(ptr, oldval, oldval + value));
 return oldval;
}

static inline
__int128 sceAtomicIncrement128AcqRel(volatile __int128* ptr)
{
 return sceAtomicAdd128AcqRel(ptr, 1);
}

static inline
__int128 sceAtomicDecrement128AcqRel(volatile __int128* ptr)
{
 return sceAtomicAdd128AcqRel(ptr, -1);
}


static inline
__int128 sceAtomicOr128AcqRel(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128AcqRel(ptr, oldval, oldval | value));
 return oldval;
}

static inline
__int128 sceAtomicAnd128AcqRel(volatile __int128* ptr, __int128 value)
{
 __int128_t oldval;
 do {
  oldval = *ptr;
 } while(oldval != sceAtomicCompareAndSwap128AcqRel(ptr, oldval, oldval & value));
 return oldval;
}

static inline
__int128 sceAtomicExchange128AcqRel(volatile __int128* ptr, __int128 swap)
{
 return __atomic_exchange_n(ptr, swap, 5);
}

static inline
bool sceAtomicCompareAndSwap128ByPointerAcqRel(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{
 __int128 c = *(__int128_t*)compare;
 __int128 old = sceAtomicCompareAndSwap128AcqRel((volatile __int128_t*)ptr, c, *(__int128_t*)swap);
 __int128 *o =(__int128 *)oldvalue;
 *o = old;
 return old == c;
}

static inline
bool sceAtomicCompareAndSwap128_64AcqRel(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{
 __int128 c = (((__int128)compareHigh) << 64) | (((__int128)compareLow) & 0xffffffffffffffff);
 __int128 s = (((__int128)swapHigh) << 64) | (((__int128)swapLow) & 0xffffffffffffffff);
 __int128 old = sceAtomicCompareAndSwap128AcqRel((volatile __int128_t*)(intptr_t)ptr, c, s);
 oldvalue[0] = (int64_t)(0xffffffffffffffff & old);
 oldvalue[1] = (int64_t)(0xffffffffffffffff & (old >> 64));
 return old == c;
}

static inline
void sceAtomicStore128AcqRel(volatile __int128* ptr, __int128 value)
{
 __atomic_store_n(ptr, value, 5);
}

static inline
__int128 sceAtomicLoad128AcqRel(const volatile __int128* ptr)
{
 sceAtomicMemoryBarrier();
 __int128 ret = __atomic_load_n(ptr, 5);
 sceAtomicMemoryBarrier();
 return ret;
}

static inline
void sceAtomicStore128_64AcqRel(volatile int64_t* ptr, const int64_t *source)
{
 __int128 s = (((__int128)source[1]) << 64) | (((__int128)source[0]) & 0xffffffffffffffff);
 sceAtomicStore128AcqRel((volatile __int128* )(intptr_t)ptr, s);
}

static inline
void sceAtomicLoad128_64AcqRel(const volatile int64_t* ptr, int64_t *destination)
{
 sceAtomicMemoryBarrier();
 __int128 val = sceAtomicLoad128AcqRel((const volatile __int128* )(intptr_t)ptr);
 destination[0] = (int64_t)(0xffffffffffffffff & val);
 destination[1] = (int64_t)(0xffffffffffffffff & (val >> 64));
 sceAtomicMemoryBarrier();
}

static inline
void* sceAtomicExchangePointerAcqRel(volatile void** ptr, void* swap)
{
     return (void*)(intptr_t)sceAtomicExchange64AcqRel((volatile int64_t*)(intptr_t)ptr, (int64_t)swap);
}
# 1350 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic/sce_atomic_impl.h" 3
static inline int8_t sceAtomicAdd8(volatile int8_t* ptr, int8_t value)
{



 return sceAtomicAdd8Relaxed(ptr, value);

}

static inline int8_t sceAtomicOr8(volatile int8_t* ptr, int8_t value)
{



 return sceAtomicOr8Relaxed(ptr, value);

}

static inline int8_t sceAtomicAnd8(volatile int8_t* ptr, int8_t value)
{



 return sceAtomicAnd8Relaxed(ptr, value);

}

static inline int8_t sceAtomicIncrement8(volatile int8_t* ptr)
{



 return sceAtomicIncrement8Relaxed(ptr);

}

static inline int8_t sceAtomicDecrement8(volatile int8_t* ptr)
{



 return sceAtomicDecrement8Relaxed(ptr);

}

static inline int8_t sceAtomicCompareAndSwap8(volatile int8_t* ptr, int8_t compare, int8_t swap)
{



 return sceAtomicCompareAndSwap8Relaxed(ptr, compare, swap);

}

static inline int8_t sceAtomicExchange8(volatile int8_t* ptr, int8_t swap)
{



 return sceAtomicExchange8Relaxed(ptr, swap);

}

static inline
void sceAtomicStore8(volatile int8_t* ptr, int8_t value)
{



 sceAtomicStore8Relaxed(ptr, value);

}

static inline
int8_t sceAtomicLoad8(const volatile int8_t* ptr)
{



 return sceAtomicLoad8Relaxed(ptr);

}

static inline int16_t sceAtomicAdd16(volatile int16_t* ptr, int16_t value)
{



 return sceAtomicAdd16Relaxed(ptr, value);

}

static inline int16_t sceAtomicOr16(volatile int16_t* ptr, int16_t value)
{



 return sceAtomicOr16Relaxed(ptr, value);

}

static inline int16_t sceAtomicAnd16(volatile int16_t* ptr, int16_t value)
{



 return sceAtomicAnd16Relaxed(ptr, value);

}

static inline int16_t sceAtomicIncrement16(volatile int16_t* ptr)
{



 return sceAtomicIncrement16Relaxed(ptr);

}

static inline int16_t sceAtomicDecrement16(volatile int16_t* ptr)
{



 return sceAtomicDecrement16Relaxed(ptr);

}

static inline int16_t sceAtomicCompareAndSwap16(volatile int16_t* ptr, int16_t compare, int16_t swap)
{



 return sceAtomicCompareAndSwap16Relaxed(ptr, compare, swap);

}

static inline int16_t sceAtomicExchange16(volatile int16_t* ptr, int16_t swap)
{



 return sceAtomicExchange16Relaxed(ptr, swap);

}

static inline
void sceAtomicStore16(volatile int16_t* ptr, int16_t value)
{



 sceAtomicStore16Relaxed(ptr, value);

}

static inline
int16_t sceAtomicLoad16(const volatile int16_t* ptr)
{



 return sceAtomicLoad16Relaxed(ptr);

}

static inline int32_t sceAtomicAdd32(volatile int32_t* ptr, int32_t value)
{



 return sceAtomicAdd32Relaxed(ptr, value);

}

static inline int32_t sceAtomicOr32(volatile int32_t* ptr, int32_t value)
{



 return sceAtomicOr32Relaxed(ptr, value);

}

static inline int32_t sceAtomicAnd32(volatile int32_t* ptr, int32_t value)
{



 return sceAtomicAnd32Relaxed(ptr, value);

}

static inline int32_t sceAtomicIncrement32(volatile int32_t* ptr)
{



 return sceAtomicIncrement32Relaxed(ptr);

}

static inline int32_t sceAtomicDecrement32(volatile int32_t* ptr)
{



 return sceAtomicDecrement32Relaxed(ptr);

}

static inline int32_t sceAtomicCompareAndSwap32(volatile int32_t* ptr, int32_t compare, int32_t swap)
{



 return sceAtomicCompareAndSwap32Relaxed(ptr, compare, swap);

}

static inline int32_t sceAtomicExchange32(volatile int32_t* ptr, int32_t swap)
{



 return sceAtomicExchange32Relaxed(ptr, swap);

}

static inline
void sceAtomicStore32(volatile int32_t* ptr, int32_t value)
{



 sceAtomicStore32Relaxed(ptr, value);

}

static inline
int32_t sceAtomicLoad32(const volatile int32_t* ptr)
{



 return sceAtomicLoad32Relaxed(ptr);

}

static inline int64_t sceAtomicAdd64(volatile int64_t* ptr, int64_t value)
{



 return sceAtomicAdd64Relaxed(ptr, value);

}

static inline int64_t sceAtomicOr64(volatile int64_t* ptr, int64_t value)
{



 return sceAtomicOr64Relaxed(ptr, value);

}

static inline int64_t sceAtomicAnd64(volatile int64_t* ptr, int64_t value)
{



 return sceAtomicAnd64Relaxed(ptr, value);

}

static inline int64_t sceAtomicIncrement64(volatile int64_t* ptr)
{



 return sceAtomicIncrement64Relaxed(ptr);

}

static inline int64_t sceAtomicDecrement64(volatile int64_t* ptr)
{



 return sceAtomicDecrement64Relaxed(ptr);

}

static inline int64_t sceAtomicCompareAndSwap64(volatile int64_t* ptr, int64_t compare, int64_t swap)
{



 return sceAtomicCompareAndSwap64Relaxed(ptr, compare, swap);

}

static inline int64_t sceAtomicExchange64(volatile int64_t* ptr, int64_t swap)
{



 return sceAtomicExchange64Relaxed(ptr, swap);

}

static inline
void sceAtomicStore64(volatile int64_t* ptr, int64_t value)
{



 sceAtomicStore64Relaxed(ptr, value);

}

static inline
int64_t sceAtomicLoad64(const volatile int64_t* ptr)
{



 return sceAtomicLoad64Relaxed(ptr);

}

static inline
__int128 sceAtomicAdd128(volatile __int128* ptr, __int128 value)
{



 __int128 ret = sceAtomicAdd128Relaxed(ptr, value);

 return ret;
}

static inline
__int128 sceAtomicIncrement128(volatile __int128* ptr)
{



 __int128 ret = sceAtomicIncrement128Relaxed(ptr);

 return ret;
}

static inline
__int128 sceAtomicDecrement128(volatile __int128* ptr)
{



 __int128 ret = sceAtomicDecrement128Relaxed(ptr);

 return ret;
}

static inline
__int128 sceAtomicCompareAndSwap128(volatile __int128* ptr, __int128 compare, __int128 swap)
{



 __int128 ret = sceAtomicCompareAndSwap128Relaxed(ptr,compare, swap);

 return ret;
}

static inline
__int128 sceAtomicOr128(volatile __int128* ptr, __int128 value)
{



 __int128 ret = sceAtomicOr128Relaxed(ptr, value);

 return ret;
}

static inline
__int128 sceAtomicAnd128(volatile __int128* ptr, __int128 value)
{



 __int128 ret = sceAtomicAnd128Relaxed(ptr, value);

 return ret;
}

static inline
__int128 sceAtomicExchange128(volatile __int128* ptr, __int128 swap)
{



 __int128 ret = sceAtomicExchange128Relaxed(ptr, swap);

 return ret;
}

static inline
void sceAtomicStore128(volatile __int128* ptr, __int128 value)
{



 sceAtomicStore128Relaxed(ptr, value);

}

static inline
__int128 sceAtomicLoad128(const volatile __int128* ptr)
{



 return sceAtomicLoad128Relaxed(ptr);

}

static inline
bool sceAtomicCompareAndSwap128ByPointer(volatile void* ptr, const void* compare, const void *swap, void *oldvalue)
{



 bool ret = sceAtomicCompareAndSwap128ByPointerRelaxed(ptr, compare, swap, oldvalue);

 return ret;
}

static inline
bool sceAtomicCompareAndSwap128_64(volatile int64_t *ptr,
           int64_t compareHigh, int64_t compareLow,
           int64_t swapHigh, int64_t swapLow,
           int64_t *oldvalue)
{



 bool ret = sceAtomicCompareAndSwap128_64Relaxed(ptr, compareHigh, compareLow, swapHigh, swapLow, oldvalue);

 return ret;
}

static inline
void sceAtomicStore128_64(volatile int64_t* ptr, const int64_t *source)
{



 sceAtomicStore128_64Relaxed(ptr, source);

}

static inline
void sceAtomicLoad128_64(volatile int64_t* ptr, int64_t *destination)
{



 sceAtomicLoad128_64Relaxed(ptr, destination);

}

static inline
void* sceAtomicExchangePointer(volatile void** ptr, void* swap)
{



 return sceAtomicExchangePointerRelaxed(ptr, swap);

}
# 14 "C:\\Program Files (x86)\\SCE\\Prospero SDKs\\8.000/target/include_common\\sce_atomic.h" 2 3
# 5 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Notifications.cpp" 2

namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxNotificationPoll(MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Notifications::NotificationPoll(outBuffer, result);
 }

 void Notifications::NotificationPoll(MemoryBufferManaged* outBuffer, APIResult* result)
 {
  MemoryBuffer buffer = MemoryBuffer::GetNotificationBuffer();
  buffer.StartResponseWrite();


  SceSaveDataEvent event;
  memset(&event, 0x00, sizeof(event));

  int ret = sceSaveDataGetEventResult(__null, &event);


  buffer.WriteInt32(ret);

  if (ret == 0)
  {

   buffer.WriteInt32(event.type);
   buffer.WriteInt32(event.userId);
   buffer.WriteInt32(event.errorCode);

   Core::WriteToBuffer(event.dirName, buffer);

  }

  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 16 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Progress.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Progress.h" 1






namespace SaveData
{
 class Progress
 {
 public:
  static void ClearProgress(APIResult* result);
  static float GetProgress(APIResult* result);
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Progress.cpp" 2


namespace SaveData
{

 extern "C" __declspec (dllexport) float PrxSaveDataGetProgress(APIResult* result)
 {
  return Progress::GetProgress(result);
 }

 extern "C" __declspec (dllexport) void PrxSaveDataClearProgress(APIResult* result)
 {
  Progress::ClearProgress(result);
 }

 void Progress::ClearProgress(APIResult* result)
 {
# 28 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Progress.cpp"
  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

 float Progress::GetProgress(APIResult* result)
 {
# 42 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Progress.cpp"
  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));


  return 0.0f;
 }

}
# 17 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Search.cpp" 1

# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source/Search.h" 1






namespace SaveData
{
 class DirNameSearchRequest : public RequestBaseManaged
 {
 public:
  TitleIdManaged titleId;
  DirNameManaged dirName;
  UInt32 maxSaveDataCount;
  SceSaveDataSortKey key;
  SceSaveDataSortOrder order;

  bool includeParams;
  bool includeBlockInfo;
  bool searchPS4;

  void CopyTo(SceSaveDataDirNameSearchCond &destination, SceSaveDataDirName& sceDirName, SceSaveDataTitleId& sceTitleId);
 };

 class Searching
 {
 public:

  static void DirNameSearch(DirNameSearchRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result);
 };
}
# 3 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Search.cpp" 2


namespace SaveData
{
 extern "C" __declspec (dllexport) void PrxSaveDataDirNameSearch(DirNameSearchRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  Searching::DirNameSearch(managedRequest, outBuffer, result);
 }

 void DirNameSearchRequest::CopyTo(SceSaveDataDirNameSearchCond& destination, SceSaveDataDirName& sceDirName, SceSaveDataTitleId& sceTitleId)
 {
  dirName.CopyTo(sceDirName);
  titleId.CopyTo(sceTitleId);

  memset(&destination, 0x00, sizeof(destination));

  destination.userId = userId;

  if (strlen(dirName.data) > 0)
  {
   destination.dirName = &sceDirName;
  }
  else
  {
   destination.dirName = __null;
  }

  if (strlen(titleId.data) > 0)
  {
   destination.titleId = &sceTitleId;
  }
  else
  {
   destination.titleId = __null;
  }
  destination.key = key;
  destination.order = order;
 }

 void Searching::DirNameSearch(DirNameSearchRequest* managedRequest, MemoryBufferManaged* outBuffer, APIResult* result)
 {
  SceSaveDataDirName dirName;
  SceSaveDataTitleId titleId;
  SceSaveDataDirNameSearchCond cond;

  memset(&dirName, 0, sizeof(SceSaveDataDirName));
  memset(&titleId, 0, sizeof(SceSaveDataTitleId));

  managedRequest->CopyTo(cond, dirName, titleId);

  SceSaveDataDirNameSearchResult searchResult;
  memset(&searchResult, 0x00, sizeof(searchResult));

  searchResult.dirNames = Core::GetTempDirNamesArray();
  searchResult.dirNamesNum = managedRequest->maxSaveDataCount;

  if (managedRequest->includeParams == true)
  {
   searchResult.params = Core::GetTempParamsArray();
  }

  if (managedRequest->includeBlockInfo == true)
  {
   searchResult.infos = Core::GetTempSearchInfosArray();
  }

  int ret = 0;
  if (managedRequest->searchPS4)
  {

   ret = sceSaveDataDirNameSearchPs4(&cond, &searchResult);



  }
  else
  {
   ret = sceSaveDataDirNameSearch(&cond, &searchResult);

  }




  MemoryBuffer buffer = MemoryBuffer::GetBuffer();
  buffer.StartResponseWrite();


  buffer.WriteUInt32(searchResult.setNum);
  buffer.WriteBool(managedRequest->includeParams);
  buffer.WriteBool(managedRequest->includeBlockInfo);

  for (int i = 0; i < searchResult.setNum; i++)
  {

   Core::WriteToBuffer(searchResult.dirNames[i], buffer);

   if (searchResult.params != __null)
   {
    Core::WriteToBuffer(searchResult.params[i], buffer);
   }

   if (searchResult.infos != __null)
   {
    Core::WriteToBuffer(searchResult.infos[i], buffer);
   }
  }


  buffer.FinishResponseWrite();
  buffer.CopyTo(outBuffer);

  if (ret < 0)
  {
   (SaveData::APIResult::SetSceResult(result, SaveData::APIResultTypes::Error, ret, "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Search.cpp", 117));
   return;
  }

  (SaveData::APIResult::SetResult(result, SaveData::APIResultTypes::Success));
 }

}
# 18 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Transactions.cpp" 1



namespace SaveData
{
 std::list<Transaction*> Transactions::s_TransactionList;

 Transaction* Transactions::CreateTransactionId(uint32_t size )
 {
  if (size < (786432)) size = (786432);

  int32_t ret = sceSaveDataCreateTransactionResource(size);

  if (ret < 0)
  {
   return __null;
  }

  Transaction* id = new Transaction();

  id->m_TransactionId = ret;

  return id;
 }

 int Transactions::DeleteTransactionId(Transaction* id)
 {
  if (id == __null)
  {
   return 0;
  }

  int ret = sceSaveDataDeleteTransactionResource(id->m_TransactionId);

  delete id;

  return ret;
 }

 void Transactions::RecordMountedTransaction(Transaction* id, SceSaveDataMountPoint& mp)
 {
  id->m_MountPoint = mp;


  s_TransactionList.push_back(id);
 }

 int Transactions::RemoveTransaction(Transaction* id)
 {
  if (id == __null)
  {
   return 0;
  }

  s_TransactionList.remove(id);

  return DeleteTransactionId(id);
 }

 Transaction* Transactions::FindTransaction(SceSaveDataMountPoint& mp)
 {
  for (std::list<Transaction*>::iterator it = s_TransactionList.begin(); it != s_TransactionList.end(); ++it)
  {
   Transaction* trans = *it;

   if (strcmp(trans->m_MountPoint.data, mp.data) == 0)
   {
    return trans;
   }
  }

  return __null;
 }

}
# 19 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2
# 1 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Utils.cpp" 1







namespace SaveData
{
# 71 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~/Source\\Utils.cpp"
 int32_t Utils::LoadFile(const char *path, uint8_t** data, size_t *datasize)
 {
  int32_t ret = 0;

  SceKernelStat st;
  ret = sceKernelStat(path, &st);
  if (ret < 0)
  {
   return ret;
  }



  *data = new uint8_t[st.st_size];

  if (*data == __null)
  {
   return -1;
  }


  int fd = sceKernelOpen(path, 0x0000, 0000000);
  if (fd < 0)
  {
   delete[] data;
   return fd;
  }

  ret = static_cast<int32_t>(sceKernelRead(fd, *data, static_cast<size_t>(st.st_size)));
  if (ret < 0)
  {
   sceKernelClose(fd);
   return ret;
  }

  *datasize = st.st_size;

  sceKernelClose(fd);

  return ret;
 }
}
# 20 "C:\\code\\scotland-yard\\Packages\\com.unity.savedata.ps5@1.0.1\\Source~\\savedata_lump.cpp" 2

