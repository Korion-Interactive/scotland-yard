using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Linq.Expressions;

using UnityEditor;
using UnityEngine;

using BitBarons.Util;

using BitBarons.Editor.CodeGenerator;
using BitBarons.Editor.CodeGenerator.Blocks;
using BitBarons.Editor.Util;
using BitBarons.Bindings;
using System.Reflection;
using System.Collections;

namespace BitBarons.Editor.Bindings
{
    [Serializable]
    public class ComplexBindingEditor : BaseNamePartEditor<ComplexBinding>
    {

        public List<BaseNamePartEditor> editorPartsA = new List<BaseNamePartEditor>();
        public List<BaseNamePartEditor> editorPartsB = new List<BaseNamePartEditor>();

        List<Type> availableTypes;

        
        CSharpFile file;

        public override string NamePartType { get { return BaseNamePartEditor.TYPE_COMPLEX; } }

        public ComplexBindingEditor(GameObject previewObject)
            : base(previewObject)
        {
            availableTypes = Parser.GetAllRegisteredParseTypes().ToList();
            availableTypes.Insert(0, null);
            
        }

        public override void OnGUI()
        {
            if(part.ProgressingNamePart)
            {
                EditorGUILayout.LabelField("Operation Preview", GetOperationString());
                EditorGUILayout.LabelField("Currently progressing input...");
                return;
            }

            EditorGUILayout.LabelField("Operation Preview", GetOperationString());

            using (EditorGuiZone.Vertical("Box")) // A
            {
                int tA = availableTypes.IndexOf(part.TypeA);
                tA = EditorGUILayout.Popup("A: Parse to Type", tA, availableTypes.Select(t => t.GetShortcutName()).ToArray());
                part.TypeAIdx = tA;

                if (part.TypeA != null)
                    SharedEditorMethods.NamePartsGUI(part.AffectedObject, editorPartsA, "A", ref part.FormatA, 
                        (o) => { part.NamePartsA.Add(o.NamePart); }, 
                        (o) => { part.NamePartsA.Remove(o.NamePart); },
                        true);
            }
            using (EditorGuiZone.Vertical("Box")) // Operator
            {
                part.Operator = (MathOperator)EditorGUILayout.EnumPopup("Operator", part.Operator);
            }

            using (EditorGuiZone.Vertical("Box")) // B
            {
                int tB = availableTypes.IndexOf(part.TypeB);
                tB = EditorGUILayout.Popup("B: Parse to Type", tB, availableTypes.Select(t => t.GetShortcutName()).ToArray());
                part.TypeBIdx = tB;

                if (part.TypeB != null)
                    SharedEditorMethods.NamePartsGUI(part.AffectedObject, editorPartsB, "B", ref part.FormatB,
                        (o) => { part.NamePartsB.Add(o.NamePart); },
                        (o) => { part.NamePartsB.Remove(o.NamePart); },
                        true);
            }
        }

        void bind_GetNamePartFailed(object sender, NamePartFailedArgs args)
        {
            switch (args.Reason)
            {
                case FailTypes.Invoke:
                    CreateMethod(args.InvokeMethodName, args.A, args.B);
                    break;
            }
        }
        void CreateMethod(string methodName, object a, object b)
        {
            if (file == null)
                file = new CSharpFile(Application.dataPath + "/BitBarons/AutoGenerated/MathOperations.cs");

            // CREATE FILE MAIN CONTENT
            var nameSpace = file.Content.AddIfNotExists(new NameSpaceBlock("BitBarons.AutoGenerated")) as CSharpBlock;
            var classBlock = nameSpace.Content.AddIfNotExists(new DataTypeBlock("MathOperations", DataType.Class) { IsStatic = true }) as CSharpBlock;

            // CREATE METHOD
            var m = new MethodBlock(methodName, typeof(string), new MethodParameter(part.TypeA, "a"), new MethodParameter(part.TypeB, "b")) { IsStatic = true };

            if (classBlock.Content.FindBlock(m) == null)
            {
                // Add method
                m.Content.Add(new Instruction(string.Format("return (a {0} b).ToString();", part.Operator.GetOperatorSignCSharp())));
                classBlock.Content.Add(m);



                file.Save(false);
                AssetDatabase.Refresh(ImportAssetOptions.ForceSynchronousImport);

                // clear assembly to see if there are errors
                Assembly assembly = Assembly.GetAssembly(typeof(SceneView));
                Type logEntries = assembly.GetType("UnityEditorInternal.LogEntries");
                logEntries.GetMethod("Clear").Invoke(new object(), null);

                int count = (int)logEntries.GetMethod("GetCount").Invoke(new object(), null);

                if (count > 0)
                {
                    part.ProgressingNamePart = false;
                    if (classBlock.Content.Remove(m))
                    {
                        part.TypeAIdx = -1;
                        part.TypeBIdx = -1;
                        file.Save(true);

                        // clear console again to get rid of unnecessary scary error message from unity
                        logEntries.GetMethod("Clear").Invoke(new object(), null);

                        this.LogError("Couldn't create operation for the selected types. Method has been removed, types have been resetted.");
                    }
                }
                else
                {
                    this.LogInfo("Method created: " + m.ToString());
                }


            }

            part.ProgressingNamePart = false;
        }

        private string GetOperationString()
        {
            string a = SharedEditorMethods.GetStringValue(editorPartsA, part.FormatA, null);
            string b = SharedEditorMethods.GetStringValue(editorPartsB, part.FormatB, null);
            string op = part.Operator.GetOperatorSignCSharp();

            return string.Format("{0} {1} {2}", a, op, b);
        }

        public override void SerializeForEditor(string context)
        {
            SharedEditorMethods.SerializeNamePartsForEditor(GetKey(context, "partsA"), editorPartsA);
            EditorPrefs.SetString(GetKey(context, "formatA"), part.FormatA);
            EditorPrefs.SetInt(GetKey(context, "typeA"), part.TypeAIdx);


            EditorPrefs.SetInt(GetKey(context, "op"), (int)part.Operator);


            SharedEditorMethods.SerializeNamePartsForEditor(GetKey(context, "partsB"), editorPartsB);
            EditorPrefs.SetString(GetKey(context, "formatB"), part.FormatB);
            EditorPrefs.SetInt(GetKey(context, "typeB"), part.TypeBIdx);
        }

        public override void DeserializeForEditor(string context)
        {
            this.editorPartsA = SharedEditorMethods.DeserializeNamePartsForEditor(GetKey(context, "partsA"), part.AffectedObject);
            part.FormatA = EditorPrefs.GetString(GetKey(context, "formatA"));
            part.TypeAIdx = EditorPrefs.GetInt(GetKey(context, "typeA"));


            part.Operator = (MathOperator)EditorPrefs.GetInt(GetKey(context, "op"));


            this.editorPartsB = SharedEditorMethods.DeserializeNamePartsForEditor(GetKey(context, "partsB"), part.AffectedObject);
            part.FormatB = EditorPrefs.GetString(GetKey(context, "formatB"));
            part.TypeBIdx = EditorPrefs.GetInt(GetKey(context, "typeB"));
        }

        protected override ComplexBinding CreatePart(GameObject previewObject)
        {
            var result = ScriptableObject.CreateInstance<ComplexBinding>();
            result.Initialize(previewObject);
            result.GetNamePartFailed += bind_GetNamePartFailed;
            return result;
        }

     
    }
}
